{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\u00b6\n\n\nWelcome to my first book.  It's free, it's open source, and it's comprehensive.\nThose attributes also describe two of my favorite technologies, and I'm basing\nmy first book on them.  The first is \nXamarin Forms\n , a technology that\nallows you to develop cross-platform mobile applications using C# and the .NET\nframework.  The second is \nAzure Mobile Apps\n, a technology that allows\nyou to connect your mobile app to  resources that are important in cloud\nconnected mobile applications such as table data, authentication, and push\nnotifications.\n\n\nThis book does not tell you everything there is to know about either topic.  It\nfocuses on the topics necessary to get your mobile apps connected to the cloud.\n\n\nWhat are Cloud Connected Mobile Apps?\n\u00b6\n\n\nI guess I should define some of the terminology that I am going to use.  When I\nrefer to a \nmobile application\n or \nmobile app\n, I mean every piece of\nsoftware that is related to the application you want to use.  This includes, for\nexample, the \nmobile client\n. This is the piece of code you run on your iPhone\nor Android phone.  It also includes the \nmobile backend\n which is the service\nthat you run in the cloud to provide important services to your mobile client.\n\n\nA \ncloud connected mobile application\n is a mobile client that connects to a\nmobile backend for shared services.  Quite a few of the apps on your phone are\ncloud connected already.  For example, Instagram uses the cloud for photo\nstorage, and Facebook uses the cloud to store the news feeds of you and your\nfriends.\n\n\nWhy Cross-Platform Native Development is important?\n\u00b6\n\n\nIt should come as no surprise that Apple and Google have pretty much won the\nmobile OS wars.  Over 90% of the smart phones being sold today run either iOS\nor Android.  However, these are two very different mobile operating systems,\nwith different programming models.  iOS is based on either \nSwift\n or\nObjective-C.  Android is based on \nJava\n.  If you want to develop for the\n80% case (and you should), then you need to know both Swift and Java.  That's\na tall order even for the most dedicated mobile developer.\n\n\nHowever, there are alternatives out there.  Most notable, you can write your\nmobile application with one code-base and just write exceptions for when the\nplatforms diverge.  You have to pick a single language and a tool set that\nsupports cross-platform development to do this.  Not all cross-platform tool\nsets are created equal, however.  Some do not compile your code to native\nbinaries, which means that you do not get access to all the functionality of\nthe mobile platforms you are targeting.\n\n\nXamarin, recently acquired by Microsoft, allows you to target all major\nplatforms - iOS, Android and Windows - to gain greater than 95% coverage of\nthe mobile smart phone market.  It does this by leveraging the .NET framework\nand compiling your code to a native binary for each platform.\n\n\nXamarin.Forms is a cross-platform framework, based on XAML and .NET, that\nallows you to use common UI pages to develop your apps.\n\n\nWhy Azure Mobile Apps?\n\u00b6\n\n\nWhen you think about the major apps in the marketplace for each mobile\nplatform, the thing that they have in common is that they have some sort\nof cloud infrastructure driving them.  It might be as simple as storing\nyour task list, or as complex as your Facebook news feed.  It could be a\ngaming leader board, or the social sharing of your photos.  Whatever it\nis, cloud connectivity is a must.\n\n\nNot all clouds are created equal.  There are some common features that you\nshould think about including irrespective of the application.  I like to use\nAzure Mobile Apps for these features because they are all included and you\ncan get started with most of the features for zero cost.  Even the features\nthat cannot be obtained without spending a little money are relatively cheap.\n\n\n\n\nInfo\n\n\nAzure Mobile Apps\n is a feature of Azure App Service.  Azure App Service\nis a collection of services that commonly are used together to develop modern\nInternet Apps.  This includes web hosting, API hosting and Mobile SDKs.\n\n\n\n\nFeatures of Cloud Connected Mobile Apps\n\u00b6\n\n\nA cloud connected mobile application will use one or more services in the\nfollowing areas:\n\n\n\n\nAuthentication\n\n\nStorage of structured data (like a task list)\n\n\nStorage of unstructured data (like photographs)\n\n\nPush notifications\n\n\nInvocation of Custom Code\n\n\n\n\nI am going to cover each of these in great detail.  In addition, I will also\ncover some common issues and solutions that developers run into while developing\ncloud connected mobile applications such as testing and going to production.\n\n\nAside from the actual features of mobile apps, there are other things to\nconsider while developing your mobile application.  Here is my list, in no\nparticular order:\n\n\n\n\nContinuous Deployment\n\n\nSlots or Staging Sites\n\n\nAutomatic Scalability\n\n\nDatabase Backups\n\n\nCombined Web\n\n\n\n\nThe point here is that my intent is to write a production quality application.\nI need to be able to deploy my site with confidence without resorting to jumping\nthrough hoops.  I want to run multiple versions of the backend so that I can run\na staging site for testing purposes.  I want to be able to roll back my\nproduction site to a previous version at a moments notice.  I want to be able to\nhandle the load when my app is successful, and I want things to be backed up\n(since bad things inevitably happen when I am least prepared).\n\n\nAll of these features are available in Azure App Service, and the Mobile Apps\nSDK that I will use throughout the book is supported only on Azure App Service.\n\n\nWho is This Book For?\n\u00b6\n\n\nThis book is for intermediate to experienced C# developers who have already\nbuilt a mobile app with Xamarin and want to take their mobile apps to the next\nlevel by utilizing cloud services.\n\n\nThis book is not for the beginner.  Explicitly, I already expect you to know how\nto develop mobile applications with C# and Xamarin technologies.  If you are\nunfamiliar with the C# language, you can get started with a free course on the\nInternet.  The basics of the language can be learned at \nwww.learncs.org\n.\nOnce you have the language basics under your belt, you can move on to building\nmobile applications with Xamarin. You can learn more about developing cross-platform\nmobile development with Xamarin at the \nXamarin\n website.  Although you do\nnot need to understand ASP.NET to get value out of this book, be aware that the\nmobile back ends that I will be covering are written in C# and ASP.NET.  A good\nunderstanding of ASP.NET will assist you.\n\n\nThings You Should Know!\n\u00b6\n\n\nBefore you get started with development, spend some time learning the tools of\nthe trade.  The command prompt on the Mac is \nbash\n and the command prompt\non the PC is \nPowerShell\n.  You should be proficient in the shell on the\nplatforms that you use.\n\n\nAdditionally, you should become familiar with the source code control system\nthat you will use.  For most, this means becoming familiar with\n\ngit\n.  Don't even think of developing without using source control.\n\n\nWhat You Will Need\n\u00b6\n\n\nThe list of hardware and software for mobile development is longer than your\ntypical development projects.  It is still, thankfully, relatively short and\neasy to acquire.\n\n\nHardware\n\u00b6\n\n\nYou will want a computer on which to develop code.  If you develop iOS\napplications, then you \nMUST\n have a Mac running the latest version of Mac\nOSX.  If you develop Universal Windows applications, then you \nMUST\n have a\nPC running Windows 10.  Android applications can be developed on either platform.\n\n\nMy own experience has taught me that the tooling for developing mobile backends\nin C# and ASP.NET (our primary languages during the course of this book) are\nbetter on a PC running Windows 10.  Thus, my hardware choice is a rather beefy\n\nWindows 10 PC\n for my main development system.  In addition, I have a\n\nMac Mini\n underneath my desk that I use to build the iOS portions of the\napplications.\n\n\nSoftware\n\u00b6\n\n\nAll of the following software are freely available.  You should install each\npackage and update it (if appropriate) so that it is fully patched.\n\n\nOn your Mac\n\u00b6\n\n\n\n\nXCode\n (available on the Mac App Store)\n\n\nXamarin Studio\n\n\nAndroid Studio and Tools\n (if you intend to build Android apps on the Mac)\n\n\n\n\nYou must run XCode at least once after installation so that you can accept the\nlicense agreement.\n\n\nOn your Windows PC\n\u00b6\n\n\n\n\nAndroid Studio and Tools\n\n\nVisual Studio Community\n\n\nAzure SDK\n\n\n\n\nWhen installing Visual Studio, you will want to install the components for\nWeb applications and Cross-platform Mobile development.  If you have already\ninstalled Visual Studio and did not install these components, run the installer\nagain to add the components.\n\n\n\n\nTip\n\n\nDevelopment Tools are big, multi-gigabyte installers.  If you are on a slow or\nrestricted link, you may want to download the installers onto a thumb drive for\nlocal installation.\n\n\n\n\nCloud Services\n\u00b6\n\n\nYou will need an Azure account to complete most of the tutorials in this book.\nIn fact, you won't be able to get very far without one. If you have an MSDN\naccount, you already have access to free Azure resources.  You just need to log\ninto your \nMSDN account\n and activate your Azure benefit.  Students may be\nable to get access to \nDreamspark\n from school resources, but this is not\nsuitable for developing mobile applications.  This is because storage costs\nmoney.  If you don't have MSDN, then there is a \nfree trial\n available.\nOnce the trial period ends, you can move to a Pay-As-You-Go account and continue\nto use free services without incurring a charge. I'll point out when you are\ngoing to incur charges on your Azure account, but I will be using free resources\nmost of the time.\n\n\nAside from Azure resources, you will want some place to store your code.  This\ndoesn't have to be in the cloud.  If you want to use the cloud, you can use\nGitHub or Visual Studio Team Services.  Both are free to use.  GitHub provides\npublic repositories for free.  Visual Studio Team Services provides private\nrespositories for free.  Visual Studio Team Services also includes other\nservices that I will talk about during the course of the book, some of which may\nincur cost.  I will be publishing all my samples and tutorial code on GitHub so\nthat you can easily download it.  You don't have to use one of these resources,\nbut I won't be covering other service usage.\n\n\nYou will need a \nDeveloper Account\n for the appropriate app store if you\nintend to distribute your mobile clients or if you intend to use specific cloud\nservices.  Apple is specific - if you intend to use push notifications or\ndistribute iOS apps, then you need an \nApple Developer Account\n,\n\nGoogle Developer Account\n and/or \nWindows Store Developer Account\n.\nThe terms of the accounts are changed constantly, so review the current terms\nwhen you sign up.  My recommendation is to defer signing up for these programs\nuntil you need something they offer.\n\n\nNow, let's get developing!  Our next section is dependent on where you are developing:\n\n\n\n\nOn a Mac, skip ahead to the \nMac section\n.\n\n\nOn a PC, the \nnext section\n covers Visual Studio.",
            "title": "Getting Started"
        },
        {
            "location": "/#introduction",
            "text": "Welcome to my first book.  It's free, it's open source, and it's comprehensive.\nThose attributes also describe two of my favorite technologies, and I'm basing\nmy first book on them.  The first is  Xamarin Forms  , a technology that\nallows you to develop cross-platform mobile applications using C# and the .NET\nframework.  The second is  Azure Mobile Apps , a technology that allows\nyou to connect your mobile app to  resources that are important in cloud\nconnected mobile applications such as table data, authentication, and push\nnotifications.  This book does not tell you everything there is to know about either topic.  It\nfocuses on the topics necessary to get your mobile apps connected to the cloud.",
            "title": "Introduction"
        },
        {
            "location": "/#what-are-cloud-connected-mobile-apps",
            "text": "I guess I should define some of the terminology that I am going to use.  When I\nrefer to a  mobile application  or  mobile app , I mean every piece of\nsoftware that is related to the application you want to use.  This includes, for\nexample, the  mobile client . This is the piece of code you run on your iPhone\nor Android phone.  It also includes the  mobile backend  which is the service\nthat you run in the cloud to provide important services to your mobile client.  A  cloud connected mobile application  is a mobile client that connects to a\nmobile backend for shared services.  Quite a few of the apps on your phone are\ncloud connected already.  For example, Instagram uses the cloud for photo\nstorage, and Facebook uses the cloud to store the news feeds of you and your\nfriends.",
            "title": "What are Cloud Connected Mobile Apps?"
        },
        {
            "location": "/#why-cross-platform-native-development-is-important",
            "text": "It should come as no surprise that Apple and Google have pretty much won the\nmobile OS wars.  Over 90% of the smart phones being sold today run either iOS\nor Android.  However, these are two very different mobile operating systems,\nwith different programming models.  iOS is based on either  Swift  or\nObjective-C.  Android is based on  Java .  If you want to develop for the\n80% case (and you should), then you need to know both Swift and Java.  That's\na tall order even for the most dedicated mobile developer.  However, there are alternatives out there.  Most notable, you can write your\nmobile application with one code-base and just write exceptions for when the\nplatforms diverge.  You have to pick a single language and a tool set that\nsupports cross-platform development to do this.  Not all cross-platform tool\nsets are created equal, however.  Some do not compile your code to native\nbinaries, which means that you do not get access to all the functionality of\nthe mobile platforms you are targeting.  Xamarin, recently acquired by Microsoft, allows you to target all major\nplatforms - iOS, Android and Windows - to gain greater than 95% coverage of\nthe mobile smart phone market.  It does this by leveraging the .NET framework\nand compiling your code to a native binary for each platform.  Xamarin.Forms is a cross-platform framework, based on XAML and .NET, that\nallows you to use common UI pages to develop your apps.",
            "title": "Why Cross-Platform Native Development is important?"
        },
        {
            "location": "/#why-azure-mobile-apps",
            "text": "When you think about the major apps in the marketplace for each mobile\nplatform, the thing that they have in common is that they have some sort\nof cloud infrastructure driving them.  It might be as simple as storing\nyour task list, or as complex as your Facebook news feed.  It could be a\ngaming leader board, or the social sharing of your photos.  Whatever it\nis, cloud connectivity is a must.  Not all clouds are created equal.  There are some common features that you\nshould think about including irrespective of the application.  I like to use\nAzure Mobile Apps for these features because they are all included and you\ncan get started with most of the features for zero cost.  Even the features\nthat cannot be obtained without spending a little money are relatively cheap.   Info  Azure Mobile Apps  is a feature of Azure App Service.  Azure App Service\nis a collection of services that commonly are used together to develop modern\nInternet Apps.  This includes web hosting, API hosting and Mobile SDKs.",
            "title": "Why Azure Mobile Apps?"
        },
        {
            "location": "/#features-of-cloud-connected-mobile-apps",
            "text": "A cloud connected mobile application will use one or more services in the\nfollowing areas:   Authentication  Storage of structured data (like a task list)  Storage of unstructured data (like photographs)  Push notifications  Invocation of Custom Code   I am going to cover each of these in great detail.  In addition, I will also\ncover some common issues and solutions that developers run into while developing\ncloud connected mobile applications such as testing and going to production.  Aside from the actual features of mobile apps, there are other things to\nconsider while developing your mobile application.  Here is my list, in no\nparticular order:   Continuous Deployment  Slots or Staging Sites  Automatic Scalability  Database Backups  Combined Web   The point here is that my intent is to write a production quality application.\nI need to be able to deploy my site with confidence without resorting to jumping\nthrough hoops.  I want to run multiple versions of the backend so that I can run\na staging site for testing purposes.  I want to be able to roll back my\nproduction site to a previous version at a moments notice.  I want to be able to\nhandle the load when my app is successful, and I want things to be backed up\n(since bad things inevitably happen when I am least prepared).  All of these features are available in Azure App Service, and the Mobile Apps\nSDK that I will use throughout the book is supported only on Azure App Service.",
            "title": "Features of Cloud Connected Mobile Apps"
        },
        {
            "location": "/#who-is-this-book-for",
            "text": "This book is for intermediate to experienced C# developers who have already\nbuilt a mobile app with Xamarin and want to take their mobile apps to the next\nlevel by utilizing cloud services.  This book is not for the beginner.  Explicitly, I already expect you to know how\nto develop mobile applications with C# and Xamarin technologies.  If you are\nunfamiliar with the C# language, you can get started with a free course on the\nInternet.  The basics of the language can be learned at  www.learncs.org .\nOnce you have the language basics under your belt, you can move on to building\nmobile applications with Xamarin. You can learn more about developing cross-platform\nmobile development with Xamarin at the  Xamarin  website.  Although you do\nnot need to understand ASP.NET to get value out of this book, be aware that the\nmobile back ends that I will be covering are written in C# and ASP.NET.  A good\nunderstanding of ASP.NET will assist you.",
            "title": "Who is This Book For?"
        },
        {
            "location": "/#things-you-should-know",
            "text": "Before you get started with development, spend some time learning the tools of\nthe trade.  The command prompt on the Mac is  bash  and the command prompt\non the PC is  PowerShell .  You should be proficient in the shell on the\nplatforms that you use.  Additionally, you should become familiar with the source code control system\nthat you will use.  For most, this means becoming familiar with git .  Don't even think of developing without using source control.",
            "title": "Things You Should Know!"
        },
        {
            "location": "/#what-you-will-need",
            "text": "The list of hardware and software for mobile development is longer than your\ntypical development projects.  It is still, thankfully, relatively short and\neasy to acquire.",
            "title": "What You Will Need"
        },
        {
            "location": "/#hardware",
            "text": "You will want a computer on which to develop code.  If you develop iOS\napplications, then you  MUST  have a Mac running the latest version of Mac\nOSX.  If you develop Universal Windows applications, then you  MUST  have a\nPC running Windows 10.  Android applications can be developed on either platform.  My own experience has taught me that the tooling for developing mobile backends\nin C# and ASP.NET (our primary languages during the course of this book) are\nbetter on a PC running Windows 10.  Thus, my hardware choice is a rather beefy Windows 10 PC  for my main development system.  In addition, I have a Mac Mini  underneath my desk that I use to build the iOS portions of the\napplications.",
            "title": "Hardware"
        },
        {
            "location": "/#software",
            "text": "All of the following software are freely available.  You should install each\npackage and update it (if appropriate) so that it is fully patched.",
            "title": "Software"
        },
        {
            "location": "/#on-your-mac",
            "text": "XCode  (available on the Mac App Store)  Xamarin Studio  Android Studio and Tools  (if you intend to build Android apps on the Mac)   You must run XCode at least once after installation so that you can accept the\nlicense agreement.",
            "title": "On your Mac"
        },
        {
            "location": "/#on-your-windows-pc",
            "text": "Android Studio and Tools  Visual Studio Community  Azure SDK   When installing Visual Studio, you will want to install the components for\nWeb applications and Cross-platform Mobile development.  If you have already\ninstalled Visual Studio and did not install these components, run the installer\nagain to add the components.   Tip  Development Tools are big, multi-gigabyte installers.  If you are on a slow or\nrestricted link, you may want to download the installers onto a thumb drive for\nlocal installation.",
            "title": "On your Windows PC"
        },
        {
            "location": "/#cloud-services",
            "text": "You will need an Azure account to complete most of the tutorials in this book.\nIn fact, you won't be able to get very far without one. If you have an MSDN\naccount, you already have access to free Azure resources.  You just need to log\ninto your  MSDN account  and activate your Azure benefit.  Students may be\nable to get access to  Dreamspark  from school resources, but this is not\nsuitable for developing mobile applications.  This is because storage costs\nmoney.  If you don't have MSDN, then there is a  free trial  available.\nOnce the trial period ends, you can move to a Pay-As-You-Go account and continue\nto use free services without incurring a charge. I'll point out when you are\ngoing to incur charges on your Azure account, but I will be using free resources\nmost of the time.  Aside from Azure resources, you will want some place to store your code.  This\ndoesn't have to be in the cloud.  If you want to use the cloud, you can use\nGitHub or Visual Studio Team Services.  Both are free to use.  GitHub provides\npublic repositories for free.  Visual Studio Team Services provides private\nrespositories for free.  Visual Studio Team Services also includes other\nservices that I will talk about during the course of the book, some of which may\nincur cost.  I will be publishing all my samples and tutorial code on GitHub so\nthat you can easily download it.  You don't have to use one of these resources,\nbut I won't be covering other service usage.  You will need a  Developer Account  for the appropriate app store if you\nintend to distribute your mobile clients or if you intend to use specific cloud\nservices.  Apple is specific - if you intend to use push notifications or\ndistribute iOS apps, then you need an  Apple Developer Account , Google Developer Account  and/or  Windows Store Developer Account .\nThe terms of the accounts are changed constantly, so review the current terms\nwhen you sign up.  My recommendation is to defer signing up for these programs\nuntil you need something they offer.  Now, let's get developing!  Our next section is dependent on where you are developing:   On a Mac, skip ahead to the  Mac section .  On a PC, the  next section  covers Visual Studio.",
            "title": "Cloud Services"
        },
        {
            "location": "/chapter1/firstapp_pc/",
            "text": "Your First Mobile App\n\u00b6\n\n\nThere is a lot of detail to absorb about the possible services that the mobile\nclient can consume and I will go into significant depth on those subjects.\nFirst, wouldn't it be nice to write some code and get something working?\nMicrosoft Azure has a great \nfirst-steps tutorial\n that takes you via the\nquickest possible route from creating a mobile backend to having a functional\nbackend.  I would like to take things a little slower so that we can understand\nwhat is going on while we are doing the process.  We will have practically the\nsame application at the end.  The primary reason for going through this slowly\nis to ensure that all our build and run processes are set up properly.  If this\nis the first mobile app you have ever written, you will see that there are quite\na few things that need to be set up.  This chapter covers the set up required\nfor a Windows PC.  If you wish to develop your applications on a Mac, then skip\nto the \nnext section\n.\n\n\nThe application we are going to build together is a simple task list.  The\nmobile client will have three screens - an entry screen, a task list and a task\ndetails page.  I have mocked these pages up using \nMockingBot\n.\n\n\n\n\nTip\n\n\nMocking your screens before you start coding is a great habit to get into.\nThere are some great tools available including free tools like \nMockingBot\n.\nDoing mockups before you start coding is a good way to prevent wasted time later\non.\n\n\n\n\n\n\n\n\nTip\n\n\nIf you are using iOS, then you may want to remove the back button as the style\nguides suggest you don't need one.  Other platforms will need it though, so it's\nbest to start with the least common denominator.  It's the same reason I add a\nrefresh button even though it's only valid on Windows Phone!\n\n\n\n\nMy ideas for this app include:\n\n\n\n\nTapping on a task title in the task list will bring up the details page.\n\n\nToggling the completed link in the task list will set the completed flag.\n\n\nTapping the spinner will initiate a network refresh.\n\n\n\n\nNow that we have our client screens planned out, we can move onto the thinking\nabout the mobile backend.\n\n\nThe Mobile Backend\n\u00b6\n\n\nThe mobile backend is an ASP.NET WebApi that is served from within Azure App\nService: a highly scalable and redundant web hosting facility that supports all\nthe major web languages (like ASP.NET, Node, PHP and Python).  Azure Mobile\nApps is an SDK (which is available in ASP.NET and Node) that runs on top of\nAzure App Service.\n\n\nCreating a Simple Azure Mobile Apps Backend\n\u00b6\n\n\nMicrosoft Azure has included a comprehensive starter kit template in the\nAzure SDK.  To get started:\n\n\n\n\nFire up Visual Studio 2015\n\n\nAdd a new project with File -> New Project...\n\n\n\n\nIn the \nNew Project\n window:\n\n\n\n\nOpen up Templates -> Visual C# -> Web and select \nASP.NET Web Application (.NET Framework)\n.\n\n\nEnter \nBackend\n for the Name and \nChapter1\n for the Solution name.\n\n\nPick a suitable directory for the Location field.\n\n\nClick on OK.\n\n\n\n\n\n\n\n\n\n\nIn the \nNew ASP.NET Web Application\n window:\n\n\n\n\nClick on \nAzure Mobile App\n.\n\n\nDo \nNOT\n check \"Host in the cloud\" or any other checkboxes.\n\n\nClick on OK.\n\n\n\n\n\n\n\n\nAt this point, Visual Studio will create your backend project.\n\n\n\n\nWarn\n\n\nIt's very tempting to select \nAzure Mobile Services\n instead - it sounds\ncloser to what you want.  Azure Mobile Services is the \nOLD\n service and is\nbeing shut down.  You should not select Azure Mobile Services for any project.\n\n\n\n\nThere are a few files of which you should take note.  The Mobile Apps SDK is\ninitialized within \nApp_Start\\Startup.MobileApp.cs\n (with the call to the\nconfiguration routine happening within \nStartup.cs\n).  The default startup\nroutine is reasonable but it hides what it is doing behind extension methods.\nThis technique is fairly common in ASP.NET programs.  Let's expand the\nconfiguration routine to only include what we need:\n\n\npublic static void ConfigureMobileApp(IAppBuilder app)\n{\n    var config = new HttpConfiguration();\n    var mobileConfig = new MobileAppConfiguration();\n\n    mobileConfig\n        .AddTablesWithEntityFramework()\n        .ApplyTo(config);\n\n    Database.SetInitializer(new MobileServiceInitializer());\n\n    app.UseWebApi(config);\n}\n\n\n\n\nThe minimal version of the mobile backend initialization is actually shorter\nthan the original.  It also only includes a data access layer.  Other services\nlike authentication, storage and push notifications are not configured.\n\n\nThere is another method in the \nApp_Start\\Startup.MobileApp.cs\n file for\nseeding data into the database for us.  We can leave that alone for now, but\nremember it is there in case you need to seed data into a new database for\nyour own backend.\n\n\n\n\nInfo\n\n\nWe refer to \"seeding data\" into a database.  This means that we are going to introduce\nsome data into the database so that we aren't operating on an empty database. The data\nwill be there when we query the database later on.\n\n\n\n\nThe next important file is the \nDbContext\n - located in\n\nModels\\MobileServiceContext.cs\n. Azure Mobile Apps is heavily dependent on\n\nEntity Framework v6.x\n and the \nDbContext\n is a central part of that\nlibrary.  Fortunately, we don't need to do anything to this file right now.\n\n\nFinally, we get to the meat of the backend.  The whole point of this\ndemonstration is to project a single database table - the TodoItem table - into\nthe mobile realm with the aid of an opinionated \nOData v3\n feed.  To that\nend, we need three items:\n\n\n\n\nA \nDbSet<>\n within the \nDbContext\n\n\nA Data Transfer Object (or DTO)\n\n\nA Table Controller\n\n\n\n\nWhen we create the project, a sample of each one of these for the TodoItem table\nis added for us.  You can see the \nDbSet<>\n in the \nModels\\MobileServiceContext.cs\n\nfile, for example.  Let's take a look at the DTO and Table Controller for this\nexample table as well.  The DTO for the TodoItem table is located within the\n\nDataObjects\n directory:\n\n\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.DataObjects\n{\n    public class TodoItem : EntityData\n    {\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n    }\n}\n\n\n\n\nNote that the model uses \nEntityData\n as a base class.  The \nEntityData\n class\nadds five additional properties to the class - we'll discuss those in more\ndetails during the \nData Access and Offline Sync\n chapter.\n\n\nFinally, let's look at the table controller for the example TodoItem table.  This\nis located in \nControllers\\TodoItemController.cs\n:\n\n\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}\n\n\n\n\nThe \nTableController\n is the central processing for the database access layer.\nIt handles all the OData capabilities for us and exposes these as REST endpoints\nwithin our WebAPI.  This means that the actual code for this controller is tiny - just 12 lines of code.\n\n\n\n\nInfo\n\n\nOData\n is a specification for accessing table data on the Internet.  It provides\na mechanism for querying and manipulating data within a table.  Entity Framework is a\ncommon data access layer for ASP.NET applications.\n\n\n\n\nWe can build the project at this point.  If Visual Studio hasn't done so already,\nthe missing NuGet packages for Azure Mobile Apps will be downloaded.  There\nshould not be any errors.  If there are, check the typing for any changes you\nmade.\n\n\nBuilding an Azure App Service for Mobile Apps\n\u00b6\n\n\nThe next step in the process is to build the resources on Azure that will\nrun your mobile backend.  Start by logging into the \nAzure Portal\n, then\nfollow these instructions:\n\n\n\n\nClick on the big \n+ New\n button in the top-left corner.\n\n\nClick on \nWeb + Mobile\n, then \nMobile App\n.\n\n\n\n\nEnter a unique name in the \nApp name\n box.\n\n\n\n\nTip\n\n\nSince the name doesn't matter and it has to be unique, you can use \na\nGUID generator\n to generate a unique name. GUIDs are not the best\nnames to use when you need to actually find resources, but using GUIDS\nprevents conflicts when deploying, so I prefer them as a naming scheme.\nYou can prefix the GUID  (example: chapter1-GUID) to aid in discovery\nlater on.  Generally, the first four digits of a GUID are enough to\nidentify individual resources.\n\n\n\n\n\n\n\n\nIf you have more than one subscription (for example, you have a trial\n   and an MSDN subscription), then ensure you select the right subscription\n   in the \nSubscription\n drop-down.\n\n\n\n\n\n\nSelect \nCreate new\n under resource group and enter a name for this\n   mobile application.\n\n\n\n\nResource Groups\n\n\nResource groups are great for grouping all the resources associated with a\nmobile application together.  During development, it means you can delete\nall the resources in one operation.  For production, it means you can see how\nmuch the service is costing you and how the resources are being used.\n\n\n\n\n\n\n\n\nFinally, select or create a new \nApp Service Plan\n.\n\n\n\n\nApp Service Plan\n\n\nThe App Service Plan is the thing that actually bills you - not the web or\nmobile backend.  You can run a number of web or mobile backends on the same\nApp Service Plan.\n\n\n\n\nI tend to create a new App Service Plan for each mobile application.  This\nis because the App Service Plan lives inside the Resource Group that you\ncreate.  The process for creating an App Service Plan is straight forward.\nYou have two decisions to make.  The first decision is where is the service\ngoing to run.  In a production environment, the correct choice is \"near your\ncustomers\".  \"Close to the developers\" is a good choice during development.\nUnfortunately, neither of those is an option you can actually choose in the\nportal, so you will have to translate into some sort of geographic location.\nWith 16 regions to choose from, you have a lot of choice.\n\n\nThe second decision you have to make is what to run the service on; also\nknown as the Pricing tier.   If you click on \nView all\n, you will see you\nhave lots of choices.  F1 Free and D1 Shared, for example, run on shared\nresources and are CPU limited. You should avoid these as the service will\nstop responding when you are over the CPU quota.  That leaves Basic,\nStandard and Premium.  Basic has no automatic scaling and can run up to 3\ninstances - perfect for development tasks.  Standard and Premium both have\nautomatic scaling, automatic backups, and large amounts of storage; they\ndiffer in features: the number of sites or instances you can run on them,\nfor example.  Finally, there is a number after the plan.  This tells you how\nbig the virtual machine is that the plan is running on.  The numbers differ\nby number of cores and memory.\n\n\nFor our purposes, an F1 Free site is enough to run this small demonstration\nproject.  More complex development projects should use something in the\nBasic range of pricing plans.  Production apps should be set up in Standard\nor Premium pricing plans.\n\n\n\n\n\n\nOnce you have created your app service plan and saved it, click on \nCreate\n.\n\n\n\n\n\n\nThe creation of the service can take a couple of minutes.  You can monitor the\nprocess of deployment by clicking on the Notifications icon.  This is in the top\nbar on the right-hand side and looks like a Bell.  Clicking on a specific\nnotification will provide more information about the activity.  Once you have\ncreated your app service, the App Service blade will open.\n\n\n\n\nInfo\n\n\nWhat's the difference between a Web App, a Mobile App and an API App?  Not a\nlot.  The type determines which Quick start projects are available in the Quick\nstart menu under \nAll settings\n.  Since we selected a Mobile app, a set of\nstarter client projects for mobile devices will be presented.\n\n\n\n\nWe will also want a place to store our data.  This role is taken on by a\nSQL Azure instance.  We could link an existing database if we had one\ndefined.  However, we can also create a test database.\n\n\n\n\nTip\n\n\nCreating a Test Database through the App Service Data Connections (as\nI describe here) allows you to create a free database.  This option is\nnot normally available through other SQL database creation flows.\n\n\n\n\n\n\nClick on \nResource groups\n in the left hand side menu.\n\n\nClick on the resource group you created.\n\n\nClick on the App Service your created.\n\n\n\n\nClick on \nAll settings\n.\n\n\n\n\nTip\n\n\nIf you pinned your App Service to the dashboard, you can click on the\npinned App Service instead.  It will bring you to the same place.\n\n\n\n\n\n\n\n\nClick on \nData connections\n in the \nMOBILE\n menu.\n\n\n\n\n\n\nClick on \nAdd\n.\n\n\n\n\nIn the \nType\n box, select \nSQL Database\n.\n\n\nClick on the unconfigured \nSQL Database\n link:\n\n\n\n\n\n\n\n\nIn the \nDatabase\n blade, select \nCreate a new database\n.\n\n\nEnter a name for the database (like \nchapter1-db\n).\n\n\nSelect a Pricing Tier (look for \nF Free\n at the bottom).\n\n\nClick on the unconfigured \nServer\n.\n\n\n\n\n\n\n\n\nEnter a unique name for the server (a GUID is a good idea here).\n\n\nEnter a username and password for the server.\n\n\nClick on \nOK\n to close the \nNew Server\n blade.\n\n\nClick on \nOK\n to close the \nNew Database\n blade.\n\n\nClick on \nOK\n to close the \nAdd Data Connection\n blade.\n\n\n\n\n\n\n\n\nThis produces another deployment step that creates a SQL Server and a SQL\ndatabase with your settings.  Once complete, the connection\n\nMS_TableConnectionString\n will be listed in Data Connections blade.\n\n\n\n\n\n\nTip\n\n\nIf you want a completely free mobile backend, search for the \nMobile\nApps Quickstart\n in the Azure Marketplace.  This template does not\nrequire a database.  It relies on a Node backend, however, so you won't\nbe developing a C# backend.\n\n\n\n\nDeploying the Azure Mobile Apps Backend\n\u00b6\n\n\nDeploying to Azure as a developer can be accomplished while entirely within\nVisual Studio:\n\n\n\n\nRight-click on the \nBackend\n project, then select \nPublish...\n.\n\n\n\n\nMake sure you see this screen shot:\n\n\n\n\nIf you do not see this image, then it is likely you have an older version\nof the Azure SDK installed.  Make sure the Azure SDK version is v2.9 or\nlater.\n\n\n\n\n\n\nClick on \nMicrosoft Azure App Service\n.\n\n\n\n\nYou may be prompted to enter your Azure credentials here.  Enter the same\n    information that you enter to access the Azure Portal.\n\n\nIn the lower box, expand the resource group that you created and select the\n    app service you created in the portal.\n\n\nClick on \nOK\n.\n\n\nClick on \nPublish\n.\n\n\n\n\nVisual Studio will open a browser.  Add \n/tables/todoitem?ZUMO-API-VERSION=2.0.0\n\nto the end of the URL.  This will show the JSON contents of the table that we\ndefined in the backend.\n\n\n\n\nInfo\n\n\nYou will see the word ZUMO all over the SDK, including in optional HTTP headers\nand throughout the SDK source code.  ZUMO was the original code name within Microsoft\nfor A\nZU\nre \nMO\nbile.\n\n\n\n\nThe Mobile Client\n\u00b6\n\n\nNow that the mobile backend is created and deployed, we can move onto the client\nside of things.  First of all, let's prepare the Visual Studio instance.  If you\nhave installed the Cross-Platform Mobile tools during the installation, most of\nthe work has already been done.  However, you may want to install the \nXamarin\nForms Templates\n using the Tools -> Extensions and Updates...\n\n\n\n\nThis template pack provides additional templates for Xamarin Forms development\nthat I find useful.  Most notably, there is a specific template for a mobile\ncross-platform project covering the Android, iOS and UWP mobile platforms.\n\n\n\n\nInfo\n\n\nWhen you compile a Xamarin.Forms application for a specific platform, you are\nproducing a true native application for that platform - whether it be iOS,\nAndroid or Windows.\n\n\n\n\nCreating a Simple Mobile Client with Xamarin\n\u00b6\n\n\nNow that we have prepared your Visual Studio instance, we can create the\nproject. Right-click on the solution and select \nAdd\n -> \nNew Project...\n.\nThis will bring up the familiar New Project dialog.  The project you want is\nunder \nVisual C#\n -> \nCross-Platform\n, and is called \nXamarin.Forms\n(UWP/Android/iOS)\n.  If you did not install the Xamarin Forms Template add-on,\nthen choose the \nBlank Xaml App (Xamarin.Forms Portable)\n project.  Give the\nproject a name, then click on \nOK\n.\n\n\n\n\n> If you did not install the Xamarin Forms Templates, then you can create a\n**Blank Xaml App (Xamarin.Forms Portable)** project instead.\n\n\n\nProject creation will take longer than you expect, but there is a lot going on.\nIf you have never created a mobile or UWP project before, you will be prompted\nto turn on Windows 10 Developer Mode:\n\n\n\n\nDeveloper mode in Windows 10 allows you to run unsigned binaries for development\npurposes and to turn on debugging so that you can step through your UWP programs\nwithin Visual Studio.\n\n\nWe will also get asked to choose what version of the Universal Windows platform\nwe want to target:\n\n\n\n\nVersion 10240 was the first version of Windows 10 that was released to the general\npublic, so that's a good minimum version to pick.  In general, the defaults for\nthe Universal Windows Platform choice are good enough.\n\n\nXamarin allows us to build iOS applications directly from Visual Studio. For\nthis to work, we must have access to a Mac. This could be anything from a\nMacBook Air/Pro, to a Mac Mini in a drawer or closet in the office, or maybe\neven a \nMac in the cloud\n.  The Xamarin tools use SSH to connect to the Mac,\nwhich must be \nconfigured to build iOS apps from Visual Studio\n.\n\n\n\n\nTip\n\n\nIf you don't have a Mac and are not interested in building iOS applications,\ndon't give up now!  You can cancel through the Mac specific project setup and\ncontinue with building a great Android and Universal Windows app.  You can\ndelete the iOS specific project after it has been created.\n\n\n\n\nWhen prompted about the Xamarin Mac Agent, click on \nOK\n to get the list of\nlocal mac agents:\n\n\n\n\nHighlight your mac (in case there are multiples), then click on \nConnect...\n.\nIf your mac is not listed or you are using a Mac in the cloud, then you can\nalways enter the IP address for your mac.\n\n\n\n\nTip\n\n\nFor more troubleshooting tips, visit \nThe Xamarin Troubleshooting Site\n.\n\n\n\n\nYou will be prompted for your username and password:\n\n\n\n\nJust enter the username and password that you use to log in to your mac and click\non \nLogin\n.\n\n\n\n\nTip\n\n\nApple tries very hard to hide the real username of your account from you.  The\neasiest way to find your mac username is to open up the Finder.  The name next\nto your home icon is the name of your account.\n\n\n\n\nIf the connection has successed, you will see a green icon in the Xamarin Visual\nStudio toolbar area. It may take a minute or two to connect and verify that the\nmac can be used.\n\n\nOnce the project is created, you will see that four new projects have been\ncreated: a common library which you named plus one project for each platform\nthat has been chosen.  Since we chose a project with three platforms, we get\nfour projects:\n\n\n\n\nMost of our work will happen in the common library.  However, we can introduce\nplatform-specific code at any point.  The platform-specific code is stored in\nthe platform-specific project.\n\n\nThere is one final item we must do before we leave the set up of the project.\nThere are a number of platform upgrades that inevitably have to happen.  The\nXamarin Platform is updated much more often than the Visual Studio plugin - the\nupdates are released via NuGet: the standard method of distributing libraries\nfor .NET applications.  In addition to the inevitable Xamarin Platform update,\nwe also will want to add the following NuGet packages:\n\n\n\n\nMicrosoft.Azure.Mobile.Client v2.0.0 or later\n\n\nNewtonsoft.Json v6.0.3 or later\n\n\n\n\n\n\nWarn\n\n\nAlthough it is tempting, do not include a v1.x version of the Mobile Client.\nThis is for the earlier Azure Mobile Services.  There are many differences between\nthe wire protocols of the two products.\n\n\n\n\nYou can install the NuGet packages by right-clicking on the project and selecting\n\nManage NuGet Packages...\n.\n\n\n\n\nYou must install the updates and the new NuGet packages on all four projects.\nThis involves repeating the same process for each client project in your\nsolution.\n\n\n\n\nInfo\n\n\nAndroid generally has more updates than the other platforms.  Ensure that you\nupdate the main Xamarin.Forms package and then refresh the update list.  This will\nensure the right list of packages is updated.\n\n\n\n\nBuilding the Common Library\n\u00b6\n\n\nThere are two parts that we must concentrate on within the common library.  The\nfirst is the connection to Azure Mobile Apps and the second is in the pages\nthat the user interacts with.  In both cases, there are best practices to observe.\n\n\nBuilding an Azure Mobile Apps Connection\n\u00b6\n\n\nWe will rely on interfaces for defining the shape for the class for any service\nthat we interact with.  This is really not important in small projects like this\none.  This technique allows us to mock the backend service, as we shall see\nlater on.  Mocking the backend service is a great technique to rapidly iterate\non the front end mobile client without getting tied into what the backend is doing.\n\n\nLet's start with the cloud service - this is defined in\n\nAbstractions\\ICloudService.cs\n.  It is basically used for initializing\nthe connection and getting a table definition:\n\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n    }\n}\n\n\n\n\nThere is a dependent implementation here: the \nICloudTable\n generic interface.  This\nrepresents a CRUD interface into our tables and is defined in \nAbstractions\\ICloudTable.cs\n:\n\n\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudTable<T> where T : TableData\n    {\n        Task<T> CreateItemAsync(T item);\n        Task<T> ReadItemAsync(string id);\n        Task<T> UpdateItemAsync(T item);\n        Task DeleteItemAsync(T item);\n\n        Task<ICollection<T>> ReadAllItemsAsync();\n    }\n}\n\n\n\n\nThe \nICloudTable<T>\n interface defines the normal CRUD operations: Create, Read,\nUpdate and Delete.  However, it does so asynchronously.  We are dealing with network\noperations in general so it is easy for those operations to tie up the UI thread\nfor an appreciable amount of time.  Making them async provides the ability to\nrespond to other events.  I also provide a \nReadAllItemsAsync()\n method that\nreturns a collection of all the items.\n\n\nThere are some fields that every single record within an Azure Mobile Apps table\nprovides.  These fields are required for offline sync capabilities like incremental\nsync and conflict resolution.  The fields are provided by an abstract base class\non the client called \nTableData\n:\n\n\nusing System;\n\nnamespace TaskList.Abstractions\n{\n    public abstract class TableData\n    {\n        public string Id { get; set; }\n        public DateTimeOffset? UpdatedAt { get; set; }\n        public DateTimeOffset? CreatedAt { get; set; }\n        public byte[] Version { get; set; }\n    }\n}\n\n\n\n\nAs we will learn when we deal with \ntable data\n, these fields need to\nbe defined with the same name and semantics as on the server.  Our model on\nthe server was sub-classed from \nEntityData\n and the \nEntityData\n class on the\nserver defines these fields.\n\n\nIt's tempting to call the client version of the class the same as the server\nversion.  If we did that, the models on both the client and server would look\nthe same.  However, I find that this confuses the issue.  The models on the\nclient and server are not the same.  They are missing the \nDeleted\n flag and\nthey do not contain any relationship information on the client.  I choose to\ndeliberately call the base class something else on the client to avoid this\nconfusion.\n\n\nWe will be adding to these interfaces in future chapters as we add more\ncapabilities to the application.\n\n\nThe concrete implementations of these classes are similarly easily defined.  The\nAzure Mobile Apps Client SDK does most of the work for us.  Here is the concrete\nimplementation of the \nICloudService\n (in \nServices\\AzureCloudService.cs\n):\n\n\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(\"https://my-backend.azurewebsites.net\");\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData\n        {\n            return new AzureCloudTable<T>(client);\n        }\n    }\n}\n\n\n\n\nThe Azure Mobile Apps Client SDK takes a lot of the pain out of communicating\nwith the mobile backend that we have already published.  Just swap out the\nname of your mobile backend and the rest is silently dealt with.\n\n\n\n\nWarn\n\n\nThe name \nMicrosoft.WindowsAzure.MobileServices\n is a hold-over from the old Azure\nMobile Services code-base.  Don't be fooled - clients for Azure Mobile Services are\nnot interchangeable with clients for Azure Mobile Apps.\n\n\n\n\nWe also need a concrete implementation of the \nICloudTable<T>\n interface (in \nServices\\AzureCloudTable.cs\n):\n\n\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudTable<T> : ICloudTable<T> where T : TableData\n    {\n        MobileServiceClient client;\n        IMobileServiceTable<T> table;\n\n        public AzureCloudTable(MobileServiceClient client)\n        {\n            this.client = client;\n            this.table = client.GetTable<T>();\n        }\n\n        #region ICloudTable implementation\n        public async Task<T> CreateItemAsync(T item)\n        {\n            await table.InsertAsync(item);\n            return item;\n        }\n\n        public async Task DeleteItemAsync(T item)\n        {\n            await table.DeleteAsync(item);\n        }\n\n        public async Task<ICollection<T>> ReadAllItemsAsync()\n        {\n            return await table.ToListAsync();\n        }\n\n        public async Task<T> ReadItemAsync(string id)\n        {\n            return await table.LookupAsync(id);\n        }\n\n        public async Task<T> UpdateItemAsync(T item)\n        {\n          await table.UpdateAsync(item);\n          return item;\n        }\n        #endregion\n    }\n}\n\n\n\n\nIt's important to note here that the Azure Mobile Apps Client SDK does a lot of\nthe work for us.  In fact, we are just wrapping the basic interface here.  This\nwon't normally be the case, but you can see that the majority of the code for\ndealing with the remote server is done for us.\n\n\n\n\nTip\n\n\nYou can use a shorthand (called a lambda expression) for methods with only one line.\nFor instance, the delete method could just as easily have been written as:\n\n\npublic async Task DeleteItemAsync(T item) => await table.DeleteAsync(item);\n\n\nYou may see this sort of short hand in samples.\n\n\n\n\nWe also need to create the model that we will use for the data.  This should\nlook very similar to the model on the server - including having the same name\nand fields.  In this case, it's \nModels\\TodoItem.cs\n:\n\n\nusing TaskList.Abstractions\n\nnamespace TaskList.Models\n{\n    public class TodoItem : TableData\n    {\n        public string Text { get; set; }\n        public bool Complete { get; set; }\n    }\n}\n\n\n\n\nWe have a final piece of code to write before we move on to the views, but it's\nan important piece.  The \nICloudService\n must be a singleton in the client.  We\nwill add authentication and offline sync capabilities in future versions of this\ncode.  The singleton becomes critical when using those features.  For right now,\nit's good practice and saves on memory if you only have one copy of the \nICloudService\n\nin your mobile client.  Since there is only one copy of the \nApp.cs\n in any\ngiven app, I can place it there.  Ideally, I'd use some sort of dependency\ninjection system or a singleton manager to deal with this.  Here is the \nApp.cs\n:\n\n\nusing TaskList.Abstractions;\nusing TaskList.Services;\nusing Xamarin.Forms;\n\nnamespace TaskList\n{\n    public class App : Application\n    {\n        public static ICloudService CloudService { get; set; }\n\n        public App()\n        {\n            CloudService = new AzureCloudService();\n            MainPage = new NavigationPage(new Pages.EntryPage());\n        }\n\n        // There are lifecycle methods here...\n    }\n}\n\n\n\n\nWe haven't written \nPages.EntryPage\n yet, but that's coming.  The original \nApp.cs\n\nclass file had several methods for handling lifecycle events like starting, suspending\nor resuming the app.  I did not touch those methods for this example.\n\n\nBuilding the UI for the App\n\u00b6\n\n\nEarlier, I showed the mockup for my UI.  It included three pages - an entry\npage, a list page and a detail page.  These pages have three elements - a\nXAML definition file, a (simple) code-behind file and a view model.\n\n\n\n\nInfo\n\n\nThis book is not intending to introduce you to everything that there is to know\nabout Xamarin and UI programming with XAML.  If you wish to have that sort of introduction,\nthen I recommend reading the excellent book by Charles Petzold: \nCreating Mobile Apps with Xamarin.Forms\n.\n\n\n\n\nI tend to use MVVM (or Model-View-ViewModel) for UI development in Xamarin\nbased applications.  It's a nice clean pattern and is well understood and\ndocumented.  In MVVM, there is a 1:1 correlation between the view and the\nview-model, 2-way communication between the view and the view-model and\nproperties within the view-model are bound directly to UI elements.  In\ngeneral (and in all my code), view-models expose an INotifyPropertyChanged\nevent to tell the UI that something within the view-model has been changed.\n\n\nTo do this, we will use a \nBaseViewModel\n class that implements the base functionality\nfor each view.  Aside from the \nINotifyPropertyChanged\n interface, there are\nsome common properties we need for each page.  Each page needs a title, for\nexample, and each page needs an indicator of network activity.  These can be\nplaced in the \nAbstractions\\BaseViewModel.cs\n class:\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\n\nnamespace TaskList.Abstractions\n{\n    public class BaseViewModel : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n        string _propTitle = string.Empty;\n        bool _propIsBusy;\n\n        public string Title\n        {\n            get { return _propTitle; }\n            set { SetProperty(ref _propTitle, value, \"Title\"); }\n        }\n\n        public bool IsBusy\n        {\n            get { return _propIsBusy; }\n            set { SetProperty(ref _propIsBusy, value, \"IsBusy\"); }\n        }\n\n        protected void SetProperty<T>(ref T store, T value, string propName, Action onChanged = null)\n        {\n            if (EqualityComparer<T>.Default.Equals(store, value))\n                return;\n            store = value;\n            if (onChanged != null)\n                onChanged();\n            OnPropertyChanged(propName);\n        }\n\n        public void OnPropertyChanged(string propName)\n        {\n            if (PropertyChanged == null)\n                return;\n            PropertyChanged(this, new PropertyChangedEventArgs(propName));\n        }\n    }\n}\n\n\n\n\nThis is a fairly common \nINotifyPropertyChanged\n interface implementation pattern.\nEach property that we want to expose is a standard property, but the \nset\n operation\nis replaced by the \nSetProperty()\n call.  The \nSetProperty()\n call deals with the\nnotification; calling the event emitter if the property has changed value.  We\nonly need two properties on the \nBaseViewModel\n: the title and the network indicator.\n\n\nI tend to write my apps in two stages.  I concentrate on the functionality of the\napp in the first stage.  There is no fancy graphics, custom UI widgets, or anything\nelse to clutter the thinking.   The page is all about the functionality of the\nvarious interactions.  Once I have the functionality working, I work on the styling\nof the page.  We won't be doing any styling work in the demonstration apps that we\nwrite during the course of this book.\n\n\nThe EntryPage has just one thing to do.  It provides a button that enters the app.\nWhen we cover authentication later on, we'll use this to log in to the backend.  If\nyou are looking at the perfect app, this is a great place to put the introductory\nscreen.\n\n\nCreating a XAML file is relatively simple.  First, create a \nPages\n directory to\nhold the pages of our application.  Then right-click on the \nPages\n directory in\nthe solution explorer and choose \nAdd\n -> \nNew Item...\n.  In the \nAdd New Item\n\ndialog, pick \nVisual C#\n -> \nCross-Platform\n -> \nForms Xaml Page\n.  Name the\nnew page \nEntryPage.cs\n.  This will create two files - \nEntryPage.xaml\n and\n\nEntryPage.xaml.cs\n.  Let's center a button on the page and wire it up with\na command.  Here is the \nPages\\EntryPage.xaml\n file:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.EntryPage\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <StackLayout HorizontalOptions=\"Center\"\n                     Orientation=\"Vertical\"\n                     VerticalOptions=\"Center\">\n            <Button BackgroundColor=\"Teal\"\n                    BorderRadius=\"10\"\n                    Command=\"{Binding LoginCommand}\"\n                    Text=\"Login\"\n                    TextColor=\"White\" />\n        </StackLayout>\n    </ContentPage.Content>\n</ContentPage>\n\n\n\n\nThere are a couple of interesting things to note here.  The \nStackLayout\n element\nis our layout element.  It occupies the entire screen (since it is a direct child\nof the content page) and the options just center whatever the contents are.  The\nonly contents are a button.\n\n\nThere are two bindings.  These are bound from the view-model.  We've already seen\nthe Title property - this is a text field that specifies the title of the page.\nThe other binding is a login command.  When the button is tapped, the login command\nwill be run.  We'll get onto that in the view-model later.\n\n\nThe other part of the XAML is the code-behind file.  Because we are moving all\nof the non-UI code into a view-model, the code-behind file is trivial:\n\n\nusing TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class EntryPage : ContentPage\n    {\n        public EntryPage()\n        {\n            InitializeComponent();\n            BindingContext = new EntryPageViewModel();\n        }\n    }\n}\n\n\n\n\nThis is a recipe that will be repeated over and over again for the code-behind\nwhen you are using a XAML-based project with MVVM.  We initialize the UI, then\nbind all the bindings to a new instantiation of the view model.\n\n\nTalking of which, the view-model needs just to handle the login click.  Note that\nthe location or namespace is \nTaskList.ViewModels\n.  I'm of two minds about location.\nThere tends to be a 1:1 relationship between the XAML file and the View Model, so\nit makes sense that they are stored together.  However, just about all the sample\ncode that I see has the view-models in a separate namespace.  Which one is correct?\nI'll go with copying the samples for now.  Here is the code for \nViewModels\\EntryPageViewModel.cs\n:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class EntryPageViewModel : BaseViewModel\n    {\n        public EntryPageViewModel()\n        {\n            Title = \"Task List\";\n        }\n\n        Command loginCmd;\n        public Command LoginCommand => loginCmd ?? (loginCmd = new Command(async () => await ExecuteLoginCommand()));\n\n        async Task ExecuteLoginCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[Login] Error = {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}\n\n\n\n\nThis is a fairly simple view-model but there are some patterns here that are\nworth explaining.  Firstly, note the way we create the \nLoginCommand\n property.\nThis is the property that is bound to the \nCommand\n parameter in the \nButton\n\nof our view.  This recipe is the method of invoking a UI action asynchronously.\nIt isn't important now, but we will want this technique repeatedly as our UI\nactions kick off network activity.\n\n\nThe second is the pattern for the \nExecuteLoginCommand\n method.  Firstly, I\nensure nothing else is happening by checking the IsBusy flag.   If nothing\nis happening, I set the IsBusy flag.  Then I do what I need to do in a try/catch\nblock.  If an exception is thrown, I deal with it.  Most of the time this\ninvolves displaying an error condition.  There are several cross-platform dialog\npackages to choose from or you can roll your own.  That is not covered here.  We\njust write a debug log statement so we can see the result in the debug log.  Once\neverything is done, we clear the IsBusy flag.\n\n\nThe only thing we are doing now is swapping out our main page for a new main\npage.  This is where we will attach authentication later on.\n\n\nThe next page is the Task List page, which is in \nPages\\TaskList.xaml\n:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.TaskList\"\n             Title=\"{Binding Title}\">\n  <ContentPage.Content>\n    <StackLayout>\n      <ListView BackgroundColor=\"#7F7F7F\"\n                CachingStrategy=\"RecycleElement\"\n                IsPullToRefreshEnabled=\"True\"\n                IsRefreshing=\"{Binding IsBusy, Mode=OneWay}\"\n                ItemsSource=\"{Binding Items}\"\n                RefreshCommand=\"{Binding RefreshCommand}\"\n                RowHeight=\"50\"\n                SelectedItem=\"{Binding SelectedItem, Mode=TwoWay}\">\n        <ListView.ItemTemplate>\n          <DataTemplate>\n            <ViewCell>\n              <StackLayout HorizontalOptions=\"FillAndExpand\"\n                           Orientation=\"Horizontal\"\n                           Padding=\"10\"\n                           VerticalOptions=\"CenterAndExpand\">\n                <Label HorizontalOptions=\"FillAndExpand\"\n                       Text=\"{Binding Text}\"\n                       TextColor=\"#272832\" />\n                <Switch IsToggled=\"{Binding Complete, Mode=OneWay}\" />\n              </StackLayout>\n            </ViewCell>\n          </DataTemplate>\n        </ListView.ItemTemplate>\n      </ListView>\n      <StackLayout HorizontalOptions=\"Center\"\n                   Orientation=\"Horizontal\">\n        <Button BackgroundColor=\"Teal\"\n                Command=\"{Binding AddNewItemCommand}\"\n                Text=\"Add New Item\"\n                TextColor=\"White\" />\n      </StackLayout>\n    </StackLayout>\n  </ContentPage.Content>\n</ContentPage>\n\n\n\n\nNote that some bindings here are one-way.  This means that the value in the\nview-model drives the value in the UI.  There is nothing within the UI that you\ncan do to alter the state of the underlying property.  Some bindings are two-way.\nDoing something in the UI (for example, toggling the switch) alters the underlying\nproperty.\n\n\nThis view is a little more complex.  It can be split into two parts - the list\nat the top of the page and the button area at the bottom of the page.  The list\narea uses a template to help with the display of each item.\n\n\nNote that the \nListView\n object has a \"pull-to-refresh\" option that I have wired\nup so that when pulled, it calls the RefreshCommand.  It also has an indicator\nthat I have wired up to the IsBusy indicator.  Anyone who is familiar with the\niOS \"pull-to-refresh\" gesture can probably guess what this does.\n\n\nThere is a view-model that goes along with the view (in \nViewModels\\TaskListViewModel.cs\n):\n\n\nusing System;\nusing System.Collections.ObjectModel;\nusing System.Collections.Specialized;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskListViewModel : BaseViewModel\n    {\n        public TaskListViewModel()\n        {\n            Title = \"Task List\";\n            RefreshList();\n        }\n\n        ObservableCollection<TodoItem> items = new ObservableCollection<TodoItem>();\n        public ObservableCollection<TodoItem> Items\n        {\n            get { return items; }\n            set { SetProperty(ref items, value, \"Items\"); }\n        }\n\n        TodoItem selectedItem;\n        public TodoItem SelectedItem\n        {\n            get { return selectedItem; }\n            set\n            {\n                SetProperty(ref selectedItem, value, \"SelectedItem\");\n                if (selectedItem != null)\n                {\n                    Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail(selectedItem));\n                    SelectedItem = null;\n                }\n            }\n        }\n\n        Command refreshCmd;\n        public Command RefreshCommand => refreshCmd ?? (refreshCmd = new Command(async () => await ExecuteRefreshCommand()));\n\n        async Task ExecuteRefreshCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                var table = App.CloudService.GetTable<TodoItem>();\n                var list = await table.ReadAllItemsAsync();\n                Items.Clear();\n                foreach (var item in list)\n                    Items.Add(item);\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskList] Error loading items: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command addNewCmd;\n        public Command AddNewItemCommand => addNewCmd ?? (addNewCmd = new Command(async () => await ExecuteAddNewItemCommand()));\n\n        async Task ExecuteAddNewItemCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                await Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskList] Error in AddNewItem: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        async Task RefreshList()\n        {\n            await ExecuteRefreshCommand();\n            MessagingCenter.Subscribe<TaskDetailViewModel>(this, \"ItemsChanged\", async (sender) =>\n            {\n                await ExecuteRefreshCommand();\n            });\n        }\n    }\n}\n\n\n\n\nThis is a combination of the patterns we have seen earlier.  The Add New Item\nand Refresh commands should be fairly normal patterns now.  We navigate to the\ndetail page (more on that later) in the case of selecting an item (which occurs\nwhen the UI sets the \nSelectedItem\n property through a two-way binding) and when\nthe user clicks on the Add New Item button.  When the Refresh button is clicked\n(or when the user opens the view for the first time), the list is refreshed.  It\nis fairly common to use an \nObservableCollection\n or another class that uses the\n\nICollectionChanged\n event handler for the list storage.  Doing so allows the UI\nto react to changes in the items.\n\n\nNote the use of the \nICloudTable\n interface here.  We are using the \nReadAllItemsAsync()\n\nmethod to get a list of items, then we copy the items we received into the \nObservableCollection\n.\n\n\nFinally, there is the TaskDetail page.  This is defined in the \nPages\\TaskDetail.xaml\n\nfile:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.TaskDetail\"\n             Title=\"{Binding Title}\">\n  <ContentPage.Content>\n    <StackLayout Padding=\"10\" Spacing=\"10\">\n      <Label Text=\"What should I be doing?\"/>\n      <Entry Text=\"{Binding Item.Text}\"/>\n      <Label Text=\"Completed?\"/>\n      <Switch IsToggled=\"{Binding Item.Complete}\"/>\n      <StackLayout VerticalOptions=\"CenterAndExpand\"/>\n      <StackLayout Orientation=\"Vertical\" VerticalOptions=\"End\">\n        <StackLayout HorizontalOptions=\"Center\" Orientation=\"Horizontal\">\n          <Button BackgroundColor=\"#A6E55E\"\n                  Command=\"{Binding SaveCommand}\"\n                  Text=\"Save\" TextColor=\"White\"/>\n          <Button BackgroundColor=\"Red\"\n                  Command=\"{Binding DeleteCommand}\"\n                  Text=\"Delete\" TextColor=\"White\"/>\n        </StackLayout>\n      </StackLayout>\n    </StackLayout>\n  </ContentPage.Content>\n</ContentPage>\n\n\n\n\nThis page is a simple form with just two buttons that need to have commands\nwired up.  However, this page is used for both the \"Add New Item\" gesture\nand the \"Edit Item\" gesture.  As a result of this, we need to handle the\npassing of the item to be edited.  This is done in the \nPages\\TaskDetail.xaml.cs\n\ncode-behind file:\n\n\nusing TaskList.Models;\nusing TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class TaskDetail : ContentPage\n    {\n        public TaskDetail(TodoItem item = null)\n        {\n            InitializeComponent();\n            BindingContext = new TaskDetailViewModel(item);\n        }\n    }\n}\n\n\n\n\nThe item that is passed in from the \nTaskList\n page is used to create a\nspecific view-model for that item.  The view-model is similarly configured\nto use that item:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskDetailViewModel : BaseViewModel\n    {\n        ICloudTable<TodoItem> table = App.CloudService.GetTable<TodoItem>();\n\n        public TaskDetailViewModel(TodoItem item = null)\n        {\n            if (item != null)\n            {\n                Item = item;\n                Title = item.Text;\n            }\n            else\n            {\n                Item = new TodoItem { Text = \"New Item\", Complete = false };\n                Title = \"New Item\";\n            }\n        }\n\n        public TodoItem Item { get; set; }\n\n        Command cmdSave;\n        public Command SaveCommand => cmdSave ?? (cmdSave = new Command(async () => await ExecuteSaveCommand()));\n\n        async Task ExecuteSaveCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id == null)\n                {\n                    await table.CreateItemAsync(Item);\n                }\n                else\n                {\n                    await table.UpdateItemAsync(Item);\n                }\n                MessagingCenter.Send<TaskDetailViewModel>(this, \"ItemsChanged\");\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskDetail] Save error: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command cmdDelete;\n        public Command DeleteCommand => cmdDelete ?? (cmdDelete = new Command(async () => await ExecuteDeleteCommand()));\n\n        async Task ExecuteDeleteCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id != null)\n                {\n                    await table.DeleteItemAsync(Item);\n                }\n                MessagingCenter.Send<TaskDetailViewModel>(this, \"ItemsChanged\");\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskDetail] Save error: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}\n\n\n\n\nThe save command uses the \nICloudTable\n interface again - this time doing\neither \nCreateItemAsync()\n or \nUpdateItemAsync()\n to create or update the\nitem.  The delete command, as you would expect, deletes the item with the\n\nDeleteItemAsync()\n method.\n\n\nThe final thing to note from our views is that I am using the \nMessagingCenter\n\nto communicate between the TaskDetail and TaskList views.  If I change the item\nin the \nTaskDetail\n list, then I want to update the list in the \nTaskList\n view.\n\n\nNote that all the code we have added to the solution thus far is in the common\n\nTaskList\n project.  Nothing is required for this simple example in a platform\nspecific project.  That isn't normal, as we shall see.\n\n\nBuilding the Client for Universal Windows\n\u00b6\n\n\nI tend to start by building the Universal Windows mobile client.  I'm using\nVisual Studio, after all, and I don't need to use any emulator.  To build the\nclients:\n\n\n\n\nRight-click on the \nTaskList.UWP (Universal Windows)\n project, then select \nSet as StartUp Project\n.\n\n\nRight-click on the \nTaskList.UWP (Universal Windows)\n project again, then select \nBuild\n.\n\n\nOnce the build is complete, Right-click on the \nTaskList.UWP (Universal Windows)\n project again, then select \nDeploy\n.\n\n\nClick on the \nLocal Machine\n button in your command bar to run the application.\n\n\n\n\nHere are the three screen screens we generated on Windows:\n\n\n\n\nThere are some problems with the UWP version.  Most notably, the \"pull-to-refresh\"\ngesture does not exist, so we will need to set up an alternate gesture.  This\ncould be as easy as adding a refresh button right next to the Add New Item\nbutton.  In addition, there is no indication of network activity - this manifests\nas a significant delay between the TaskList page appearing and the data appearing\nin the list.\n\n\nAside from this, I did do some styling work to ensure that the final version\nlooked like my mock-ups (with the exception of the UI form of the switch, which\nis platform dependent).  If you want to see what I did to correct this, check out\nthe final version of \nthe Chapter 1 sample\n on GitHub.\n\n\n\n\nTip\n\n\n\n\nBuilding for On-Premise\n    If you want to run your backend using on-premise resources (for example, Azure\n    Stack or a local IIS service), your UWP application will need the \nPrivate Networks\n\n    capability.  You can add this in the \nPackage.appxmanifest\n file.  Choose the\n    \nCapabilities\n tab and add the required capability.\n\n\nIf you need to build the project, ensure you redeploy the project after building.\nIt's a step that is easy to miss and can cause some consternation as you change\nthe code and it doesn't seem to have an effect on the application.\n\n\nBuilding the Client for Android\n\u00b6\n\n\nBuilding Android with Visual Studio is as easy as building the Universal Windows\nversion of the mobile client:\n\n\n\n\nRight-click on the \nTaskList.Droid\n project, then select \nSet as StartUp Project\n.\n\n\nRight-click on the \nTaskList.Droid\n project again, then select \nBuild\n.\n\n\n\n\nThe button for running the application has a drop-down that is now significant.\nIt lets you choose the type of device that you will use.  Normally, this runs\neither a 5\" or 7\" KitKat-based Android device.  There is some setup required for\nthe Visual Studio Emulator for Android.  The Visual Studio Emulator for Android\nruns within Hyper-V, so you must install Hyper-V before use.  You get the following\nerror if you don't do this:\n\n\n\n\nTo install Hyper-V:\n\n\n\n\nClose all applications (your system will be rebooted during this process).\n\n\nSearch for \nPrograms and Features\n.\n\n\nClick on \nTurn Windows features on or off\n (in the left-hand menu).\n\n\nExpand the \nHyper-V\n node.\n\n\nCheck all the boxes below the \nHyper-V\n node.  This will include Hyper-V Management Tools and Hyper-V Services.\n\n\nClick on \nOK\n.\n\n\nYour system will install the required pieces and then ask you to restart.  Click on \nRestart now\n when prompted.\n\n\n\n\nOnce you have done this, the next hurdle is to be added to the Hyper-V Administrators\nsecurity group.  It gets done for you (again - the first time you try to run the\napplication after installing Hyper-V).  Once it is done, close Visual Studio (again),\nthe log out and back in again.\n\n\nAs if that wasn't enough, the emulator also needs an Internet connection to\nstart.\n\n\n\n\nYou should be able to just click on \nYes\n or \nOK\n to enable the Internet\nconnection.  My laptop required a reboot before this would work, however.  In\naddition, the process may request elevated privileges.\n\n\n\n\nTip\n\n\nIf you want to run additional Android profiles before starting, run the\n\nVisual Studio Emulator for Android\n and download any additional profiles.\nFor example, if you wish to emulate something similar to a Samsung Galaxy S6,\nthen download the profile for a 5.1\" Marshmallow (6.0.0) XXHDPI Phone.\n\n\n\n\nFinally the Visual Studio Emulator for Android starts when you click on the Run\nbutton.  Fortunately, the setup of the emulator only has to be done once per\nmachine.  The Visual Studio Emulator for Android is also a superior emulator\nto the standard Android Emulator, so this process is well worth going through.\n\n\n\n\nTip\n\n\nWhen testing the mobile client manually through the Visual Studio Emulator for\nAndroid, you are likely to need to rebuild the application.  You do not have to\nshut down the emulator between runs.  You can leave it running.  The application\nwill be stopped and replaced before starting again.  This can significantly speed\nup the debug cycle since you are not waiting for the emulator to start each time.\n\n\n\n\nWatch the Output window.  If the debugger won't connect or the application\nwon't start, you may need to restart your computer again to get the network\nworking.\n\n\n\n\nTip\n\n\nIf your computer doesn't run Hyper-V well (or at all), then the emulator won't run\nwell (or at all) either.  I find laptops to be particularly prone to this problem.\nIf this happens, you can always run the Google Emulator instead.  Build the application\nas normal.  You will find the APK file to install in \n...\\TaskList.Droid\\bin\\Debug\n.\nFortunately, there are lots of resources that show how to do this.  You can find the\nanswer on \nStack Overflow\n\n\n\n\nIf everything is working, you should see the Visual Studio Emulator for Android\ndisplay your mobile client:\n\n\n\n\n\n\nWarn\n\n\nYou can also build the Android version on a mac with Xamarin Studio.  However, I find\nthat version mismatches between Mono (which is used on the mac) and Visual Studio - particularly\nin reference to the version of the .NET framework - cause issues when swapping between the\ntwo environments.  For best results, stay in one environment.\n\n\n\n\nNote that the task list view is a \"light\" style and the rest of the app is a\n\"dark\" style.  This is because the default styling on an Android device is\ndark.  We are using the default styling on two of the pages and specifying\ncolors on the list page.  Fortunately, Xamarin Forms allows for \nplatform-specific\nstyling\n.  The \nfinal sample\n has platform-specific styling for the\nlist page.\n\n\nBuilding the Client for iOS\n\u00b6\n\n\nFinally, we get to the iOS platform.  You will need to ensure your Mac is turned\non and accessible, that it has XCode installed (and you have run XCode once so\nthat you can accept the license agreement), and it has Xamarin Studio installed.\n\n\nWhen you created the projects, you were asked to link Visual Studio to your mac.\nThis linkage is used for building the project.  In essence, the entire project\nis sent to the Mac and the build tools that are supplied with Xamarin Studio\nwill be used to build the project.\n\n\n\n\nRight-click on the \nTaskList.iOS\n project and select \nSet as StartUp Project\n.\n\n\nRight-click on the \nTaskList.iOS\n project and select \nBuild\n.\n\n\n\n\nYou knew it was not going to be that easy, right?  Here are the errors that I\nreceived when building for the first time:\n\n\n\n\nThere are two errors right at the top.  Let's cover the first one.  The error\nabout \nBuild Action 'EmbeddedResource' is not supported\n is an annoying one.\nThe fix is to do the following:\n\n\n\n\nSet the iOS project as the StartUp project.\n\n\nGo through each project, expand the \nReferences\n node and ensure that there are\n   no references with a warning (a little yellow triangle).  If there are - fix those\n   first.  Generally, this is fixed by either using the \nRestore NuGet Packages\n option\n   or removing the reference and then adding it again from NuGet.\n\n\nClose the solution.\n\n\nRe-open the solution.  You don't need to close Visual Studio to do this.\n\n\nRight-click on the iOS project and select \nClean\n.\n\n\nRight-click on the iOS project and select \nRebuild\n.\n\n\n\n\nOnce you have done this sequence, the error should go away.\n\n\nThe error about \nNo valid iOS code signing keys found in keychain\n is because\nwe have not yet signed up for an Apple Developer Account and linked it to our\nMac development environment.\n\n\n\n\nGo to the \nApple Developer Center\n.\n\n\nClick on \nAccount\n in the top navigation bar.\n\n\nIf you haven't got an Apple ID yet, create one first.\n\n\nIf you have go an Apple ID, then log in.\n\n\n\n\nThere are a sequence of sign-up prompts in both cases (first for creating your\nApple ID and secondly for signing up for the Apple Developer program).  Once\nyou have gone through this process, you are registered as an Apple Developer.\n\n\n\n\nInfo\n\n\nIf you want to distribute your apps on the Apple App Store, run on real devices or\nget access to the beta bits, then you might consider signing up for the Apple Developer\nProgram.  The Apple Developer Program is an additional cost and is not required for\ndeveloping iOS apps that are only run on the iOS simulator.\n\n\n\n\nOnce you have created your account and enabled it as a developer account, open\nup XCode.  Go to \nPreferences...\n, then \nAccount\n and\nclick on the \n+\n in the bottom-left corner of the window:\n\n\n\n\nSign in with the same account you used to sign up for the developer account.\n\n\n\n\nClick on the \nView Details\n button.  This will bring up the Signing Identities\nlist.  For a free account, it looks like this:\n\n\n\n\nClick on the Create button next to \niOS Development\n.  Once the UI comes back,\nclick on \nDone\n.  For more information on this process, refer to the \nApple Documentation\n.\n\n\nYou can close XCode at this point.  Ensure Xamarin Studio is not running.  Back\nwithin Visual Studio, right-click on the \nTaskList.iOS\n project and select \nRebuild\n.\nThis will (finally!) build the application for you.\n\n\n\n\nTip\n\n\nGetting an error about \nProvisioning Profiles\n not being available?  This is because\nyou are building for a real device instead of the simulator.  In order to build for a\nreal device, you must have a linked Apple Developer Program.  To get around this, select\na Simulator before building.\n\n\n\n\nThe \nRun\n button has received a \nDevice\n label, but there are several simulator options.\nYou should only use \nDevice\n if you have signed up for the Apple Developer Program.  Pick\none of the simulator options like the \niPhone 6 iOS 9.3\n simulator, then click on it\nto run the simulator.  Before long, you should see the following:\n\n\n\n\nAt some point, you will need a platform initialization call on all platforms.  It's best to\nadd it now.  In TaskList.Droid, this should be added in \nMainActivity.cs\n and in TaskList.iOS,\nit's \nAppDelegate.cs\n.  In each of these files, there is a line that initializes the Xamarin\nForms system.\n\n\n// Android Version\nglobal::Xamarin.Forms.Forms.Init(this, bundle);\n// iOS Version\nglobal::Xamarin.Forms.Forms.Init ();\n\n\n\n\nImmediately before this line, you should add the  initializer for Azure Mobile Apps. It's\nimportant that the Azure Mobile Apps subsystem is initialized prior to Xamarin Forms being\ninitialized and any UI code being called.\n\n\nMicrosoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n\n\n\nThis initializer is not required on the UWP project.  Once this is done and you have re-built\nthe project, we can see the fruits of our labor.  You can, of course, run the IPA in the\niOS simulator on the Mac.  However, it's much more satisfying (to me, at least) to be able\nto do everything from within Visual Studio.  For this, you need to install the\n\nXamarin Installer\n.  This is an MSI for your Windows development system and is\nquickly installed.  Once installed, start (or restart) Visual Studio, select \nTools\n ->\n\nOptions\n.  Search for \nXamarin\n, and select the \niOS Settings\n page.  There is\na new option:\n\n\n\n\nNote the \nRemote Simulator to Windows\n.  This should be checked.  You may need to\nrebuild the TaskList.iOS project after installing the Xamarin Simulator.  The debug\nwindow will tell you if this is the case.  There are also a few \nknown issues\n\nso check the documentation if you run into problems.\n\n\nThe final product screens look like this:\n\n\n\n\nSome Final Thoughts\n\u00b6\n\n\nIf you have got through the entire process outlined in this Chapter and built the application\nfor each platform, then congratulations.  There are a lot of places where things can go\nwrong.  You are really integrating the build systems across Visual Studio, Android, Xamarin,\nand XCode.\n\n\nFortunately, once these are set up, it's likely that they will continue working and you\nwon't have to think too much about them again. The Android and iOS build tools and simulators\nwill just work.\n\n\nIf you would rather develop code on your mac, the next chapter is for you - it gets into\nthe nitty gritty of developing the exact same app, but using Xamarin Studio instead.\n\n\nThe following 7 chapters each take one aspect of the cloud services that can be provided to\nmobile apps and explores it in detail, using an Azure Mobile App as a beginning. You can\njump around at this point, but be aware that we expect you to cover these topics in order.\nIf you do the data chapter before covering authentication, it's likely you will have missed\nimportant functionality in your app to complete the work.",
            "title": "Your First App - PC Edition"
        },
        {
            "location": "/chapter1/firstapp_pc/#your-first-mobile-app",
            "text": "There is a lot of detail to absorb about the possible services that the mobile\nclient can consume and I will go into significant depth on those subjects.\nFirst, wouldn't it be nice to write some code and get something working?\nMicrosoft Azure has a great  first-steps tutorial  that takes you via the\nquickest possible route from creating a mobile backend to having a functional\nbackend.  I would like to take things a little slower so that we can understand\nwhat is going on while we are doing the process.  We will have practically the\nsame application at the end.  The primary reason for going through this slowly\nis to ensure that all our build and run processes are set up properly.  If this\nis the first mobile app you have ever written, you will see that there are quite\na few things that need to be set up.  This chapter covers the set up required\nfor a Windows PC.  If you wish to develop your applications on a Mac, then skip\nto the  next section .  The application we are going to build together is a simple task list.  The\nmobile client will have three screens - an entry screen, a task list and a task\ndetails page.  I have mocked these pages up using  MockingBot .   Tip  Mocking your screens before you start coding is a great habit to get into.\nThere are some great tools available including free tools like  MockingBot .\nDoing mockups before you start coding is a good way to prevent wasted time later\non.     Tip  If you are using iOS, then you may want to remove the back button as the style\nguides suggest you don't need one.  Other platforms will need it though, so it's\nbest to start with the least common denominator.  It's the same reason I add a\nrefresh button even though it's only valid on Windows Phone!   My ideas for this app include:   Tapping on a task title in the task list will bring up the details page.  Toggling the completed link in the task list will set the completed flag.  Tapping the spinner will initiate a network refresh.   Now that we have our client screens planned out, we can move onto the thinking\nabout the mobile backend.",
            "title": "Your First Mobile App"
        },
        {
            "location": "/chapter1/firstapp_pc/#the-mobile-backend",
            "text": "The mobile backend is an ASP.NET WebApi that is served from within Azure App\nService: a highly scalable and redundant web hosting facility that supports all\nthe major web languages (like ASP.NET, Node, PHP and Python).  Azure Mobile\nApps is an SDK (which is available in ASP.NET and Node) that runs on top of\nAzure App Service.",
            "title": "The Mobile Backend"
        },
        {
            "location": "/chapter1/firstapp_pc/#creating-a-simple-azure-mobile-apps-backend",
            "text": "Microsoft Azure has included a comprehensive starter kit template in the\nAzure SDK.  To get started:   Fire up Visual Studio 2015  Add a new project with File -> New Project...   In the  New Project  window:   Open up Templates -> Visual C# -> Web and select  ASP.NET Web Application (.NET Framework) .  Enter  Backend  for the Name and  Chapter1  for the Solution name.  Pick a suitable directory for the Location field.  Click on OK.      In the  New ASP.NET Web Application  window:   Click on  Azure Mobile App .  Do  NOT  check \"Host in the cloud\" or any other checkboxes.  Click on OK.     At this point, Visual Studio will create your backend project.   Warn  It's very tempting to select  Azure Mobile Services  instead - it sounds\ncloser to what you want.  Azure Mobile Services is the  OLD  service and is\nbeing shut down.  You should not select Azure Mobile Services for any project.   There are a few files of which you should take note.  The Mobile Apps SDK is\ninitialized within  App_Start\\Startup.MobileApp.cs  (with the call to the\nconfiguration routine happening within  Startup.cs ).  The default startup\nroutine is reasonable but it hides what it is doing behind extension methods.\nThis technique is fairly common in ASP.NET programs.  Let's expand the\nconfiguration routine to only include what we need:  public static void ConfigureMobileApp(IAppBuilder app)\n{\n    var config = new HttpConfiguration();\n    var mobileConfig = new MobileAppConfiguration();\n\n    mobileConfig\n        .AddTablesWithEntityFramework()\n        .ApplyTo(config);\n\n    Database.SetInitializer(new MobileServiceInitializer());\n\n    app.UseWebApi(config);\n}  The minimal version of the mobile backend initialization is actually shorter\nthan the original.  It also only includes a data access layer.  Other services\nlike authentication, storage and push notifications are not configured.  There is another method in the  App_Start\\Startup.MobileApp.cs  file for\nseeding data into the database for us.  We can leave that alone for now, but\nremember it is there in case you need to seed data into a new database for\nyour own backend.   Info  We refer to \"seeding data\" into a database.  This means that we are going to introduce\nsome data into the database so that we aren't operating on an empty database. The data\nwill be there when we query the database later on.   The next important file is the  DbContext  - located in Models\\MobileServiceContext.cs . Azure Mobile Apps is heavily dependent on Entity Framework v6.x  and the  DbContext  is a central part of that\nlibrary.  Fortunately, we don't need to do anything to this file right now.  Finally, we get to the meat of the backend.  The whole point of this\ndemonstration is to project a single database table - the TodoItem table - into\nthe mobile realm with the aid of an opinionated  OData v3  feed.  To that\nend, we need three items:   A  DbSet<>  within the  DbContext  A Data Transfer Object (or DTO)  A Table Controller   When we create the project, a sample of each one of these for the TodoItem table\nis added for us.  You can see the  DbSet<>  in the  Models\\MobileServiceContext.cs \nfile, for example.  Let's take a look at the DTO and Table Controller for this\nexample table as well.  The DTO for the TodoItem table is located within the DataObjects  directory:  using Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.DataObjects\n{\n    public class TodoItem : EntityData\n    {\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n    }\n}  Note that the model uses  EntityData  as a base class.  The  EntityData  class\nadds five additional properties to the class - we'll discuss those in more\ndetails during the  Data Access and Offline Sync  chapter.  Finally, let's look at the table controller for the example TodoItem table.  This\nis located in  Controllers\\TodoItemController.cs :  using System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}  The  TableController  is the central processing for the database access layer.\nIt handles all the OData capabilities for us and exposes these as REST endpoints\nwithin our WebAPI.  This means that the actual code for this controller is tiny - just 12 lines of code.   Info  OData  is a specification for accessing table data on the Internet.  It provides\na mechanism for querying and manipulating data within a table.  Entity Framework is a\ncommon data access layer for ASP.NET applications.   We can build the project at this point.  If Visual Studio hasn't done so already,\nthe missing NuGet packages for Azure Mobile Apps will be downloaded.  There\nshould not be any errors.  If there are, check the typing for any changes you\nmade.",
            "title": "Creating a Simple Azure Mobile Apps Backend"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-an-azure-app-service-for-mobile-apps",
            "text": "The next step in the process is to build the resources on Azure that will\nrun your mobile backend.  Start by logging into the  Azure Portal , then\nfollow these instructions:   Click on the big  + New  button in the top-left corner.  Click on  Web + Mobile , then  Mobile App .   Enter a unique name in the  App name  box.   Tip  Since the name doesn't matter and it has to be unique, you can use  a\nGUID generator  to generate a unique name. GUIDs are not the best\nnames to use when you need to actually find resources, but using GUIDS\nprevents conflicts when deploying, so I prefer them as a naming scheme.\nYou can prefix the GUID  (example: chapter1-GUID) to aid in discovery\nlater on.  Generally, the first four digits of a GUID are enough to\nidentify individual resources.     If you have more than one subscription (for example, you have a trial\n   and an MSDN subscription), then ensure you select the right subscription\n   in the  Subscription  drop-down.    Select  Create new  under resource group and enter a name for this\n   mobile application.   Resource Groups  Resource groups are great for grouping all the resources associated with a\nmobile application together.  During development, it means you can delete\nall the resources in one operation.  For production, it means you can see how\nmuch the service is costing you and how the resources are being used.     Finally, select or create a new  App Service Plan .   App Service Plan  The App Service Plan is the thing that actually bills you - not the web or\nmobile backend.  You can run a number of web or mobile backends on the same\nApp Service Plan.   I tend to create a new App Service Plan for each mobile application.  This\nis because the App Service Plan lives inside the Resource Group that you\ncreate.  The process for creating an App Service Plan is straight forward.\nYou have two decisions to make.  The first decision is where is the service\ngoing to run.  In a production environment, the correct choice is \"near your\ncustomers\".  \"Close to the developers\" is a good choice during development.\nUnfortunately, neither of those is an option you can actually choose in the\nportal, so you will have to translate into some sort of geographic location.\nWith 16 regions to choose from, you have a lot of choice.  The second decision you have to make is what to run the service on; also\nknown as the Pricing tier.   If you click on  View all , you will see you\nhave lots of choices.  F1 Free and D1 Shared, for example, run on shared\nresources and are CPU limited. You should avoid these as the service will\nstop responding when you are over the CPU quota.  That leaves Basic,\nStandard and Premium.  Basic has no automatic scaling and can run up to 3\ninstances - perfect for development tasks.  Standard and Premium both have\nautomatic scaling, automatic backups, and large amounts of storage; they\ndiffer in features: the number of sites or instances you can run on them,\nfor example.  Finally, there is a number after the plan.  This tells you how\nbig the virtual machine is that the plan is running on.  The numbers differ\nby number of cores and memory.  For our purposes, an F1 Free site is enough to run this small demonstration\nproject.  More complex development projects should use something in the\nBasic range of pricing plans.  Production apps should be set up in Standard\nor Premium pricing plans.    Once you have created your app service plan and saved it, click on  Create .    The creation of the service can take a couple of minutes.  You can monitor the\nprocess of deployment by clicking on the Notifications icon.  This is in the top\nbar on the right-hand side and looks like a Bell.  Clicking on a specific\nnotification will provide more information about the activity.  Once you have\ncreated your app service, the App Service blade will open.   Info  What's the difference between a Web App, a Mobile App and an API App?  Not a\nlot.  The type determines which Quick start projects are available in the Quick\nstart menu under  All settings .  Since we selected a Mobile app, a set of\nstarter client projects for mobile devices will be presented.   We will also want a place to store our data.  This role is taken on by a\nSQL Azure instance.  We could link an existing database if we had one\ndefined.  However, we can also create a test database.   Tip  Creating a Test Database through the App Service Data Connections (as\nI describe here) allows you to create a free database.  This option is\nnot normally available through other SQL database creation flows.    Click on  Resource groups  in the left hand side menu.  Click on the resource group you created.  Click on the App Service your created.   Click on  All settings .   Tip  If you pinned your App Service to the dashboard, you can click on the\npinned App Service instead.  It will bring you to the same place.     Click on  Data connections  in the  MOBILE  menu.    Click on  Add .   In the  Type  box, select  SQL Database .  Click on the unconfigured  SQL Database  link:     In the  Database  blade, select  Create a new database .  Enter a name for the database (like  chapter1-db ).  Select a Pricing Tier (look for  F Free  at the bottom).  Click on the unconfigured  Server .     Enter a unique name for the server (a GUID is a good idea here).  Enter a username and password for the server.  Click on  OK  to close the  New Server  blade.  Click on  OK  to close the  New Database  blade.  Click on  OK  to close the  Add Data Connection  blade.     This produces another deployment step that creates a SQL Server and a SQL\ndatabase with your settings.  Once complete, the connection MS_TableConnectionString  will be listed in Data Connections blade.    Tip  If you want a completely free mobile backend, search for the  Mobile\nApps Quickstart  in the Azure Marketplace.  This template does not\nrequire a database.  It relies on a Node backend, however, so you won't\nbe developing a C# backend.",
            "title": "Building an Azure App Service for Mobile Apps"
        },
        {
            "location": "/chapter1/firstapp_pc/#deploying-the-azure-mobile-apps-backend",
            "text": "Deploying to Azure as a developer can be accomplished while entirely within\nVisual Studio:   Right-click on the  Backend  project, then select  Publish... .   Make sure you see this screen shot:   If you do not see this image, then it is likely you have an older version\nof the Azure SDK installed.  Make sure the Azure SDK version is v2.9 or\nlater.    Click on  Microsoft Azure App Service .   You may be prompted to enter your Azure credentials here.  Enter the same\n    information that you enter to access the Azure Portal.  In the lower box, expand the resource group that you created and select the\n    app service you created in the portal.  Click on  OK .  Click on  Publish .   Visual Studio will open a browser.  Add  /tables/todoitem?ZUMO-API-VERSION=2.0.0 \nto the end of the URL.  This will show the JSON contents of the table that we\ndefined in the backend.   Info  You will see the word ZUMO all over the SDK, including in optional HTTP headers\nand throughout the SDK source code.  ZUMO was the original code name within Microsoft\nfor A ZU re  MO bile.",
            "title": "Deploying the Azure Mobile Apps Backend"
        },
        {
            "location": "/chapter1/firstapp_pc/#the-mobile-client",
            "text": "Now that the mobile backend is created and deployed, we can move onto the client\nside of things.  First of all, let's prepare the Visual Studio instance.  If you\nhave installed the Cross-Platform Mobile tools during the installation, most of\nthe work has already been done.  However, you may want to install the  Xamarin\nForms Templates  using the Tools -> Extensions and Updates...   This template pack provides additional templates for Xamarin Forms development\nthat I find useful.  Most notably, there is a specific template for a mobile\ncross-platform project covering the Android, iOS and UWP mobile platforms.   Info  When you compile a Xamarin.Forms application for a specific platform, you are\nproducing a true native application for that platform - whether it be iOS,\nAndroid or Windows.",
            "title": "The Mobile Client"
        },
        {
            "location": "/chapter1/firstapp_pc/#creating-a-simple-mobile-client-with-xamarin",
            "text": "Now that we have prepared your Visual Studio instance, we can create the\nproject. Right-click on the solution and select  Add  ->  New Project... .\nThis will bring up the familiar New Project dialog.  The project you want is\nunder  Visual C#  ->  Cross-Platform , and is called  Xamarin.Forms\n(UWP/Android/iOS) .  If you did not install the Xamarin Forms Template add-on,\nthen choose the  Blank Xaml App (Xamarin.Forms Portable)  project.  Give the\nproject a name, then click on  OK .   > If you did not install the Xamarin Forms Templates, then you can create a\n**Blank Xaml App (Xamarin.Forms Portable)** project instead.  Project creation will take longer than you expect, but there is a lot going on.\nIf you have never created a mobile or UWP project before, you will be prompted\nto turn on Windows 10 Developer Mode:   Developer mode in Windows 10 allows you to run unsigned binaries for development\npurposes and to turn on debugging so that you can step through your UWP programs\nwithin Visual Studio.  We will also get asked to choose what version of the Universal Windows platform\nwe want to target:   Version 10240 was the first version of Windows 10 that was released to the general\npublic, so that's a good minimum version to pick.  In general, the defaults for\nthe Universal Windows Platform choice are good enough.  Xamarin allows us to build iOS applications directly from Visual Studio. For\nthis to work, we must have access to a Mac. This could be anything from a\nMacBook Air/Pro, to a Mac Mini in a drawer or closet in the office, or maybe\neven a  Mac in the cloud .  The Xamarin tools use SSH to connect to the Mac,\nwhich must be  configured to build iOS apps from Visual Studio .   Tip  If you don't have a Mac and are not interested in building iOS applications,\ndon't give up now!  You can cancel through the Mac specific project setup and\ncontinue with building a great Android and Universal Windows app.  You can\ndelete the iOS specific project after it has been created.   When prompted about the Xamarin Mac Agent, click on  OK  to get the list of\nlocal mac agents:   Highlight your mac (in case there are multiples), then click on  Connect... .\nIf your mac is not listed or you are using a Mac in the cloud, then you can\nalways enter the IP address for your mac.   Tip  For more troubleshooting tips, visit  The Xamarin Troubleshooting Site .   You will be prompted for your username and password:   Just enter the username and password that you use to log in to your mac and click\non  Login .   Tip  Apple tries very hard to hide the real username of your account from you.  The\neasiest way to find your mac username is to open up the Finder.  The name next\nto your home icon is the name of your account.   If the connection has successed, you will see a green icon in the Xamarin Visual\nStudio toolbar area. It may take a minute or two to connect and verify that the\nmac can be used.  Once the project is created, you will see that four new projects have been\ncreated: a common library which you named plus one project for each platform\nthat has been chosen.  Since we chose a project with three platforms, we get\nfour projects:   Most of our work will happen in the common library.  However, we can introduce\nplatform-specific code at any point.  The platform-specific code is stored in\nthe platform-specific project.  There is one final item we must do before we leave the set up of the project.\nThere are a number of platform upgrades that inevitably have to happen.  The\nXamarin Platform is updated much more often than the Visual Studio plugin - the\nupdates are released via NuGet: the standard method of distributing libraries\nfor .NET applications.  In addition to the inevitable Xamarin Platform update,\nwe also will want to add the following NuGet packages:   Microsoft.Azure.Mobile.Client v2.0.0 or later  Newtonsoft.Json v6.0.3 or later    Warn  Although it is tempting, do not include a v1.x version of the Mobile Client.\nThis is for the earlier Azure Mobile Services.  There are many differences between\nthe wire protocols of the two products.   You can install the NuGet packages by right-clicking on the project and selecting Manage NuGet Packages... .   You must install the updates and the new NuGet packages on all four projects.\nThis involves repeating the same process for each client project in your\nsolution.   Info  Android generally has more updates than the other platforms.  Ensure that you\nupdate the main Xamarin.Forms package and then refresh the update list.  This will\nensure the right list of packages is updated.",
            "title": "Creating a Simple Mobile Client with Xamarin"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-the-common-library",
            "text": "There are two parts that we must concentrate on within the common library.  The\nfirst is the connection to Azure Mobile Apps and the second is in the pages\nthat the user interacts with.  In both cases, there are best practices to observe.",
            "title": "Building the Common Library"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-an-azure-mobile-apps-connection",
            "text": "We will rely on interfaces for defining the shape for the class for any service\nthat we interact with.  This is really not important in small projects like this\none.  This technique allows us to mock the backend service, as we shall see\nlater on.  Mocking the backend service is a great technique to rapidly iterate\non the front end mobile client without getting tied into what the backend is doing.  Let's start with the cloud service - this is defined in Abstractions\\ICloudService.cs .  It is basically used for initializing\nthe connection and getting a table definition:  namespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n    }\n}  There is a dependent implementation here: the  ICloudTable  generic interface.  This\nrepresents a CRUD interface into our tables and is defined in  Abstractions\\ICloudTable.cs :  using System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudTable<T> where T : TableData\n    {\n        Task<T> CreateItemAsync(T item);\n        Task<T> ReadItemAsync(string id);\n        Task<T> UpdateItemAsync(T item);\n        Task DeleteItemAsync(T item);\n\n        Task<ICollection<T>> ReadAllItemsAsync();\n    }\n}  The  ICloudTable<T>  interface defines the normal CRUD operations: Create, Read,\nUpdate and Delete.  However, it does so asynchronously.  We are dealing with network\noperations in general so it is easy for those operations to tie up the UI thread\nfor an appreciable amount of time.  Making them async provides the ability to\nrespond to other events.  I also provide a  ReadAllItemsAsync()  method that\nreturns a collection of all the items.  There are some fields that every single record within an Azure Mobile Apps table\nprovides.  These fields are required for offline sync capabilities like incremental\nsync and conflict resolution.  The fields are provided by an abstract base class\non the client called  TableData :  using System;\n\nnamespace TaskList.Abstractions\n{\n    public abstract class TableData\n    {\n        public string Id { get; set; }\n        public DateTimeOffset? UpdatedAt { get; set; }\n        public DateTimeOffset? CreatedAt { get; set; }\n        public byte[] Version { get; set; }\n    }\n}  As we will learn when we deal with  table data , these fields need to\nbe defined with the same name and semantics as on the server.  Our model on\nthe server was sub-classed from  EntityData  and the  EntityData  class on the\nserver defines these fields.  It's tempting to call the client version of the class the same as the server\nversion.  If we did that, the models on both the client and server would look\nthe same.  However, I find that this confuses the issue.  The models on the\nclient and server are not the same.  They are missing the  Deleted  flag and\nthey do not contain any relationship information on the client.  I choose to\ndeliberately call the base class something else on the client to avoid this\nconfusion.  We will be adding to these interfaces in future chapters as we add more\ncapabilities to the application.  The concrete implementations of these classes are similarly easily defined.  The\nAzure Mobile Apps Client SDK does most of the work for us.  Here is the concrete\nimplementation of the  ICloudService  (in  Services\\AzureCloudService.cs ):  using Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(\"https://my-backend.azurewebsites.net\");\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData\n        {\n            return new AzureCloudTable<T>(client);\n        }\n    }\n}  The Azure Mobile Apps Client SDK takes a lot of the pain out of communicating\nwith the mobile backend that we have already published.  Just swap out the\nname of your mobile backend and the rest is silently dealt with.   Warn  The name  Microsoft.WindowsAzure.MobileServices  is a hold-over from the old Azure\nMobile Services code-base.  Don't be fooled - clients for Azure Mobile Services are\nnot interchangeable with clients for Azure Mobile Apps.   We also need a concrete implementation of the  ICloudTable<T>  interface (in  Services\\AzureCloudTable.cs ):  using System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudTable<T> : ICloudTable<T> where T : TableData\n    {\n        MobileServiceClient client;\n        IMobileServiceTable<T> table;\n\n        public AzureCloudTable(MobileServiceClient client)\n        {\n            this.client = client;\n            this.table = client.GetTable<T>();\n        }\n\n        #region ICloudTable implementation\n        public async Task<T> CreateItemAsync(T item)\n        {\n            await table.InsertAsync(item);\n            return item;\n        }\n\n        public async Task DeleteItemAsync(T item)\n        {\n            await table.DeleteAsync(item);\n        }\n\n        public async Task<ICollection<T>> ReadAllItemsAsync()\n        {\n            return await table.ToListAsync();\n        }\n\n        public async Task<T> ReadItemAsync(string id)\n        {\n            return await table.LookupAsync(id);\n        }\n\n        public async Task<T> UpdateItemAsync(T item)\n        {\n          await table.UpdateAsync(item);\n          return item;\n        }\n        #endregion\n    }\n}  It's important to note here that the Azure Mobile Apps Client SDK does a lot of\nthe work for us.  In fact, we are just wrapping the basic interface here.  This\nwon't normally be the case, but you can see that the majority of the code for\ndealing with the remote server is done for us.   Tip  You can use a shorthand (called a lambda expression) for methods with only one line.\nFor instance, the delete method could just as easily have been written as:  public async Task DeleteItemAsync(T item) => await table.DeleteAsync(item);  You may see this sort of short hand in samples.   We also need to create the model that we will use for the data.  This should\nlook very similar to the model on the server - including having the same name\nand fields.  In this case, it's  Models\\TodoItem.cs :  using TaskList.Abstractions\n\nnamespace TaskList.Models\n{\n    public class TodoItem : TableData\n    {\n        public string Text { get; set; }\n        public bool Complete { get; set; }\n    }\n}  We have a final piece of code to write before we move on to the views, but it's\nan important piece.  The  ICloudService  must be a singleton in the client.  We\nwill add authentication and offline sync capabilities in future versions of this\ncode.  The singleton becomes critical when using those features.  For right now,\nit's good practice and saves on memory if you only have one copy of the  ICloudService \nin your mobile client.  Since there is only one copy of the  App.cs  in any\ngiven app, I can place it there.  Ideally, I'd use some sort of dependency\ninjection system or a singleton manager to deal with this.  Here is the  App.cs :  using TaskList.Abstractions;\nusing TaskList.Services;\nusing Xamarin.Forms;\n\nnamespace TaskList\n{\n    public class App : Application\n    {\n        public static ICloudService CloudService { get; set; }\n\n        public App()\n        {\n            CloudService = new AzureCloudService();\n            MainPage = new NavigationPage(new Pages.EntryPage());\n        }\n\n        // There are lifecycle methods here...\n    }\n}  We haven't written  Pages.EntryPage  yet, but that's coming.  The original  App.cs \nclass file had several methods for handling lifecycle events like starting, suspending\nor resuming the app.  I did not touch those methods for this example.",
            "title": "Building an Azure Mobile Apps Connection"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-the-ui-for-the-app",
            "text": "Earlier, I showed the mockup for my UI.  It included three pages - an entry\npage, a list page and a detail page.  These pages have three elements - a\nXAML definition file, a (simple) code-behind file and a view model.   Info  This book is not intending to introduce you to everything that there is to know\nabout Xamarin and UI programming with XAML.  If you wish to have that sort of introduction,\nthen I recommend reading the excellent book by Charles Petzold:  Creating Mobile Apps with Xamarin.Forms .   I tend to use MVVM (or Model-View-ViewModel) for UI development in Xamarin\nbased applications.  It's a nice clean pattern and is well understood and\ndocumented.  In MVVM, there is a 1:1 correlation between the view and the\nview-model, 2-way communication between the view and the view-model and\nproperties within the view-model are bound directly to UI elements.  In\ngeneral (and in all my code), view-models expose an INotifyPropertyChanged\nevent to tell the UI that something within the view-model has been changed.  To do this, we will use a  BaseViewModel  class that implements the base functionality\nfor each view.  Aside from the  INotifyPropertyChanged  interface, there are\nsome common properties we need for each page.  Each page needs a title, for\nexample, and each page needs an indicator of network activity.  These can be\nplaced in the  Abstractions\\BaseViewModel.cs  class:  using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\n\nnamespace TaskList.Abstractions\n{\n    public class BaseViewModel : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n        string _propTitle = string.Empty;\n        bool _propIsBusy;\n\n        public string Title\n        {\n            get { return _propTitle; }\n            set { SetProperty(ref _propTitle, value, \"Title\"); }\n        }\n\n        public bool IsBusy\n        {\n            get { return _propIsBusy; }\n            set { SetProperty(ref _propIsBusy, value, \"IsBusy\"); }\n        }\n\n        protected void SetProperty<T>(ref T store, T value, string propName, Action onChanged = null)\n        {\n            if (EqualityComparer<T>.Default.Equals(store, value))\n                return;\n            store = value;\n            if (onChanged != null)\n                onChanged();\n            OnPropertyChanged(propName);\n        }\n\n        public void OnPropertyChanged(string propName)\n        {\n            if (PropertyChanged == null)\n                return;\n            PropertyChanged(this, new PropertyChangedEventArgs(propName));\n        }\n    }\n}  This is a fairly common  INotifyPropertyChanged  interface implementation pattern.\nEach property that we want to expose is a standard property, but the  set  operation\nis replaced by the  SetProperty()  call.  The  SetProperty()  call deals with the\nnotification; calling the event emitter if the property has changed value.  We\nonly need two properties on the  BaseViewModel : the title and the network indicator.  I tend to write my apps in two stages.  I concentrate on the functionality of the\napp in the first stage.  There is no fancy graphics, custom UI widgets, or anything\nelse to clutter the thinking.   The page is all about the functionality of the\nvarious interactions.  Once I have the functionality working, I work on the styling\nof the page.  We won't be doing any styling work in the demonstration apps that we\nwrite during the course of this book.  The EntryPage has just one thing to do.  It provides a button that enters the app.\nWhen we cover authentication later on, we'll use this to log in to the backend.  If\nyou are looking at the perfect app, this is a great place to put the introductory\nscreen.  Creating a XAML file is relatively simple.  First, create a  Pages  directory to\nhold the pages of our application.  Then right-click on the  Pages  directory in\nthe solution explorer and choose  Add  ->  New Item... .  In the  Add New Item \ndialog, pick  Visual C#  ->  Cross-Platform  ->  Forms Xaml Page .  Name the\nnew page  EntryPage.cs .  This will create two files -  EntryPage.xaml  and EntryPage.xaml.cs .  Let's center a button on the page and wire it up with\na command.  Here is the  Pages\\EntryPage.xaml  file:  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.EntryPage\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <StackLayout HorizontalOptions=\"Center\"\n                     Orientation=\"Vertical\"\n                     VerticalOptions=\"Center\">\n            <Button BackgroundColor=\"Teal\"\n                    BorderRadius=\"10\"\n                    Command=\"{Binding LoginCommand}\"\n                    Text=\"Login\"\n                    TextColor=\"White\" />\n        </StackLayout>\n    </ContentPage.Content>\n</ContentPage>  There are a couple of interesting things to note here.  The  StackLayout  element\nis our layout element.  It occupies the entire screen (since it is a direct child\nof the content page) and the options just center whatever the contents are.  The\nonly contents are a button.  There are two bindings.  These are bound from the view-model.  We've already seen\nthe Title property - this is a text field that specifies the title of the page.\nThe other binding is a login command.  When the button is tapped, the login command\nwill be run.  We'll get onto that in the view-model later.  The other part of the XAML is the code-behind file.  Because we are moving all\nof the non-UI code into a view-model, the code-behind file is trivial:  using TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class EntryPage : ContentPage\n    {\n        public EntryPage()\n        {\n            InitializeComponent();\n            BindingContext = new EntryPageViewModel();\n        }\n    }\n}  This is a recipe that will be repeated over and over again for the code-behind\nwhen you are using a XAML-based project with MVVM.  We initialize the UI, then\nbind all the bindings to a new instantiation of the view model.  Talking of which, the view-model needs just to handle the login click.  Note that\nthe location or namespace is  TaskList.ViewModels .  I'm of two minds about location.\nThere tends to be a 1:1 relationship between the XAML file and the View Model, so\nit makes sense that they are stored together.  However, just about all the sample\ncode that I see has the view-models in a separate namespace.  Which one is correct?\nI'll go with copying the samples for now.  Here is the code for  ViewModels\\EntryPageViewModel.cs :  using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class EntryPageViewModel : BaseViewModel\n    {\n        public EntryPageViewModel()\n        {\n            Title = \"Task List\";\n        }\n\n        Command loginCmd;\n        public Command LoginCommand => loginCmd ?? (loginCmd = new Command(async () => await ExecuteLoginCommand()));\n\n        async Task ExecuteLoginCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[Login] Error = {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}  This is a fairly simple view-model but there are some patterns here that are\nworth explaining.  Firstly, note the way we create the  LoginCommand  property.\nThis is the property that is bound to the  Command  parameter in the  Button \nof our view.  This recipe is the method of invoking a UI action asynchronously.\nIt isn't important now, but we will want this technique repeatedly as our UI\nactions kick off network activity.  The second is the pattern for the  ExecuteLoginCommand  method.  Firstly, I\nensure nothing else is happening by checking the IsBusy flag.   If nothing\nis happening, I set the IsBusy flag.  Then I do what I need to do in a try/catch\nblock.  If an exception is thrown, I deal with it.  Most of the time this\ninvolves displaying an error condition.  There are several cross-platform dialog\npackages to choose from or you can roll your own.  That is not covered here.  We\njust write a debug log statement so we can see the result in the debug log.  Once\neverything is done, we clear the IsBusy flag.  The only thing we are doing now is swapping out our main page for a new main\npage.  This is where we will attach authentication later on.  The next page is the Task List page, which is in  Pages\\TaskList.xaml :  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.TaskList\"\n             Title=\"{Binding Title}\">\n  <ContentPage.Content>\n    <StackLayout>\n      <ListView BackgroundColor=\"#7F7F7F\"\n                CachingStrategy=\"RecycleElement\"\n                IsPullToRefreshEnabled=\"True\"\n                IsRefreshing=\"{Binding IsBusy, Mode=OneWay}\"\n                ItemsSource=\"{Binding Items}\"\n                RefreshCommand=\"{Binding RefreshCommand}\"\n                RowHeight=\"50\"\n                SelectedItem=\"{Binding SelectedItem, Mode=TwoWay}\">\n        <ListView.ItemTemplate>\n          <DataTemplate>\n            <ViewCell>\n              <StackLayout HorizontalOptions=\"FillAndExpand\"\n                           Orientation=\"Horizontal\"\n                           Padding=\"10\"\n                           VerticalOptions=\"CenterAndExpand\">\n                <Label HorizontalOptions=\"FillAndExpand\"\n                       Text=\"{Binding Text}\"\n                       TextColor=\"#272832\" />\n                <Switch IsToggled=\"{Binding Complete, Mode=OneWay}\" />\n              </StackLayout>\n            </ViewCell>\n          </DataTemplate>\n        </ListView.ItemTemplate>\n      </ListView>\n      <StackLayout HorizontalOptions=\"Center\"\n                   Orientation=\"Horizontal\">\n        <Button BackgroundColor=\"Teal\"\n                Command=\"{Binding AddNewItemCommand}\"\n                Text=\"Add New Item\"\n                TextColor=\"White\" />\n      </StackLayout>\n    </StackLayout>\n  </ContentPage.Content>\n</ContentPage>  Note that some bindings here are one-way.  This means that the value in the\nview-model drives the value in the UI.  There is nothing within the UI that you\ncan do to alter the state of the underlying property.  Some bindings are two-way.\nDoing something in the UI (for example, toggling the switch) alters the underlying\nproperty.  This view is a little more complex.  It can be split into two parts - the list\nat the top of the page and the button area at the bottom of the page.  The list\narea uses a template to help with the display of each item.  Note that the  ListView  object has a \"pull-to-refresh\" option that I have wired\nup so that when pulled, it calls the RefreshCommand.  It also has an indicator\nthat I have wired up to the IsBusy indicator.  Anyone who is familiar with the\niOS \"pull-to-refresh\" gesture can probably guess what this does.  There is a view-model that goes along with the view (in  ViewModels\\TaskListViewModel.cs ):  using System;\nusing System.Collections.ObjectModel;\nusing System.Collections.Specialized;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskListViewModel : BaseViewModel\n    {\n        public TaskListViewModel()\n        {\n            Title = \"Task List\";\n            RefreshList();\n        }\n\n        ObservableCollection<TodoItem> items = new ObservableCollection<TodoItem>();\n        public ObservableCollection<TodoItem> Items\n        {\n            get { return items; }\n            set { SetProperty(ref items, value, \"Items\"); }\n        }\n\n        TodoItem selectedItem;\n        public TodoItem SelectedItem\n        {\n            get { return selectedItem; }\n            set\n            {\n                SetProperty(ref selectedItem, value, \"SelectedItem\");\n                if (selectedItem != null)\n                {\n                    Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail(selectedItem));\n                    SelectedItem = null;\n                }\n            }\n        }\n\n        Command refreshCmd;\n        public Command RefreshCommand => refreshCmd ?? (refreshCmd = new Command(async () => await ExecuteRefreshCommand()));\n\n        async Task ExecuteRefreshCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                var table = App.CloudService.GetTable<TodoItem>();\n                var list = await table.ReadAllItemsAsync();\n                Items.Clear();\n                foreach (var item in list)\n                    Items.Add(item);\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskList] Error loading items: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command addNewCmd;\n        public Command AddNewItemCommand => addNewCmd ?? (addNewCmd = new Command(async () => await ExecuteAddNewItemCommand()));\n\n        async Task ExecuteAddNewItemCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                await Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskList] Error in AddNewItem: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        async Task RefreshList()\n        {\n            await ExecuteRefreshCommand();\n            MessagingCenter.Subscribe<TaskDetailViewModel>(this, \"ItemsChanged\", async (sender) =>\n            {\n                await ExecuteRefreshCommand();\n            });\n        }\n    }\n}  This is a combination of the patterns we have seen earlier.  The Add New Item\nand Refresh commands should be fairly normal patterns now.  We navigate to the\ndetail page (more on that later) in the case of selecting an item (which occurs\nwhen the UI sets the  SelectedItem  property through a two-way binding) and when\nthe user clicks on the Add New Item button.  When the Refresh button is clicked\n(or when the user opens the view for the first time), the list is refreshed.  It\nis fairly common to use an  ObservableCollection  or another class that uses the ICollectionChanged  event handler for the list storage.  Doing so allows the UI\nto react to changes in the items.  Note the use of the  ICloudTable  interface here.  We are using the  ReadAllItemsAsync() \nmethod to get a list of items, then we copy the items we received into the  ObservableCollection .  Finally, there is the TaskDetail page.  This is defined in the  Pages\\TaskDetail.xaml \nfile:  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.TaskDetail\"\n             Title=\"{Binding Title}\">\n  <ContentPage.Content>\n    <StackLayout Padding=\"10\" Spacing=\"10\">\n      <Label Text=\"What should I be doing?\"/>\n      <Entry Text=\"{Binding Item.Text}\"/>\n      <Label Text=\"Completed?\"/>\n      <Switch IsToggled=\"{Binding Item.Complete}\"/>\n      <StackLayout VerticalOptions=\"CenterAndExpand\"/>\n      <StackLayout Orientation=\"Vertical\" VerticalOptions=\"End\">\n        <StackLayout HorizontalOptions=\"Center\" Orientation=\"Horizontal\">\n          <Button BackgroundColor=\"#A6E55E\"\n                  Command=\"{Binding SaveCommand}\"\n                  Text=\"Save\" TextColor=\"White\"/>\n          <Button BackgroundColor=\"Red\"\n                  Command=\"{Binding DeleteCommand}\"\n                  Text=\"Delete\" TextColor=\"White\"/>\n        </StackLayout>\n      </StackLayout>\n    </StackLayout>\n  </ContentPage.Content>\n</ContentPage>  This page is a simple form with just two buttons that need to have commands\nwired up.  However, this page is used for both the \"Add New Item\" gesture\nand the \"Edit Item\" gesture.  As a result of this, we need to handle the\npassing of the item to be edited.  This is done in the  Pages\\TaskDetail.xaml.cs \ncode-behind file:  using TaskList.Models;\nusing TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class TaskDetail : ContentPage\n    {\n        public TaskDetail(TodoItem item = null)\n        {\n            InitializeComponent();\n            BindingContext = new TaskDetailViewModel(item);\n        }\n    }\n}  The item that is passed in from the  TaskList  page is used to create a\nspecific view-model for that item.  The view-model is similarly configured\nto use that item:  using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskDetailViewModel : BaseViewModel\n    {\n        ICloudTable<TodoItem> table = App.CloudService.GetTable<TodoItem>();\n\n        public TaskDetailViewModel(TodoItem item = null)\n        {\n            if (item != null)\n            {\n                Item = item;\n                Title = item.Text;\n            }\n            else\n            {\n                Item = new TodoItem { Text = \"New Item\", Complete = false };\n                Title = \"New Item\";\n            }\n        }\n\n        public TodoItem Item { get; set; }\n\n        Command cmdSave;\n        public Command SaveCommand => cmdSave ?? (cmdSave = new Command(async () => await ExecuteSaveCommand()));\n\n        async Task ExecuteSaveCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id == null)\n                {\n                    await table.CreateItemAsync(Item);\n                }\n                else\n                {\n                    await table.UpdateItemAsync(Item);\n                }\n                MessagingCenter.Send<TaskDetailViewModel>(this, \"ItemsChanged\");\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskDetail] Save error: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command cmdDelete;\n        public Command DeleteCommand => cmdDelete ?? (cmdDelete = new Command(async () => await ExecuteDeleteCommand()));\n\n        async Task ExecuteDeleteCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id != null)\n                {\n                    await table.DeleteItemAsync(Item);\n                }\n                MessagingCenter.Send<TaskDetailViewModel>(this, \"ItemsChanged\");\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskDetail] Save error: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}  The save command uses the  ICloudTable  interface again - this time doing\neither  CreateItemAsync()  or  UpdateItemAsync()  to create or update the\nitem.  The delete command, as you would expect, deletes the item with the DeleteItemAsync()  method.  The final thing to note from our views is that I am using the  MessagingCenter \nto communicate between the TaskDetail and TaskList views.  If I change the item\nin the  TaskDetail  list, then I want to update the list in the  TaskList  view.  Note that all the code we have added to the solution thus far is in the common TaskList  project.  Nothing is required for this simple example in a platform\nspecific project.  That isn't normal, as we shall see.",
            "title": "Building the UI for the App"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-the-client-for-universal-windows",
            "text": "I tend to start by building the Universal Windows mobile client.  I'm using\nVisual Studio, after all, and I don't need to use any emulator.  To build the\nclients:   Right-click on the  TaskList.UWP (Universal Windows)  project, then select  Set as StartUp Project .  Right-click on the  TaskList.UWP (Universal Windows)  project again, then select  Build .  Once the build is complete, Right-click on the  TaskList.UWP (Universal Windows)  project again, then select  Deploy .  Click on the  Local Machine  button in your command bar to run the application.   Here are the three screen screens we generated on Windows:   There are some problems with the UWP version.  Most notably, the \"pull-to-refresh\"\ngesture does not exist, so we will need to set up an alternate gesture.  This\ncould be as easy as adding a refresh button right next to the Add New Item\nbutton.  In addition, there is no indication of network activity - this manifests\nas a significant delay between the TaskList page appearing and the data appearing\nin the list.  Aside from this, I did do some styling work to ensure that the final version\nlooked like my mock-ups (with the exception of the UI form of the switch, which\nis platform dependent).  If you want to see what I did to correct this, check out\nthe final version of  the Chapter 1 sample  on GitHub.   Tip   Building for On-Premise\n    If you want to run your backend using on-premise resources (for example, Azure\n    Stack or a local IIS service), your UWP application will need the  Private Networks \n    capability.  You can add this in the  Package.appxmanifest  file.  Choose the\n     Capabilities  tab and add the required capability.  If you need to build the project, ensure you redeploy the project after building.\nIt's a step that is easy to miss and can cause some consternation as you change\nthe code and it doesn't seem to have an effect on the application.",
            "title": "Building the Client for Universal Windows"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-the-client-for-android",
            "text": "Building Android with Visual Studio is as easy as building the Universal Windows\nversion of the mobile client:   Right-click on the  TaskList.Droid  project, then select  Set as StartUp Project .  Right-click on the  TaskList.Droid  project again, then select  Build .   The button for running the application has a drop-down that is now significant.\nIt lets you choose the type of device that you will use.  Normally, this runs\neither a 5\" or 7\" KitKat-based Android device.  There is some setup required for\nthe Visual Studio Emulator for Android.  The Visual Studio Emulator for Android\nruns within Hyper-V, so you must install Hyper-V before use.  You get the following\nerror if you don't do this:   To install Hyper-V:   Close all applications (your system will be rebooted during this process).  Search for  Programs and Features .  Click on  Turn Windows features on or off  (in the left-hand menu).  Expand the  Hyper-V  node.  Check all the boxes below the  Hyper-V  node.  This will include Hyper-V Management Tools and Hyper-V Services.  Click on  OK .  Your system will install the required pieces and then ask you to restart.  Click on  Restart now  when prompted.   Once you have done this, the next hurdle is to be added to the Hyper-V Administrators\nsecurity group.  It gets done for you (again - the first time you try to run the\napplication after installing Hyper-V).  Once it is done, close Visual Studio (again),\nthe log out and back in again.  As if that wasn't enough, the emulator also needs an Internet connection to\nstart.   You should be able to just click on  Yes  or  OK  to enable the Internet\nconnection.  My laptop required a reboot before this would work, however.  In\naddition, the process may request elevated privileges.   Tip  If you want to run additional Android profiles before starting, run the Visual Studio Emulator for Android  and download any additional profiles.\nFor example, if you wish to emulate something similar to a Samsung Galaxy S6,\nthen download the profile for a 5.1\" Marshmallow (6.0.0) XXHDPI Phone.   Finally the Visual Studio Emulator for Android starts when you click on the Run\nbutton.  Fortunately, the setup of the emulator only has to be done once per\nmachine.  The Visual Studio Emulator for Android is also a superior emulator\nto the standard Android Emulator, so this process is well worth going through.   Tip  When testing the mobile client manually through the Visual Studio Emulator for\nAndroid, you are likely to need to rebuild the application.  You do not have to\nshut down the emulator between runs.  You can leave it running.  The application\nwill be stopped and replaced before starting again.  This can significantly speed\nup the debug cycle since you are not waiting for the emulator to start each time.   Watch the Output window.  If the debugger won't connect or the application\nwon't start, you may need to restart your computer again to get the network\nworking.   Tip  If your computer doesn't run Hyper-V well (or at all), then the emulator won't run\nwell (or at all) either.  I find laptops to be particularly prone to this problem.\nIf this happens, you can always run the Google Emulator instead.  Build the application\nas normal.  You will find the APK file to install in  ...\\TaskList.Droid\\bin\\Debug .\nFortunately, there are lots of resources that show how to do this.  You can find the\nanswer on  Stack Overflow   If everything is working, you should see the Visual Studio Emulator for Android\ndisplay your mobile client:    Warn  You can also build the Android version on a mac with Xamarin Studio.  However, I find\nthat version mismatches between Mono (which is used on the mac) and Visual Studio - particularly\nin reference to the version of the .NET framework - cause issues when swapping between the\ntwo environments.  For best results, stay in one environment.   Note that the task list view is a \"light\" style and the rest of the app is a\n\"dark\" style.  This is because the default styling on an Android device is\ndark.  We are using the default styling on two of the pages and specifying\ncolors on the list page.  Fortunately, Xamarin Forms allows for  platform-specific\nstyling .  The  final sample  has platform-specific styling for the\nlist page.",
            "title": "Building the Client for Android"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-the-client-for-ios",
            "text": "Finally, we get to the iOS platform.  You will need to ensure your Mac is turned\non and accessible, that it has XCode installed (and you have run XCode once so\nthat you can accept the license agreement), and it has Xamarin Studio installed.  When you created the projects, you were asked to link Visual Studio to your mac.\nThis linkage is used for building the project.  In essence, the entire project\nis sent to the Mac and the build tools that are supplied with Xamarin Studio\nwill be used to build the project.   Right-click on the  TaskList.iOS  project and select  Set as StartUp Project .  Right-click on the  TaskList.iOS  project and select  Build .   You knew it was not going to be that easy, right?  Here are the errors that I\nreceived when building for the first time:   There are two errors right at the top.  Let's cover the first one.  The error\nabout  Build Action 'EmbeddedResource' is not supported  is an annoying one.\nThe fix is to do the following:   Set the iOS project as the StartUp project.  Go through each project, expand the  References  node and ensure that there are\n   no references with a warning (a little yellow triangle).  If there are - fix those\n   first.  Generally, this is fixed by either using the  Restore NuGet Packages  option\n   or removing the reference and then adding it again from NuGet.  Close the solution.  Re-open the solution.  You don't need to close Visual Studio to do this.  Right-click on the iOS project and select  Clean .  Right-click on the iOS project and select  Rebuild .   Once you have done this sequence, the error should go away.  The error about  No valid iOS code signing keys found in keychain  is because\nwe have not yet signed up for an Apple Developer Account and linked it to our\nMac development environment.   Go to the  Apple Developer Center .  Click on  Account  in the top navigation bar.  If you haven't got an Apple ID yet, create one first.  If you have go an Apple ID, then log in.   There are a sequence of sign-up prompts in both cases (first for creating your\nApple ID and secondly for signing up for the Apple Developer program).  Once\nyou have gone through this process, you are registered as an Apple Developer.   Info  If you want to distribute your apps on the Apple App Store, run on real devices or\nget access to the beta bits, then you might consider signing up for the Apple Developer\nProgram.  The Apple Developer Program is an additional cost and is not required for\ndeveloping iOS apps that are only run on the iOS simulator.   Once you have created your account and enabled it as a developer account, open\nup XCode.  Go to  Preferences... , then  Account  and\nclick on the  +  in the bottom-left corner of the window:   Sign in with the same account you used to sign up for the developer account.   Click on the  View Details  button.  This will bring up the Signing Identities\nlist.  For a free account, it looks like this:   Click on the Create button next to  iOS Development .  Once the UI comes back,\nclick on  Done .  For more information on this process, refer to the  Apple Documentation .  You can close XCode at this point.  Ensure Xamarin Studio is not running.  Back\nwithin Visual Studio, right-click on the  TaskList.iOS  project and select  Rebuild .\nThis will (finally!) build the application for you.   Tip  Getting an error about  Provisioning Profiles  not being available?  This is because\nyou are building for a real device instead of the simulator.  In order to build for a\nreal device, you must have a linked Apple Developer Program.  To get around this, select\na Simulator before building.   The  Run  button has received a  Device  label, but there are several simulator options.\nYou should only use  Device  if you have signed up for the Apple Developer Program.  Pick\none of the simulator options like the  iPhone 6 iOS 9.3  simulator, then click on it\nto run the simulator.  Before long, you should see the following:   At some point, you will need a platform initialization call on all platforms.  It's best to\nadd it now.  In TaskList.Droid, this should be added in  MainActivity.cs  and in TaskList.iOS,\nit's  AppDelegate.cs .  In each of these files, there is a line that initializes the Xamarin\nForms system.  // Android Version\nglobal::Xamarin.Forms.Forms.Init(this, bundle);\n// iOS Version\nglobal::Xamarin.Forms.Forms.Init ();  Immediately before this line, you should add the  initializer for Azure Mobile Apps. It's\nimportant that the Azure Mobile Apps subsystem is initialized prior to Xamarin Forms being\ninitialized and any UI code being called.  Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();  This initializer is not required on the UWP project.  Once this is done and you have re-built\nthe project, we can see the fruits of our labor.  You can, of course, run the IPA in the\niOS simulator on the Mac.  However, it's much more satisfying (to me, at least) to be able\nto do everything from within Visual Studio.  For this, you need to install the Xamarin Installer .  This is an MSI for your Windows development system and is\nquickly installed.  Once installed, start (or restart) Visual Studio, select  Tools  -> Options .  Search for  Xamarin , and select the  iOS Settings  page.  There is\na new option:   Note the  Remote Simulator to Windows .  This should be checked.  You may need to\nrebuild the TaskList.iOS project after installing the Xamarin Simulator.  The debug\nwindow will tell you if this is the case.  There are also a few  known issues \nso check the documentation if you run into problems.  The final product screens look like this:",
            "title": "Building the Client for iOS"
        },
        {
            "location": "/chapter1/firstapp_pc/#some-final-thoughts",
            "text": "If you have got through the entire process outlined in this Chapter and built the application\nfor each platform, then congratulations.  There are a lot of places where things can go\nwrong.  You are really integrating the build systems across Visual Studio, Android, Xamarin,\nand XCode.  Fortunately, once these are set up, it's likely that they will continue working and you\nwon't have to think too much about them again. The Android and iOS build tools and simulators\nwill just work.  If you would rather develop code on your mac, the next chapter is for you - it gets into\nthe nitty gritty of developing the exact same app, but using Xamarin Studio instead.  The following 7 chapters each take one aspect of the cloud services that can be provided to\nmobile apps and explores it in detail, using an Azure Mobile App as a beginning. You can\njump around at this point, but be aware that we expect you to cover these topics in order.\nIf you do the data chapter before covering authentication, it's likely you will have missed\nimportant functionality in your app to complete the work.",
            "title": "Some Final Thoughts"
        },
        {
            "location": "/chapter1/firstapp_mac/",
            "text": "Your First Mobile App on a Mac\n\u00b6\n\n\nThere is a lot of detail to absorb about the possible services that the mobile\nclient can consume and I will go into significant depth on those subjects.\nFirst, wouldn't it be nice to write some code and get something working?\nMicrosoft Azure has a great \nfirst-steps tutorial\n that takes you via the\nquickest possible route from creating a mobile backend to having a functional\nbackend.  I would like to take things a little slower so that we can understand\nwhat is going on while we are doing the process.  We will have practically the\nsame application at the end.  The primary reason for going through this slowly\nis to ensure that all our build and run processes are set up properly.  If this\nis the first mobile app you have ever written, you will see that there are quite\na few things that need to be set up.  This chapter covers the set up required\nfor a MacOS computer.  If you wish to develop your applications on a Windows PC, then skip\nto the \nnext section\n.\n\n\nThe application we are going to build together is a simple task list.  The\nmobile client will have three screens - an entry screen, a task list and a task\ndetails page.  I have mocked these pages up using \nMockingBot\n.\n\n\n\n\nTip\n\n\nMocking your screens before you start coding is a great habit to get into.\nThere are some great tools available including free tools like \nMockingBot\n.\nDoing mockups before you start coding is a good way to prevent wasted time later\non.\n\n\n\n\n\n\n\n\nTip\n\n\nIf you are using iOS, then you may want to remove the back button as the style\nguides suggest you don't need one.  Other platforms will need it though, so it's\nbest to start with the least common denominator.  It's the same reason I add a\nrefresh button even though it's only valid on Windows Phone!\n\n\n\n\nMy ideas for this app include:\n\n\n\n\nTapping on a task title in the task list will bring up the details page.\n\n\nToggling the completed link in the task list will set the completed flag.\n\n\nTapping the spinner will initiate a network refresh.\n\n\n\n\nNow that we have our client screens planned out, we can move onto the thinking\nabout the mobile backend.\n\n\nThe Mobile Backend\n\u00b6\n\n\nThe mobile backend is an ASP.NET WebApi that is served from within Azure App\nService: a highly scalable and redundant web hosting facility that supports all\nthe major web languages (like ASP.NET, Node, PHP and Python).  Azure Mobile\nApps is an SDK (which is available in ASP.NET and Node) that runs on top of\nAzure App Service.\n\n\nCreating a Simple Azure Mobile Apps Backend\n\u00b6\n\n\nTo get started:\n\n\n\n\nFire up Xamarin Studio\n\n\nAdd a new project with File -> New Solution...\n\n\n\n\nIn the \nNew Project\n window:\n\n\n\n\nChoose Other -> ASP.NET and select \nEmpty ASP.NET Project\n.\n\n\nClick Next.\n\n\n\n\n\n\n\n\nIn the \nConfigure your Web project\n window:\n\n\n\n\nCheck the \nWeb API\n checkbox.\n\n\nClick Next.\n\n\n\n\n\n\n\n\nIn the \nConfigure your new project\n window:\n\n\n\n\nEnter \nBackend\n for the for the Project Name and \nChapter1\n for the Solution name.\n\n\nPick a suitable directory for the Location field.\n\n\nClick on Create.\n\n\n\n\n\n\n\n\nAt this point, Xamarin Studio will create your backend project.\n\n\nYou may need to accept licenses for several packages to continue with\nthe project creation.  As Xamarin Studio doesn't have templates for all\nof the same ASP.NET projects that Visual Studio does, we'll need to do\nsome additional work to set our project up.\n\n\nFirst, we need to change our project to target .NET 4.6.  Right click on\nyour \nBackend\n project in the Solution Explorer and choose Options.  Under\nthe \nBuild\n section, select \nGeneral\n.  Under the Target Framework dropdown\nselect .NET Framework 4.6.1:\n\n\n\n\nClick \nOK\n to accept the change and close the Project Options.\n\n\nNext we'll install multiple NuGet packages.  Expand the \nBackend\n project\nin the Solution Explorer and right click on \nPackages\n and then select\n\nAdd Packages\n.  Find and add the following packages:\n\n\n\n\nAzure Mobile .NET Server SDK\n\n\nAzure Mobile .NET Server Tables\n\n\nAzure Mobile .NET Server CORS\n\n\nAzure Mobile .NET Server Notifications\n\n\nAzure Mobile .NET Server Authentication\n\n\nAzure Mobile .NET Server Home\n\n\nAzure Mobile .NET Server Quickstart\n\n\nAzure Mobile .NET Server Entity\n\n\nMicrosoft.OWIN.Host.SystemWeb\n\n\n\n\n\n\nTip\n\n\nThe Azure Mobile .NET Server Quickstart NuGet package has all the other packages\nas dependencies.  Add the Quickstart package first to save yourself some time.\n\n\n\n\nYou should also take the opportunity to update any NuGet packages that were\nautomatically added to the project.  To do so, right click on \nPackages\n and\nchoose \nUpdate\n.\n\n\nNext you'll need to add the following folders to the \nBackend\n project.  Right\nclick on \nBackend\n and select Add -> New Folder and create the following:\n\n\n\n\nControllers\n\n\nDataObjects\n\n\nModels\n\n\n\n\nNext you'll need to remove the following files that were created as part of the template.\nRight click on each of the following files and choose Remove and click the Delete button:\n\n\n\n\nApp_Start/WebApiConfig.cs\n\n\nGlobal.asax\n\n\n\n\nNow we can add the files that will consist of our backend.  We'll start by\ncreating the three files that will handle projecting a single table in our\ndatabase - the TodoItem table - into the mobile realm with the aid of an\nopinionated \nOData v3\n feed.  To that end, we need three items:\n\n\n\n\nA \nDbSet<>\n within the \nDbContext\n\n\nA Data Transfer Object (or DTO)\n\n\nA Table Controller\n\n\n\n\nStart by right clicking on \nDataObjects\n and choose Add -> New File.  Select General -> Empty Class and name it\n\nTodoItem.cs\n.  As we're building a task list application, this is the DTO\nfor our TodoItems:\n\n\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.DataObjects\n{\n    public class TodoItem : EntityData\n    {\n        public string Text { get; set; }\n        public bool Complete { get; set; }\n    }\n}\n\n\n\n\nNote that the model uses \nEntityData\n as a base class.  The \nEntityData\n class\nadds five additional properties to the class - we'll discuss those in more\ndetails during the \nData Access and Offline Sync\n chapter.\n\n\nNext, we'll create our \nDbContext\n which uses \nEntity Framework\n to deal with creating\nour Database Model when we upload our backend to Azure.  Right click on \nModels\n and choose\nAdd -> New File.  Select General -> Empty Class and name it \nMobileServiceContext.cs\n.\nAdd the following code:\n\n\nusing System.Data.Entity;\nusing System.Data.Entity.ModelConfiguration.Conventions;\nusing System.Linq;\nusing Microsoft.Azure.Mobile.Server;\nusing Microsoft.Azure.Mobile.Server.Tables;\nusing Backend.DataObjects;\n\nnamespace Backend.Models\n{\n    public class MobileServiceContext : DbContext\n    {\n        // You can add custom code to this file. Changes will not be overwritten.\n        //\n        // If you want Entity Framework to alter your database\n        // automatically whenever you change your model schema, please use data migrations.\n        // For more information refer to the documentation:\n        // http://msdn.microsoft.com/en-us/data/jj591621.aspx\n        //\n        // To enable Entity Framework migrations in the cloud, please ensure that the\n        // service name, set by the 'MS_MobileServiceName' AppSettings in the local\n        // Web.config, is the same as the service name when hosted in Azure.\n\n        private const string connectionStringName = \"Name=MS_TableConnectionString\";\n\n        public MobileServiceContext() : base(connectionStringName)\n        {\n        }\n\n        public DbSet<TodoItem> TodoItems { get; set; }\n\n        protected override void OnModelCreating(DbModelBuilder modelBuilder)\n        {\n            modelBuilder.Conventions.Add(\n                new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n                    \"ServiceTableColumn\", (property, attributes) => attributes.Single().ColumnType.ToString()));\n        }\n    }\n}\n\n\n\n\nNext we'll create the controller for our TodoItem table.  Right click on \nControllers\n\nand choose Add -> New File.  Select General -> Empty Class and name it\n\nTodoItemController.cs\n.  Add the following code:\n\n\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}\n\n\n\n\nThe \nTableController\n is the central processing for the database access layer.\nIt handles all the OData capabilities for us and exposes these as REST endpoints\nwithin our WebAPI.  This means that the actual code for this controller is tiny - just 12 lines of code.\n\n\n\n\nInfo\n\n\nOData\n is a specification for accessing table data on the Internet.  It provides\na mechanism for querying and manipulating data within a table.  Entity Framework is a\ncommon data access layer for ASP.NET applications.\n\n\n\n\nMoving on, we'll create the startup file for our backend.  Right click on \nApp_Start\n\n-> Add -> New File.  Select General -> Empty Class and name it\n\nStartup.MobileApp.cs\n.\n\n\n\n\nInfo\n\n\nIf you name a file in Xamarin Studio with a period in it without including the specific\nextension (.cs) at the end, Xamarin Studio will not automatically set the file up\nto be compiled correctly.\n\n\n\n\nThis class handles initializing our mobile application backend:\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.Configuration;\nusing System.Data.Entity;\nusing System.Web.Http;\nusing Microsoft.Azure.Mobile.Server;\nusing Microsoft.Azure.Mobile.Server.Authentication;\nusing Microsoft.Azure.Mobile.Server.Config;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Owin;\n\nnamespace Backend\n{\n    public partial class Startup\n    {\n        public static void ConfigureMobileApp(IAppBuilder app)\n        {\n            var config = new HttpConfiguration();\n            var mobileConfig = new MobileAppConfiguration();\n\n            mobileConfig\n                .AddTablesWithEntityFramework()\n                .ApplyTo(config);\n\n            Database.SetInitializer(new MobileServiceInitializer());\n\n            app.UseWebApi(config);\n        }\n    }\n\n    public class MobileServiceInitializer : CreateDatabaseIfNotExists<MobileServiceContext>\n    {\n        protected override void Seed(MobileServiceContext context)\n        {\n            List<TodoItem> todoItems = new List<TodoItem>\n            {\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"First item\", Complete = false },\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"Second item\", Complete = false }\n            };\n\n            foreach (TodoItem todoItem in todoItems)\n            {\n                context.Set<TodoItem>().Add(todoItem);\n            }\n\n            base.Seed(context);\n        }\n    }\n}\n\n\n\n\nIf you were to create a new Mobile App based application in Visual Studio or download the\nquickstart application from the Azure portal, the startup\nwould be considerably inflated with additional functionality for things like\nauthentication and push notifications.  Currently we have it set up to only implement\nour data layer.\n\n\nThere is another method in the \nApp_Start\\Startup.MobileApp.cs\n file for\nseeding data into the database for us.  We can leave that alone for now, but\nremember it is there in case you need to seed data into a new database for\nyour own backend.\n\n\n\n\nInfo\n\n\nWhen we refer to \"seeding data\" into a database, this means that we are going to introduce\nsome data into the database so that we aren't operating on an empty database. The data\nwill be there when we query the database later on.\n\n\n\n\nFinally we need to add a startup class for our ASP.NET\napplication.  Right click on \nBackend\n -> Add -> New File.  Select General ->\nEmpty Class and name it \nStartup.cs\n.  The purpose of this class is just to kick off\nthe configuration of our mobile app backend:\n\n\nusing Microsoft.Owin;\nusing Owin;\n\n[assembly: OwinStartup(typeof(Backend.Startup))]\n\nnamespace Backend\n{\n    public partial class Startup\n    {\n        public void Configuration(IAppBuilder app)\n        {\n            ConfigureMobileApp(app);\n        }\n    }\n}\n\n\n\n\nOur last step in our backend before publishing it is to edit the \nweb.config\n:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!--\nWeb.config file for TestProject.\n\nThe settings that can be used in this file are documented at\nhttp://www.mono-project.com/Config_system.web and\nhttp://msdn2.microsoft.com/en-us/library/b5ysx397.aspx\n-->\n<configuration>\n  <configSections>\n    <section name=\"entityFramework\" type=\"System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" requirePermission=\"false\" />\n    <!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 -->\n    <!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 -->\n  </configSections>\n  <connectionStrings>\n    <add name=\"MS_TableConnectionString\" connectionString=\"Data Source=(localdb)\\MSSQLLocalDB;AttachDbFilename=|DataDirectory|\\aspnet-MobileAppsBookTest-20160923095604.mdf;Initial Catalog=aspnet-MobileAppsBookTest-20160923095604;Integrated Security=True;MultipleActiveResultSets=True\" providerName=\"System.Data.SqlClient\" />\n  </connectionStrings>\n  <appSettings>\n    <add key=\"PreserveLoginUrl\" value=\"true\" />\n    <!-- Use these settings for local development. After publishing to your\n    Mobile App, these settings will be overridden by the values specified\n    in the portal. -->\n    <add key=\"MS_SigningKey\" value=\"Overridden by portal settings\" />\n    <add key=\"EMA_RuntimeUrl\" value=\"Overridden by portal settings\" />\n    <!-- When using this setting, be sure to add matching Notification Hubs connection\n    string in the connectionStrings section with the name \"MS_NotificationHubConnectionString\". -->\n    <add key=\"MS_NotificationHubName\" value=\"Overridden by portal settings\" />\n  </appSettings>\n  <system.web>\n    <customErrors mode=\"Off\" />\n    <httpRuntime targetFramework=\"4.6.1\" />\n    <compilation debug=\"true\" targetFramework=\"4.6.1\">\n      <assemblies />\n    </compilation>\n  </system.web>\n  <system.webServer>\n    <validation validateIntegratedModeConfiguration=\"false\" />\n    <modules runAllManagedModulesForAllRequests=\"true\" />\n    <handlers>\n      <remove name=\"ExtensionlessUrlHandler-Integrated-4.0\" />\n      <remove name=\"OPTIONSVerbHandler\" />\n      <remove name=\"TRACEVerbHandler\" />\n      <add name=\"ExtensionlessUrlHandler-Integrated-4.0\" path=\"*.\" verb=\"*\" type=\"System.Web.Handlers.TransferRequestHandler\" preCondition=\"integratedMode,runtimeVersionv4.0\" />\n    </handlers>\n  </system.webServer>\n  <runtime>\n    <assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\" xmlns:bcl=\"urn:schemas-microsoft-com:bcl\">\n      <dependentAssembly>\n        <assemblyIdentity name=\"System.Spatial\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-5.7.0.0\" newVersion=\"5.7.0.0\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"System.Web.Http\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-5.2.3.0\" newVersion=\"5.2.3.0\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"System.Net.Http.Formatting\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-5.2.3.0\" newVersion=\"5.2.3.0\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"Microsoft.Data.Edm\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-5.7.0.0\" newVersion=\"5.7.0.0\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"Microsoft.Data.OData\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-5.7.0.0\" newVersion=\"5.7.0.0\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"Newtonsoft.Json\" publicKeyToken=\"30ad4fe6b2a6aeed\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-9.0.0.0\" newVersion=\"9.0.0.0\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"Microsoft.Owin\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-3.0.1.0\" newVersion=\"3.0.1.0\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"System.IdentityModel.Tokens.Jwt\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-5.0.0.127\" newVersion=\"5.0.0.127\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"System.Web.Http.OData\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-5.7.0.0\" newVersion=\"5.7.0.0\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"AutoMapper\" publicKeyToken=\"be96cd2c38ef1005\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-5.1.1.0\" newVersion=\"5.1.1.0\" />\n      </dependentAssembly>\n    </assemblyBinding>\n  </runtime>\n  <entityFramework>\n    <defaultConnectionFactory type=\"System.Data.Entity.Infrastructure.SqlConnectionFactory, EntityFramework\" />\n    <providers>\n      <provider invariantName=\"System.Data.SqlClient\" type=\"System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer\" />\n    </providers>\n  </entityFramework>\n</configuration>\n\n\n\n\nChoose \nBuild All\n from the \nBuild\n menu and ensure your project compiles\nwithout errors.\n\n\nBuilding an Azure App Service for Mobile Apps\n\u00b6\n\n\nThe next step in the process is to build the resources on Azure that will\nrun your mobile backend.  Start by logging into the \nAzure Portal\n, then\nfollow these instructions:\n\n\n\n\nClick on the big \n+ New\n button in the top-left corner.\n\n\nClick on \nWeb + Mobile\n, then \nMobile App\n.\n\n\n\n\nEnter a unique name in the \nApp name\n box.\n\n\n\n\nTip\n\n\nSince the name doesn't matter and it has to be unique, you can use \na\nGUID generator\n to generate a unique name. GUIDs are not the best\nnames to use when you need to actually find resources, but using GUIDS\nprevents conflicts when deploying, so I prefer them as a naming scheme.\nYou can prefix the GUID  (example: chapter1-GUID) to aid in discovery\nlater on.  Generally, the first four digits of a GUID are enough to\nidentify individual resources.\n\n\n\n\n\n\n\n\nIf you have more than one subscription (for example, you have a trial\n   and an MSDN subscription), then ensure you select the right subscription\n   in the \nSubscription\n drop-down.\n\n\n\n\n\n\nSelect \nCreate new\n under resource group and enter a name for this\n   mobile application.\n\n\n\n\nResource Groups\n\n\nResource groups are great for grouping all the resources associated with a\nmobile application together.  During development, it means you can delete\nall the resources in one operation.  For production, it means you can see how\nmuch the service is costing you and how the resources are being used.\n\n\n\n\n\n\n\n\nFinally, select or create a new \nApp Service Plan\n.\n\n\n\n\nApp Service Plan\n\n\nThe App Service Plan is the thing that actually bills you - not the web or\nmobile backend.  You can run a number of web or mobile backends on the same\nApp Service Plan.\n\n\n\n\nI tend to create a new App Service Plan for each mobile application.  This\nis because the App Service Plan lives inside the Resource Group that you\ncreate.  The process for creating an App Service Plan is straight forward.\nYou have two decisions to make.  The first decision is where is the service\ngoing to run.  In a production environment, the correct choice is \"near your\ncustomers\".  \"Close to the developers\" is a good choice during development.\nUnfortunately, neither of those is an option you can actually choose in the\nportal, so you will have to translate into some sort of geographic location.\nWith 22 regions to choose from, you have a lot of choice.\n\n\nThe second decision you have to make is what to run the service on; also\nknown as the Pricing tier.   If you click on \nView all\n, you will see you\nhave lots of choices.  F1 Free and D1 Shared, for example, run on shared\nresources and are CPU limited. You should avoid these as the service will\nstop responding when you are over the CPU quota.  That leaves Basic,\nStandard, and Premium.  Basic has no automatic scaling and can run up to 3\ninstances - perfect for development tasks.  Standard and Premium both have\nautomatic scaling, automatic backups, and large amounts of storage; they\ndiffer in features: the number of sites or instances you can run on them,\nfor example.  Finally, there is a number after the plan.  This tells you how\nbig the virtual machine is that the plan is running on.  The numbers differ\nby number of cores and memory.\n\n\nFor our purposes, a F1 Free site is enough to run this small demonstration\nproject.  More complex development projects should use something in the\nBasic range of pricing plans.  Production apps should be set up in Standard\nor Premium pricing plans.\n\n\n\n\n\n\nOnce you have created your app service plan and saved it, click on \nCreate\n.\n\n\n\n\n\n\nThe creation of the service can take a couple of minutes.  You can monitor the\nprocess of deployment by clicking on the Notifications icon.  This is in the top\nbar on the right-hand side and looks like a Bell.  Clicking on a specific\nnotification will provide more information about the activity.  Once you have\ncreated your app service, the App Service blade will open.\n\n\n\n\nInfo\n\n\nWhat's the difference between a Web App, a Mobile App and an API App?  Not a\nlot.  The type determines which Quick start projects are available in the Quick\nstart menu under \nAll settings\n.  Since we selected a Mobile app, a set of\nstarter client projects for mobile devices will be presented.\n\n\n\n\nWe will also want a place to store our data.  This role is taken on by a\nSQL Azure instance.  We could link an existing database if we had one\ndefined.  However, we can also create a test database.\n\n\n\n\nTip\n\n\nCreating a Test Database through the App Service Data Connections (as\nI describe here) allows you to create a free database.  This option is\nnot normally available through other SQL database creation flows.\n\n\n\n\n\n\nClick on \nResource groups\n in the left hand side menu.\n\n\nClick on the resource group you created.\n\n\n\n\nClick on the App Service your created.\n\n\n\n\nTip\n\n\nIf you pinned your App Service to the dashboard, you can click on the\npinned App Service instead.  It will bring you to the same place.\n\n\n\n\n\n\n\n\nClick on \nData connections\n in the \nMOBILE\n menu.\n\n\n\n\n\n\nClick on \nAdd\n.\n\n\n\n\nIn the \nType\n box, select \nSQL Database\n.\n\n\nClick on the unconfigured \nSQL Database\n link:\n\n\n\n\n\n\n\n\nEnter a name for the database (like \nchapter1-db\n).\n\n\nSelect a Pricing Tier (look for \nF Free\n at the bottom).\n\n\nClick on the unconfigured \nServer\n.\n\n\n\n\n\n\n\n\nEnter a unique name for the server (a GUID is a good idea here).\n\n\nEnter a username and password for the server.\n\n\nMake sure the Location for your database server is the same as your\nMobile App.\n\n\nClick on \nSelect\n to close the \nNew Server\n blade.\n\n\nClick on \nSelect\n to close the \nNew Database\n blade.\n\n\nAn error may appear asking you to set the Database Connection string,\nif so, click on the Database Connection and then click \nOK\n on it's blade.\n\n\nClick on \nOK\n to close the \nAdd Data Connection\n blade.\n\n\n\n\n\n\n\n\nThis produces another deployment step that creates a SQL Server and a SQL\ndatabase with your settings.  Once complete, the connection\n\nMS_TableConnectionString\n will be listed in Data Connections blade.\n\n\n\n\n\n\nTip\n\n\nIf you want a completely free mobile backend, search for the \nMobile\nApps Quickstart\n in the Azure Marketplace.  This template does not\nrequire a database.  It relies on a Node backend, however, so you won't\nbe developing a C# backend.\n\n\n\n\nDeploying the Azure Mobile Apps Backend\n\u00b6\n\n\nPublishing a Mobile App backend is very integrated into Visual Studio.  Since\nwe're developing with Xamarin Studio, we'll need to do things a bit differently.\nThere are a number of potential deployment options including FTP, connecting\nto a Continuous Integration server, connecting a Dropbox folder, or creating a local git repository.  To\nkeep things simple, we'll use an adminstration site named Kudu (also called\nSCM) to copy the files over.  Once we're ready, we'll need to collect the compiled\napplication files since Xamarin doesn't have any publish functionality.\n\n\n\n\nReturn to the browser and the Azure Portal.\n\n\nGo to the Settings blade for your Mobile App.\n\n\nClick on \nAdvanced Tools\n in the \nDEVELOPMENT TOOLS\n menu.\n\n\n\n\nClick on \nGo\n in the \nAdvanced Tools\n blade.\n\n\n\n\n\n\n\n\nThe page that loads should match https://{YourMobileApp}.scm.azurewebsites.net/.\n\n\n\n\nSelect the \nDebug Console\n menu from the top and choose \nCMD\n.\n\n\nWithin the file structure listing, click on \nsite\n.\n\n\nClick on \nwwwroot\n.\n\n\nYou should see a \nhostingstart.html\n file here.  Click the circle with a minus\nsymbol in it to the left of that file and confirm the dialog to delete this file.\n\n\nOn your computer, navigate to the folder that contains your Mobile App Backend.\n\n\n\n\nSelect the following folder and files:\n\n\n\n\nbin\n\n\npackages.config\n\n\nWeb.config\n\n\n\n\n\n\n\n\nDrag and drop those files into the browser window above the Console.\n\n\n\n\n\n\nA progress indicator should appear near the top right.  Upon completion you\nshould see the files appear in the file list:\n\n\n\n\n\n\n\n\nIn the browser navigate to the URL for your Mobile App.  This should match the\nformat https://{YourMobileApp}.azurewebsites.net/.\n\n\nAdd \n/tables/todoitem?ZUMO-API-VERSION=2.0.0\n\nto the end of the URL.  This will show the JSON contents of the table that we\ndefined in the backend.\n\n\n\n\nInfo\n\n\nYou will see the word ZUMO all over the SDK, including in optional HTTP headers\nand throughout the SDK source code.  ZUMO was the original code name within Microsoft\nfor A\nZU\nre \nMO\nbile.\n\n\n\n\nThe Mobile Client\n\u00b6\n\n\nNow that the mobile backend is created and deployed, we can move onto the client\nside of things.  As we're using Xamarin Studio, we should already have everything\nwe need installed to proceed with creating a Xamarin.Forms application for\nboth Android and iOS.\n\n\n\n\nInfo\n\n\nWhen you compile a Xamarin.Forms application for a specific platform, you are\nproducing a true native application for that platform - whether it be iOS,\nAndroid or Windows.\n\n\n\n\nCreating a Simple Mobile Client with Xamarin\n\u00b6\n\n\nRight-click on the \nChapter1\n solution and select \nAdd\n -> \nAdd New Project\n.\nThis will bring up the familiar New Project dialog.  The project you want is\nunder \nMultiplatform\n -> \nApp\n, and is called \nForms App\n.  Select that\nand click \nNext\n.  Give the project a name such as \nTaskList\n, ensure Android and iOS are both\nselected, select \nUse Portable Class Library\n and click Next.\n\n\n\n\nOn the next screen, leave all of the default values and click Create.\n\n\nOnce the setup is complete, you will see that three new projects have been\ncreated: a common library which you named plus one project for each platform\nthat has been chosen.  Since we chose both Android and iOS, we get\nthree projects:\n\n\n\n\nMost of our work will happen in the common library.  However, we can introduce\nplatform-specific code at any point.  The platform-specific code is stored in\nthe platform-specific project.\n\n\nThere is one final item we must do before we leave the set up of the project.\nThere are a number of platform upgrades that inevitably have to happen.  The\nXamarin Platform is updated much more often than the project templates in Xamarin\nStudio - the updates are released via NuGet: the standard method of distributing\nlibraries for .NET applications.  In addition to the inevitable Xamarin Platform\nupdates, we also will want to add the following NuGet packages:\n\n\n\n\nMicrosoft.Azure.Mobile.Client v2.0.0 or later\n\n\nNewtonsoft.Json v6.0.3 or later\n\n\n\n\n\n\nWarn\n\n\nAlthough it is tempting, do not include a v1.x version of the Mobile Client.\nThis is for the earlier Azure Mobile Services.  There are many differences between\nthe wire protocols of the two products.\n\n\n\n\nYou can start by updating the existing NuGet packages by right-clicking on the\nPackages folder in each project and selecting \nUpdate\n.\n\n\nNext we can install the NuGet packages by right-clicking on the Packages folder in each\nproject and selecting \nAdd Packages...\n.\n\n\n\n\nYou must install the updates and the new NuGet packages on all three projects.\nThis involves repeating the same process for each client project in your\nsolution.\n\n\n\n\nInfo\n\n\nAndroid generally has more updates than the other platforms.  Ensure that you\nupdate the main Xamarin.Forms package and then refresh the update list.  This will\nensure the right list of packages is updated.\n\n\n\n\nBuilding the Common Library\n\u00b6\n\n\nThere are two parts that we must concentrate on within the common library.  The\nfirst is the connection to Azure Mobile Apps and the second is in the pages\nthat the user interacts with.  In both cases, there are best practices to observe.\nStart by adding the following folders to your Portable Class Library project:\n\n\n\n\nAbstractions\n\n\nModels\n\n\nPages\n\n\nServices\n\n\nViewModels\n\n\n\n\nBuilding an Azure Mobile Apps Connection\n\u00b6\n\n\nWe will rely on interfaces for defining the shape for the class for any service\nthat we interact with.  This is really not important in small projects like this\none.  This technique allows us to mock the backend service, as we shall see\nlater on.  Mocking the backend service is a great technique to rapidly iterate\non the front end mobile client without getting tied into what the backend is doing.\n\n\nLet's start with the cloud service - this will be defined in a new interface\n\nAbstractions\\ICloudService.cs\n.  It is basically used for initializing\nthe connection and getting a table definition:\n\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n    }\n}\n\n\n\n\nThere is a dependent implementation here: the \nICloudTable\n generic interface.  This\nrepresents a CRUD interface into our tables and will be defined in \nAbstractions\\ICloudTable.cs\n:\n\n\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudTable<T> where T : TableData\n    {\n        Task<T> CreateItemAsync(T item);\n        Task<T> ReadItemAsync(string id);\n        Task<T> UpdateItemAsync(T item);\n        Task DeleteItemAsync(T item);\n\n        Task<ICollection<T>> ReadAllItemsAsync();\n    }\n}\n\n\n\n\nThe \nICloudTable<T>\n interface defines the normal CRUD operations: Create, Read,\nUpdate, and Delete.  However, it does so asynchronously.  We are dealing with network\noperations in general so it is easy for those operations to tie up the UI thread\nfor an appreciable amount of time.  Making them async provides the ability to\nrespond to other events.  I also provide a \nReadAllItemsAsync()\n method that\nreturns a collection of all the items.\n\n\nThere are some fields that every single record within an Azure Mobile Apps table\nprovides.  These fields are required for offline sync capabilities like incremental\nsync and conflict resolution.  The fields are provided by a new abstract base class\non the client called \nAbstractions\\TableData\n:\n\n\nusing System;\n\nnamespace TaskList.Abstractions\n{\n    public abstract class TableData\n    {\n        public string Id { get; set; }\n        public DateTimeOffset? UpdatedAt { get; set; }\n        public DateTimeOffset? CreatedAt { get; set; }\n        public byte[] Version { get; set; }\n    }\n}\n\n\n\n\nAs we will learn when we deal with \ntable data\n, these fields need to\nbe defined with the same name and semantics as on the server.  Our model on\nthe server was sub-classed from \nEntityData\n and the \nEntityData\n class on the\nserver defines these fields.\n\n\nIt's tempting to call the client version of the class the same as the server\nversion.  If we did that, the models on both the client and server would look\nthe same.  However, I find that this confuses the issue.  The models on the\nclient and server are not the same.  They are missing the \nDeleted\n flag and\nthey do not contain any relationship information on the client.  I choose to\ndeliberately call the base class something else on the client to avoid this\nconfusion.\n\n\nWe will be adding to these interfaces in future chapters as we add more\ncapabilities to the application.\n\n\nThe concrete implementations of these classes are similarly easily defined.  The\nAzure Mobile Apps Client SDK does most of the work for us.  Here is the concrete\nimplementation of the \nICloudService\n (in \nServices\\AzureCloudService.cs\n):\n\n\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(\"https://my-backend.azurewebsites.net\");\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData\n        {\n            return new AzureCloudTable<T>(client);\n        }\n    }\n}\n\n\n\n\nThe Azure Mobile Apps Client SDK takes a lot of the pain out of communicating\nwith the mobile backend that we have already published.  Just swap \nmy-backend\n out for the\nname of your mobile backend and the rest is silently dealt with.\n\n\n\n\nWarn\n\n\nThe name \nMicrosoft.WindowsAzure.MobileServices\n is a hold-over from the old Azure\nMobile Services code-base.  Don't be fooled - clients for Azure Mobile Services are\nnot interchangeable with clients for Azure Mobile Apps.\n\n\n\n\nWe also need a concrete implementation of the \nICloudTable<T>\n interface\n(in \nServices\\AzureCloudTable.cs\n):\n\n\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudTable<T> : ICloudTable<T> where T : TableData\n    {\n        MobileServiceClient client;\n        IMobileServiceTable<T> table;\n\n        public AzureCloudTable(MobileServiceClient client)\n        {\n            this.client = client;\n            this.table = client.GetTable<T>();\n        }\n\n        #region ICloudTable implementation\n        public async Task<T> CreateItemAsync(T item)\n        {\n            await table.InsertAsync(item);\n            return item;\n        }\n\n        public async Task DeleteItemAsync(T item)\n        {\n            await table.DeleteAsync(item);\n        }\n\n        public async Task<ICollection<T>> ReadAllItemsAsync()\n        {\n            return await table.ToListAsync();\n        }\n\n        public async Task<T> ReadItemAsync(string id)\n        {\n            return await table.LookupAsync(id);\n        }\n\n        public async Task<T> UpdateItemAsync(T item)\n        {\n          await table.UpdateAsync(item);\n          return item;\n        }\n        #endregion\n    }\n}\n\n\n\n\nIt's important to note here that the Azure Mobile Apps Client SDK does a lot of\nthe work for us.  In fact, we are just wrapping the basic interface here.  This\nwon't normally be the case, but you can see that the majority of the code for\ndealing with the remote server is done for us.\n\n\n\n\nTip\n\n\nYou can use a shorthand (called a lambda expression) for methods with only one line.\nFor instance, the delete method could just as easily have been written as:\n\n\npublic async Task DeleteItemAsync(T item) => await table.DeleteAsync(item);\n\n\nYou may see this sort of short hand in samples.\n\n\n\n\nWe also need to create the model that we will use for the data.  This should\nlook very similar to the model on the server - including having the same name\nand fields.  In this case, it's \nModels\\TodoItem.cs\n:\n\n\nusing TaskList.Abstractions;\n\nnamespace TaskList.Models\n{\n    public class TodoItem : TableData\n    {\n        public string Text { get; set; }\n        public bool Complete { get; set; }\n    }\n}\n\n\n\n\nWe have a final piece of code to write before we move on to the views, but it's\nan important piece.  The \nICloudService\n must be a singleton in the client.  We\nwill add authentication and offline sync capabilities in future versions of this\ncode.  The singleton becomes critical when using those features.  For right now,\nit's good practice and saves on memory if you only have one copy of the \nICloudService\n\nin your mobile client.  Since there is only one copy of the \nApp.cs\n in any\ngiven app, I can place it there.  Ideally, I'd use some sort of dependency\ninjection system or a singleton manager to deal with this.  Here is the \nApp.cs\n:\n\n\nusing TaskList.Abstractions;\nusing TaskList.Services;\nusing Xamarin.Forms;\n\nnamespace TaskList\n{\n    public class App : Application\n    {\n        public static ICloudService CloudService { get; set; }\n\n        public App()\n        {\n            CloudService = new AzureCloudService();\n            MainPage = new NavigationPage(new Pages.EntryPage());\n        }\n\n        // There are life cycle methods here...\n    }\n}\n\n\n\n\nWe haven't written \nPages.EntryPage\n yet, but that's coming.  The original \nApp.cs\n\nclass file had several methods for handling life cycle events like starting, suspending,\nor resuming the app.  I did not touch those methods for this example.\n\n\nBuilding the UI for the App\n\u00b6\n\n\nEarlier, I showed the mockup for my UI.  It included three pages - an entry\npage, a list page, and a detail page.  These pages have three elements - a\nXAML definition file, a (simple) code-behind file, and a view model.\n\n\n\n\nInfo\n\n\nThis book is not intending to introduce you to everything that there is to know\nabout Xamarin and UI programming with XAML.  If you wish to have that sort of introduction,\nthen I recommend reading the excellent book by Charles Petzold:\n\nCreating Mobile Apps with Xamarin.Forms\n.\n\n\n\n\nI tend to use MVVM (or Model-View-ViewModel) for UI development in Xamarin\nbased applications.  It's a nice clean pattern and is well understood and\ndocumented.  In MVVM, there is a 1:1 correlation between the view and the\nview-model, 2-way communication between the view and the view-model and\nproperties within the view-model are bound directly to UI elements.  In\ngeneral (and in all my code), view-models expose an INotifyPropertyChanged\nevent to tell the UI that something within the view-model has been changed.\n\n\nTo do this, we will use a \nBaseViewModel\n class that implements the base functionality\nfor each view.  Aside from the \nINotifyPropertyChanged\n interface, there are\nsome common properties we need for each page.  Each page needs a title, for\nexample, and each page needs an indicator of network activity.  These can be\nplaced in the \nAbstractions\\BaseViewModel.cs\n class:\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\n\nnamespace TaskList.Abstractions\n{\n    public class BaseViewModel : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n        string _propTitle = string.Empty;\n        bool _propIsBusy;\n\n        public string Title\n        {\n            get { return _propTitle; }\n            set { SetProperty(ref _propTitle, value, \"Title\"); }\n        }\n\n        public bool IsBusy\n        {\n            get { return _propIsBusy; }\n            set { SetProperty(ref _propIsBusy, value, \"IsBusy\"); }\n        }\n\n        protected void SetProperty<T>(ref T store, T value, string propName, Action onChanged = null)\n        {\n            if (EqualityComparer<T>.Default.Equals(store, value))\n                return;\n            store = value;\n            if (onChanged != null)\n                onChanged();\n            OnPropertyChanged(propName);\n        }\n\n        public void OnPropertyChanged(string propName)\n        {\n            if (PropertyChanged == null)\n                return;\n            PropertyChanged(this, new PropertyChangedEventArgs(propName));\n        }\n    }\n}\n\n\n\n\nThis is a fairly common \nINotifyPropertyChanged\n interface implementation pattern.\nEach property that we want to expose is a standard property, but the \nset\n operation\nis replaced by the \nSetProperty()\n call.  The \nSetProperty()\n call deals with the\nnotification; calling the event emitter if the property has changed value.  We\nonly need two properties on the \nBaseViewModel\n: the title and the network indicator.\n\n\nI tend to write my apps in two stages.  I concentrate on the functionality of the\napp in the first stage.  There is no fancy graphics, custom UI widgets, or anything\nelse to clutter the thinking.   The page is all about the functionality of the\nvarious interactions.  Once I have the functionality working, I work on the styling\nof the page.  We won't be doing any styling work in the demonstration apps that we\nwrite during the course of this book.\n\n\nThe EntryPage has just one thing to do.  It provides a button that enters the app.\nWhen we cover authentication later on, we'll use this to log in to the backend.  If\nyou are looking at the perfect app, this is a great place to put the introductory\nscreen.\n\n\nCreating a XAML file is relatively simple.  We already created a \nPages\n directory to\nhold the pages of our application.  Right-click on the \nPages\n directory in\nthe solution explorer and choose \nAdd\n -> \nNew File...\n.  In the \nAdd New File\n\ndialog, pick \nForms\n -> \nForms ContentPage Xaml\n.  Name the\nnew page \nEntryPage\n.  This will create two files - \nEntryPage.xaml\n and\n\nEntryPage.xaml.cs\n.  Let's center a button on the page and wire it up with\na command.  Here is the \nPages\\EntryPage.xaml\n file:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.EntryPage\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <StackLayout HorizontalOptions=\"Center\"\n                     Orientation=\"Vertical\"\n                     VerticalOptions=\"Center\">\n            <Button BackgroundColor=\"Teal\"\n                    BorderRadius=\"10\"\n                    Command=\"{Binding LoginCommand}\"\n                    Text=\"Login\"\n                    TextColor=\"White\" />\n        </StackLayout>\n    </ContentPage.Content>\n</ContentPage>\n\n\n\n\nThere are a couple of interesting things to note here.  The \nStackLayout\n element\nis our layout element.  It occupies the entire screen (since it is a direct child\nof the content page) and the options just center whatever the contents are.  The\nonly contents are a button.\n\n\nThere are two bindings.  These are bound from the view-model.  We've already seen\nthe Title property - this is a text field that specifies the title of the page.\nThe other binding is a login command.  When the button is tapped, the login command\nwill be run.  We'll get onto that in the view-model later.\n\n\nThe other file created is the code-behind file.  Because we are moving all\nof the non-UI code into a view-model, the code-behind file is trivial:\n\n\nusing TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class EntryPage : ContentPage\n    {\n        public EntryPage()\n        {\n            InitializeComponent();\n            BindingContext = new EntryPageViewModel();\n        }\n    }\n}\n\n\n\n\nThis is a recipe that will be repeated over and over again for the code-behind\nwhen you are using a XAML-based project with MVVM.  We initialize the UI, then\nbind all the bindings to a new instance of the view model.\n\n\nSpeaking of which, the view-model just needs to handle the login click.  Note that\nthe location or namespace is \nTaskList.ViewModels\n.  I'm of two minds about location.\nThere tends to be a 1:1 relationship between the XAML file and the View Model, so\nit makes sense that they are stored together.  However, just about all the sample\ncode that I see has the view-models in a separate namespace.  Which one is correct?\nI'll go with copying the samples for now.  Here is the code for \nViewModels\\EntryPageViewModel.cs\n:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class EntryPageViewModel : BaseViewModel\n    {\n        public EntryPageViewModel()\n        {\n            Title = \"Task List\";\n        }\n\n        Command loginCmd;\n        public Command LoginCommand => loginCmd ?? (loginCmd = new Command(async () => await ExecuteLoginCommand()));\n\n        async Task ExecuteLoginCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[Login] Error = {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}\n\n\n\n\nThis is a fairly simple view-model but there are some patterns here that are\nworth explaining.  Firstly, note the way we create the \nLoginCommand\n property.\nThis is the property that is bound to the \nCommand\n parameter in the \nButton\n\nof our view.  This recipe is the method of invoking a UI action asynchronously.\nIt isn't important now, but we will want this technique repeatedly as our UI\nactions kick off network activity.\n\n\nThe second is the pattern for the \nExecuteLoginCommand\n method.  Firstly, I\nensure nothing else is happening by checking the IsBusy flag.   If nothing\nis happening, I set the IsBusy flag.  Then I do what I need to do in a try/catch\nblock.  If an exception is thrown, I deal with it.  Most of the time this\ninvolves displaying an error condition.  There are several cross-platform dialog\npackages to choose from or you can roll your own.  That is not covered here.  We\njust write a debug log statement so we can see the result in the debug log.  Once\neverything is done, we clear the IsBusy flag.\n\n\nThe only thing we are doing now is swapping out our main page for a new main\npage.  This is where we will attach authentication later on.\n\n\nThe next page is the Task List page, which is in \nPages\\TaskList.xaml\n:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.TaskList\"\n             Title=\"{Binding Title}\">\n  <ContentPage.Content>\n    <StackLayout>\n      <ListView BackgroundColor=\"#7F7F7F\"\n                CachingStrategy=\"RecycleElement\"\n                IsPullToRefreshEnabled=\"True\"\n                IsRefreshing=\"{Binding IsBusy, Mode=OneWay}\"\n                ItemsSource=\"{Binding Items}\"\n                RefreshCommand=\"{Binding RefreshCommand}\"\n                RowHeight=\"50\"\n                SelectedItem=\"{Binding SelectedItem, Mode=TwoWay}\">\n        <ListView.ItemTemplate>\n          <DataTemplate>\n            <ViewCell>\n              <StackLayout HorizontalOptions=\"FillAndExpand\"\n                           Orientation=\"Horizontal\"\n                           Padding=\"10\"\n                           VerticalOptions=\"CenterAndExpand\">\n                <Label HorizontalOptions=\"FillAndExpand\"\n                       Text=\"{Binding Text}\"\n                       TextColor=\"#272832\" />\n                <Switch IsToggled=\"{Binding Complete, Mode=OneWay}\" />\n              </StackLayout>\n            </ViewCell>\n          </DataTemplate>\n        </ListView.ItemTemplate>\n      </ListView>\n      <StackLayout HorizontalOptions=\"Center\"\n                   Orientation=\"Horizontal\">\n        <Button BackgroundColor=\"Teal\"\n                Command=\"{Binding AddNewItemCommand}\"\n                Text=\"Add New Item\"\n                TextColor=\"White\" />\n      </StackLayout>\n    </StackLayout>\n  </ContentPage.Content>\n</ContentPage>\n\n\n\n\nNote that some bindings here are one-way.  This means that the value in the\nview-model drives the value in the UI.  There is nothing within the UI that you\ncan do to alter the state of the underlying property.  Some bindings are two-way.\nDoing something in the UI (for example, toggling the switch) alters the underlying\nproperty.\n\n\nThis view is a little more complex.  It can be split into two parts - the list\nat the top of the page and the button area at the bottom of the page.  The list\narea uses a template to help with the display of each item.\n\n\nNote that the \nListView\n object has a \"pull-to-refresh\" option that I have wired\nup so that when pulled, it calls the RefreshCommand.  It also has an indicator\nthat I have wired up to the IsBusy indicator.  Anyone who is familiar with the\niOS \"pull-to-refresh\" gesture can probably guess what this does.\n\n\nThe code behind for the TaskList can be found in \nPages\\TaskList.xaml.cs\n:\n\n\nusing TaskList.ViewModels;using Xamarin.Forms;\nnamespace TaskList.Pages\n{\n    public partial class TaskList : ContentPage\n    {\n        public TaskList()\n        {\n            InitializeComponent();\n            BindingContext = new TaskListViewModel();\n        }\n    }\n}\n\n\n\n\nThere is a view-model that goes along with the view (in \nViewModels\\TaskListViewModel.cs\n):\n\n\nusing System;\nusing System.Collections.ObjectModel;\nusing System.Collections.Specialized;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskListViewModel : BaseViewModel\n    {\n        public TaskListViewModel()\n        {\n            Title = \"Task List\";\n            RefreshList();\n        }\n\n        ObservableCollection<TodoItem> items = new ObservableCollection<TodoItem>();\n        public ObservableCollection<TodoItem> Items\n        {\n            get { return items; }\n            set { SetProperty(ref items, value, \"Items\"); }\n        }\n\n        TodoItem selectedItem;\n        public TodoItem SelectedItem\n        {\n            get { return selectedItem; }\n            set\n            {\n                SetProperty(ref selectedItem, value, \"SelectedItem\");\n                if (selectedItem != null)\n                {\n                    Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail(selectedItem));\n                    SelectedItem = null;\n                }\n            }\n        }\n\n        Command refreshCmd;\n        public Command RefreshCommand => refreshCmd ?? (refreshCmd = new Command(async () => await ExecuteRefreshCommand()));\n\n        async Task ExecuteRefreshCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                var table = App.CloudService.GetTable<TodoItem>();\n                var list = await table.ReadAllItemsAsync();\n                Items.Clear();\n                foreach (var item in list)\n                    Items.Add(item);\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskList] Error loading items: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command addNewCmd;\n        public Command AddNewItemCommand => addNewCmd ?? (addNewCmd = new Command(async () => await ExecuteAddNewItemCommand()));\n\n        async Task ExecuteAddNewItemCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                await Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskList] Error in AddNewItem: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        async Task RefreshList()\n        {\n            await ExecuteRefreshCommand();\n            MessagingCenter.Subscribe<TaskDetailViewModel>(this, \"ItemsChanged\", async (sender) =>\n            {\n                await ExecuteRefreshCommand();\n            });\n        }\n    }\n}\n\n\n\n\nThis is a combination of the patterns we have seen earlier.  The Add New Item\nand Refresh commands should be fairly normal patterns now.  We navigate to the\ndetail page (more on that later) in the case of selecting an item (which occurs\nwhen the UI sets the \nSelectedItem\n property through a two-way binding) and when\nthe user clicks on the Add New Item button.  When the Refresh button is clicked\n(or when the user opens the view for the first time), the list is refreshed.  It\nis fairly common to use an \nObservableCollection\n or another class that uses the\n\nICollectionChanged\n event handler for the list storage.  Doing so allows the UI\nto react to changes in the items.\n\n\nNote the use of the \nICloudTable\n interface here.  We are using the \nReadAllItemsAsync()\n\nmethod to get a list of items, then we copy the items we received into the \nObservableCollection\n.\n\n\nFinally, there is the TaskDetail page.  This is defined in the \nPages\\TaskDetail.xaml\n\nfile:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.TaskDetail\"\n             Title=\"{Binding Title}\">\n  <ContentPage.Content>\n    <StackLayout Padding=\"10\" Spacing=\"10\">\n      <Label Text=\"What should I be doing?\"/>\n      <Entry Text=\"{Binding Item.Text}\"/>\n      <Label Text=\"Completed?\"/>\n      <Switch IsToggled=\"{Binding Item.Complete}\"/>\n      <StackLayout VerticalOptions=\"CenterAndExpand\"/>\n      <StackLayout Orientation=\"Vertical\" VerticalOptions=\"End\">\n        <StackLayout HorizontalOptions=\"Center\" Orientation=\"Horizontal\">\n          <Button BackgroundColor=\"#A6E55E\"\n                  Command=\"{Binding SaveCommand}\"\n                  Text=\"Save\" TextColor=\"White\"/>\n          <Button BackgroundColor=\"Red\"\n                  Command=\"{Binding DeleteCommand}\"\n                  Text=\"Delete\" TextColor=\"White\"/>\n        </StackLayout>\n      </StackLayout>\n    </StackLayout>\n  </ContentPage.Content>\n</ContentPage>\n\n\n\n\nThis page is a simple form with just two buttons that need to have commands\nwired up.  However, this page is used for both the \"Add New Item\" gesture\nand the \"Edit Item\" gesture.  As a result of this, we need to handle the\npassing of the item to be edited.  This is done in the \nPages\\TaskDetail.xaml.cs\n\ncode-behind file:\n\n\nusing TaskList.Models;\nusing TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class TaskDetail : ContentPage\n    {\n        public TaskDetail(TodoItem item = null)\n        {\n            InitializeComponent();\n            BindingContext = new TaskDetailViewModel(item);\n        }\n    }\n}\n\n\n\n\nThe item that is passed in from the \nTaskList\n page is used to create a\nspecific view-model for that item.  The view-model is similarly configured\nto use that item:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskDetailViewModel : BaseViewModel\n    {\n        ICloudTable<TodoItem> table = App.CloudService.GetTable<TodoItem>();\n\n        public TaskDetailViewModel(TodoItem item = null)\n        {\n            if (item != null)\n            {\n                Item = item;\n                Title = item.Text;\n            }\n            else\n            {\n                Item = new TodoItem { Text = \"New Item\", Complete = false };\n                Title = \"New Item\";\n            }\n        }\n\n        public TodoItem Item { get; set; }\n\n        Command cmdSave;\n        public Command SaveCommand => cmdSave ?? (cmdSave = new Command(async () => await ExecuteSaveCommand()));\n\n        async Task ExecuteSaveCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id == null)\n                {\n                    await table.CreateItemAsync(Item);\n                }\n                else\n                {\n                    await table.UpdateItemAsync(Item);\n                }\n                MessagingCenter.Send<TaskDetailViewModel>(this, \"ItemsChanged\");\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskDetail] Save error: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command cmdDelete;\n        public Command DeleteCommand => cmdDelete ?? (cmdDelete = new Command(async () => await ExecuteDeleteCommand()));\n\n        async Task ExecuteDeleteCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id != null)\n                {\n                    await table.DeleteItemAsync(Item);\n                }\n                MessagingCenter.Send<TaskDetailViewModel>(this, \"ItemsChanged\");\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskDetail] Save error: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}\n\n\n\n\nThe save command uses the \nICloudTable\n interface again - this time doing\neither \nCreateItemAsync()\n or \nUpdateItemAsync()\n to create or update the\nitem.  The delete command, as you would expect, deletes the item with the\n\nDeleteItemAsync()\n method.\n\n\nThe final thing to note from our views is that I am using the \nMessagingCenter\n\nto communicate between the TaskDetail and TaskList views.  If I change the item\nin the \nTaskDetail\n list, then I want to update the list in the \nTaskList\n view.\n\n\nNote that all the code we have added to the solution thus far is in the common\n\nTaskList\n project.  Nothing is required for this simple example in a platform\nspecific project.  That isn't normal, as we shall see.\n\n\nBuilding the Client for Android\n\u00b6\n\n\nNow we're ready to build our client applications.  We'll start with the Android version.  Prior\nto running the application, we need to make two additional changes.  Go to your Android\nproject and open the \nMainActivity.cs\n file.  In the \nOnCreate\n method we need to add\nan initalizer for our Mobile Apps SDK:\n\n\nprotected override void OnCreate(Bundle bundle)\n{\n    TabLayoutResource = Resource.Layout.Tabbar;\n    ToolbarResource = Resource.Layout.Toolbar;\n    base.OnCreate(bundle);\n\n    Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n    global::Xamarin.Forms.Forms.Init(this, bundle);\n    LoadApplication(new App());\n}\n\n\n\n\nFinally, as Android has an explicit permission model (this has somewhat changed in the latest\nversion of Android), we need to say the application requires the Internet permission.  Right-click\non the Android project and go to \nOptions\n.  Select \nAndroid Application\n from under the\n\nBuild\n section.  At the bottom of the options panel, you'll see a list of permissions.\nFind Internet and check it and then click the OK button.\n\n\n\n\nNext we need to configure the solution to run the Android project.\n\n\n\n\nRight-click on the \nTaskList.Droid\n project, then select \nSet as StartUp Project\n.\n\n\nRight-click on the \nTaskList.Droid\n project again, then select \nBuild TaskList.Droid\n.\n\n\n\n\nThe drop-down between the run button in the top left of Xamarin Studio and the Build status\nat the top of Xamarin Studio, now allows you to choose an emualtor or device to run your app\nagainst.  By default, Xamarin Studio will create several emulators for you.  You can also use\nthe \nManage Google Emulators...\n option to create additional Android Virtual Devices (AVDs)\nand download other images online.\n\n\n\n\nTip\n\n\nWhen testing the mobile client manually through the Android Emulator,\nyou are likely to need to rebuild the application.  You do not have to\nshut down the emulator between runs.  You can leave it running.  The application\nwill be stopped and replaced before starting again.  This can significantly speed\nup the debug cycle since you are not waiting for the emulator to start each time.\n\n\n\n\nWatch the Output window.  If the debugger won't connect or the application\nwon't start, you may need to restart your computer or the emulator to get the network\nworking.\n\n\nIf everything is working, you should see the Android Emulator\ndisplay your mobile client:\n\n\n\n\n\n\nWarn\n\n\nYou can also build the Android version on Windows with Visual Studio.  However, I find\nthat version mismatches between Mono (which is used on the mac) and Visual Studio - particularly\nin reference to the version of the .NET framework - cause issues when swapping between the\ntwo environments.  For best results, stay in one environment.\n\n\n\n\nNote that the task list view is a \"dark\" style and the rest of the app is a\n\"light\" style.  This is because the default styling on an Android device is\nlight.  We are using the default styling on two of the pages and specifying\ncolors on the list page.  Fortunately, Xamarin Forms allows for \nplatform-specific\nstyling\n.  The \nfinal sample\n has platform-specific styling for the\nlist page.\n\n\nBuilding the Client for iOS\n\u00b6\n\n\nWith Android done, we can now turn to the iOS platform.  Like we did for Android, we must\nfirst initalize our Mobile Apps SDK for our platform.  Open the \nAppDelegate.cs\n file in\nyour iOS project.  In the FinishedLaunching method, we will initalize our SDK:\n\n\npublic override bool FinishedLaunching(UIApplication app, NSDictionary options)\n{\n    global::Xamarin.Forms.Forms.Init();\n\n    Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n    LoadApplication(new App());\n    return base.FinishedLaunching(app, options);\n}\n\n\n\n\nNow we can build and run our app:\n\n\n\n\nRight-click on the \nTaskList.iOS\n project and select \nSet as StartUp Project\n.\n\n\nRight-click on the \nTaskList.iOS\n project and select \nBuild TaskList.iOS\n.\n\n\n\n\nIf you have never used Xamarin Studio to build and run an iOS app before, it is possible\nthat you will receive an error having to do with code signing keys, provisioning profiles,\nor signing identities.  If so it may be  because you have not yet signed up for an Apple\nDeveloper Account and linked it to your Mac development environment.\n\n\n\n\nGo to the \nApple Developer Center\n.\n\n\nClick on \nAccount\n in the top navigation bar.\n\n\nIf you haven't got an Apple ID yet, create one first.\n\n\nIf you have go an Apple ID, then log in.\n\n\n\n\nThere are a sequence of sign-up prompts in both cases (first for creating your\nApple ID and secondly for signing up for the Apple Developer program).  Once\nyou have gone through this process, you are registered as an Apple Developer.\n\n\n\n\nInfo\n\n\nIf you want to distribute your apps on the Apple App Store, run on real devices or\nget access to the beta bits, then you might consider signing up for the Apple Developer\nProgram.  The Apple Developer Program is an additional cost and is not required for\ndeveloping iOS apps that are only run on the iOS simulator.\n\n\n\n\nOnce you have created your account and enabled it as a developer account, open\nup Xcode.  Go to \nPreferences...\n, then \nAccount\n and\nclick on the \n+\n in the bottom-left corner of the window and pick \nAdd Apple ID...\n:\n\n\n\n\nSign in with the same account you used to sign up for the developer account.\n\n\n\n\nClick on the \nView Details\n button.  This will bring up the Signing Identities\nlist.  For a free account, it looks like this:\n\n\n\n\nClick on the Create button next to \niOS Development\n.  Once the UI comes back,\nclick on \nDone\n.  For more information on this process, refer to the \nApple Documentation\n.\n\n\nYou can close Xcode at this point.  Return to Xamarin Studio, right-click on the\n\nTaskList.iOS\n project and build again.  This will (finally!) build the application for you.\n\n\n\n\nTip\n\n\nGetting an error about \nProvisioning Profiles\n not being available?  This is because\nyou are building for a real device instead of the simulator.  In order to build for a\nreal device, you must have a linked Apple Developer Program.  To get around this, select\na Simulator before building.\n\n\n\n\nYou can now select from several simulator options from the drop-down to the left of the\nbuild status.\nYou should only use \nDevice\n if you have signed up for the Apple Developer Program.  Pick\none of the simulator options like the \niPhone 6 iOS 10.0\n simulator, then click on it\nto run the simulator.\n\n\nThe final product screens look like this:\n\n\n\n\nSome Final Thoughts\n\u00b6\n\n\nIf you have got through the entire process outlined in this Chapter and built the application\nfor each platform, then congratulations.  There are a lot of places where things can go\nwrong.  You are really integrating the build systems across Android, iOS, Xamarin, Xcode,\nand Azure.\n\n\nFortunately, once these are set up, it's likely that they will continue working and you\nwon't have to think too much about them again. The Android and iOS build tools and simulators\nwill just work.\n\n\nThe following 7 chapters each take one aspect of the cloud services that can be provided to\nmobile apps and explores it in detail, using an Azure Mobile App as a beginning. You can\njump around at this point, but be aware that we expect you to cover these topics in order.\nIf you do the data chapter before covering authentication, it's likely you will have missed\nimportant functionality in your app to complete the work.",
            "title": "Your First App - Mac Edition"
        },
        {
            "location": "/chapter1/firstapp_mac/#your-first-mobile-app-on-a-mac",
            "text": "There is a lot of detail to absorb about the possible services that the mobile\nclient can consume and I will go into significant depth on those subjects.\nFirst, wouldn't it be nice to write some code and get something working?\nMicrosoft Azure has a great  first-steps tutorial  that takes you via the\nquickest possible route from creating a mobile backend to having a functional\nbackend.  I would like to take things a little slower so that we can understand\nwhat is going on while we are doing the process.  We will have practically the\nsame application at the end.  The primary reason for going through this slowly\nis to ensure that all our build and run processes are set up properly.  If this\nis the first mobile app you have ever written, you will see that there are quite\na few things that need to be set up.  This chapter covers the set up required\nfor a MacOS computer.  If you wish to develop your applications on a Windows PC, then skip\nto the  next section .  The application we are going to build together is a simple task list.  The\nmobile client will have three screens - an entry screen, a task list and a task\ndetails page.  I have mocked these pages up using  MockingBot .   Tip  Mocking your screens before you start coding is a great habit to get into.\nThere are some great tools available including free tools like  MockingBot .\nDoing mockups before you start coding is a good way to prevent wasted time later\non.     Tip  If you are using iOS, then you may want to remove the back button as the style\nguides suggest you don't need one.  Other platforms will need it though, so it's\nbest to start with the least common denominator.  It's the same reason I add a\nrefresh button even though it's only valid on Windows Phone!   My ideas for this app include:   Tapping on a task title in the task list will bring up the details page.  Toggling the completed link in the task list will set the completed flag.  Tapping the spinner will initiate a network refresh.   Now that we have our client screens planned out, we can move onto the thinking\nabout the mobile backend.",
            "title": "Your First Mobile App on a Mac"
        },
        {
            "location": "/chapter1/firstapp_mac/#the-mobile-backend",
            "text": "The mobile backend is an ASP.NET WebApi that is served from within Azure App\nService: a highly scalable and redundant web hosting facility that supports all\nthe major web languages (like ASP.NET, Node, PHP and Python).  Azure Mobile\nApps is an SDK (which is available in ASP.NET and Node) that runs on top of\nAzure App Service.",
            "title": "The Mobile Backend"
        },
        {
            "location": "/chapter1/firstapp_mac/#creating-a-simple-azure-mobile-apps-backend",
            "text": "To get started:   Fire up Xamarin Studio  Add a new project with File -> New Solution...   In the  New Project  window:   Choose Other -> ASP.NET and select  Empty ASP.NET Project .  Click Next.     In the  Configure your Web project  window:   Check the  Web API  checkbox.  Click Next.     In the  Configure your new project  window:   Enter  Backend  for the for the Project Name and  Chapter1  for the Solution name.  Pick a suitable directory for the Location field.  Click on Create.     At this point, Xamarin Studio will create your backend project.  You may need to accept licenses for several packages to continue with\nthe project creation.  As Xamarin Studio doesn't have templates for all\nof the same ASP.NET projects that Visual Studio does, we'll need to do\nsome additional work to set our project up.  First, we need to change our project to target .NET 4.6.  Right click on\nyour  Backend  project in the Solution Explorer and choose Options.  Under\nthe  Build  section, select  General .  Under the Target Framework dropdown\nselect .NET Framework 4.6.1:   Click  OK  to accept the change and close the Project Options.  Next we'll install multiple NuGet packages.  Expand the  Backend  project\nin the Solution Explorer and right click on  Packages  and then select Add Packages .  Find and add the following packages:   Azure Mobile .NET Server SDK  Azure Mobile .NET Server Tables  Azure Mobile .NET Server CORS  Azure Mobile .NET Server Notifications  Azure Mobile .NET Server Authentication  Azure Mobile .NET Server Home  Azure Mobile .NET Server Quickstart  Azure Mobile .NET Server Entity  Microsoft.OWIN.Host.SystemWeb    Tip  The Azure Mobile .NET Server Quickstart NuGet package has all the other packages\nas dependencies.  Add the Quickstart package first to save yourself some time.   You should also take the opportunity to update any NuGet packages that were\nautomatically added to the project.  To do so, right click on  Packages  and\nchoose  Update .  Next you'll need to add the following folders to the  Backend  project.  Right\nclick on  Backend  and select Add -> New Folder and create the following:   Controllers  DataObjects  Models   Next you'll need to remove the following files that were created as part of the template.\nRight click on each of the following files and choose Remove and click the Delete button:   App_Start/WebApiConfig.cs  Global.asax   Now we can add the files that will consist of our backend.  We'll start by\ncreating the three files that will handle projecting a single table in our\ndatabase - the TodoItem table - into the mobile realm with the aid of an\nopinionated  OData v3  feed.  To that end, we need three items:   A  DbSet<>  within the  DbContext  A Data Transfer Object (or DTO)  A Table Controller   Start by right clicking on  DataObjects  and choose Add -> New File.  Select General -> Empty Class and name it TodoItem.cs .  As we're building a task list application, this is the DTO\nfor our TodoItems:  using Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.DataObjects\n{\n    public class TodoItem : EntityData\n    {\n        public string Text { get; set; }\n        public bool Complete { get; set; }\n    }\n}  Note that the model uses  EntityData  as a base class.  The  EntityData  class\nadds five additional properties to the class - we'll discuss those in more\ndetails during the  Data Access and Offline Sync  chapter.  Next, we'll create our  DbContext  which uses  Entity Framework  to deal with creating\nour Database Model when we upload our backend to Azure.  Right click on  Models  and choose\nAdd -> New File.  Select General -> Empty Class and name it  MobileServiceContext.cs .\nAdd the following code:  using System.Data.Entity;\nusing System.Data.Entity.ModelConfiguration.Conventions;\nusing System.Linq;\nusing Microsoft.Azure.Mobile.Server;\nusing Microsoft.Azure.Mobile.Server.Tables;\nusing Backend.DataObjects;\n\nnamespace Backend.Models\n{\n    public class MobileServiceContext : DbContext\n    {\n        // You can add custom code to this file. Changes will not be overwritten.\n        //\n        // If you want Entity Framework to alter your database\n        // automatically whenever you change your model schema, please use data migrations.\n        // For more information refer to the documentation:\n        // http://msdn.microsoft.com/en-us/data/jj591621.aspx\n        //\n        // To enable Entity Framework migrations in the cloud, please ensure that the\n        // service name, set by the 'MS_MobileServiceName' AppSettings in the local\n        // Web.config, is the same as the service name when hosted in Azure.\n\n        private const string connectionStringName = \"Name=MS_TableConnectionString\";\n\n        public MobileServiceContext() : base(connectionStringName)\n        {\n        }\n\n        public DbSet<TodoItem> TodoItems { get; set; }\n\n        protected override void OnModelCreating(DbModelBuilder modelBuilder)\n        {\n            modelBuilder.Conventions.Add(\n                new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n                    \"ServiceTableColumn\", (property, attributes) => attributes.Single().ColumnType.ToString()));\n        }\n    }\n}  Next we'll create the controller for our TodoItem table.  Right click on  Controllers \nand choose Add -> New File.  Select General -> Empty Class and name it TodoItemController.cs .  Add the following code:  using System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}  The  TableController  is the central processing for the database access layer.\nIt handles all the OData capabilities for us and exposes these as REST endpoints\nwithin our WebAPI.  This means that the actual code for this controller is tiny - just 12 lines of code.   Info  OData  is a specification for accessing table data on the Internet.  It provides\na mechanism for querying and manipulating data within a table.  Entity Framework is a\ncommon data access layer for ASP.NET applications.   Moving on, we'll create the startup file for our backend.  Right click on  App_Start \n-> Add -> New File.  Select General -> Empty Class and name it Startup.MobileApp.cs .   Info  If you name a file in Xamarin Studio with a period in it without including the specific\nextension (.cs) at the end, Xamarin Studio will not automatically set the file up\nto be compiled correctly.   This class handles initializing our mobile application backend:  using System;\nusing System.Collections.Generic;\nusing System.Configuration;\nusing System.Data.Entity;\nusing System.Web.Http;\nusing Microsoft.Azure.Mobile.Server;\nusing Microsoft.Azure.Mobile.Server.Authentication;\nusing Microsoft.Azure.Mobile.Server.Config;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Owin;\n\nnamespace Backend\n{\n    public partial class Startup\n    {\n        public static void ConfigureMobileApp(IAppBuilder app)\n        {\n            var config = new HttpConfiguration();\n            var mobileConfig = new MobileAppConfiguration();\n\n            mobileConfig\n                .AddTablesWithEntityFramework()\n                .ApplyTo(config);\n\n            Database.SetInitializer(new MobileServiceInitializer());\n\n            app.UseWebApi(config);\n        }\n    }\n\n    public class MobileServiceInitializer : CreateDatabaseIfNotExists<MobileServiceContext>\n    {\n        protected override void Seed(MobileServiceContext context)\n        {\n            List<TodoItem> todoItems = new List<TodoItem>\n            {\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"First item\", Complete = false },\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"Second item\", Complete = false }\n            };\n\n            foreach (TodoItem todoItem in todoItems)\n            {\n                context.Set<TodoItem>().Add(todoItem);\n            }\n\n            base.Seed(context);\n        }\n    }\n}  If you were to create a new Mobile App based application in Visual Studio or download the\nquickstart application from the Azure portal, the startup\nwould be considerably inflated with additional functionality for things like\nauthentication and push notifications.  Currently we have it set up to only implement\nour data layer.  There is another method in the  App_Start\\Startup.MobileApp.cs  file for\nseeding data into the database for us.  We can leave that alone for now, but\nremember it is there in case you need to seed data into a new database for\nyour own backend.   Info  When we refer to \"seeding data\" into a database, this means that we are going to introduce\nsome data into the database so that we aren't operating on an empty database. The data\nwill be there when we query the database later on.   Finally we need to add a startup class for our ASP.NET\napplication.  Right click on  Backend  -> Add -> New File.  Select General ->\nEmpty Class and name it  Startup.cs .  The purpose of this class is just to kick off\nthe configuration of our mobile app backend:  using Microsoft.Owin;\nusing Owin;\n\n[assembly: OwinStartup(typeof(Backend.Startup))]\n\nnamespace Backend\n{\n    public partial class Startup\n    {\n        public void Configuration(IAppBuilder app)\n        {\n            ConfigureMobileApp(app);\n        }\n    }\n}  Our last step in our backend before publishing it is to edit the  web.config :  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!--\nWeb.config file for TestProject.\n\nThe settings that can be used in this file are documented at\nhttp://www.mono-project.com/Config_system.web and\nhttp://msdn2.microsoft.com/en-us/library/b5ysx397.aspx\n-->\n<configuration>\n  <configSections>\n    <section name=\"entityFramework\" type=\"System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" requirePermission=\"false\" />\n    <!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 -->\n    <!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 -->\n  </configSections>\n  <connectionStrings>\n    <add name=\"MS_TableConnectionString\" connectionString=\"Data Source=(localdb)\\MSSQLLocalDB;AttachDbFilename=|DataDirectory|\\aspnet-MobileAppsBookTest-20160923095604.mdf;Initial Catalog=aspnet-MobileAppsBookTest-20160923095604;Integrated Security=True;MultipleActiveResultSets=True\" providerName=\"System.Data.SqlClient\" />\n  </connectionStrings>\n  <appSettings>\n    <add key=\"PreserveLoginUrl\" value=\"true\" />\n    <!-- Use these settings for local development. After publishing to your\n    Mobile App, these settings will be overridden by the values specified\n    in the portal. -->\n    <add key=\"MS_SigningKey\" value=\"Overridden by portal settings\" />\n    <add key=\"EMA_RuntimeUrl\" value=\"Overridden by portal settings\" />\n    <!-- When using this setting, be sure to add matching Notification Hubs connection\n    string in the connectionStrings section with the name \"MS_NotificationHubConnectionString\". -->\n    <add key=\"MS_NotificationHubName\" value=\"Overridden by portal settings\" />\n  </appSettings>\n  <system.web>\n    <customErrors mode=\"Off\" />\n    <httpRuntime targetFramework=\"4.6.1\" />\n    <compilation debug=\"true\" targetFramework=\"4.6.1\">\n      <assemblies />\n    </compilation>\n  </system.web>\n  <system.webServer>\n    <validation validateIntegratedModeConfiguration=\"false\" />\n    <modules runAllManagedModulesForAllRequests=\"true\" />\n    <handlers>\n      <remove name=\"ExtensionlessUrlHandler-Integrated-4.0\" />\n      <remove name=\"OPTIONSVerbHandler\" />\n      <remove name=\"TRACEVerbHandler\" />\n      <add name=\"ExtensionlessUrlHandler-Integrated-4.0\" path=\"*.\" verb=\"*\" type=\"System.Web.Handlers.TransferRequestHandler\" preCondition=\"integratedMode,runtimeVersionv4.0\" />\n    </handlers>\n  </system.webServer>\n  <runtime>\n    <assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\" xmlns:bcl=\"urn:schemas-microsoft-com:bcl\">\n      <dependentAssembly>\n        <assemblyIdentity name=\"System.Spatial\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-5.7.0.0\" newVersion=\"5.7.0.0\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"System.Web.Http\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-5.2.3.0\" newVersion=\"5.2.3.0\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"System.Net.Http.Formatting\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-5.2.3.0\" newVersion=\"5.2.3.0\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"Microsoft.Data.Edm\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-5.7.0.0\" newVersion=\"5.7.0.0\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"Microsoft.Data.OData\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-5.7.0.0\" newVersion=\"5.7.0.0\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"Newtonsoft.Json\" publicKeyToken=\"30ad4fe6b2a6aeed\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-9.0.0.0\" newVersion=\"9.0.0.0\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"Microsoft.Owin\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-3.0.1.0\" newVersion=\"3.0.1.0\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"System.IdentityModel.Tokens.Jwt\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-5.0.0.127\" newVersion=\"5.0.0.127\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"System.Web.Http.OData\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-5.7.0.0\" newVersion=\"5.7.0.0\" />\n      </dependentAssembly>\n      <dependentAssembly>\n        <assemblyIdentity name=\"AutoMapper\" publicKeyToken=\"be96cd2c38ef1005\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-5.1.1.0\" newVersion=\"5.1.1.0\" />\n      </dependentAssembly>\n    </assemblyBinding>\n  </runtime>\n  <entityFramework>\n    <defaultConnectionFactory type=\"System.Data.Entity.Infrastructure.SqlConnectionFactory, EntityFramework\" />\n    <providers>\n      <provider invariantName=\"System.Data.SqlClient\" type=\"System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer\" />\n    </providers>\n  </entityFramework>\n</configuration>  Choose  Build All  from the  Build  menu and ensure your project compiles\nwithout errors.",
            "title": "Creating a Simple Azure Mobile Apps Backend"
        },
        {
            "location": "/chapter1/firstapp_mac/#building-an-azure-app-service-for-mobile-apps",
            "text": "The next step in the process is to build the resources on Azure that will\nrun your mobile backend.  Start by logging into the  Azure Portal , then\nfollow these instructions:   Click on the big  + New  button in the top-left corner.  Click on  Web + Mobile , then  Mobile App .   Enter a unique name in the  App name  box.   Tip  Since the name doesn't matter and it has to be unique, you can use  a\nGUID generator  to generate a unique name. GUIDs are not the best\nnames to use when you need to actually find resources, but using GUIDS\nprevents conflicts when deploying, so I prefer them as a naming scheme.\nYou can prefix the GUID  (example: chapter1-GUID) to aid in discovery\nlater on.  Generally, the first four digits of a GUID are enough to\nidentify individual resources.     If you have more than one subscription (for example, you have a trial\n   and an MSDN subscription), then ensure you select the right subscription\n   in the  Subscription  drop-down.    Select  Create new  under resource group and enter a name for this\n   mobile application.   Resource Groups  Resource groups are great for grouping all the resources associated with a\nmobile application together.  During development, it means you can delete\nall the resources in one operation.  For production, it means you can see how\nmuch the service is costing you and how the resources are being used.     Finally, select or create a new  App Service Plan .   App Service Plan  The App Service Plan is the thing that actually bills you - not the web or\nmobile backend.  You can run a number of web or mobile backends on the same\nApp Service Plan.   I tend to create a new App Service Plan for each mobile application.  This\nis because the App Service Plan lives inside the Resource Group that you\ncreate.  The process for creating an App Service Plan is straight forward.\nYou have two decisions to make.  The first decision is where is the service\ngoing to run.  In a production environment, the correct choice is \"near your\ncustomers\".  \"Close to the developers\" is a good choice during development.\nUnfortunately, neither of those is an option you can actually choose in the\nportal, so you will have to translate into some sort of geographic location.\nWith 22 regions to choose from, you have a lot of choice.  The second decision you have to make is what to run the service on; also\nknown as the Pricing tier.   If you click on  View all , you will see you\nhave lots of choices.  F1 Free and D1 Shared, for example, run on shared\nresources and are CPU limited. You should avoid these as the service will\nstop responding when you are over the CPU quota.  That leaves Basic,\nStandard, and Premium.  Basic has no automatic scaling and can run up to 3\ninstances - perfect for development tasks.  Standard and Premium both have\nautomatic scaling, automatic backups, and large amounts of storage; they\ndiffer in features: the number of sites or instances you can run on them,\nfor example.  Finally, there is a number after the plan.  This tells you how\nbig the virtual machine is that the plan is running on.  The numbers differ\nby number of cores and memory.  For our purposes, a F1 Free site is enough to run this small demonstration\nproject.  More complex development projects should use something in the\nBasic range of pricing plans.  Production apps should be set up in Standard\nor Premium pricing plans.    Once you have created your app service plan and saved it, click on  Create .    The creation of the service can take a couple of minutes.  You can monitor the\nprocess of deployment by clicking on the Notifications icon.  This is in the top\nbar on the right-hand side and looks like a Bell.  Clicking on a specific\nnotification will provide more information about the activity.  Once you have\ncreated your app service, the App Service blade will open.   Info  What's the difference between a Web App, a Mobile App and an API App?  Not a\nlot.  The type determines which Quick start projects are available in the Quick\nstart menu under  All settings .  Since we selected a Mobile app, a set of\nstarter client projects for mobile devices will be presented.   We will also want a place to store our data.  This role is taken on by a\nSQL Azure instance.  We could link an existing database if we had one\ndefined.  However, we can also create a test database.   Tip  Creating a Test Database through the App Service Data Connections (as\nI describe here) allows you to create a free database.  This option is\nnot normally available through other SQL database creation flows.    Click on  Resource groups  in the left hand side menu.  Click on the resource group you created.   Click on the App Service your created.   Tip  If you pinned your App Service to the dashboard, you can click on the\npinned App Service instead.  It will bring you to the same place.     Click on  Data connections  in the  MOBILE  menu.    Click on  Add .   In the  Type  box, select  SQL Database .  Click on the unconfigured  SQL Database  link:     Enter a name for the database (like  chapter1-db ).  Select a Pricing Tier (look for  F Free  at the bottom).  Click on the unconfigured  Server .     Enter a unique name for the server (a GUID is a good idea here).  Enter a username and password for the server.  Make sure the Location for your database server is the same as your\nMobile App.  Click on  Select  to close the  New Server  blade.  Click on  Select  to close the  New Database  blade.  An error may appear asking you to set the Database Connection string,\nif so, click on the Database Connection and then click  OK  on it's blade.  Click on  OK  to close the  Add Data Connection  blade.     This produces another deployment step that creates a SQL Server and a SQL\ndatabase with your settings.  Once complete, the connection MS_TableConnectionString  will be listed in Data Connections blade.    Tip  If you want a completely free mobile backend, search for the  Mobile\nApps Quickstart  in the Azure Marketplace.  This template does not\nrequire a database.  It relies on a Node backend, however, so you won't\nbe developing a C# backend.",
            "title": "Building an Azure App Service for Mobile Apps"
        },
        {
            "location": "/chapter1/firstapp_mac/#deploying-the-azure-mobile-apps-backend",
            "text": "Publishing a Mobile App backend is very integrated into Visual Studio.  Since\nwe're developing with Xamarin Studio, we'll need to do things a bit differently.\nThere are a number of potential deployment options including FTP, connecting\nto a Continuous Integration server, connecting a Dropbox folder, or creating a local git repository.  To\nkeep things simple, we'll use an adminstration site named Kudu (also called\nSCM) to copy the files over.  Once we're ready, we'll need to collect the compiled\napplication files since Xamarin doesn't have any publish functionality.   Return to the browser and the Azure Portal.  Go to the Settings blade for your Mobile App.  Click on  Advanced Tools  in the  DEVELOPMENT TOOLS  menu.   Click on  Go  in the  Advanced Tools  blade.     The page that loads should match https://{YourMobileApp}.scm.azurewebsites.net/.   Select the  Debug Console  menu from the top and choose  CMD .  Within the file structure listing, click on  site .  Click on  wwwroot .  You should see a  hostingstart.html  file here.  Click the circle with a minus\nsymbol in it to the left of that file and confirm the dialog to delete this file.  On your computer, navigate to the folder that contains your Mobile App Backend.   Select the following folder and files:   bin  packages.config  Web.config     Drag and drop those files into the browser window above the Console.    A progress indicator should appear near the top right.  Upon completion you\nshould see the files appear in the file list:     In the browser navigate to the URL for your Mobile App.  This should match the\nformat https://{YourMobileApp}.azurewebsites.net/.  Add  /tables/todoitem?ZUMO-API-VERSION=2.0.0 \nto the end of the URL.  This will show the JSON contents of the table that we\ndefined in the backend.   Info  You will see the word ZUMO all over the SDK, including in optional HTTP headers\nand throughout the SDK source code.  ZUMO was the original code name within Microsoft\nfor A ZU re  MO bile.",
            "title": "Deploying the Azure Mobile Apps Backend"
        },
        {
            "location": "/chapter1/firstapp_mac/#the-mobile-client",
            "text": "Now that the mobile backend is created and deployed, we can move onto the client\nside of things.  As we're using Xamarin Studio, we should already have everything\nwe need installed to proceed with creating a Xamarin.Forms application for\nboth Android and iOS.   Info  When you compile a Xamarin.Forms application for a specific platform, you are\nproducing a true native application for that platform - whether it be iOS,\nAndroid or Windows.",
            "title": "The Mobile Client"
        },
        {
            "location": "/chapter1/firstapp_mac/#creating-a-simple-mobile-client-with-xamarin",
            "text": "Right-click on the  Chapter1  solution and select  Add  ->  Add New Project .\nThis will bring up the familiar New Project dialog.  The project you want is\nunder  Multiplatform  ->  App , and is called  Forms App .  Select that\nand click  Next .  Give the project a name such as  TaskList , ensure Android and iOS are both\nselected, select  Use Portable Class Library  and click Next.   On the next screen, leave all of the default values and click Create.  Once the setup is complete, you will see that three new projects have been\ncreated: a common library which you named plus one project for each platform\nthat has been chosen.  Since we chose both Android and iOS, we get\nthree projects:   Most of our work will happen in the common library.  However, we can introduce\nplatform-specific code at any point.  The platform-specific code is stored in\nthe platform-specific project.  There is one final item we must do before we leave the set up of the project.\nThere are a number of platform upgrades that inevitably have to happen.  The\nXamarin Platform is updated much more often than the project templates in Xamarin\nStudio - the updates are released via NuGet: the standard method of distributing\nlibraries for .NET applications.  In addition to the inevitable Xamarin Platform\nupdates, we also will want to add the following NuGet packages:   Microsoft.Azure.Mobile.Client v2.0.0 or later  Newtonsoft.Json v6.0.3 or later    Warn  Although it is tempting, do not include a v1.x version of the Mobile Client.\nThis is for the earlier Azure Mobile Services.  There are many differences between\nthe wire protocols of the two products.   You can start by updating the existing NuGet packages by right-clicking on the\nPackages folder in each project and selecting  Update .  Next we can install the NuGet packages by right-clicking on the Packages folder in each\nproject and selecting  Add Packages... .   You must install the updates and the new NuGet packages on all three projects.\nThis involves repeating the same process for each client project in your\nsolution.   Info  Android generally has more updates than the other platforms.  Ensure that you\nupdate the main Xamarin.Forms package and then refresh the update list.  This will\nensure the right list of packages is updated.",
            "title": "Creating a Simple Mobile Client with Xamarin"
        },
        {
            "location": "/chapter1/firstapp_mac/#building-the-common-library",
            "text": "There are two parts that we must concentrate on within the common library.  The\nfirst is the connection to Azure Mobile Apps and the second is in the pages\nthat the user interacts with.  In both cases, there are best practices to observe.\nStart by adding the following folders to your Portable Class Library project:   Abstractions  Models  Pages  Services  ViewModels",
            "title": "Building the Common Library"
        },
        {
            "location": "/chapter1/firstapp_mac/#building-an-azure-mobile-apps-connection",
            "text": "We will rely on interfaces for defining the shape for the class for any service\nthat we interact with.  This is really not important in small projects like this\none.  This technique allows us to mock the backend service, as we shall see\nlater on.  Mocking the backend service is a great technique to rapidly iterate\non the front end mobile client without getting tied into what the backend is doing.  Let's start with the cloud service - this will be defined in a new interface Abstractions\\ICloudService.cs .  It is basically used for initializing\nthe connection and getting a table definition:  namespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n    }\n}  There is a dependent implementation here: the  ICloudTable  generic interface.  This\nrepresents a CRUD interface into our tables and will be defined in  Abstractions\\ICloudTable.cs :  using System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudTable<T> where T : TableData\n    {\n        Task<T> CreateItemAsync(T item);\n        Task<T> ReadItemAsync(string id);\n        Task<T> UpdateItemAsync(T item);\n        Task DeleteItemAsync(T item);\n\n        Task<ICollection<T>> ReadAllItemsAsync();\n    }\n}  The  ICloudTable<T>  interface defines the normal CRUD operations: Create, Read,\nUpdate, and Delete.  However, it does so asynchronously.  We are dealing with network\noperations in general so it is easy for those operations to tie up the UI thread\nfor an appreciable amount of time.  Making them async provides the ability to\nrespond to other events.  I also provide a  ReadAllItemsAsync()  method that\nreturns a collection of all the items.  There are some fields that every single record within an Azure Mobile Apps table\nprovides.  These fields are required for offline sync capabilities like incremental\nsync and conflict resolution.  The fields are provided by a new abstract base class\non the client called  Abstractions\\TableData :  using System;\n\nnamespace TaskList.Abstractions\n{\n    public abstract class TableData\n    {\n        public string Id { get; set; }\n        public DateTimeOffset? UpdatedAt { get; set; }\n        public DateTimeOffset? CreatedAt { get; set; }\n        public byte[] Version { get; set; }\n    }\n}  As we will learn when we deal with  table data , these fields need to\nbe defined with the same name and semantics as on the server.  Our model on\nthe server was sub-classed from  EntityData  and the  EntityData  class on the\nserver defines these fields.  It's tempting to call the client version of the class the same as the server\nversion.  If we did that, the models on both the client and server would look\nthe same.  However, I find that this confuses the issue.  The models on the\nclient and server are not the same.  They are missing the  Deleted  flag and\nthey do not contain any relationship information on the client.  I choose to\ndeliberately call the base class something else on the client to avoid this\nconfusion.  We will be adding to these interfaces in future chapters as we add more\ncapabilities to the application.  The concrete implementations of these classes are similarly easily defined.  The\nAzure Mobile Apps Client SDK does most of the work for us.  Here is the concrete\nimplementation of the  ICloudService  (in  Services\\AzureCloudService.cs ):  using Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(\"https://my-backend.azurewebsites.net\");\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData\n        {\n            return new AzureCloudTable<T>(client);\n        }\n    }\n}  The Azure Mobile Apps Client SDK takes a lot of the pain out of communicating\nwith the mobile backend that we have already published.  Just swap  my-backend  out for the\nname of your mobile backend and the rest is silently dealt with.   Warn  The name  Microsoft.WindowsAzure.MobileServices  is a hold-over from the old Azure\nMobile Services code-base.  Don't be fooled - clients for Azure Mobile Services are\nnot interchangeable with clients for Azure Mobile Apps.   We also need a concrete implementation of the  ICloudTable<T>  interface\n(in  Services\\AzureCloudTable.cs ):  using System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudTable<T> : ICloudTable<T> where T : TableData\n    {\n        MobileServiceClient client;\n        IMobileServiceTable<T> table;\n\n        public AzureCloudTable(MobileServiceClient client)\n        {\n            this.client = client;\n            this.table = client.GetTable<T>();\n        }\n\n        #region ICloudTable implementation\n        public async Task<T> CreateItemAsync(T item)\n        {\n            await table.InsertAsync(item);\n            return item;\n        }\n\n        public async Task DeleteItemAsync(T item)\n        {\n            await table.DeleteAsync(item);\n        }\n\n        public async Task<ICollection<T>> ReadAllItemsAsync()\n        {\n            return await table.ToListAsync();\n        }\n\n        public async Task<T> ReadItemAsync(string id)\n        {\n            return await table.LookupAsync(id);\n        }\n\n        public async Task<T> UpdateItemAsync(T item)\n        {\n          await table.UpdateAsync(item);\n          return item;\n        }\n        #endregion\n    }\n}  It's important to note here that the Azure Mobile Apps Client SDK does a lot of\nthe work for us.  In fact, we are just wrapping the basic interface here.  This\nwon't normally be the case, but you can see that the majority of the code for\ndealing with the remote server is done for us.   Tip  You can use a shorthand (called a lambda expression) for methods with only one line.\nFor instance, the delete method could just as easily have been written as:  public async Task DeleteItemAsync(T item) => await table.DeleteAsync(item);  You may see this sort of short hand in samples.   We also need to create the model that we will use for the data.  This should\nlook very similar to the model on the server - including having the same name\nand fields.  In this case, it's  Models\\TodoItem.cs :  using TaskList.Abstractions;\n\nnamespace TaskList.Models\n{\n    public class TodoItem : TableData\n    {\n        public string Text { get; set; }\n        public bool Complete { get; set; }\n    }\n}  We have a final piece of code to write before we move on to the views, but it's\nan important piece.  The  ICloudService  must be a singleton in the client.  We\nwill add authentication and offline sync capabilities in future versions of this\ncode.  The singleton becomes critical when using those features.  For right now,\nit's good practice and saves on memory if you only have one copy of the  ICloudService \nin your mobile client.  Since there is only one copy of the  App.cs  in any\ngiven app, I can place it there.  Ideally, I'd use some sort of dependency\ninjection system or a singleton manager to deal with this.  Here is the  App.cs :  using TaskList.Abstractions;\nusing TaskList.Services;\nusing Xamarin.Forms;\n\nnamespace TaskList\n{\n    public class App : Application\n    {\n        public static ICloudService CloudService { get; set; }\n\n        public App()\n        {\n            CloudService = new AzureCloudService();\n            MainPage = new NavigationPage(new Pages.EntryPage());\n        }\n\n        // There are life cycle methods here...\n    }\n}  We haven't written  Pages.EntryPage  yet, but that's coming.  The original  App.cs \nclass file had several methods for handling life cycle events like starting, suspending,\nor resuming the app.  I did not touch those methods for this example.",
            "title": "Building an Azure Mobile Apps Connection"
        },
        {
            "location": "/chapter1/firstapp_mac/#building-the-ui-for-the-app",
            "text": "Earlier, I showed the mockup for my UI.  It included three pages - an entry\npage, a list page, and a detail page.  These pages have three elements - a\nXAML definition file, a (simple) code-behind file, and a view model.   Info  This book is not intending to introduce you to everything that there is to know\nabout Xamarin and UI programming with XAML.  If you wish to have that sort of introduction,\nthen I recommend reading the excellent book by Charles Petzold: Creating Mobile Apps with Xamarin.Forms .   I tend to use MVVM (or Model-View-ViewModel) for UI development in Xamarin\nbased applications.  It's a nice clean pattern and is well understood and\ndocumented.  In MVVM, there is a 1:1 correlation between the view and the\nview-model, 2-way communication between the view and the view-model and\nproperties within the view-model are bound directly to UI elements.  In\ngeneral (and in all my code), view-models expose an INotifyPropertyChanged\nevent to tell the UI that something within the view-model has been changed.  To do this, we will use a  BaseViewModel  class that implements the base functionality\nfor each view.  Aside from the  INotifyPropertyChanged  interface, there are\nsome common properties we need for each page.  Each page needs a title, for\nexample, and each page needs an indicator of network activity.  These can be\nplaced in the  Abstractions\\BaseViewModel.cs  class:  using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\n\nnamespace TaskList.Abstractions\n{\n    public class BaseViewModel : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n        string _propTitle = string.Empty;\n        bool _propIsBusy;\n\n        public string Title\n        {\n            get { return _propTitle; }\n            set { SetProperty(ref _propTitle, value, \"Title\"); }\n        }\n\n        public bool IsBusy\n        {\n            get { return _propIsBusy; }\n            set { SetProperty(ref _propIsBusy, value, \"IsBusy\"); }\n        }\n\n        protected void SetProperty<T>(ref T store, T value, string propName, Action onChanged = null)\n        {\n            if (EqualityComparer<T>.Default.Equals(store, value))\n                return;\n            store = value;\n            if (onChanged != null)\n                onChanged();\n            OnPropertyChanged(propName);\n        }\n\n        public void OnPropertyChanged(string propName)\n        {\n            if (PropertyChanged == null)\n                return;\n            PropertyChanged(this, new PropertyChangedEventArgs(propName));\n        }\n    }\n}  This is a fairly common  INotifyPropertyChanged  interface implementation pattern.\nEach property that we want to expose is a standard property, but the  set  operation\nis replaced by the  SetProperty()  call.  The  SetProperty()  call deals with the\nnotification; calling the event emitter if the property has changed value.  We\nonly need two properties on the  BaseViewModel : the title and the network indicator.  I tend to write my apps in two stages.  I concentrate on the functionality of the\napp in the first stage.  There is no fancy graphics, custom UI widgets, or anything\nelse to clutter the thinking.   The page is all about the functionality of the\nvarious interactions.  Once I have the functionality working, I work on the styling\nof the page.  We won't be doing any styling work in the demonstration apps that we\nwrite during the course of this book.  The EntryPage has just one thing to do.  It provides a button that enters the app.\nWhen we cover authentication later on, we'll use this to log in to the backend.  If\nyou are looking at the perfect app, this is a great place to put the introductory\nscreen.  Creating a XAML file is relatively simple.  We already created a  Pages  directory to\nhold the pages of our application.  Right-click on the  Pages  directory in\nthe solution explorer and choose  Add  ->  New File... .  In the  Add New File \ndialog, pick  Forms  ->  Forms ContentPage Xaml .  Name the\nnew page  EntryPage .  This will create two files -  EntryPage.xaml  and EntryPage.xaml.cs .  Let's center a button on the page and wire it up with\na command.  Here is the  Pages\\EntryPage.xaml  file:  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.EntryPage\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <StackLayout HorizontalOptions=\"Center\"\n                     Orientation=\"Vertical\"\n                     VerticalOptions=\"Center\">\n            <Button BackgroundColor=\"Teal\"\n                    BorderRadius=\"10\"\n                    Command=\"{Binding LoginCommand}\"\n                    Text=\"Login\"\n                    TextColor=\"White\" />\n        </StackLayout>\n    </ContentPage.Content>\n</ContentPage>  There are a couple of interesting things to note here.  The  StackLayout  element\nis our layout element.  It occupies the entire screen (since it is a direct child\nof the content page) and the options just center whatever the contents are.  The\nonly contents are a button.  There are two bindings.  These are bound from the view-model.  We've already seen\nthe Title property - this is a text field that specifies the title of the page.\nThe other binding is a login command.  When the button is tapped, the login command\nwill be run.  We'll get onto that in the view-model later.  The other file created is the code-behind file.  Because we are moving all\nof the non-UI code into a view-model, the code-behind file is trivial:  using TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class EntryPage : ContentPage\n    {\n        public EntryPage()\n        {\n            InitializeComponent();\n            BindingContext = new EntryPageViewModel();\n        }\n    }\n}  This is a recipe that will be repeated over and over again for the code-behind\nwhen you are using a XAML-based project with MVVM.  We initialize the UI, then\nbind all the bindings to a new instance of the view model.  Speaking of which, the view-model just needs to handle the login click.  Note that\nthe location or namespace is  TaskList.ViewModels .  I'm of two minds about location.\nThere tends to be a 1:1 relationship between the XAML file and the View Model, so\nit makes sense that they are stored together.  However, just about all the sample\ncode that I see has the view-models in a separate namespace.  Which one is correct?\nI'll go with copying the samples for now.  Here is the code for  ViewModels\\EntryPageViewModel.cs :  using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class EntryPageViewModel : BaseViewModel\n    {\n        public EntryPageViewModel()\n        {\n            Title = \"Task List\";\n        }\n\n        Command loginCmd;\n        public Command LoginCommand => loginCmd ?? (loginCmd = new Command(async () => await ExecuteLoginCommand()));\n\n        async Task ExecuteLoginCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[Login] Error = {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}  This is a fairly simple view-model but there are some patterns here that are\nworth explaining.  Firstly, note the way we create the  LoginCommand  property.\nThis is the property that is bound to the  Command  parameter in the  Button \nof our view.  This recipe is the method of invoking a UI action asynchronously.\nIt isn't important now, but we will want this technique repeatedly as our UI\nactions kick off network activity.  The second is the pattern for the  ExecuteLoginCommand  method.  Firstly, I\nensure nothing else is happening by checking the IsBusy flag.   If nothing\nis happening, I set the IsBusy flag.  Then I do what I need to do in a try/catch\nblock.  If an exception is thrown, I deal with it.  Most of the time this\ninvolves displaying an error condition.  There are several cross-platform dialog\npackages to choose from or you can roll your own.  That is not covered here.  We\njust write a debug log statement so we can see the result in the debug log.  Once\neverything is done, we clear the IsBusy flag.  The only thing we are doing now is swapping out our main page for a new main\npage.  This is where we will attach authentication later on.  The next page is the Task List page, which is in  Pages\\TaskList.xaml :  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.TaskList\"\n             Title=\"{Binding Title}\">\n  <ContentPage.Content>\n    <StackLayout>\n      <ListView BackgroundColor=\"#7F7F7F\"\n                CachingStrategy=\"RecycleElement\"\n                IsPullToRefreshEnabled=\"True\"\n                IsRefreshing=\"{Binding IsBusy, Mode=OneWay}\"\n                ItemsSource=\"{Binding Items}\"\n                RefreshCommand=\"{Binding RefreshCommand}\"\n                RowHeight=\"50\"\n                SelectedItem=\"{Binding SelectedItem, Mode=TwoWay}\">\n        <ListView.ItemTemplate>\n          <DataTemplate>\n            <ViewCell>\n              <StackLayout HorizontalOptions=\"FillAndExpand\"\n                           Orientation=\"Horizontal\"\n                           Padding=\"10\"\n                           VerticalOptions=\"CenterAndExpand\">\n                <Label HorizontalOptions=\"FillAndExpand\"\n                       Text=\"{Binding Text}\"\n                       TextColor=\"#272832\" />\n                <Switch IsToggled=\"{Binding Complete, Mode=OneWay}\" />\n              </StackLayout>\n            </ViewCell>\n          </DataTemplate>\n        </ListView.ItemTemplate>\n      </ListView>\n      <StackLayout HorizontalOptions=\"Center\"\n                   Orientation=\"Horizontal\">\n        <Button BackgroundColor=\"Teal\"\n                Command=\"{Binding AddNewItemCommand}\"\n                Text=\"Add New Item\"\n                TextColor=\"White\" />\n      </StackLayout>\n    </StackLayout>\n  </ContentPage.Content>\n</ContentPage>  Note that some bindings here are one-way.  This means that the value in the\nview-model drives the value in the UI.  There is nothing within the UI that you\ncan do to alter the state of the underlying property.  Some bindings are two-way.\nDoing something in the UI (for example, toggling the switch) alters the underlying\nproperty.  This view is a little more complex.  It can be split into two parts - the list\nat the top of the page and the button area at the bottom of the page.  The list\narea uses a template to help with the display of each item.  Note that the  ListView  object has a \"pull-to-refresh\" option that I have wired\nup so that when pulled, it calls the RefreshCommand.  It also has an indicator\nthat I have wired up to the IsBusy indicator.  Anyone who is familiar with the\niOS \"pull-to-refresh\" gesture can probably guess what this does.  The code behind for the TaskList can be found in  Pages\\TaskList.xaml.cs :  using TaskList.ViewModels;using Xamarin.Forms;\nnamespace TaskList.Pages\n{\n    public partial class TaskList : ContentPage\n    {\n        public TaskList()\n        {\n            InitializeComponent();\n            BindingContext = new TaskListViewModel();\n        }\n    }\n}  There is a view-model that goes along with the view (in  ViewModels\\TaskListViewModel.cs ):  using System;\nusing System.Collections.ObjectModel;\nusing System.Collections.Specialized;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskListViewModel : BaseViewModel\n    {\n        public TaskListViewModel()\n        {\n            Title = \"Task List\";\n            RefreshList();\n        }\n\n        ObservableCollection<TodoItem> items = new ObservableCollection<TodoItem>();\n        public ObservableCollection<TodoItem> Items\n        {\n            get { return items; }\n            set { SetProperty(ref items, value, \"Items\"); }\n        }\n\n        TodoItem selectedItem;\n        public TodoItem SelectedItem\n        {\n            get { return selectedItem; }\n            set\n            {\n                SetProperty(ref selectedItem, value, \"SelectedItem\");\n                if (selectedItem != null)\n                {\n                    Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail(selectedItem));\n                    SelectedItem = null;\n                }\n            }\n        }\n\n        Command refreshCmd;\n        public Command RefreshCommand => refreshCmd ?? (refreshCmd = new Command(async () => await ExecuteRefreshCommand()));\n\n        async Task ExecuteRefreshCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                var table = App.CloudService.GetTable<TodoItem>();\n                var list = await table.ReadAllItemsAsync();\n                Items.Clear();\n                foreach (var item in list)\n                    Items.Add(item);\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskList] Error loading items: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command addNewCmd;\n        public Command AddNewItemCommand => addNewCmd ?? (addNewCmd = new Command(async () => await ExecuteAddNewItemCommand()));\n\n        async Task ExecuteAddNewItemCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                await Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskList] Error in AddNewItem: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        async Task RefreshList()\n        {\n            await ExecuteRefreshCommand();\n            MessagingCenter.Subscribe<TaskDetailViewModel>(this, \"ItemsChanged\", async (sender) =>\n            {\n                await ExecuteRefreshCommand();\n            });\n        }\n    }\n}  This is a combination of the patterns we have seen earlier.  The Add New Item\nand Refresh commands should be fairly normal patterns now.  We navigate to the\ndetail page (more on that later) in the case of selecting an item (which occurs\nwhen the UI sets the  SelectedItem  property through a two-way binding) and when\nthe user clicks on the Add New Item button.  When the Refresh button is clicked\n(or when the user opens the view for the first time), the list is refreshed.  It\nis fairly common to use an  ObservableCollection  or another class that uses the ICollectionChanged  event handler for the list storage.  Doing so allows the UI\nto react to changes in the items.  Note the use of the  ICloudTable  interface here.  We are using the  ReadAllItemsAsync() \nmethod to get a list of items, then we copy the items we received into the  ObservableCollection .  Finally, there is the TaskDetail page.  This is defined in the  Pages\\TaskDetail.xaml \nfile:  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.TaskDetail\"\n             Title=\"{Binding Title}\">\n  <ContentPage.Content>\n    <StackLayout Padding=\"10\" Spacing=\"10\">\n      <Label Text=\"What should I be doing?\"/>\n      <Entry Text=\"{Binding Item.Text}\"/>\n      <Label Text=\"Completed?\"/>\n      <Switch IsToggled=\"{Binding Item.Complete}\"/>\n      <StackLayout VerticalOptions=\"CenterAndExpand\"/>\n      <StackLayout Orientation=\"Vertical\" VerticalOptions=\"End\">\n        <StackLayout HorizontalOptions=\"Center\" Orientation=\"Horizontal\">\n          <Button BackgroundColor=\"#A6E55E\"\n                  Command=\"{Binding SaveCommand}\"\n                  Text=\"Save\" TextColor=\"White\"/>\n          <Button BackgroundColor=\"Red\"\n                  Command=\"{Binding DeleteCommand}\"\n                  Text=\"Delete\" TextColor=\"White\"/>\n        </StackLayout>\n      </StackLayout>\n    </StackLayout>\n  </ContentPage.Content>\n</ContentPage>  This page is a simple form with just two buttons that need to have commands\nwired up.  However, this page is used for both the \"Add New Item\" gesture\nand the \"Edit Item\" gesture.  As a result of this, we need to handle the\npassing of the item to be edited.  This is done in the  Pages\\TaskDetail.xaml.cs \ncode-behind file:  using TaskList.Models;\nusing TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class TaskDetail : ContentPage\n    {\n        public TaskDetail(TodoItem item = null)\n        {\n            InitializeComponent();\n            BindingContext = new TaskDetailViewModel(item);\n        }\n    }\n}  The item that is passed in from the  TaskList  page is used to create a\nspecific view-model for that item.  The view-model is similarly configured\nto use that item:  using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskDetailViewModel : BaseViewModel\n    {\n        ICloudTable<TodoItem> table = App.CloudService.GetTable<TodoItem>();\n\n        public TaskDetailViewModel(TodoItem item = null)\n        {\n            if (item != null)\n            {\n                Item = item;\n                Title = item.Text;\n            }\n            else\n            {\n                Item = new TodoItem { Text = \"New Item\", Complete = false };\n                Title = \"New Item\";\n            }\n        }\n\n        public TodoItem Item { get; set; }\n\n        Command cmdSave;\n        public Command SaveCommand => cmdSave ?? (cmdSave = new Command(async () => await ExecuteSaveCommand()));\n\n        async Task ExecuteSaveCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id == null)\n                {\n                    await table.CreateItemAsync(Item);\n                }\n                else\n                {\n                    await table.UpdateItemAsync(Item);\n                }\n                MessagingCenter.Send<TaskDetailViewModel>(this, \"ItemsChanged\");\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskDetail] Save error: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command cmdDelete;\n        public Command DeleteCommand => cmdDelete ?? (cmdDelete = new Command(async () => await ExecuteDeleteCommand()));\n\n        async Task ExecuteDeleteCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id != null)\n                {\n                    await table.DeleteItemAsync(Item);\n                }\n                MessagingCenter.Send<TaskDetailViewModel>(this, \"ItemsChanged\");\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskDetail] Save error: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}  The save command uses the  ICloudTable  interface again - this time doing\neither  CreateItemAsync()  or  UpdateItemAsync()  to create or update the\nitem.  The delete command, as you would expect, deletes the item with the DeleteItemAsync()  method.  The final thing to note from our views is that I am using the  MessagingCenter \nto communicate between the TaskDetail and TaskList views.  If I change the item\nin the  TaskDetail  list, then I want to update the list in the  TaskList  view.  Note that all the code we have added to the solution thus far is in the common TaskList  project.  Nothing is required for this simple example in a platform\nspecific project.  That isn't normal, as we shall see.",
            "title": "Building the UI for the App"
        },
        {
            "location": "/chapter1/firstapp_mac/#building-the-client-for-android",
            "text": "Now we're ready to build our client applications.  We'll start with the Android version.  Prior\nto running the application, we need to make two additional changes.  Go to your Android\nproject and open the  MainActivity.cs  file.  In the  OnCreate  method we need to add\nan initalizer for our Mobile Apps SDK:  protected override void OnCreate(Bundle bundle)\n{\n    TabLayoutResource = Resource.Layout.Tabbar;\n    ToolbarResource = Resource.Layout.Toolbar;\n    base.OnCreate(bundle);\n\n    Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n    global::Xamarin.Forms.Forms.Init(this, bundle);\n    LoadApplication(new App());\n}  Finally, as Android has an explicit permission model (this has somewhat changed in the latest\nversion of Android), we need to say the application requires the Internet permission.  Right-click\non the Android project and go to  Options .  Select  Android Application  from under the Build  section.  At the bottom of the options panel, you'll see a list of permissions.\nFind Internet and check it and then click the OK button.   Next we need to configure the solution to run the Android project.   Right-click on the  TaskList.Droid  project, then select  Set as StartUp Project .  Right-click on the  TaskList.Droid  project again, then select  Build TaskList.Droid .   The drop-down between the run button in the top left of Xamarin Studio and the Build status\nat the top of Xamarin Studio, now allows you to choose an emualtor or device to run your app\nagainst.  By default, Xamarin Studio will create several emulators for you.  You can also use\nthe  Manage Google Emulators...  option to create additional Android Virtual Devices (AVDs)\nand download other images online.   Tip  When testing the mobile client manually through the Android Emulator,\nyou are likely to need to rebuild the application.  You do not have to\nshut down the emulator between runs.  You can leave it running.  The application\nwill be stopped and replaced before starting again.  This can significantly speed\nup the debug cycle since you are not waiting for the emulator to start each time.   Watch the Output window.  If the debugger won't connect or the application\nwon't start, you may need to restart your computer or the emulator to get the network\nworking.  If everything is working, you should see the Android Emulator\ndisplay your mobile client:    Warn  You can also build the Android version on Windows with Visual Studio.  However, I find\nthat version mismatches between Mono (which is used on the mac) and Visual Studio - particularly\nin reference to the version of the .NET framework - cause issues when swapping between the\ntwo environments.  For best results, stay in one environment.   Note that the task list view is a \"dark\" style and the rest of the app is a\n\"light\" style.  This is because the default styling on an Android device is\nlight.  We are using the default styling on two of the pages and specifying\ncolors on the list page.  Fortunately, Xamarin Forms allows for  platform-specific\nstyling .  The  final sample  has platform-specific styling for the\nlist page.",
            "title": "Building the Client for Android"
        },
        {
            "location": "/chapter1/firstapp_mac/#building-the-client-for-ios",
            "text": "With Android done, we can now turn to the iOS platform.  Like we did for Android, we must\nfirst initalize our Mobile Apps SDK for our platform.  Open the  AppDelegate.cs  file in\nyour iOS project.  In the FinishedLaunching method, we will initalize our SDK:  public override bool FinishedLaunching(UIApplication app, NSDictionary options)\n{\n    global::Xamarin.Forms.Forms.Init();\n\n    Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n    LoadApplication(new App());\n    return base.FinishedLaunching(app, options);\n}  Now we can build and run our app:   Right-click on the  TaskList.iOS  project and select  Set as StartUp Project .  Right-click on the  TaskList.iOS  project and select  Build TaskList.iOS .   If you have never used Xamarin Studio to build and run an iOS app before, it is possible\nthat you will receive an error having to do with code signing keys, provisioning profiles,\nor signing identities.  If so it may be  because you have not yet signed up for an Apple\nDeveloper Account and linked it to your Mac development environment.   Go to the  Apple Developer Center .  Click on  Account  in the top navigation bar.  If you haven't got an Apple ID yet, create one first.  If you have go an Apple ID, then log in.   There are a sequence of sign-up prompts in both cases (first for creating your\nApple ID and secondly for signing up for the Apple Developer program).  Once\nyou have gone through this process, you are registered as an Apple Developer.   Info  If you want to distribute your apps on the Apple App Store, run on real devices or\nget access to the beta bits, then you might consider signing up for the Apple Developer\nProgram.  The Apple Developer Program is an additional cost and is not required for\ndeveloping iOS apps that are only run on the iOS simulator.   Once you have created your account and enabled it as a developer account, open\nup Xcode.  Go to  Preferences... , then  Account  and\nclick on the  +  in the bottom-left corner of the window and pick  Add Apple ID... :   Sign in with the same account you used to sign up for the developer account.   Click on the  View Details  button.  This will bring up the Signing Identities\nlist.  For a free account, it looks like this:   Click on the Create button next to  iOS Development .  Once the UI comes back,\nclick on  Done .  For more information on this process, refer to the  Apple Documentation .  You can close Xcode at this point.  Return to Xamarin Studio, right-click on the TaskList.iOS  project and build again.  This will (finally!) build the application for you.   Tip  Getting an error about  Provisioning Profiles  not being available?  This is because\nyou are building for a real device instead of the simulator.  In order to build for a\nreal device, you must have a linked Apple Developer Program.  To get around this, select\na Simulator before building.   You can now select from several simulator options from the drop-down to the left of the\nbuild status.\nYou should only use  Device  if you have signed up for the Apple Developer Program.  Pick\none of the simulator options like the  iPhone 6 iOS 10.0  simulator, then click on it\nto run the simulator.  The final product screens look like this:",
            "title": "Building the Client for iOS"
        },
        {
            "location": "/chapter1/firstapp_mac/#some-final-thoughts",
            "text": "If you have got through the entire process outlined in this Chapter and built the application\nfor each platform, then congratulations.  There are a lot of places where things can go\nwrong.  You are really integrating the build systems across Android, iOS, Xamarin, Xcode,\nand Azure.  Fortunately, once these are set up, it's likely that they will continue working and you\nwon't have to think too much about them again. The Android and iOS build tools and simulators\nwill just work.  The following 7 chapters each take one aspect of the cloud services that can be provided to\nmobile apps and explores it in detail, using an Azure Mobile App as a beginning. You can\njump around at this point, but be aware that we expect you to cover these topics in order.\nIf you do the data chapter before covering authentication, it's likely you will have missed\nimportant functionality in your app to complete the work.",
            "title": "Some Final Thoughts"
        },
        {
            "location": "/chapter2/authconcepts/",
            "text": "Authentication Concepts\n\u00b6\n\n\nOne of the very first things you want to do when developing a mobile app is to provide users with a unique\nexperience.  For our example task list application, this could be as simple as providing a task list for the\nuser who is logged in.  In more complex applications, this is the gateway to role-based access controls, group\nrules, and sharing with your friends.  In all these cases, properly identifying the user using the phone is the\nstarting point.\n\n\nAuthentication provides a process by which the user that is using the mobile device can be identified securely.\nThis is generally done by entering a username and password.  However, modern systems can also provide\n\nmulti-factor authentication\n, send you a text message to a registered device, or \nuse your fingerprint\n\nas the password.\n\n\nThe OAuth Process\n\u00b6\n\n\nIn just about every single mobile application, a process called \nOAuth\n is used to properly identify a user\nto the mobile backend.  OAuth is not an authentication mechanism in its own right.  It is used to route the\nauthentication request to the right place and to verify that the authentication took place. There are three\nactors in the OAuth protocol:\n\n\n\n\nThe \nClient\n is the application attempting to get access to the resource.\n\n\nThe \nResource\n is the mobile backend that the client is attempting to access.\n\n\nThe \nIdentity Provider\n (or IdP) is the service that is responsible for authenticating the client.\n\n\n\n\nAt the end of the process, a cryptographically signed token is minted.  This token is added to every request\nmade by the client to the resource to securely identify the user.\n\n\nServer Side vs. Client Side\n\u00b6\n\n\nThere are two types of authentication flow: Server-flow and Client-flow.  They are so named because of who\ncontrols the flow of the actual authentication.\n\n\n\n\nServer-flow is named because the authentication flow is managed by the Azure App Service (the server) through a\nwebview-based work flow.  It is generally used in two cases:\n\n\n\n\nYou want a simple placeholder for authentication in your mobile app while you are developing other code.\n\n\nYou are developing a traditional web app.\n\n\n\n\n\n\nTip\n\n\nIf you are developing a single-page application (SPA), then client-flow is the more appropriate model for\nauthentication.  The SPA looks more like a mobile client than a traditional web app.  In particular, you will\nbe redirected away from your single page and returned to the app at a specific entry point, removing any\ncontext from the app.\n\n\n\n\nIn the case of server-flow:\n\n\n\n\nThe client brings up a web view and asks for the login page from the resource.\n\n\nThe resource redirects the client to the identity provider.\n\n\nThe identity provider does the authentication before redirecting the client\n   back to the resource (with an identity provider token).\n\n\nThe resource validates the identity provider token with the identity provider.\n\n\nFinally, the resource mints a new resource token that it returns to the client.\n\n\n\n\nClient-flow authentication uses an IdP provided SDK to integrate a more native feel to the authentication\nflow.  The actual flow happens on the client, communicating only with the identity provider.  It is used\nis most cases:\n\n\n\n\nYou want a more integrated experience for your users.\n\n\nYou want the most native feel to your authentication flow.\n\n\nYou are developing a single-page web application.\n\n\n\n\nA client-flow feels similar to the server-flow, but using a native SDK instead of a web view.\n\n\n\n\nThe client uses the identity provider SDK to communicate with the identity provider.\n\n\nThe identity provider authenticates the user, returning an identity provider token.\n\n\nThe client presents the identity provider token to the resource.\n\n\nThe resource validates the identity provider token with the identity provider.\n\n\nFinally, the resource mints a new resource token that it returns to the client.\n\n\n\n\nFor example, if you use the Facebook SDK for authentication, your app will seamlessly switch over into the\nFacebook app and ask you to authorize your client application before switching you back to your client application.\n\n\nYou should use the identity provider SDK when developing an app that will be released on the app store.  The\nidentity providers will advise you to use their SDK and it provides the best experience for your end users.\n\n\n\n\nInfo\n\n\nThe Azure App Service Authentication / Authorization service works with any App Service, including web apps\nand API apps.  It's not just for Mobile Apps.\n\n\n\n\nAuthentication Providers\n\u00b6\n\n\nAzure Mobile Apps supports five identity providers natively:\n\n\n\n\nAzure Active Directory\n\n\nFacebook\n\n\nGoogle\n\n\nMicrosoft (MSA)\n\n\nTwitter\n\n\n\n\n\n\nInfo\n\n\nAzure App Service Authentication / Authorization maintains a token store in the XDrive (which is the drive that is\nshared among all instances of the backend within the same App Service Plan).  The token store is located at\n\nD:\\\\home\\\\data\\\\.auth\\\\tokens\n on the backend.  The tokens are encrypted and stored in a per-user encrypted file.\n\n\n\n\nIn addition, you can set up client-flow custom authentication that allows you to mint a ZUMO token to your\nspecifications for any provider using a client-flow.  For example, you could use authentication providers\nlike \nAzure AD B2C\n, \nLinkedIn\n or \nGitHub\n, a third-party authentication provider like  \nAuth0\n,\nor you could set up an identity table in your database so that you can check  username and password without\nan identity provider.",
            "title": "Concepts"
        },
        {
            "location": "/chapter2/authconcepts/#authentication-concepts",
            "text": "One of the very first things you want to do when developing a mobile app is to provide users with a unique\nexperience.  For our example task list application, this could be as simple as providing a task list for the\nuser who is logged in.  In more complex applications, this is the gateway to role-based access controls, group\nrules, and sharing with your friends.  In all these cases, properly identifying the user using the phone is the\nstarting point.  Authentication provides a process by which the user that is using the mobile device can be identified securely.\nThis is generally done by entering a username and password.  However, modern systems can also provide multi-factor authentication , send you a text message to a registered device, or  use your fingerprint \nas the password.",
            "title": "Authentication Concepts"
        },
        {
            "location": "/chapter2/authconcepts/#the-oauth-process",
            "text": "In just about every single mobile application, a process called  OAuth  is used to properly identify a user\nto the mobile backend.  OAuth is not an authentication mechanism in its own right.  It is used to route the\nauthentication request to the right place and to verify that the authentication took place. There are three\nactors in the OAuth protocol:   The  Client  is the application attempting to get access to the resource.  The  Resource  is the mobile backend that the client is attempting to access.  The  Identity Provider  (or IdP) is the service that is responsible for authenticating the client.   At the end of the process, a cryptographically signed token is minted.  This token is added to every request\nmade by the client to the resource to securely identify the user.",
            "title": "The OAuth Process"
        },
        {
            "location": "/chapter2/authconcepts/#server-side-vs-client-side",
            "text": "There are two types of authentication flow: Server-flow and Client-flow.  They are so named because of who\ncontrols the flow of the actual authentication.   Server-flow is named because the authentication flow is managed by the Azure App Service (the server) through a\nwebview-based work flow.  It is generally used in two cases:   You want a simple placeholder for authentication in your mobile app while you are developing other code.  You are developing a traditional web app.    Tip  If you are developing a single-page application (SPA), then client-flow is the more appropriate model for\nauthentication.  The SPA looks more like a mobile client than a traditional web app.  In particular, you will\nbe redirected away from your single page and returned to the app at a specific entry point, removing any\ncontext from the app.   In the case of server-flow:   The client brings up a web view and asks for the login page from the resource.  The resource redirects the client to the identity provider.  The identity provider does the authentication before redirecting the client\n   back to the resource (with an identity provider token).  The resource validates the identity provider token with the identity provider.  Finally, the resource mints a new resource token that it returns to the client.   Client-flow authentication uses an IdP provided SDK to integrate a more native feel to the authentication\nflow.  The actual flow happens on the client, communicating only with the identity provider.  It is used\nis most cases:   You want a more integrated experience for your users.  You want the most native feel to your authentication flow.  You are developing a single-page web application.   A client-flow feels similar to the server-flow, but using a native SDK instead of a web view.   The client uses the identity provider SDK to communicate with the identity provider.  The identity provider authenticates the user, returning an identity provider token.  The client presents the identity provider token to the resource.  The resource validates the identity provider token with the identity provider.  Finally, the resource mints a new resource token that it returns to the client.   For example, if you use the Facebook SDK for authentication, your app will seamlessly switch over into the\nFacebook app and ask you to authorize your client application before switching you back to your client application.  You should use the identity provider SDK when developing an app that will be released on the app store.  The\nidentity providers will advise you to use their SDK and it provides the best experience for your end users.   Info  The Azure App Service Authentication / Authorization service works with any App Service, including web apps\nand API apps.  It's not just for Mobile Apps.",
            "title": "Server Side vs. Client Side"
        },
        {
            "location": "/chapter2/authconcepts/#authentication-providers",
            "text": "Azure Mobile Apps supports five identity providers natively:   Azure Active Directory  Facebook  Google  Microsoft (MSA)  Twitter    Info  Azure App Service Authentication / Authorization maintains a token store in the XDrive (which is the drive that is\nshared among all instances of the backend within the same App Service Plan).  The token store is located at D:\\\\home\\\\data\\\\.auth\\\\tokens  on the backend.  The tokens are encrypted and stored in a per-user encrypted file.   In addition, you can set up client-flow custom authentication that allows you to mint a ZUMO token to your\nspecifications for any provider using a client-flow.  For example, you could use authentication providers\nlike  Azure AD B2C ,  LinkedIn  or  GitHub , a third-party authentication provider like   Auth0 ,\nor you could set up an identity table in your database so that you can check  username and password without\nan identity provider.",
            "title": "Authentication Providers"
        },
        {
            "location": "/chapter2/backend/",
            "text": "Adding Authentication to a Mobile Backend\n\u00b6\n\n\nThe Azure App Service Authentication / Authorization service integrates seamlessly into an Azure Mobile Apps\nbackend as a piece of middleware that fills in the Identity information for ASP.NET.  That means the only\nthing we have to worry about is authorization.  The authentication piece (determining that a user is who they\nsay they are) is already taken care of.\n\n\nAuthorization (which is the determination of whether an authenticated user can use a specific API) can happen\nat either the controller level or an individual operation level.  We can add authorization to an entire table\ncontroller by adding the \n[Authorize]\n attribute to the table controller.  For example, here is our table\ncontroller from the first chapter with authorization required for all operations:\n\n\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    [Authorize]\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}\n\n\n\n\nAuthorization can also happen on a per-operation basis by adding the \n[Authorize]\n attribute to a single method\nwithin the table controller.  For example, instead of requiring authorization on the entire table, we want a\nversion where reading was possible anonymously but updating the database required authentication:\n\n\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        [Authorize]\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        [Authorize]\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        [Authorize]\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}\n\n\n\n\nNote that the \n[Authorize]\n attribute can do much more than what is provided here.  Underneath there are various\nparameters that you can adjust to see if the user belongs to a specific group or role.  However, the token that\nis checked to see if the user is authenticated does not pull in any of the other information that is normally\nneeded for such authorization tasks.  As a result, the \n[Authorize]\n tags is really only checking whether a\nrequest requires authentication or not.\n\n\nConfiguring an Authentication Provider\n\u00b6\n\n\nConfiguration of the identity provider is very dependent on the identity provider and whether the client is using\na client-flow or server-flow.  Choose one of the several options for authentication:\n\n\n\n\nEnterprise Authentication\n covers Azure Active Directory.\n\n\nSocial Authentication\n covers Facebook, Google, Microsoft and Twitter.\n\n\n\n\nWe can also configure authentication using custom routes.  This allows us to use other (non-supported) services\nor to completely customize our flow (for example, to use an existing identity database).  We will cover custom\nauthentication later on.",
            "title": "Authentication in the Backend"
        },
        {
            "location": "/chapter2/backend/#adding-authentication-to-a-mobile-backend",
            "text": "The Azure App Service Authentication / Authorization service integrates seamlessly into an Azure Mobile Apps\nbackend as a piece of middleware that fills in the Identity information for ASP.NET.  That means the only\nthing we have to worry about is authorization.  The authentication piece (determining that a user is who they\nsay they are) is already taken care of.  Authorization (which is the determination of whether an authenticated user can use a specific API) can happen\nat either the controller level or an individual operation level.  We can add authorization to an entire table\ncontroller by adding the  [Authorize]  attribute to the table controller.  For example, here is our table\ncontroller from the first chapter with authorization required for all operations:  using System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    [Authorize]\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}  Authorization can also happen on a per-operation basis by adding the  [Authorize]  attribute to a single method\nwithin the table controller.  For example, instead of requiring authorization on the entire table, we want a\nversion where reading was possible anonymously but updating the database required authentication:  using System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        [Authorize]\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        [Authorize]\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        [Authorize]\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}  Note that the  [Authorize]  attribute can do much more than what is provided here.  Underneath there are various\nparameters that you can adjust to see if the user belongs to a specific group or role.  However, the token that\nis checked to see if the user is authenticated does not pull in any of the other information that is normally\nneeded for such authorization tasks.  As a result, the  [Authorize]  tags is really only checking whether a\nrequest requires authentication or not.",
            "title": "Adding Authentication to a Mobile Backend"
        },
        {
            "location": "/chapter2/backend/#configuring-an-authentication-provider",
            "text": "Configuration of the identity provider is very dependent on the identity provider and whether the client is using\na client-flow or server-flow.  Choose one of the several options for authentication:   Enterprise Authentication  covers Azure Active Directory.  Social Authentication  covers Facebook, Google, Microsoft and Twitter.   We can also configure authentication using custom routes.  This allows us to use other (non-supported) services\nor to completely customize our flow (for example, to use an existing identity database).  We will cover custom\nauthentication later on.",
            "title": "Configuring an Authentication Provider"
        },
        {
            "location": "/chapter2/enterprise/",
            "text": "Enterprise Authentication\n\u00b6\n\n\nEnterprise Authentication is handled by Azure Active Directory, which is fairly commonly configured within Azure.\nEvery Azure subscription has a default directory associated with it that you can leverage for this section.  In\naddition, if your organization has an Office 365 subscription, this will likely be tied to an Azure Active Directory\ndomain to allow enterprise sign-in.  In either case, you have a directory you can use for providing authentication\nto your app.\n\n\nIn general, you will need to get special permissions to update the directory. If you want to use your organizations\ncorporate directory, then you are likely to have to get your IT department involved to set it up.\n\n\nAzure Active Directory: Server-Flow setup\n\u00b6\n\n\nThe Azure Active Directory server-flow is perhaps the easiest of all the authentication methods to configure.  No\nmatter if you are doing a client flow or server flow, you need to set up the server flow first.\n\n\n\n\nTip\n\n\nWe recommend that you implement Client Flow in any non-trivial application.\n\n\n\n\nIf you are using your default directory and you want to add a couple of test users, you will need to set those up\nfirst.   Start by going to the \nClassic Azure Portal\n:\n\n\n\n\nClick on the \nDefault Directory\n, then click on \nUSERS\n.  You will notice that your Azure-linked ID is already\npresent.\n\n\n\n\nClick on \nAdd User\n at the bottom of the screen.  Enter a username in the box provided before clicking on the\narrow.  Then fill in the personal information and click on the arrow again.  Finally, click on \ncreate\n.  Note\nthe password, before clicking on the tick.  Now you have two users - your Azure ID and the one you just created.\nNote the username.  It is based on the tenant, so it will be something like \nadrian@photoadrianoutlook.onmicrosoft.com\n.\n\n\nTo configure your app, switch back to the regular \nAzure Portal\n, find your App Service, click on\n\nAll Settings\n followed by \nAuthentication / Authorization\n. Finally, select \nAzure Active Directory\n.\n\n\n\n\nClick on \nExpress\n.  Note that all the information is filled in for you.  All you have to do is click on \nOK\n,\nfollowed by \nSave\n.\n\n\n\n\nInfo\n\n\nMake sure you create the app service in the right directory / subscription.  If you have access to more than one\ndirectory, you can choose the right one by selecting it under your account drop-down in the top-right corner.\n\n\n\n\nThere is also an \nAdvanced\n track.  This is used in client-flow situations and in situations where you have more\nthan one directory.  The Express flow is great for getting started quickly.\n\n\nYou can walk through a server-flow authentication to test that you have all the settings correct.  Point your browser\nat https://\nyoursite\n.azurewebsites.net/.auth/login/aad.  The browser will take you through an authentication flow\nbefore giving you a successful authentication image:\n\n\n\n\nAdding Authentication to a Mobile Client\n\u00b6\n\n\nNow that the backend is completely configured, we can move our attention to the mobile client.  We are going to be\nusing the same mobile client that we developed in the first chapter, but we are now going to add authentication to\nit.  Web views are one of those items that are platform dependent. Fortunately for us, Xamarin has already thought\nof this and provided a facility for running platform specific code called the \nDependencyService\n.\n\n\n\n\nInfo\n\n\nIf we run our application right now, clicking on the \"Enter the App\" button will result in an error.  We will be\nable to see the Unauthorized error in the debug window of Visual Studio.\n\n\n\n\nOur first step is to define an \nAbstractions\\ILoginProvider.cs\n interface within the  shared project:\n\n\nusing Microsoft.WindowsAzure.MobileServices;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ILoginProvider\n    {\n        Task LoginAsync(MobileServiceClient client);\n    }\n}\n\n\n\n\nNext, we are going to extend our \nAbstractions\\ICloudService.cs\n interface so that the main application can call\nthe login routine:\n\n\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n    }\n}\n\n\n\n\nOur code will call \nLoginAsync()\n in the \nICloudService\n, which will get the platform-specific version of the\nlogin provider and call \nLoginAsync()\n there, but with our defined mobile service client.  That is defined in the\n\nServices\\AzureCloudService.cs\n class:\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing Xamarin.Forms;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(Locations.AppServiceUrl);\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData => new AzureCloudTable<T>(client);\n\n        public Task LoginAsync()\n        {\n            var loginProvider = DependencyService.Get<ILoginProvider>();\n            return loginProvider.LoginAsync(client);\n        }\n    }\n}\n\n\n\n\nThe method looks up the platform dependent version of the login provider and executes the login method, passing\nalong the client (which we will need later).\n\n\nIn each platform-specific project, we are going to define a concrete implementation of the login provider that uses\na web view to hold the actual authentication flow.  Here is the droid \nServices\\DroidLoginProvider.cs\n (in the\nTaskList.Droid project):\n\n\nusing System.Threading.Tasks;\nusing Android.Content;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        Context context;\n\n        public void Init(Context context)\n        {\n            this.context = context;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(context, \"aad\");\n        }\n    }\n}\n\n\n\n\nLet us take a closer look at this implementation.  The \nLoginAsync()\n method on the Azure Mobile Apps client object\ntakes the Android context (which is normally the main window) and a provider - we can pick any of \"facebook\",\n\"google\", \"microsoftaccount\", \"twitter\" or \"aad\" depending on what we have defined in the Azure App Service.  The\nclever piece is the \nXamarin.Forms.Dependency\n call at the top - that registers the class as a platform service\nso we can access it through the Xamarin dependency service.\n\n\nNote that we need an extra initialization routine for Android that must be called prior the login provider being\ncalled to pass along the main window of the app (also known as the context).  This is done in the \nMainActivity.cs\n\nfile \nafter\n the Xamarin Forms initialization call.  The dependency service is not set up until after the Xamarin\nForms library is initialized, so we will not be able to get the login provider reference before that point:\n\n\nprotected override void OnCreate(Bundle bundle)\n{\n    base.OnCreate(bundle);\n\n    Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n    global::Xamarin.Forms.Forms.Init(this, bundle);\n\n    ((DroidLoginProvider)DependencyService.Get<ILoginProvider>()).Init(this);\n\n    LoadApplication(new App());\n}\n\n\n\n\niOS is similar, but does not require the initialization step in the main startup class.  The login provider class\nis in \nServices\\iOSLoginProvider.cs\n (in the \nTaskList.iOS\n project):\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.iOS.Services;\nusing UIKit;\n\n[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]\nnamespace TaskList.iOS.Services\n{\n    public class iOSLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(RootView, \"aad\");\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n    }\n}\n\n\n\n\nNote that we are using the same pattern here for registering the concrete implementation with the dependency service,\nso we can get it the same way. Finally, here is the UWP \nServices\\UWPLoginProvider.cs\n (in the TaskList.UWP project):\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.UWP.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(\"aad\");\n        }\n    }\n}\n\n\n\n\nNow that we have all the platform-specific login routines registered, we can move on to adding the login routine to\nthe UI.  We have already got a button on the entry page to enter the app.  It makes sense to wire up that button so\nthat it logs us in as well. The Command for the login button is in the \nViewModels\\EntryPageViewModel.cs\n:\n\n\nasync Task ExecuteLoginCommand()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var cloudService = ServiceLocator.Instance.Resolve<ICloudService>();\n        await cloudService.LoginAsync();\n        Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n    }\n    catch (Exception ex)\n    {\n        Debug.WriteLine($\"[ExecuteLoginCommand] Error = {ex.Message}\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}\n\n\n\n\n\n\nInfo\n\n\nThe \nServiceLocator\n class is a basic singleton handler.  It is available in the \nChapter2\n project.  It\nreturns the concrete version of the cloud service, just like the Singleton version we defined in Chapter1.\n\n\n\n\nWhen you run the application, clicking on the \"Enter the App\" button will now present you with an Authenticate window:\n\n\n\n\nGoing through the authentication process will get you to the task list again.  If the authentication process fails,\nthen \nLoginAsync()\n will throw an error, which is caught at the ViewModel.  Right now, the \nEntryPageViewModel\n\ndoes nothing more than print a diagnostic message to the debug window of Visual Studio.\n\n\nAzure Active Directory: Client-Flow Setup\n\u00b6\n\n\nConfiguring Azure Active Directory for client-flow is a three-step process.  First, we need to create a WEB\napplication.  This represents the resource: in our case, the resource is the Azure Mobile Apps backend.  Then\nwe need to create a NATIVE application.  This represents the client: in our case, the ADAL (Active Directory\nAccess Library) library will need this information.  Finally, we need to give the NATIVE application permission\nto access the WEB application.\n\n\nIt starts with configuring a server-flow to protect the resource.  We've already done that above. Then configure\na \"Native Application\" and give it permissions to the web application:\n\n\n\n\nLog on to the \nClassic Portal\n.\n\n\nSelect the \nDefault Directory\n from your list of all items.\n\n\nClick on the \nAPPLICATIONS\n tab.\n\n\n\n\n\n\n\n\nNote that our existing web application is already there.  You will see more applications, depending on what you\n  have set up.  In this example, I have Visual Studio Team Services and Office 365 set up.\n\n\nClick on the \nADD\n button at the bottom of the page.\n\n\n\n\n\n\n\n\nClick on \nAdd an application my organization is developing\n.\n\n\n\n\n\n\n\n\nEnter a name for the app registration, and select \nNATIVE CLIENT APPLICATION\n.\n\n\nClick on the Next arrow.\n\n\nEnter a valid URI - it can be anything, but it has to be valid\n\n\n\n\n\n\n\n\nClick on the tick to create the application.\n\n\nThe wizard will close, but you will be brought to the app configuration.  Click on the \nCONFIGURE\n tab.\n\n\n\n\n\n\n\n\nAdd a Redirect URI of the form: \nhttps://yoursite.azurewebsites.net/.auth/login/done\n.\n\n\n\n\n\n\n\n\nAt the bottom of the page is the \npermissions to other applications\n section.  Click on the \nAdd application\n button.\n\n\n\n\n\n\n\n\nClick on the \nSHOW\n drop-down and select \nAll Apps\n, then click on the tick next to the search box.\n\n\nClick on the web application that you set up during the server-flow configuration, then click on the  tick in\n  the lower-right corner.\n\n\n\n\n\n\n\n\nClick on \nDelegated Permissions\n next to the web application.  Check the box next to \nAccess\n, then click\n  on \nSave\n at the bottom of the screen.\n\n\n\n\n\n\nAt this point the application configuration will be saved.\n\n\nSo, what did we just do there?  We created a new Azure AD app for the native application.  We then gave permission\nfor the native application to access resources that are protected by the web application.  In our Azure App Service,\nwe configured the service so that the Azure AD web application is used to protect our resources.  The net effect is\n that our native application OR our web application can access the App Service resources that are protected via the\n \n[Authorize]\n attribute.\n\n\nBefore continuing, you will need the \nClient ID\n and the \nRedirect URI\n for the NATIVE application. You can enter\nthese into the \nHelpers\\Locations.cs\n file in the shared project:\n\n\nnamespace TaskList.Helpers\n{\n    public static class Locations\n    {\n        public static readonly string AppServiceUrl = \"https://the-book.azurewebsites.net\";\n\n        public static readonly string AadClientId = \"b61c7d68-2086-43a1-a8c9-d93c5732cc84\";\n\n        public static readonly string AadRedirectUri = \"https://the-book.azurewebsites.net/.auth/login/done\";\n\n        public static readonly string AadAuthority = \"https://login.windows.net/photoadrianoutlook.onmicrosoft.com\";\n    }\n}\n\n\n\n\nThe \nAadClientId\n and \nAadRedirectUri\n must match what we have configured in Azure AD for the native app.  The\nother piece of information we need to add is the Azure AD Authority for the directory.  If you click on the\n\nDOMAINS\n tab, it will generally tell you what domain you are in. The Authority is just a path on the\n\nhttps://login.windows.net\n that corresponds to your domain.  There is also a GUID version of this domain.  You\ncan find the GUID by looking at the \nView Endpoints\n in the \nAPPLICATIONS\n tab.  Look at the first path section\nof most all the endpoints.\n\n\nAdd the \nMicrosoft.IdentityModel.Clients.ActiveDirectory\n NuGet package using \nManage NuGet Packages...\n to\neach platform project.  This package contains the ADAL library as a portable class library.\n\n\n\n\nNow you can add the client flow to each project.  Start with the login provider in the \nTaskList.UWP\n project,\nlocated in the \nServices\\UWPLoginProvider.cs\n file:\n\n\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.UWP.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync()\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters(PromptBehavior.Auto, false));\n            return authResult.AccessToken;\n        }\n\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginADALAsync();\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server-Flow Version\n            // await client.LoginAsync(\"aad\");\n        }\n    }\n}\n\n\n\n\nThe \nLoginADALAsync()\n method does the actual client-flow - using the ADAL library to authenticate the user and\nreturn the access token.  The \nLoginAsync()\n method initiates the client-flow.  It uses the token it receives\nfrom the client-flow to log in to the App Service, by packaging the token into a JSON object.  I have placed\nthe client and server flow next to each other so you can compare the two.\n\n\nIn the \nTaskList.Droid\n project, we need to deal with the \nContext\n, as is common with Android libraries.  The\nclient flow in \nServices\\DroidLoginProvider.cs\n is remarkably similar though:\n\n\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Android.App;\nusing Android.Content;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\nusing TaskList.Helpers;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        Context context;\n\n        public void Init(Context context)\n        {\n            this.context = context;\n        }\n\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync()\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters((Activity)context));\n            return authResult.AccessToken;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginADALAsync();\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server-Flow Version\n            // await client.LoginAsync(context, \"aad\");\n        }\n    }\n}\n\n\n\n\nThe only real difference between this one and the Universal Windows edition is the PlatformParameters. We need to\npass in the context of the MainActivity (which is passed in through the \nInit()\n call).  However, we must also handle\nthe response from the ADAL library.  This is done in \nMainActivity.cs\n. Add the following method to the \nMainActivity\n\nclass:\n\n\nprotected override void OnActivityResult(int requestCode, Result resultCode, Intent data)\n{\n    base.OnActivityResult(requestCode, resultCode, data);\n    AuthenticationAgentContinuationHelper.SetAuthenticationAgentContinuationEventArgs(requestCode, resultCode, data);\n}\n\n\n\n\nFinally, the iOS version also requires access to the root view, so its \nPlatformParameters\n are also slightly\ndifferent.  Here is \nServices\\iOSLoginProvider.cs\n:\n\n\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.iOS.Services;\nusing UIKit;\n\n[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]\nnamespace TaskList.iOS.Services\n{\n    public class iOSLoginProvider : ILoginProvider\n    {\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync(UIViewController view)\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters(view));\n            return authResult.AccessToken;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            var rootView = UIApplication.SharedApplication.KeyWindow.RootViewController;\n\n            // Client Flow\n            var accessToken = await LoginADALAsync(rootView);\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server Flow\n            //await client.LoginAsync(rootView, \"aad\");\n        }\n    }\n}\n\n\n\n\nNote that we can balance the needs of each platform by using the dependency service.  The code that is unique to\nthe platform is minimized and stored with the platform.\n\n\nIf you aren't interested in social authentication (Facebook, Google, Microsoft or Twitter authentication providers),\nyou can \nskip the Social Authentication section\n.",
            "title": "Enterprise Authentication"
        },
        {
            "location": "/chapter2/enterprise/#enterprise-authentication",
            "text": "Enterprise Authentication is handled by Azure Active Directory, which is fairly commonly configured within Azure.\nEvery Azure subscription has a default directory associated with it that you can leverage for this section.  In\naddition, if your organization has an Office 365 subscription, this will likely be tied to an Azure Active Directory\ndomain to allow enterprise sign-in.  In either case, you have a directory you can use for providing authentication\nto your app.  In general, you will need to get special permissions to update the directory. If you want to use your organizations\ncorporate directory, then you are likely to have to get your IT department involved to set it up.",
            "title": "Enterprise Authentication"
        },
        {
            "location": "/chapter2/enterprise/#azure-active-directory-server-flow-setup",
            "text": "The Azure Active Directory server-flow is perhaps the easiest of all the authentication methods to configure.  No\nmatter if you are doing a client flow or server flow, you need to set up the server flow first.   Tip  We recommend that you implement Client Flow in any non-trivial application.   If you are using your default directory and you want to add a couple of test users, you will need to set those up\nfirst.   Start by going to the  Classic Azure Portal :   Click on the  Default Directory , then click on  USERS .  You will notice that your Azure-linked ID is already\npresent.   Click on  Add User  at the bottom of the screen.  Enter a username in the box provided before clicking on the\narrow.  Then fill in the personal information and click on the arrow again.  Finally, click on  create .  Note\nthe password, before clicking on the tick.  Now you have two users - your Azure ID and the one you just created.\nNote the username.  It is based on the tenant, so it will be something like  adrian@photoadrianoutlook.onmicrosoft.com .  To configure your app, switch back to the regular  Azure Portal , find your App Service, click on All Settings  followed by  Authentication / Authorization . Finally, select  Azure Active Directory .   Click on  Express .  Note that all the information is filled in for you.  All you have to do is click on  OK ,\nfollowed by  Save .   Info  Make sure you create the app service in the right directory / subscription.  If you have access to more than one\ndirectory, you can choose the right one by selecting it under your account drop-down in the top-right corner.   There is also an  Advanced  track.  This is used in client-flow situations and in situations where you have more\nthan one directory.  The Express flow is great for getting started quickly.  You can walk through a server-flow authentication to test that you have all the settings correct.  Point your browser\nat https:// yoursite .azurewebsites.net/.auth/login/aad.  The browser will take you through an authentication flow\nbefore giving you a successful authentication image:",
            "title": "Azure Active Directory: Server-Flow setup"
        },
        {
            "location": "/chapter2/enterprise/#adding-authentication-to-a-mobile-client",
            "text": "Now that the backend is completely configured, we can move our attention to the mobile client.  We are going to be\nusing the same mobile client that we developed in the first chapter, but we are now going to add authentication to\nit.  Web views are one of those items that are platform dependent. Fortunately for us, Xamarin has already thought\nof this and provided a facility for running platform specific code called the  DependencyService .   Info  If we run our application right now, clicking on the \"Enter the App\" button will result in an error.  We will be\nable to see the Unauthorized error in the debug window of Visual Studio.   Our first step is to define an  Abstractions\\ILoginProvider.cs  interface within the  shared project:  using Microsoft.WindowsAzure.MobileServices;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ILoginProvider\n    {\n        Task LoginAsync(MobileServiceClient client);\n    }\n}  Next, we are going to extend our  Abstractions\\ICloudService.cs  interface so that the main application can call\nthe login routine:  using System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n    }\n}  Our code will call  LoginAsync()  in the  ICloudService , which will get the platform-specific version of the\nlogin provider and call  LoginAsync()  there, but with our defined mobile service client.  That is defined in the Services\\AzureCloudService.cs  class:  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing Xamarin.Forms;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(Locations.AppServiceUrl);\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData => new AzureCloudTable<T>(client);\n\n        public Task LoginAsync()\n        {\n            var loginProvider = DependencyService.Get<ILoginProvider>();\n            return loginProvider.LoginAsync(client);\n        }\n    }\n}  The method looks up the platform dependent version of the login provider and executes the login method, passing\nalong the client (which we will need later).  In each platform-specific project, we are going to define a concrete implementation of the login provider that uses\na web view to hold the actual authentication flow.  Here is the droid  Services\\DroidLoginProvider.cs  (in the\nTaskList.Droid project):  using System.Threading.Tasks;\nusing Android.Content;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        Context context;\n\n        public void Init(Context context)\n        {\n            this.context = context;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(context, \"aad\");\n        }\n    }\n}  Let us take a closer look at this implementation.  The  LoginAsync()  method on the Azure Mobile Apps client object\ntakes the Android context (which is normally the main window) and a provider - we can pick any of \"facebook\",\n\"google\", \"microsoftaccount\", \"twitter\" or \"aad\" depending on what we have defined in the Azure App Service.  The\nclever piece is the  Xamarin.Forms.Dependency  call at the top - that registers the class as a platform service\nso we can access it through the Xamarin dependency service.  Note that we need an extra initialization routine for Android that must be called prior the login provider being\ncalled to pass along the main window of the app (also known as the context).  This is done in the  MainActivity.cs \nfile  after  the Xamarin Forms initialization call.  The dependency service is not set up until after the Xamarin\nForms library is initialized, so we will not be able to get the login provider reference before that point:  protected override void OnCreate(Bundle bundle)\n{\n    base.OnCreate(bundle);\n\n    Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n    global::Xamarin.Forms.Forms.Init(this, bundle);\n\n    ((DroidLoginProvider)DependencyService.Get<ILoginProvider>()).Init(this);\n\n    LoadApplication(new App());\n}  iOS is similar, but does not require the initialization step in the main startup class.  The login provider class\nis in  Services\\iOSLoginProvider.cs  (in the  TaskList.iOS  project):  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.iOS.Services;\nusing UIKit;\n\n[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]\nnamespace TaskList.iOS.Services\n{\n    public class iOSLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(RootView, \"aad\");\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n    }\n}  Note that we are using the same pattern here for registering the concrete implementation with the dependency service,\nso we can get it the same way. Finally, here is the UWP  Services\\UWPLoginProvider.cs  (in the TaskList.UWP project):  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.UWP.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(\"aad\");\n        }\n    }\n}  Now that we have all the platform-specific login routines registered, we can move on to adding the login routine to\nthe UI.  We have already got a button on the entry page to enter the app.  It makes sense to wire up that button so\nthat it logs us in as well. The Command for the login button is in the  ViewModels\\EntryPageViewModel.cs :  async Task ExecuteLoginCommand()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var cloudService = ServiceLocator.Instance.Resolve<ICloudService>();\n        await cloudService.LoginAsync();\n        Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n    }\n    catch (Exception ex)\n    {\n        Debug.WriteLine($\"[ExecuteLoginCommand] Error = {ex.Message}\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}   Info  The  ServiceLocator  class is a basic singleton handler.  It is available in the  Chapter2  project.  It\nreturns the concrete version of the cloud service, just like the Singleton version we defined in Chapter1.   When you run the application, clicking on the \"Enter the App\" button will now present you with an Authenticate window:   Going through the authentication process will get you to the task list again.  If the authentication process fails,\nthen  LoginAsync()  will throw an error, which is caught at the ViewModel.  Right now, the  EntryPageViewModel \ndoes nothing more than print a diagnostic message to the debug window of Visual Studio.",
            "title": "Adding Authentication to a Mobile Client"
        },
        {
            "location": "/chapter2/enterprise/#azure-active-directory-client-flow-setup",
            "text": "Configuring Azure Active Directory for client-flow is a three-step process.  First, we need to create a WEB\napplication.  This represents the resource: in our case, the resource is the Azure Mobile Apps backend.  Then\nwe need to create a NATIVE application.  This represents the client: in our case, the ADAL (Active Directory\nAccess Library) library will need this information.  Finally, we need to give the NATIVE application permission\nto access the WEB application.  It starts with configuring a server-flow to protect the resource.  We've already done that above. Then configure\na \"Native Application\" and give it permissions to the web application:   Log on to the  Classic Portal .  Select the  Default Directory  from your list of all items.  Click on the  APPLICATIONS  tab.     Note that our existing web application is already there.  You will see more applications, depending on what you\n  have set up.  In this example, I have Visual Studio Team Services and Office 365 set up.  Click on the  ADD  button at the bottom of the page.     Click on  Add an application my organization is developing .     Enter a name for the app registration, and select  NATIVE CLIENT APPLICATION .  Click on the Next arrow.  Enter a valid URI - it can be anything, but it has to be valid     Click on the tick to create the application.  The wizard will close, but you will be brought to the app configuration.  Click on the  CONFIGURE  tab.     Add a Redirect URI of the form:  https://yoursite.azurewebsites.net/.auth/login/done .     At the bottom of the page is the  permissions to other applications  section.  Click on the  Add application  button.     Click on the  SHOW  drop-down and select  All Apps , then click on the tick next to the search box.  Click on the web application that you set up during the server-flow configuration, then click on the  tick in\n  the lower-right corner.     Click on  Delegated Permissions  next to the web application.  Check the box next to  Access , then click\n  on  Save  at the bottom of the screen.    At this point the application configuration will be saved.  So, what did we just do there?  We created a new Azure AD app for the native application.  We then gave permission\nfor the native application to access resources that are protected by the web application.  In our Azure App Service,\nwe configured the service so that the Azure AD web application is used to protect our resources.  The net effect is\n that our native application OR our web application can access the App Service resources that are protected via the\n  [Authorize]  attribute.  Before continuing, you will need the  Client ID  and the  Redirect URI  for the NATIVE application. You can enter\nthese into the  Helpers\\Locations.cs  file in the shared project:  namespace TaskList.Helpers\n{\n    public static class Locations\n    {\n        public static readonly string AppServiceUrl = \"https://the-book.azurewebsites.net\";\n\n        public static readonly string AadClientId = \"b61c7d68-2086-43a1-a8c9-d93c5732cc84\";\n\n        public static readonly string AadRedirectUri = \"https://the-book.azurewebsites.net/.auth/login/done\";\n\n        public static readonly string AadAuthority = \"https://login.windows.net/photoadrianoutlook.onmicrosoft.com\";\n    }\n}  The  AadClientId  and  AadRedirectUri  must match what we have configured in Azure AD for the native app.  The\nother piece of information we need to add is the Azure AD Authority for the directory.  If you click on the DOMAINS  tab, it will generally tell you what domain you are in. The Authority is just a path on the https://login.windows.net  that corresponds to your domain.  There is also a GUID version of this domain.  You\ncan find the GUID by looking at the  View Endpoints  in the  APPLICATIONS  tab.  Look at the first path section\nof most all the endpoints.  Add the  Microsoft.IdentityModel.Clients.ActiveDirectory  NuGet package using  Manage NuGet Packages...  to\neach platform project.  This package contains the ADAL library as a portable class library.   Now you can add the client flow to each project.  Start with the login provider in the  TaskList.UWP  project,\nlocated in the  Services\\UWPLoginProvider.cs  file:  using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.UWP.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync()\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters(PromptBehavior.Auto, false));\n            return authResult.AccessToken;\n        }\n\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginADALAsync();\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server-Flow Version\n            // await client.LoginAsync(\"aad\");\n        }\n    }\n}  The  LoginADALAsync()  method does the actual client-flow - using the ADAL library to authenticate the user and\nreturn the access token.  The  LoginAsync()  method initiates the client-flow.  It uses the token it receives\nfrom the client-flow to log in to the App Service, by packaging the token into a JSON object.  I have placed\nthe client and server flow next to each other so you can compare the two.  In the  TaskList.Droid  project, we need to deal with the  Context , as is common with Android libraries.  The\nclient flow in  Services\\DroidLoginProvider.cs  is remarkably similar though:  using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Android.App;\nusing Android.Content;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\nusing TaskList.Helpers;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        Context context;\n\n        public void Init(Context context)\n        {\n            this.context = context;\n        }\n\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync()\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters((Activity)context));\n            return authResult.AccessToken;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginADALAsync();\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server-Flow Version\n            // await client.LoginAsync(context, \"aad\");\n        }\n    }\n}  The only real difference between this one and the Universal Windows edition is the PlatformParameters. We need to\npass in the context of the MainActivity (which is passed in through the  Init()  call).  However, we must also handle\nthe response from the ADAL library.  This is done in  MainActivity.cs . Add the following method to the  MainActivity \nclass:  protected override void OnActivityResult(int requestCode, Result resultCode, Intent data)\n{\n    base.OnActivityResult(requestCode, resultCode, data);\n    AuthenticationAgentContinuationHelper.SetAuthenticationAgentContinuationEventArgs(requestCode, resultCode, data);\n}  Finally, the iOS version also requires access to the root view, so its  PlatformParameters  are also slightly\ndifferent.  Here is  Services\\iOSLoginProvider.cs :  using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.iOS.Services;\nusing UIKit;\n\n[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]\nnamespace TaskList.iOS.Services\n{\n    public class iOSLoginProvider : ILoginProvider\n    {\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync(UIViewController view)\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters(view));\n            return authResult.AccessToken;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            var rootView = UIApplication.SharedApplication.KeyWindow.RootViewController;\n\n            // Client Flow\n            var accessToken = await LoginADALAsync(rootView);\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server Flow\n            //await client.LoginAsync(rootView, \"aad\");\n        }\n    }\n}  Note that we can balance the needs of each platform by using the dependency service.  The code that is unique to\nthe platform is minimized and stored with the platform.  If you aren't interested in social authentication (Facebook, Google, Microsoft or Twitter authentication providers),\nyou can  skip the Social Authentication section .",
            "title": "Azure Active Directory: Client-Flow Setup"
        },
        {
            "location": "/chapter2/social/",
            "text": "Social Authentication\n\u00b6\n\n\nAzure App Service provides built-in support for Facebook, Google, Microsoft and Twitter.  Irrespective of whether\nyou intend to use server-flow or client-flow, you will need to configure the Azure App Service Authentication /\nAuthorization service.  The method is pretty similar in each case:\n\n\n\n\nObtain a Developer Account for the provider.\n\n\nCreate a new application, obtaining a Client ID and Secret.\n\n\nTurn on Azure App Service Authentication.\n\n\nEnter the Client ID and Secret into the specific provider setup.\n\n\nSave the configuration.\n\n\n\n\nBefore you start any of this, create a new Azure Mobile Apps as we described in \nChapter 1\n.  If you want\na site to deploy for the configuration, the \nBackend\n project in the \nChapter2\n solution is pre-configured for\nauthorization. You just need to deploy it to Azure App Service.\n\n\nFacebook Configuration\n\u00b6\n\n\nI am going to assume you have a Facebook account already.  If you do not have a Facebook account, go to \nFacebook\n\nand sign up.  All your friends are likely there already!  Now log in to the \nFacebook Developers\n web site.  Create\na new Facebook application:\n\n\n\n\nNote\n: Facebook updates the look and feel of their developer site on a regular basis.  As a result, the screen shots\nI have provided here may be different.  If in doubt, follow the bullet descriptions to find your way.\n\n\n\n\nInfo\n\n\nIf you are not already registered, click on the drop-down in the top-right corner and \nRegister as a Developer\n\nbefore continuing.\n\n\n\n\n\n\nClick on the \nMy Apps\n link in the top right corner of the screen.\n\n\nClick on \nCreate a New App\n.\n\n\nFill in the form:\n\n\n\n\n\n\n\n\n\n\nIf required, verify your account according to the instructions.  This usually involves adding a credit card number\nor verifying your mobile phone number.\n\n\n\n\n\n\nClick on the \nGet Started\n button next to \nFacebook Login\n.\n\n\n\n\n\n\n\n\n\n\nEnter your application URL + \n/.auth/login/facebook/callback\n in the \nValid OAuth redirect URIs\n.\n\n\n\n\n\n\n\n\nClick on \nSave Changes\n.\n\n\nClick on the \nSettings\n -> \nBasic\n in the left hand side-bar.\n\n\nClick on the \nShow\n button next to the App Secret\n\n\n\n\nNow that you have the \nApp ID\n and \nApp Secret\n, you can continue configuration of your app within the\n\nAzure Portal\n.\n\n\n\n\nOpen up your App Service by clicking on \nAll Resources\n or \nApp Services\n followed by the name of your app service.\n\n\nIn the \nSettings\n blade, click on \nAuthentication / Authorization\n which is under \nFeatures\n.\n\n\nTurn \nApp Service Authentication\n to \nOn\n.\n\n\nIn the \nAction to take when request is not authenticated\n, select \nAllow Request (no action)\n.\n\n\n\n\n\n\nDanger\n\n\nIt is very tempting to choose \nLog in with Facebook\n.  However, you need to avoid this.  Selecting this option\nwill mean that all requests need to be authenticated and you will not get the information about the identity on the\nback end.  Selecting \nAllow Request\n means your app is in charge of what gets authenticated and what does not\nrequire authentication.\n\n\n\n\n\n\nClick on \nFacebook\n (which should show \nNot Configured\n).\n\n\nCut and Paste the \nApp ID\n and \nApp Secret\n into the boxes provided.\n\n\nSelect \npublic_profile\n and \nemail\n for Scopes.\n\n\n\n\n\n\nWarn\n\n\nIf you request anything but public_profile, user_friends, and email, your app will need further review by\nFacebook, which will take time.  This process is not worth it for test apps like this one.\n\n\n\n\n\n\nClick on \nOK\n (at the bottom of the blade) to close the Facebook configuration blade.\n\n\nClick on \nSave\n (at the top of the blade) to save your Authentication changes.\n\n\n\n\nYou can test your authentication process by browsing to https://\nyoursite\n.azurewebsites.net/.auth/login/facebook;\nthis is the same endpoint that the Azure Mobile Apps Client SDK calls when it is time to integrate authentication\ninto the mobile client.\n\n\n\n\nIf you are not logged in to facebook already, you will be prompted for your facebook credentials first.  Finally,\nhere is your happy page - the page that signifies you have done everything right:\n\n\n\n\n\n\nWarn\n\n\nEvery single OAuth provider will ask you what sort of information you want to have access to.  These \"claims\"\ntranslate into permissions.  The more permissions you request, the less likely the user is going to accept\nthem.  Be a good net citizen and only request the information you are actually going to use.\n\n\n\n\nGoogle Configuration\n\u00b6\n\n\nIt should be no shock that you need a \nGoogle Account\n to get started.  If you do not have one already (or you\nwant a different account for your development activities), create a new account now.  Then log in to the\n\nGoogle Developer Portal\n.  Click on the \nCreate Project\n link at the top:\n\n\n\n\nEnter a nice name (like mine) and click on \nCreate\n.  The screen will show the progress and eventually the project\nwill be listed in the \nAll Projects\n list.  It takes about 30 seconds to create a project.  Once you have your\nGoogle project, click on it to see all the wonderful things you can add to your project:\n\n\n\n\nThere is no \"Google Login\" that can guide you here.  The API you need to add is called \nGoogle+\n and is listed under\nthe \nSocial APIs\n.  Click on it, then click on \nEnable\n at the top of the screen.\n\n\nJust because it is enabled does not mean you automatically get to use it.  Click on \nCredentials\n link in the\nleft-hand side bar.  You will also see a \"Go to Credentials\" button at the top of the screen, but it does not take\nyou to the same screen, so do not click it.\n\n\nOn the Credentials screen, click on the \nOAuth consent screen\n tab:\n\n\n\n\nFill in the form and click on \nSave\n.  This brings up the next step - creating credentials.  Click on the\n\nCreate Credentials\n button.  This pops up a drop-down menu.  You want the \nOAuth Client ID\n.\n\n\n\n\nThe specific type of client ID you want is a \nWeb Application\n.  The server flow version of the application is\na web-based form authentication, which matches the \nWeb Application\n version of the Client ID.\n\n\nWhen you select \nWeb Application\n, you will get another form:\n\n\n\n\nEnter the URL of your App Service in the \nAuthorized JavaScript origins\n box, and the URL +\n\n/.auth/login/google/callback\n into the \nAuthorized redirect URIs\n box, then click on \nCreate\n.\n\n\n\n\nWarn\n\n\nGoogle is one of those providers that requires authentication redirect URIs to be secure - so ensure you use the\nhttps version of your URL.\n\n\n\n\nAt this point, Google will show you the Client ID and Client Secret for your app.  You can also get the Client ID and\nClient Secret from the interface by clicking on the \nCredentials\n link on the left-hand side bar.\n\n\nThe process from here is practically the same as Facebook.  Open your App Service within the Azure Portal, click on\n\nAll Settings\n, then \nAuthentication / Authorization\n and finally \nGoogle\n (assuming you have already turned\non the authentication service).  Cut and paste the Client ID and Client Secret into the boxes provided.  Click on\n\nOK\n (at the bottom) followed by \nSave\n (at the top of the page).\n\n\n\n\nInfo\n\n\nYou can define multiple providers at the same time.  The code in the client determines what authentication mechanism\ngets used.\n\n\n\n\nYou can test this just like Facebook.  Go to https://\nyoursite\n/.auth/login/google with your browser.  You should get\nsomething like the following:\n\n\n\n\nConfirming here should get us to the same happy screen we achieved with Facebook.\n\n\nIf you happen to mis-type the Authorized redirect URI, Google will tell you that the URI is wrong.  I inevitably swap\nhttp for https.  When this happens, it is an easy fix, but you have to wait a few minutes before the authentication\nsystem updates itself.\n\n\n\n\nWarn\n\n\nGoogle is turning off the ability to use \"Server Flow\" authentication with its service.  If you wish to use Google\nauthentication, you must use \"Client Flow\" and their SDK.\n\n\n\n\nMicrosoft Account Configuration\n\u00b6\n\n\nThe advantage of the Microsoft Account (or MSA, as it is known) is that you already have an account - you need one for\nAzure.  So this is the first time I am not going to explicitly tell you to sign up for an account.\n\n\nYour first step is to go to the \nMicrosoft Account Developer Center\n and log on with your Microsoft account.  You\nshould use the same one as you use for Azure, but it is not required.\n\n\n\n\nJust to confuse us, there are two \nAdd an App\n buttons. Strangely, they are different. Click on the one next to\n\nMy applications\n.\n\n\n\n\nEnter an awesome name and click on \nCreate application\n.\n\n\n\n\nClick on \nAdd Platform\n, followed by \nWeb\n.  In the \nRedirect URIs\n, enter your app URL +\n\n/.auth/login/microsoftaccount/callback\n. Then click on \nSave\n.\n\n\n\n\nNow click on \nGenerate New Password\n under \nApplication Secrets\n.\n\n\n\n\nUnlike the other social providers, this is the only time you will get to see your client secret, so make a note of it\nor cut and paste it into a notepad.  Once you have it copied somewhere, click on \nOK\n, followed by \nSave\n.\n\n\nYou now have all the information you need to configure the Microsoft Account section within your App Server\nAuthentication / Authorization.  The Client ID you need to enter is the Application ID and the Client Secret is the\npassword you just copied somewhere.\n\n\n\n\nNote that you have to choose claims that you want to read.  The \nwl.basic\n and \nwl.emails\n will give you enough\ninformation to get started with this tutorial.\n\n\nClick on \nOK\n (at the bottom), followed by \nSave\n (at the top).  You can test the settings by pointing your browser\nto https://\nyoursite\n.azurewebsites.net/.auth/login/microsoftaccount.  You will see what should be a normal claims\nrequest page:\n\n\n\n\nClicking on \nYes\n should take you to the normal success page.\n\n\nTwitter Configuration\n\u00b6\n\n\nI hope you are seeing that all the OAuth providers take a very similar route to configuring their service.  The\nsemantics of the service are slightly different in each case.  Twitter is no different.  As you might expect, before\ncontinuing, sign up for \nTwitter\n.  Once you have signed up, the \nTwitter Developers Portal\n is your next stop.\nOnce there, you can click on \nCreate New App\n:\n\n\n\n\nMost of the fields are self-explanatory.  The \nCallback URL\n is the same thing that the other social providers have\ncalled the Redirect URL.  The appropriate value is your app URL + \n/.auth/login/twitter/callback\n.  There is a legal\nagreement at the bottom of the page, then you can click on \nCreate your Twitter application\n button.\n\n\n\n\nDanger\n\n\nAll social authentication providers have some sort of legal agreement that governs their use.  In general, demo or\nPoC apps are fair use.  However, you should get a legal opinion before using a social authentication provider in a\nproduction app.\n\n\n\n\nOnce you have created the app, you will get a tabbed display with all the settings.  Click on the \nKeys and Access\nTokens\n tab:\n\n\n\n\nNote the values for the \nConsumer Key (API Key)\n and \nConsumer Secret (API Secret)\n.  They get entered into the\nAzure Portal.\n\n\n\n\nWarn\n\n\nThere is a check box in the \nSettings\n tab that says \nAllow this application to be used to Sign in with Twitter\n.\nAt the time of writing, this is checked by default.  However, if you find you can not log in for some reason, then\nensure this checkbox is checked.\n\n\n\n\nBack in the Azure Portal, select your app service, then \nAll Settings\n, \nAuthentication / Authorization\n, and\nfinally \nTwitter\n (assuming you have already turned Authentication on).  You can now cut and paste the Consumer\nKey and Consumer Secret into the appropriate boxes, before clicking on \nOK\n (at the bottom) followed by \nSave\n\n(at the top).\n\n\nAs with the other providers, you should test the authentication flow by pointing your browser to\nhttps://\nyoursite\n.azurewebsites.net/.auth/login/twitter.\n\n\n\n\nClicking on \nAuthorize app\n should show you our normal successful authentication screen.\n\n\nThe social authentication providers should now all be configured to handle a web-based or server-flow authentication\nrequest.  There are times when configuring a client-flow authentication is different.  We will point those out when we\nget to them.\n\n\nAdding Authentication to a Mobile Client\n\u00b6\n\n\nNow that the backend is completely configured, we can move our attention to the mobile client.  We are going to be\nusing the same mobile client that we developed in the first chapter, but we are now going to add authentication to\nit.  Web views are one of those items that are platform dependent. Fortunately for us, Xamarin has already thought\nof this and provided a facility for running platform specific code called the \nDependencyService\n.\n\n\n\n\nInfo\n\n\nIf you have already implemented authentication during the Enterprise Authentication section, this code is the\nsame.  You just have to alter the provider name.\n\n\n\n\nIf we run our application right now, clicking on the \"Enter the App\" button will result in an error.  You will be\nable to see the Unauthorized error in the debug window of Visual Studio.  Our first step is to define an\n\nAbstractions\\ILoginProvider.cs\n interface within the shared project:\n\n\nusing Microsoft.WindowsAzure.MobileServices;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ILoginProvider\n    {\n        Task LoginAsync(MobileServiceClient client);\n    }\n}\n\n\n\n\nNext, we extend our \nAbstractions\\ICloudService.cs\n interface so that the main application can call the login routine:\n\n\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n    }\n}\n\n\n\n\nOur code will call \nLoginAsync()\n in the \nICloudService\n, which will get the platform-specific version of the\nlogin provider and call \nLoginAsync()\n there, but with our defined mobile service client.  That is defined in the\n\nServices\\AzureCloudService.cs\n class:\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing Xamarin.Forms;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(Locations.AppServiceUrl);\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData => new AzureCloudTable<T>(client);\n\n        public Task LoginAsync()\n        {\n            var loginProvider = DependencyService.Get<ILoginProvider>();\n            return loginProvider.LoginAsync(client);\n        }\n    }\n}\n\n\n\n\nThe method looks up the platform dependent version of the login provider and executes the login method, passing\nalong the client (which we will need later).\n\n\nIn each platform-specific project, we are going to define a concrete implementation of the login provider that uses\na web view to hold the actual authentication flow.  Here is the droid \nServices\\DroidLoginProvider.cs\n (in the\nTaskList.Droid project):\n\n\nusing System.Threading.Tasks;\nusing Android.Content;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        Context context;\n\n        public void Init(Context context)\n        {\n            this.context = context;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(context, \"facebook\");\n        }\n    }\n}\n\n\n\n\n\n\nTip\n\n\nReplace \"facebook\" with \"google\", \"microsoftaccount\" or \"twitter\", depending on your identity provider.\n\n\n\n\nLet us take a closer look at this implementation.  The \nLoginAsync()\n method on the Azure Mobile Apps client object\ntakes the Android context (which is normally the main window) and a provider - we can pick any of \"facebook\",\n\"google\", \"microsoftaccount\", \"twitter\" or \"aad\" depending on what we have defined in the Azure App Service.  The\nclever piece is the \nXamarin.Forms.Dependency\n call at the top - that registers the class as a platform service\nso we can access it through the Xamarin dependency service.\n\n\nNote that we need an extra initialization routine for Android that must be called prior the login provider being\ncalled to pass along the main window of the app (also known as the context).  This is done in the \nMainActivity.cs\n\nfile \nafter\n the Xamarin Forms initialization call.  The dependency service is not set up until after the Xamarin\nForms library is initialized, so we will not be able to get the login provider reference before that point:\n\n\nprotected override void OnCreate(Bundle bundle)\n{\n    base.OnCreate(bundle);\n\n    Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n    global::Xamarin.Forms.Forms.Init(this, bundle);\n\n    ((DroidLoginProvider)DependencyService.Get<ILoginProvider>()).Init(this);\n\n    LoadApplication(new App());\n}\n\n\n\n\niOS is similar, but does not require the initialization step in the main startup class.  The login provider class\nis in \nServices\\iOSLoginProvider.cs\n (in the \nTaskList.iOS\n project):\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.iOS.Services;\nusing UIKit;\n\n[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]\nnamespace TaskList.iOS.Services\n{\n    public class iOSLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(RootView, \"facebook\");\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n    }\n}\n\n\n\n\nNote that we are using the same pattern here for registering the concrete implementation with the dependency service,\nso we can get it the same way. Finally, here is the UWP \nServices\\UWPLoginProvider.cs\n (in the TaskList.UWP project):\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.UWP.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(\"facebook\");\n        }\n    }\n}\n\n\n\n\nNow that we have all the platform-specific login routines registered, we can move on to adding the login routine to\nthe UI.  We have already got a button on the entry page to enter the app.  It makes sense to wire up that button so\nthat it logs us in as well. The Command for the login button is in the \nViewModels\\EntryPageViewModel.cs\n:\n\n\nasync Task ExecuteLoginCommand()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var cloudService = ServiceLocator.Instance.Resolve<ICloudService>();\n        await cloudService.LoginAsync();\n        Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n    }\n    catch (Exception ex)\n    {\n        Debug.WriteLine($\"[ExecuteLoginCommand] Error = {ex.Message}\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}\n\n\n\n\n\n\nInfo\n\n\nThe \nServiceLocator\n class is my basic singleton handler.  It is available in the \nChapter2\n project.  It\nreturns the concrete version of the cloud service, just like the Singleton version we defined in Chapter1.\n\n\n\n\nWhen you run the application, clicking on the \"Enter the App\" button will now present you with an Authenticate window:\n\n\n![AAD Authenticate][img58]\n\n\nGoing through the authentication process will get you to the task list again.  If the authentication process fails,\nthen \nLoginAsync()\n will throw an error, which is caught at the ViewModel.  Right now, the \nEntryPageViewModel\n\ndoes nothing more than print a diagnostic message to the debug window of Visual Studio.\n\n\nClient-Flow for Social Providers\n\u00b6\n\n\nIn each of the social providers, the identity provider SDK (provided by Facebook, Google, or Twitter) will need to be\nintegrated.  In general, these SDKs are provided for a native platform (Objective-C or Swift for iOS, Java for Android),\nuse callbacks or delegates (as is common practice in native libraries) and are thus more complicated to integrate with\nyour mobile client than those that have a C#/.NET SDK delivered on NuGet.\n\n\n\n\nWarn\n\n\nTesting Client Flow for social providers requires that the social app be installed on the device.  You cannot\ninstall other apps on the iOS simulator and there may be restrictions on the Android Emulator.  This means that\nyou need to test client flow for social providers on an actual device.\n\n\n\n\nThe reward for doing so are a more integrated experience on mobile devices.  For example, if you integrate the Google\nPlay Services SDK in an Android app, the app will seamlessly authenticate itself with the connected Google account in\nthe background, avoiding the need for repeatedly authenticating the client.  It may ask for a fingerprint instead if\nthe app is not trusted.  If you integrate the Facebook SDK, then the app will automatically switch to the Facebook app\nand ask you to approve the authentication request there instead of authenticating the user through a web view.  Both\nof these provide a more integrated experience for the end user, so this work is well worth pursuing.\n\n\n\n\nWarn\n\n\nGoogle is turning off WebView flows, which are required for \"Server Flow\" authentication.  This means that you\nmust use a client flow with the Google+ SDK if you wish to authenticate users using a Google ID.\n\n\n\n\nAs an example, here is the client flow for Facebook.  I've implemented this using the \nXamarin.Facebook.iOS\n library,\nwhich can be downloaded and installed into the iOS project from NuGet.  The \nServices\\iOSLoginProvider.cs\n contains\nthe following:\n\n\n        #region Facebook Client Flow\n        private TaskCompletionSource<string> fbtcs;\n\n        public async Task<string> LoginFacebookAsync()\n        {\n            fbtcs = new TaskCompletionSource<string>();\n            var loginManager = new LoginManager();\n\n            loginManager.LogInWithReadPermissions(new[] { \"public_profile\" }, RootView, LoginTokenHandler);\n            return await fbtcs.Task;\n        }\n\n        private void LoginTokenHandler(LoginManagerLoginResult loginResult, NSError error)\n        {\n            if (loginResult.Token != null)\n            {\n                fbtcs.TrySetResult(loginResult.Token.TokenString);\n            }\n            else\n            {\n                fbtcs.TrySetException(new Exception(\"Facebook Client Flow Login Failed\"));\n            }\n        }\n        #endregion\n\n\n\n\nNote the use of a \nTaskCompletionSource<>()\n here.  This is used often to convert callback APIs into awaitable APIs.\nWe set off the async call with the callback, then await on the completion (which is signified by the\n\nTaskCompletionSource\n).  When the callback is called, it sets the value of the \nTaskCompletionSource\n (or causes\nan exception) and that causes the task to complete.\n\n\nThe \nLoginAsync()\n method can now be updated like this:\n\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            var accessToken = await LoginFacebookAsync();\n\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"facebook\", zumoPayload);\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n\n\n\n\nWith this version, clicking on the login button will seamlessly switch into the Facebook application and ask the\nuser to confirm the request, before switching back authenticated.",
            "title": "Social Authentication"
        },
        {
            "location": "/chapter2/social/#social-authentication",
            "text": "Azure App Service provides built-in support for Facebook, Google, Microsoft and Twitter.  Irrespective of whether\nyou intend to use server-flow or client-flow, you will need to configure the Azure App Service Authentication /\nAuthorization service.  The method is pretty similar in each case:   Obtain a Developer Account for the provider.  Create a new application, obtaining a Client ID and Secret.  Turn on Azure App Service Authentication.  Enter the Client ID and Secret into the specific provider setup.  Save the configuration.   Before you start any of this, create a new Azure Mobile Apps as we described in  Chapter 1 .  If you want\na site to deploy for the configuration, the  Backend  project in the  Chapter2  solution is pre-configured for\nauthorization. You just need to deploy it to Azure App Service.",
            "title": "Social Authentication"
        },
        {
            "location": "/chapter2/social/#facebook-configuration",
            "text": "I am going to assume you have a Facebook account already.  If you do not have a Facebook account, go to  Facebook \nand sign up.  All your friends are likely there already!  Now log in to the  Facebook Developers  web site.  Create\na new Facebook application:   Note : Facebook updates the look and feel of their developer site on a regular basis.  As a result, the screen shots\nI have provided here may be different.  If in doubt, follow the bullet descriptions to find your way.   Info  If you are not already registered, click on the drop-down in the top-right corner and  Register as a Developer \nbefore continuing.    Click on the  My Apps  link in the top right corner of the screen.  Click on  Create a New App .  Fill in the form:      If required, verify your account according to the instructions.  This usually involves adding a credit card number\nor verifying your mobile phone number.    Click on the  Get Started  button next to  Facebook Login .      Enter your application URL +  /.auth/login/facebook/callback  in the  Valid OAuth redirect URIs .     Click on  Save Changes .  Click on the  Settings  ->  Basic  in the left hand side-bar.  Click on the  Show  button next to the App Secret   Now that you have the  App ID  and  App Secret , you can continue configuration of your app within the Azure Portal .   Open up your App Service by clicking on  All Resources  or  App Services  followed by the name of your app service.  In the  Settings  blade, click on  Authentication / Authorization  which is under  Features .  Turn  App Service Authentication  to  On .  In the  Action to take when request is not authenticated , select  Allow Request (no action) .    Danger  It is very tempting to choose  Log in with Facebook .  However, you need to avoid this.  Selecting this option\nwill mean that all requests need to be authenticated and you will not get the information about the identity on the\nback end.  Selecting  Allow Request  means your app is in charge of what gets authenticated and what does not\nrequire authentication.    Click on  Facebook  (which should show  Not Configured ).  Cut and Paste the  App ID  and  App Secret  into the boxes provided.  Select  public_profile  and  email  for Scopes.    Warn  If you request anything but public_profile, user_friends, and email, your app will need further review by\nFacebook, which will take time.  This process is not worth it for test apps like this one.    Click on  OK  (at the bottom of the blade) to close the Facebook configuration blade.  Click on  Save  (at the top of the blade) to save your Authentication changes.   You can test your authentication process by browsing to https:// yoursite .azurewebsites.net/.auth/login/facebook;\nthis is the same endpoint that the Azure Mobile Apps Client SDK calls when it is time to integrate authentication\ninto the mobile client.   If you are not logged in to facebook already, you will be prompted for your facebook credentials first.  Finally,\nhere is your happy page - the page that signifies you have done everything right:    Warn  Every single OAuth provider will ask you what sort of information you want to have access to.  These \"claims\"\ntranslate into permissions.  The more permissions you request, the less likely the user is going to accept\nthem.  Be a good net citizen and only request the information you are actually going to use.",
            "title": "Facebook Configuration"
        },
        {
            "location": "/chapter2/social/#google-configuration",
            "text": "It should be no shock that you need a  Google Account  to get started.  If you do not have one already (or you\nwant a different account for your development activities), create a new account now.  Then log in to the Google Developer Portal .  Click on the  Create Project  link at the top:   Enter a nice name (like mine) and click on  Create .  The screen will show the progress and eventually the project\nwill be listed in the  All Projects  list.  It takes about 30 seconds to create a project.  Once you have your\nGoogle project, click on it to see all the wonderful things you can add to your project:   There is no \"Google Login\" that can guide you here.  The API you need to add is called  Google+  and is listed under\nthe  Social APIs .  Click on it, then click on  Enable  at the top of the screen.  Just because it is enabled does not mean you automatically get to use it.  Click on  Credentials  link in the\nleft-hand side bar.  You will also see a \"Go to Credentials\" button at the top of the screen, but it does not take\nyou to the same screen, so do not click it.  On the Credentials screen, click on the  OAuth consent screen  tab:   Fill in the form and click on  Save .  This brings up the next step - creating credentials.  Click on the Create Credentials  button.  This pops up a drop-down menu.  You want the  OAuth Client ID .   The specific type of client ID you want is a  Web Application .  The server flow version of the application is\na web-based form authentication, which matches the  Web Application  version of the Client ID.  When you select  Web Application , you will get another form:   Enter the URL of your App Service in the  Authorized JavaScript origins  box, and the URL + /.auth/login/google/callback  into the  Authorized redirect URIs  box, then click on  Create .   Warn  Google is one of those providers that requires authentication redirect URIs to be secure - so ensure you use the\nhttps version of your URL.   At this point, Google will show you the Client ID and Client Secret for your app.  You can also get the Client ID and\nClient Secret from the interface by clicking on the  Credentials  link on the left-hand side bar.  The process from here is practically the same as Facebook.  Open your App Service within the Azure Portal, click on All Settings , then  Authentication / Authorization  and finally  Google  (assuming you have already turned\non the authentication service).  Cut and paste the Client ID and Client Secret into the boxes provided.  Click on OK  (at the bottom) followed by  Save  (at the top of the page).   Info  You can define multiple providers at the same time.  The code in the client determines what authentication mechanism\ngets used.   You can test this just like Facebook.  Go to https:// yoursite /.auth/login/google with your browser.  You should get\nsomething like the following:   Confirming here should get us to the same happy screen we achieved with Facebook.  If you happen to mis-type the Authorized redirect URI, Google will tell you that the URI is wrong.  I inevitably swap\nhttp for https.  When this happens, it is an easy fix, but you have to wait a few minutes before the authentication\nsystem updates itself.   Warn  Google is turning off the ability to use \"Server Flow\" authentication with its service.  If you wish to use Google\nauthentication, you must use \"Client Flow\" and their SDK.",
            "title": "Google Configuration"
        },
        {
            "location": "/chapter2/social/#microsoft-account-configuration",
            "text": "The advantage of the Microsoft Account (or MSA, as it is known) is that you already have an account - you need one for\nAzure.  So this is the first time I am not going to explicitly tell you to sign up for an account.  Your first step is to go to the  Microsoft Account Developer Center  and log on with your Microsoft account.  You\nshould use the same one as you use for Azure, but it is not required.   Just to confuse us, there are two  Add an App  buttons. Strangely, they are different. Click on the one next to My applications .   Enter an awesome name and click on  Create application .   Click on  Add Platform , followed by  Web .  In the  Redirect URIs , enter your app URL + /.auth/login/microsoftaccount/callback . Then click on  Save .   Now click on  Generate New Password  under  Application Secrets .   Unlike the other social providers, this is the only time you will get to see your client secret, so make a note of it\nor cut and paste it into a notepad.  Once you have it copied somewhere, click on  OK , followed by  Save .  You now have all the information you need to configure the Microsoft Account section within your App Server\nAuthentication / Authorization.  The Client ID you need to enter is the Application ID and the Client Secret is the\npassword you just copied somewhere.   Note that you have to choose claims that you want to read.  The  wl.basic  and  wl.emails  will give you enough\ninformation to get started with this tutorial.  Click on  OK  (at the bottom), followed by  Save  (at the top).  You can test the settings by pointing your browser\nto https:// yoursite .azurewebsites.net/.auth/login/microsoftaccount.  You will see what should be a normal claims\nrequest page:   Clicking on  Yes  should take you to the normal success page.",
            "title": "Microsoft Account Configuration"
        },
        {
            "location": "/chapter2/social/#twitter-configuration",
            "text": "I hope you are seeing that all the OAuth providers take a very similar route to configuring their service.  The\nsemantics of the service are slightly different in each case.  Twitter is no different.  As you might expect, before\ncontinuing, sign up for  Twitter .  Once you have signed up, the  Twitter Developers Portal  is your next stop.\nOnce there, you can click on  Create New App :   Most of the fields are self-explanatory.  The  Callback URL  is the same thing that the other social providers have\ncalled the Redirect URL.  The appropriate value is your app URL +  /.auth/login/twitter/callback .  There is a legal\nagreement at the bottom of the page, then you can click on  Create your Twitter application  button.   Danger  All social authentication providers have some sort of legal agreement that governs their use.  In general, demo or\nPoC apps are fair use.  However, you should get a legal opinion before using a social authentication provider in a\nproduction app.   Once you have created the app, you will get a tabbed display with all the settings.  Click on the  Keys and Access\nTokens  tab:   Note the values for the  Consumer Key (API Key)  and  Consumer Secret (API Secret) .  They get entered into the\nAzure Portal.   Warn  There is a check box in the  Settings  tab that says  Allow this application to be used to Sign in with Twitter .\nAt the time of writing, this is checked by default.  However, if you find you can not log in for some reason, then\nensure this checkbox is checked.   Back in the Azure Portal, select your app service, then  All Settings ,  Authentication / Authorization , and\nfinally  Twitter  (assuming you have already turned Authentication on).  You can now cut and paste the Consumer\nKey and Consumer Secret into the appropriate boxes, before clicking on  OK  (at the bottom) followed by  Save \n(at the top).  As with the other providers, you should test the authentication flow by pointing your browser to\nhttps:// yoursite .azurewebsites.net/.auth/login/twitter.   Clicking on  Authorize app  should show you our normal successful authentication screen.  The social authentication providers should now all be configured to handle a web-based or server-flow authentication\nrequest.  There are times when configuring a client-flow authentication is different.  We will point those out when we\nget to them.",
            "title": "Twitter Configuration"
        },
        {
            "location": "/chapter2/social/#adding-authentication-to-a-mobile-client",
            "text": "Now that the backend is completely configured, we can move our attention to the mobile client.  We are going to be\nusing the same mobile client that we developed in the first chapter, but we are now going to add authentication to\nit.  Web views are one of those items that are platform dependent. Fortunately for us, Xamarin has already thought\nof this and provided a facility for running platform specific code called the  DependencyService .   Info  If you have already implemented authentication during the Enterprise Authentication section, this code is the\nsame.  You just have to alter the provider name.   If we run our application right now, clicking on the \"Enter the App\" button will result in an error.  You will be\nable to see the Unauthorized error in the debug window of Visual Studio.  Our first step is to define an Abstractions\\ILoginProvider.cs  interface within the shared project:  using Microsoft.WindowsAzure.MobileServices;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ILoginProvider\n    {\n        Task LoginAsync(MobileServiceClient client);\n    }\n}  Next, we extend our  Abstractions\\ICloudService.cs  interface so that the main application can call the login routine:  using System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n    }\n}  Our code will call  LoginAsync()  in the  ICloudService , which will get the platform-specific version of the\nlogin provider and call  LoginAsync()  there, but with our defined mobile service client.  That is defined in the Services\\AzureCloudService.cs  class:  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing Xamarin.Forms;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(Locations.AppServiceUrl);\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData => new AzureCloudTable<T>(client);\n\n        public Task LoginAsync()\n        {\n            var loginProvider = DependencyService.Get<ILoginProvider>();\n            return loginProvider.LoginAsync(client);\n        }\n    }\n}  The method looks up the platform dependent version of the login provider and executes the login method, passing\nalong the client (which we will need later).  In each platform-specific project, we are going to define a concrete implementation of the login provider that uses\na web view to hold the actual authentication flow.  Here is the droid  Services\\DroidLoginProvider.cs  (in the\nTaskList.Droid project):  using System.Threading.Tasks;\nusing Android.Content;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        Context context;\n\n        public void Init(Context context)\n        {\n            this.context = context;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(context, \"facebook\");\n        }\n    }\n}   Tip  Replace \"facebook\" with \"google\", \"microsoftaccount\" or \"twitter\", depending on your identity provider.   Let us take a closer look at this implementation.  The  LoginAsync()  method on the Azure Mobile Apps client object\ntakes the Android context (which is normally the main window) and a provider - we can pick any of \"facebook\",\n\"google\", \"microsoftaccount\", \"twitter\" or \"aad\" depending on what we have defined in the Azure App Service.  The\nclever piece is the  Xamarin.Forms.Dependency  call at the top - that registers the class as a platform service\nso we can access it through the Xamarin dependency service.  Note that we need an extra initialization routine for Android that must be called prior the login provider being\ncalled to pass along the main window of the app (also known as the context).  This is done in the  MainActivity.cs \nfile  after  the Xamarin Forms initialization call.  The dependency service is not set up until after the Xamarin\nForms library is initialized, so we will not be able to get the login provider reference before that point:  protected override void OnCreate(Bundle bundle)\n{\n    base.OnCreate(bundle);\n\n    Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n    global::Xamarin.Forms.Forms.Init(this, bundle);\n\n    ((DroidLoginProvider)DependencyService.Get<ILoginProvider>()).Init(this);\n\n    LoadApplication(new App());\n}  iOS is similar, but does not require the initialization step in the main startup class.  The login provider class\nis in  Services\\iOSLoginProvider.cs  (in the  TaskList.iOS  project):  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.iOS.Services;\nusing UIKit;\n\n[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]\nnamespace TaskList.iOS.Services\n{\n    public class iOSLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(RootView, \"facebook\");\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n    }\n}  Note that we are using the same pattern here for registering the concrete implementation with the dependency service,\nso we can get it the same way. Finally, here is the UWP  Services\\UWPLoginProvider.cs  (in the TaskList.UWP project):  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.UWP.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(\"facebook\");\n        }\n    }\n}  Now that we have all the platform-specific login routines registered, we can move on to adding the login routine to\nthe UI.  We have already got a button on the entry page to enter the app.  It makes sense to wire up that button so\nthat it logs us in as well. The Command for the login button is in the  ViewModels\\EntryPageViewModel.cs :  async Task ExecuteLoginCommand()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var cloudService = ServiceLocator.Instance.Resolve<ICloudService>();\n        await cloudService.LoginAsync();\n        Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n    }\n    catch (Exception ex)\n    {\n        Debug.WriteLine($\"[ExecuteLoginCommand] Error = {ex.Message}\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}   Info  The  ServiceLocator  class is my basic singleton handler.  It is available in the  Chapter2  project.  It\nreturns the concrete version of the cloud service, just like the Singleton version we defined in Chapter1.   When you run the application, clicking on the \"Enter the App\" button will now present you with an Authenticate window:  ![AAD Authenticate][img58]  Going through the authentication process will get you to the task list again.  If the authentication process fails,\nthen  LoginAsync()  will throw an error, which is caught at the ViewModel.  Right now, the  EntryPageViewModel \ndoes nothing more than print a diagnostic message to the debug window of Visual Studio.",
            "title": "Adding Authentication to a Mobile Client"
        },
        {
            "location": "/chapter2/social/#client-flow-for-social-providers",
            "text": "In each of the social providers, the identity provider SDK (provided by Facebook, Google, or Twitter) will need to be\nintegrated.  In general, these SDKs are provided for a native platform (Objective-C or Swift for iOS, Java for Android),\nuse callbacks or delegates (as is common practice in native libraries) and are thus more complicated to integrate with\nyour mobile client than those that have a C#/.NET SDK delivered on NuGet.   Warn  Testing Client Flow for social providers requires that the social app be installed on the device.  You cannot\ninstall other apps on the iOS simulator and there may be restrictions on the Android Emulator.  This means that\nyou need to test client flow for social providers on an actual device.   The reward for doing so are a more integrated experience on mobile devices.  For example, if you integrate the Google\nPlay Services SDK in an Android app, the app will seamlessly authenticate itself with the connected Google account in\nthe background, avoiding the need for repeatedly authenticating the client.  It may ask for a fingerprint instead if\nthe app is not trusted.  If you integrate the Facebook SDK, then the app will automatically switch to the Facebook app\nand ask you to approve the authentication request there instead of authenticating the user through a web view.  Both\nof these provide a more integrated experience for the end user, so this work is well worth pursuing.   Warn  Google is turning off WebView flows, which are required for \"Server Flow\" authentication.  This means that you\nmust use a client flow with the Google+ SDK if you wish to authenticate users using a Google ID.   As an example, here is the client flow for Facebook.  I've implemented this using the  Xamarin.Facebook.iOS  library,\nwhich can be downloaded and installed into the iOS project from NuGet.  The  Services\\iOSLoginProvider.cs  contains\nthe following:          #region Facebook Client Flow\n        private TaskCompletionSource<string> fbtcs;\n\n        public async Task<string> LoginFacebookAsync()\n        {\n            fbtcs = new TaskCompletionSource<string>();\n            var loginManager = new LoginManager();\n\n            loginManager.LogInWithReadPermissions(new[] { \"public_profile\" }, RootView, LoginTokenHandler);\n            return await fbtcs.Task;\n        }\n\n        private void LoginTokenHandler(LoginManagerLoginResult loginResult, NSError error)\n        {\n            if (loginResult.Token != null)\n            {\n                fbtcs.TrySetResult(loginResult.Token.TokenString);\n            }\n            else\n            {\n                fbtcs.TrySetException(new Exception(\"Facebook Client Flow Login Failed\"));\n            }\n        }\n        #endregion  Note the use of a  TaskCompletionSource<>()  here.  This is used often to convert callback APIs into awaitable APIs.\nWe set off the async call with the callback, then await on the completion (which is signified by the TaskCompletionSource ).  When the callback is called, it sets the value of the  TaskCompletionSource  (or causes\nan exception) and that causes the task to complete.  The  LoginAsync()  method can now be updated like this:          public async Task LoginAsync(MobileServiceClient client)\n        {\n            var accessToken = await LoginFacebookAsync();\n\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"facebook\", zumoPayload);\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;  With this version, clicking on the login button will seamlessly switch into the Facebook application and ask the\nuser to confirm the request, before switching back authenticated.",
            "title": "Client-Flow for Social Providers"
        },
        {
            "location": "/chapter2/debugging/",
            "text": "What is in a JWT\n\u00b6\n\n\nAt this point you will have the \"Authentication Success\" screen - perhaps several times.  If you bring up the\nDeveloper Tools for your browser, you can take a look at the token that is being minted for the authentication\nsession.  Take a look at the URL on the \"successful authentication\" page.\n\n\n\n\nThe authentication token is clearly marked (after you strip away the URL encoding).  You can use a\n[URL Decoder / Encoder][16] - just cut and paste the entire URL into the box and click on \nDecode\n.  Note that\nthe token is actually a JSON object.  You can now easily extract the \nauthenticationToken\n field from the JSON\nobject.\n\n\n\n\nTechnically, the authentication token is a \nJSON Web Token\n.  This is a mechanism for transferring claims\nbetween two systems securely.  The JWT is a cryptographically signed JSON object.  You can decode the JWT using\nthe \njwt.io tool\n.  Cut and paste the authentication token into the \nEncoded\n box and it will be decoded.\n\n\n\n\nNote that the contents of the JWT are revealed even without knowing the secret.  The client secret is generated\n(or entered as part of a configuration) at the identity provider and is used to cryptographically sign the token.\nYou will need the client secret to verify the signature of the token.  The client secret is copied from the identity\nprovider to the resource (in this case, the App Service).\n\n\nWe can see other items within the token.  The \nIssuer\n is the place that issued the token.  This is generally a URI.\nThe \nAudience\n is an identifier for who the token is for.  In this case, we have a token minted by the Azure App\nService for use accessing that same App Service, so the issuer and audience are both the URI.  If you look at an\nAuth0 token, you will see that the issuer is the Auth0 domain and the audience is the Client ID of the Auth0 tenant.\n\n\nEach token will also have a number of claims.  The most common claim is the \nSubject\n of the token.  This is generally\na security ID, but could be any unique user ID.\n\n\n\n\nInfo\n\n\nAzure App Service sets the subject to a stable SID.  The stable SID is unique to the identity provider that is\nused for the authentication and guaranteed not to change, even if the user changes their email address or username\non the underlying identity provider.\n\n\n\n\nTechnically, the JWT can include any data and there are some identity providers that place just about everything\nabout the user in the JWT.  App Service keeps the amount of data small because the client will be sending the JWT\nwith every request. Imagine adding a few kilobytes to every single request that the client makes.  The bandwidth\nusage will add up quickly, and your app will be known as a bandwidth hog.\n\n\nHowever, there are some fields that are pretty universal.  Your JWT should always have the following fields:\n\n\n\n\nsub = Subject (the identifier for the token)\n\n\nexp = Expiry (when the token expires)\n\n\nnbf = Not Before (the earliest point in time the token is valid)\n\n\niss = Issuer (the site that issued the token)\n\n\naud = Audience (who is the token for)\n\n\n\n\nThe timestamps (exp and nbf) are all UNIX timestamps (i.e. the number of seconds since January 1, 1970).\n\n\nApp Service adds to this:\n\n\n\n\nstable_sid = Security Id of the user\n\n\nidp = the IdP that was used in the authentication request\n\n\nver = the Version of the token\n\n\n\n\nApp Service will be able to validate any token provided to it when presented in an X-ZUMO-AUTH header.  If you are\nusing Azure Active Directory, you can also use the more standard Bearer Authorization header.  If the token does\nnot match, then the X-ZUMO-AUTH header will be stripped from the request before the request is passed to your site.\n\n\nTesting Authentication without a Client\n\u00b6\n\n\nTesting authentication against your App Service without a client requires a REST client.  I use \nPostman\n,\nwhich is based on Google Chrome.  If you use Firefox, you might want to take a look at \nRESTClient\n.  Telerik\nalso distributes a web debugging proxy called \nFiddler\n that can do API testing.  To test the server, we will\nneed a token.  We can get one by testing authentication configuration by pointing the browser to \n/.auth/login/aad\n.\nThe return URL will contain a token in the query string and as \na secure cookie\n.\n\n\n\n\nTip\n\n\nYou can test any of the supported identity providers by replacing \naad\n with the authentication provider name:\n\nfacebook\n, \ngoogle\n, \nmicrosoftaccount\n and \ntwitter\n are possibilities here.\n\n\n\n\nWe can then do a request to \n/tables/todoitem\n to try and obtain the list of current tasks.  We will need to add\ntwo headers:\n\n\n\n\nZUMO-API-VERSION\n should contain a value of \n2.0.0\n.\n\n\nX-ZUMO-AUTH\n should contain the token you received.\n\n\n\n\nMy first request shows authentication failing:\n\n\n\n\nGo through one of the authentication flows and copy the authentication token.  In Postman, add a new header called\n\nX-ZUMO-AUTH\n and paste the authentication token in.\n\n\n\n\nNote that we have tested all this without touching the client.  Separating the backend operations from the client\noperations means we can be sure of where the inevitable bug that creeps in is located.  We have verified that we\ncan do each authentication flow on the server side and that the server is properly rejecting unauthenticated requests,\nplus it is properly returning data when authenticated requests are issued.\n\n\nDeveloping Locally\n\u00b6\n\n\nOne would normally be able to run the ASP.NET backend locally and get full functionality without authentication.\nHowever, authentication puts a stop to that because the redirect URLs, secrets and other authentication configuration\nsettings only work with a known endpoint.  To alleviate that, Azure Mobile Apps allows you to run a local server while\nusing an authentication endpoint in Azure App Service.  When the authentication transaction takes place, it is taking\nplace against the Azure App Service.   When it is not doing the OAuth transaction, however, it is operating against a\nlocal server.\n\n\nSetting this up requires a little bit of local machine configuration and a change to the configuration of your client.\n\n\nUpdate your Local Development Environment\n\u00b6\n\n\nThe first step in this process is to make your local IIS development environment look more like the Azure App Service,\nparticularly in reference to the authentication settings.  This means setting up a few app settings that should be\npulled from your App Service.\n\n\n\n\nLog on to the \nAzure Portal\n.\n\n\nSelect your App Service from the \nApp Services\n list.\n\n\nClick on \nTools\n, then \nAdvanced Tools\n, then \nGo\n.\n\n\n\n\nKudu (now known as \nAdvanced Tools\n in the Azure portal menu) is the backend debug console for Azure App Service and\nthere is a lot you can do here.  Of note in this instance is that you can gain access to the keys and audience for your\nApp Service.\n\n\n\n\nClick on \nEnvironment\n in the top banner.\n\n\nClick on \nEnvironment variables\n.\n\n\nScroll down to the environment variables starting with \nWEBSITE_AUTH\n.\n\n\nMake a note of the \nWEBSITE_AUTH_SIGNING_KEY\n and \nWEBSITE_AUTH_ALLOWED_AUDIENCES\n values.\n\n\n\n\nAdd the following to your project Web.config \n<appSettings>\n section:\n\n\n  <appSettings>\n    <add key=\"PreserveLoginUrl\" value=\"true\" />\n    <add key=\"MS_SigningKey\" value=\"Overridden by portal settings\" />\n    <add key=\"EMA_RuntimeUrl\" value=\"Overridden by portal settings\" />\n    <add key=\"MS_NotificationHubName\" value=\"Overridden by portal settings\" />\n    <add key=\"SigningKey\" value=\"{Your WEBSITE_AUTH_SIGNING_KEY}\"/>\n    <add key=\"ValidAudience\" value=\"{Your WEBSITE_AUTH_ALLOWED_AUDIENCES}\"/>\n    <add key=\"ValidIssuer\" value=\"https://{Your WEBSITE_HOSTNAME}/\"/>\n  </appSettings>\n\n\n\n\n\n\nTip\n\n\nBoth the ValidAudience and ValidIssuer will have a slash on the end and be a https URL.\n\n\n\n\nThe last three keys are the keys you will need to add.  Make sure you do not have a \nHostName\n key as this is how\nthe startup file determines if you are running locally or remote. Talking of which, edit your\n\nApp_Start\\Startup.MobileApp.cs\n file to include the following:\n\n\n        public static void ConfigureMobileApp(IAppBuilder app)\n        {\n            HttpConfiguration config = new HttpConfiguration();\n\n            new MobileAppConfiguration()\n                .AddTablesWithEntityFramework()\n                .ApplyTo(config);\n\n            // Use Entity Framework Code First to create database tables based on your DbContext\n            Database.SetInitializer(new MobileServiceInitializer());\n\n            MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();\n\n            if (string.IsNullOrEmpty(settings.HostName))\n            {\n                app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions\n                {\n                    SigningKey = ConfigurationManager.AppSettings[\"SigningKey\"],\n                    ValidAudiences = new[] { ConfigurationManager.AppSettings[\"ValidAudience\"] },\n                    ValidIssuers = new[] { ConfigurationManager.AppSettings[\"ValidIssuer\"] },\n                    TokenHandler = config.GetAppServiceTokenHandler()\n                });\n            }\n\n            app.UseWebApi(config);\n        }\n\n\n\n\nThe \nUserAppServiceAuthentication()\n method sets up authentication checking.  This section is not required when running\nwithin App Service.\n\n\nIf you are running the server locally, you should either set up a local SQL Server instance and put the connection\nstring into the \nWeb.config\n file, or \nopen the firewall on your SQL Azure\n database so that your local development\nenvironment can connect to it, then place the connection string in the \nWeb.config\n.  You can get the connection string\nof the SQL Azure instance by looking at the Connection Strings in the \nApplication properties\n of your App Service.\n\n\nUpdate your Mobile Client\n\u00b6\n\n\nFor this demonstration, I have updated the \nTaskList.UWP\n application so that it is using the server-flow\nauthentication for Azure Active Directory.  This means updating the \nLoginAsync()\n method in the\n\nServices\\UWPLoginProvider.cs\n file to be the following:\n\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Server-Flow Version\n            await client.LoginAsync(\"aad\");\n        }\n\n\n\n\nThis is because the default local IIS instance is IIS Express.  IIS Express only listens for local connections.  If\nyou run a client from another device (for example, the Android emulator on a Hyper-V service or the iOS simulator\non a Mac), then that client would be connecting via a network connection.  You can still debug locally, but you need\nto \nconvert your environment to IIS\n first.\n\n\nIn the \nTaskList (Portable)\n project, update the \nHelpers\\Locations.cs\n file:\n\n\nnamespace TaskList.Helpers\n{\n    public static class Locations\n    {\n#if DEBUG\n        public static readonly string AppServiceUrl = \"http://localhost:17568/\";\n        public static readonly string AlternateLoginHost = \"https://the-book.azurewebsites.net\";\n#else\n        public static readonly string AppServiceUrl = \"https://the-book.azurewebsites.net\";\n        public static readonly string AlternateLoginHost = null;\n#endif\n    }\n}\n\n\n\n\nThe \nAppServiceUrl\n is always set to the location of your backend.  In this case, I right-clicked on the \nBackend\n\nproject and selected \nProperties\n then \nWeb\n.  The correct URL for local debugging is listed in the\n\nProject URL\n.  The \nAlternateLoginHost\n is set to the App Service when locally debugging or null if not. You can\nspecify the \nDEBUG\n constant in the \nBuild\n tab.\n\n\nIn the same project, update the \nServices\\AzureCloudService.cs\n constructor to the following:\n\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(Locations.AppServiceUrl);\n            if (Locations.AlternateLoginHost != null)\n                client.AlternateLoginHost = new Uri(Locations.AlternateLoginHost);\n        }\n\n\n\n\n\n\nTip\n\n\nIt's a good idea to separate the client and server into different solutions.  Although it doesn't hurt anything to\nhave them in the same solution (like we have), having the client and server separated allows you to attach a debugger\nseparately - which allows you to debug both sides of the connection at the same time.\n\n\n\n\nWith these settings, the client will contact the AlternateLoginHost listed for the authentication process and then\ncontact the local server for the rest of the transaction.\n\n\nRun the Local Server\n\u00b6\n\n\nRunning the local server and the client takes a larger machine.  You need to run two instances of Visual Studio: one\nfor the client and one for the server. This is really where you will appreciate multiple monitors (my personal favorite)\nor the snap action to the sides of the screens.\n\n\nEnsure you have your backend and clients in different solutions if you intend to run both client and server.  The\ndebugger in Visual Studio will stop one to run the other when they are in the same solution.",
            "title": "Debugging Authentication"
        },
        {
            "location": "/chapter2/debugging/#what-is-in-a-jwt",
            "text": "At this point you will have the \"Authentication Success\" screen - perhaps several times.  If you bring up the\nDeveloper Tools for your browser, you can take a look at the token that is being minted for the authentication\nsession.  Take a look at the URL on the \"successful authentication\" page.   The authentication token is clearly marked (after you strip away the URL encoding).  You can use a\n[URL Decoder / Encoder][16] - just cut and paste the entire URL into the box and click on  Decode .  Note that\nthe token is actually a JSON object.  You can now easily extract the  authenticationToken  field from the JSON\nobject.   Technically, the authentication token is a  JSON Web Token .  This is a mechanism for transferring claims\nbetween two systems securely.  The JWT is a cryptographically signed JSON object.  You can decode the JWT using\nthe  jwt.io tool .  Cut and paste the authentication token into the  Encoded  box and it will be decoded.   Note that the contents of the JWT are revealed even without knowing the secret.  The client secret is generated\n(or entered as part of a configuration) at the identity provider and is used to cryptographically sign the token.\nYou will need the client secret to verify the signature of the token.  The client secret is copied from the identity\nprovider to the resource (in this case, the App Service).  We can see other items within the token.  The  Issuer  is the place that issued the token.  This is generally a URI.\nThe  Audience  is an identifier for who the token is for.  In this case, we have a token minted by the Azure App\nService for use accessing that same App Service, so the issuer and audience are both the URI.  If you look at an\nAuth0 token, you will see that the issuer is the Auth0 domain and the audience is the Client ID of the Auth0 tenant.  Each token will also have a number of claims.  The most common claim is the  Subject  of the token.  This is generally\na security ID, but could be any unique user ID.   Info  Azure App Service sets the subject to a stable SID.  The stable SID is unique to the identity provider that is\nused for the authentication and guaranteed not to change, even if the user changes their email address or username\non the underlying identity provider.   Technically, the JWT can include any data and there are some identity providers that place just about everything\nabout the user in the JWT.  App Service keeps the amount of data small because the client will be sending the JWT\nwith every request. Imagine adding a few kilobytes to every single request that the client makes.  The bandwidth\nusage will add up quickly, and your app will be known as a bandwidth hog.  However, there are some fields that are pretty universal.  Your JWT should always have the following fields:   sub = Subject (the identifier for the token)  exp = Expiry (when the token expires)  nbf = Not Before (the earliest point in time the token is valid)  iss = Issuer (the site that issued the token)  aud = Audience (who is the token for)   The timestamps (exp and nbf) are all UNIX timestamps (i.e. the number of seconds since January 1, 1970).  App Service adds to this:   stable_sid = Security Id of the user  idp = the IdP that was used in the authentication request  ver = the Version of the token   App Service will be able to validate any token provided to it when presented in an X-ZUMO-AUTH header.  If you are\nusing Azure Active Directory, you can also use the more standard Bearer Authorization header.  If the token does\nnot match, then the X-ZUMO-AUTH header will be stripped from the request before the request is passed to your site.",
            "title": "What is in a JWT"
        },
        {
            "location": "/chapter2/debugging/#testing-authentication-without-a-client",
            "text": "Testing authentication against your App Service without a client requires a REST client.  I use  Postman ,\nwhich is based on Google Chrome.  If you use Firefox, you might want to take a look at  RESTClient .  Telerik\nalso distributes a web debugging proxy called  Fiddler  that can do API testing.  To test the server, we will\nneed a token.  We can get one by testing authentication configuration by pointing the browser to  /.auth/login/aad .\nThe return URL will contain a token in the query string and as  a secure cookie .   Tip  You can test any of the supported identity providers by replacing  aad  with the authentication provider name: facebook ,  google ,  microsoftaccount  and  twitter  are possibilities here.   We can then do a request to  /tables/todoitem  to try and obtain the list of current tasks.  We will need to add\ntwo headers:   ZUMO-API-VERSION  should contain a value of  2.0.0 .  X-ZUMO-AUTH  should contain the token you received.   My first request shows authentication failing:   Go through one of the authentication flows and copy the authentication token.  In Postman, add a new header called X-ZUMO-AUTH  and paste the authentication token in.   Note that we have tested all this without touching the client.  Separating the backend operations from the client\noperations means we can be sure of where the inevitable bug that creeps in is located.  We have verified that we\ncan do each authentication flow on the server side and that the server is properly rejecting unauthenticated requests,\nplus it is properly returning data when authenticated requests are issued.",
            "title": "Testing Authentication without a Client"
        },
        {
            "location": "/chapter2/debugging/#developing-locally",
            "text": "One would normally be able to run the ASP.NET backend locally and get full functionality without authentication.\nHowever, authentication puts a stop to that because the redirect URLs, secrets and other authentication configuration\nsettings only work with a known endpoint.  To alleviate that, Azure Mobile Apps allows you to run a local server while\nusing an authentication endpoint in Azure App Service.  When the authentication transaction takes place, it is taking\nplace against the Azure App Service.   When it is not doing the OAuth transaction, however, it is operating against a\nlocal server.  Setting this up requires a little bit of local machine configuration and a change to the configuration of your client.",
            "title": "Developing Locally"
        },
        {
            "location": "/chapter2/debugging/#update-your-local-development-environment",
            "text": "The first step in this process is to make your local IIS development environment look more like the Azure App Service,\nparticularly in reference to the authentication settings.  This means setting up a few app settings that should be\npulled from your App Service.   Log on to the  Azure Portal .  Select your App Service from the  App Services  list.  Click on  Tools , then  Advanced Tools , then  Go .   Kudu (now known as  Advanced Tools  in the Azure portal menu) is the backend debug console for Azure App Service and\nthere is a lot you can do here.  Of note in this instance is that you can gain access to the keys and audience for your\nApp Service.   Click on  Environment  in the top banner.  Click on  Environment variables .  Scroll down to the environment variables starting with  WEBSITE_AUTH .  Make a note of the  WEBSITE_AUTH_SIGNING_KEY  and  WEBSITE_AUTH_ALLOWED_AUDIENCES  values.   Add the following to your project Web.config  <appSettings>  section:    <appSettings>\n    <add key=\"PreserveLoginUrl\" value=\"true\" />\n    <add key=\"MS_SigningKey\" value=\"Overridden by portal settings\" />\n    <add key=\"EMA_RuntimeUrl\" value=\"Overridden by portal settings\" />\n    <add key=\"MS_NotificationHubName\" value=\"Overridden by portal settings\" />\n    <add key=\"SigningKey\" value=\"{Your WEBSITE_AUTH_SIGNING_KEY}\"/>\n    <add key=\"ValidAudience\" value=\"{Your WEBSITE_AUTH_ALLOWED_AUDIENCES}\"/>\n    <add key=\"ValidIssuer\" value=\"https://{Your WEBSITE_HOSTNAME}/\"/>\n  </appSettings>   Tip  Both the ValidAudience and ValidIssuer will have a slash on the end and be a https URL.   The last three keys are the keys you will need to add.  Make sure you do not have a  HostName  key as this is how\nthe startup file determines if you are running locally or remote. Talking of which, edit your App_Start\\Startup.MobileApp.cs  file to include the following:          public static void ConfigureMobileApp(IAppBuilder app)\n        {\n            HttpConfiguration config = new HttpConfiguration();\n\n            new MobileAppConfiguration()\n                .AddTablesWithEntityFramework()\n                .ApplyTo(config);\n\n            // Use Entity Framework Code First to create database tables based on your DbContext\n            Database.SetInitializer(new MobileServiceInitializer());\n\n            MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();\n\n            if (string.IsNullOrEmpty(settings.HostName))\n            {\n                app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions\n                {\n                    SigningKey = ConfigurationManager.AppSettings[\"SigningKey\"],\n                    ValidAudiences = new[] { ConfigurationManager.AppSettings[\"ValidAudience\"] },\n                    ValidIssuers = new[] { ConfigurationManager.AppSettings[\"ValidIssuer\"] },\n                    TokenHandler = config.GetAppServiceTokenHandler()\n                });\n            }\n\n            app.UseWebApi(config);\n        }  The  UserAppServiceAuthentication()  method sets up authentication checking.  This section is not required when running\nwithin App Service.  If you are running the server locally, you should either set up a local SQL Server instance and put the connection\nstring into the  Web.config  file, or  open the firewall on your SQL Azure  database so that your local development\nenvironment can connect to it, then place the connection string in the  Web.config .  You can get the connection string\nof the SQL Azure instance by looking at the Connection Strings in the  Application properties  of your App Service.",
            "title": "Update your Local Development Environment"
        },
        {
            "location": "/chapter2/debugging/#update-your-mobile-client",
            "text": "For this demonstration, I have updated the  TaskList.UWP  application so that it is using the server-flow\nauthentication for Azure Active Directory.  This means updating the  LoginAsync()  method in the Services\\UWPLoginProvider.cs  file to be the following:          public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Server-Flow Version\n            await client.LoginAsync(\"aad\");\n        }  This is because the default local IIS instance is IIS Express.  IIS Express only listens for local connections.  If\nyou run a client from another device (for example, the Android emulator on a Hyper-V service or the iOS simulator\non a Mac), then that client would be connecting via a network connection.  You can still debug locally, but you need\nto  convert your environment to IIS  first.  In the  TaskList (Portable)  project, update the  Helpers\\Locations.cs  file:  namespace TaskList.Helpers\n{\n    public static class Locations\n    {\n#if DEBUG\n        public static readonly string AppServiceUrl = \"http://localhost:17568/\";\n        public static readonly string AlternateLoginHost = \"https://the-book.azurewebsites.net\";\n#else\n        public static readonly string AppServiceUrl = \"https://the-book.azurewebsites.net\";\n        public static readonly string AlternateLoginHost = null;\n#endif\n    }\n}  The  AppServiceUrl  is always set to the location of your backend.  In this case, I right-clicked on the  Backend \nproject and selected  Properties  then  Web .  The correct URL for local debugging is listed in the Project URL .  The  AlternateLoginHost  is set to the App Service when locally debugging or null if not. You can\nspecify the  DEBUG  constant in the  Build  tab.  In the same project, update the  Services\\AzureCloudService.cs  constructor to the following:          public AzureCloudService()\n        {\n            client = new MobileServiceClient(Locations.AppServiceUrl);\n            if (Locations.AlternateLoginHost != null)\n                client.AlternateLoginHost = new Uri(Locations.AlternateLoginHost);\n        }   Tip  It's a good idea to separate the client and server into different solutions.  Although it doesn't hurt anything to\nhave them in the same solution (like we have), having the client and server separated allows you to attach a debugger\nseparately - which allows you to debug both sides of the connection at the same time.   With these settings, the client will contact the AlternateLoginHost listed for the authentication process and then\ncontact the local server for the rest of the transaction.",
            "title": "Update your Mobile Client"
        },
        {
            "location": "/chapter2/debugging/#run-the-local-server",
            "text": "Running the local server and the client takes a larger machine.  You need to run two instances of Visual Studio: one\nfor the client and one for the server. This is really where you will appreciate multiple monitors (my personal favorite)\nor the snap action to the sides of the screens.  Ensure you have your backend and clients in different solutions if you intend to run both client and server.  The\ndebugger in Visual Studio will stop one to run the other when they are in the same solution.",
            "title": "Run the Local Server"
        },
        {
            "location": "/chapter2/custom/",
            "text": "Custom authentication\n\u00b6\n\n\nFor some situations, the social or enterprise flows are not valid for the mobile client.  Perhaps you want the ability\nto provide a sign-up process with a username and password rather than using a social provider.  Perhaps you want to use\nan alternate provider that is not one of the supported five providers.  Whatever the reason, Azure App Service provides\nthe ability to handle all situations.  In this section, I will look at three methods for providing a unique set of\nusernames with no connection to the social or enterprise authentication.\n\n\nUsing an Identity Database.\n\u00b6\n\n\nProbably the most common request is to use a custom identity database.  In general, this is desirable because you\nalready have a database of usernames and password.  However, it's probably the least desirable option because of the\nsecurity concerns that come along with this technique.  The news is rife with password leakage for very large\norganizations.  The best way to ensure you do not disclose a users password is to not have it in the first place.\n\n\n\n\nWarn\n\n\nI'm not going to cover the sign-up case here.  This would be an additional process and would use a regular Web API\nto insert data into the database after validation (and probably verification via email or text message).\n\n\n\n\nThe first thing we need to add to our project is a model for the user object.  I created the following in the \nModels\n\nfolder of the \nBackend\n project:\n\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace Backend.Models\n{\n    public class User\n    {\n        [Key]\n        public int Id { get; set; }\n\n        public string Username { get; set; }\n\n        public string Password { get; set; }\n    }\n}\n\n\n\n\nWe also need to modify the \nMobileServiceContext.cs\n file so that the database table is included in the Entity Framework\ncontext:\n\n\n    public class MobileServiceContext : DbContext\n    {\n        private const string connectionStringName = \"Name=MS_TableConnectionString\";\n\n        public MobileServiceContext() : base(connectionStringName)\n        {\n        }\n\n        public DbSet<TodoItem> TodoItems { get; set; }\n        public DbSet<User> Users { get; set; }\n\n        protected override void OnModelCreating(DbModelBuilder modelBuilder)\n        {\n            modelBuilder.Conventions.Add(\n                new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n                    \"ServiceTableColumn\", (property, attributes) => attributes.Single().ColumnType.ToString()));\n        }\n    }\n\n\n\n\nFinally, we probably want to put some seed data into the database when it is first created so that we can test it.\nAdjust the \nMobileServiceInitializer\n in the \nStartup.MobileApp.cs\n file:\n\n\n        protected override void Seed(MobileServiceContext context)\n        {\n            List<TodoItem> todoItems = new List<TodoItem>\n            {\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"First item\", Complete = false },\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"Second item\", Complete = false }\n            };\n\n            foreach (TodoItem todoItem in todoItems)\n            {\n                context.Set<TodoItem>().Add(todoItem);\n            }\n\n            List<User> users = new List<User>\n            {\n                new User { Id = 1, Username = \"adrian\", Password = \"supersecret\" }\n            };\n\n            foreach (User user in users)\n            {\n                context.Set<User>().Add(user);\n            }\n\n            base.Seed(context);\n        }\n\n\n\n\nNote that we are storing the passwords in plain text.  This is most definitely frowned upon.  We should be using some\nsort of encryption.  This code is most definitely just for demonstration purposes.  Continuing the code on the backend,\nwe need to handle the request to authenticate from the client.  We will use a custom API controller for this; it is\nlocated in \nControllers\\CustomAuthController.cs\n:\n\n\nusing System;\nusing System.IdentityModel.Tokens;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Web.Http;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server.Login;\nusing Newtonsoft.Json;\n\nnamespace Backend.Controllers\n{\n    [Route(\".auth/login/custom\")]\n    public class CustomAuthController : ApiController\n    {\n        private MobileServiceContext db;\n        private string signingKey, audience, issuer;\n\n        public CustomAuthController()\n        {\n            db = new MobileServiceContext();\n            signingKey = Environment.GetEnvironmentVariable(\"WEBSITE_AUTH_SIGNING_KEY\");\n            var website = Environment.GetEnvironmentVariable(\"WEBSITE_HOSTNAME\");\n            audience = $\"https://{website}/\";\n            issuer = $\"https://{website}/\";\n        }\n\n        [HttpPost]\n        public IHttpActionResult Post([FromBody] User body)\n        {\n            if (body == null || body.Username == null || body.Password == null ||\n                body.Username.Length == 0 || body.Password.Length == 0)\n            {\n                return BadRequest(); ;\n            }\n\n            if (!IsValidUser(body))\n            {\n                return Unauthorized();\n            }\n\n            var claims = new Claim[]\n            {\n                new Claim(JwtRegisteredClaimNames.Sub, body.Username)\n            };\n\n            JwtSecurityToken token = AppServiceLoginHandler.CreateToken(\n                claims, signingKey, audience, issuer, TimeSpan.FromDays(30));\n            return Ok(new LoginResult()\n            {\n                AuthenticationToken = token.RawData,\n                User = new LoginResultUser { UserId = body.Username }\n            });\n        }\n\n        protected override void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                db.Dispose();\n            }\n            base.Dispose(disposing);\n        }\n\n        private bool IsValidUser(User user)\n        {\n            return db.Users.Count(u => u.Username.Equals(user.Username) && u.Password.Equals(user.Password)) > 0;\n        }\n    }\n\n    public class LoginResult\n    {\n        [JsonProperty(PropertyName = \"authenticationToken\")]\n        public string AuthenticationToken { get; set; }\n\n        [JsonProperty(PropertyName = \"user\")]\n        public LoginResultUser User { get; set; }\n    }\n\n    public class LoginResultUser\n    {\n        [JsonProperty(PropertyName = \"userId\")]\n        public string UserId { get; set; }\n    }\n}\n\n\n\n\nThere is a lot going on here:\n\n\n\n\nThe constructor reads the signing key and other information that we need for constructing the JWT.  Note that the\n  signing key is only available if you have the Authentication / Authorization is turned on.\n\n\nThe \nLoginResult\n and \nLoginResultUser\n provide the response to the client, when serialized by the JSON serializer.\n\n\nThe \nPost()\n method is where the work happens.  It verifies that you have a valid object, then checks that the\n  username and password match something in the user database.  It then constructs the JWT and returns the required\n  JSON object.\n\n\nThe \nIsValidUser()\n method actually validates the username and password provided in the request with the users in\n  the database.  This version is very simplistic.  I expect your version to at least include encryption of the password.\n\n\n\n\n\n\nWarn\n\n\nYou must turn on Authentication / Authorization in your App Service.  Set the \nAction to take when request\nis not authenticated\n to \nAllow Request (no action)\n and do not configure any of the supported authentication\nproviders.\n\n\n\n\nYou can add additional claims in the token that is passed back to the client by adding additional rows to the \nclaims\n\nobject.  For example:\n\n\n    var claims = new Claim[]\n    {\n        new Claim(JwtRegisteredClaimNames.Sub, body.Username),\n        new Claim(\"foo\", \"Value for Foo\")\n    };\n\n\n\n\nFor example, you could do a custom authentication that includes group information, permissions structures, or\nadditional information about the user from the directory.  Claim names are normally three letters and the value\nis always a string.  It is normal to create a class (just like the \nJwtRegisteredClaimNames\n) with the strings\nin it that can be shared between the client and server projects:\n\n\npublic static class LocalClaimNames\n{\n    public string MainUser => \"mus\"\n};\n\n\n\n\nThe only claim that \nmust\n be present is the \"sub\" claim (referenced here by \nJwtRegisteredClaimNames.Sub\n claim\ntype).  The token, when encoded, must fit in a HTTP header.  For Windows systems based on IIS, the maximum size\nof a header is 16Kb.  For Linux systems based on Apache, the maximum size of a header is 8Kb.  The server will\nreturn \n413 Entity Too Large\n if the header is too long.  The token is also transmitted with every single\nrequest so you should make efforts to reduce the size of the token.  It is better to make two requests initially\n(one request for the token followed by an authenticated request for the extra information) than to include the\nextra information in the token.\n\n\nNext, we need to wire the custom authentication controller so that it appears in the same place as all the other\nauthenticators.  We are going to access it via the \n/.auth/login/custom\n endpoint.  The normal ASP.NET methods can be\napplied for this.  In this project, we can enable \nattribute routing\n:\n\n\npublic static void ConfigureMobileApp(IAppBuilder app)\n{\n    HttpConfiguration config = new HttpConfiguration();\n\n    new MobileAppConfiguration()\n        .AddTablesWithEntityFramework()\n        .ApplyTo(config);\n\n    // Map routes by attribute\n    config.MapHttpAttributeRoutes();\n\n    // Use Entity Framework Code First to create database tables based on your DbContext\n    Database.SetInitializer(new MobileServiceInitializer());\n\n    MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();\n\n    if (string.IsNullOrEmpty(settings.HostName))\n    {\n        app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions\n        {\n            SigningKey = ConfigurationManager.AppSettings[\"SigningKey\"],\n            ValidAudiences = new[] { ConfigurationManager.AppSettings[\"ValidAudience\"] },\n            ValidIssuers = new[] { ConfigurationManager.AppSettings[\"ValidIssuer\"] },\n            TokenHandler = config.GetAppServiceTokenHandler()\n        });\n    }\n\n    app.UseWebApi(config);\n}\n\n\n\n\nAt this point, we can deploy the backend to the App Service and send a suitably formed POST request to\nthe backend.  I use [Postman][19] for this purpose. The request:\n\n\n\n\nA successful POST will return the token and user ID in the response:\n\n\n\n\nAny other request (such as no body or a wrong username or password) should produce the right response.  If the body is\ncorrect, but the information is wrong, then a 401 Unauthorized response should be produced.  If the body is invalid, then\n400 Bad Request should be produced.\n\n\n\n\nInfo\n\n\nThe format of the response is exactly the same as the token response we saw earlier when we were discussing\nthe contents of a JWT.\n\n\n\n\nWe can now turn our attention to the mobile client.  Custom Authentication is always implemented using a client-flow\nmechanism. To implement this, we are going to adjust the entry page so that the username and password fields are\ndisplayed.  The gathered username and password will then be passed to a new ICloudService \nLoginAsync()\n method.\nAll of the UI work is done in the shared project.\n\n\nTo start, we need a copy of the \nUser.cs\n model from the backend project.  Unlike Data Transfer Objects, this model is\nthe same:\n\n\nnamespace TaskList.Models\n{\n    public class User\n    {\n        public string Username { get; set; }\n        public string Password { get; set; }\n    }\n}\n\n\n\n\nThe abstraction we use for the cloud service needs to be adjusted so that we can pass the user object into the login\nmethod.  This is the \nAbstractions\\ICloudService.cs\n interface:\n\n\nusing System.Threading.Tasks;\nusing TaskList.Models;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n\n        Task LoginAsync(User user);\n    }\n}\n\n\n\n\nI am adding a new version of the \nLoginAsync()\n method.  The concrete version of this method no longer has to go\nthrough the dependency service since I can use shared code.  Here is the definition of our new \nLoginAsync()\n\nmethod in \nServices\\AzureCloudService.cs\n:\n\n\n        public Task LoginAsync(User user)\n        {\n            return client.LoginAsync(\"custom\", JObject.FromObject(user));\n        }\n\n\n\n\nFinally, we need to update the view-model \nViewModels\\EntryPageViewModel.cs\n so that we can store the username and\npassword in the model.  We will also update the call to the \nLoginAsync()\n method of the cloud service so it calls\nour new method:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class EntryPageViewModel : BaseViewModel\n    {\n        public EntryPageViewModel()\n        {\n            Title = \"Task List\";\n            User = new Models.User { Username = \"\", Password = \"\" };\n        }\n\n        Command loginCmd;\n        public Command LoginCommand => loginCmd ?? (loginCmd = new Command(async () => await ExecuteLoginCommand()));\n\n        public Models.User User { get; set; }\n\n        async Task ExecuteLoginCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                var cloudService = ServiceLocator.Instance.Resolve<ICloudService>();\n                await cloudService.LoginAsync(User);\n                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[ExecuteLoginCommand] Error = {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}\n\n\n\n\nThere are three new pieces here.  Firstly, we have the User property (for holding the username and password in our\nform).  Next, the constructor initializes the user object to an empty object.  Finally, the call to \nLoginAsync()\n\npasses the user object to the cloud service.\n\n\nWe also need some UI changes.  Specifically, we need a couple of fields for the username and password added to the\n\nPages\\EntryPage.xaml\n file:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage x:Class=\"TaskList.Pages.EntryPage\"\n             xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <StackLayout HorizontalOptions=\"Center\"\n                     Orientation=\"Vertical\"\n                     VerticalOptions=\"Center\">\n            <Label Text=\"Username?\" />\n            <Entry Text=\"{Binding User.Username}\" />\n            <Label Text=\"Password?\" />\n            <Entry IsPassword=\"True\" Text=\"{Binding User.Password}\" />\n\n            <Button BackgroundColor=\"Teal\"\n                    BorderRadius=\"10\"\n                    Command=\"{Binding LoginCommand}\"\n                    Text=\"Enter The App\"\n                    TextColor=\"White\" />\n        </StackLayout>\n    </ContentPage.Content>\n</ContentPage>\n\n\n\n\nThere is lots to complain about in this demonstration (including lack of encryption, storage of passwords, and a\ngenerally bad UI).  However, it serves to demonstrate the salient points for using a (perhaps pre-existing) identity\ndatabase for authentication of the users.\n\n\nUsing Azure Active Directory B2C\n\u00b6\n\n\nCustom authentication allows you to really customize the process, but I like to reduce the amount of code I write by\nusing services or libraries.   The whole sign-in and sign-up process is ripe for this.  The code needed for building\nthe sign-in / sign-up process is boiler-plate code.  It also introduces problems that I have to deal with going forward.\nI have to store passwords and profile information, which introduces a security concern.  I have to scale the database\nand ensure my app scales with it as my app gets popular.  Finally, I am being fairly inflexible and causing potential\nprivacy concerns with my users.\n\n\nThere are a couple of services that I can use to get around these concerns.  The first is an Azure service:\n\nAzure Active Directory B2C\n.  The B2C stands for Business to Consumer.  It is a mechanism by which you can add a\nsign-in and sign-up flow to your application.  The user can enter a username or password, or, at your option, add on\nsupport for one or more social providers.  In addition, there is support for branding the sign-in process, doing email\nverification of sign-ups and automatic password resets via email.  The Azure AD B2C sign-in / sign-up process is\nprimarily a server-flow proecss, so we will be able to add support in our app with just one line of code.\n\n\nThe Minimal Setup of Azure AD B2C\n\u00b6\n\n\nAzure AD is managed from the \nClassic Azure Portal\n, so start by logging in using your Azure\nSubscription credentials.\n\n\n\n\nClick on the big \n+ NEW\n button in the bottom left of the screen.\n\n\nSelect \nApp Services\n -> \nActive Directory\n -> \nDirectory\n -> \nCustom Create\n.\n\n\n\n\n\n\n\n\nChoose a name for the tenant, then choose a unique domain name (which will appear in the   \nonmicrosoft.com\n\n  domain) and country.  Ensure you check the \nThis is a B2C directory.\n\n\n\n\n\n\n\n\nClick on the tick to create the directory.  As noted, this process will take a couple of minutes to complete.\n\n\n\n\nThis creates a new tenant for you to manage.  If you go back to your \nAzure Portal\n and click on your name\n(top right corner), you will note that there is a new DIRECTORY entry for your B2C tenant.  This is where you will be\nmanaging your B2C tenant.\n\n\nIt's a good idea to pin the B2C settings blade to your dashboard or navigation pane so you can access it faster.\nTo do this:\n\n\n\n\nLog in to the \nAzure Portal\n.\n\n\nSwitch to your B2C tenant by clicking on your name, then selecting the new tenant in the drop-down.\n\n\nThe portal will probably ask you to confirm your ID and password.\n\n\nClick on \nBrowse>\n in the left-hand navigation bar.\n\n\nSearch for \nB2C\n.\n\n\nClick on the empty star next to \nAzure AD B2C\n.\n\n\n\n\n\n\nThis will make Azure AD B2C appear in your left hand navigation bar.  To place it on the dashboard, click on\n\nAzure AD B2C\n in the left hand navigation bar, then click on the pin at the top of the \nAZURE AD B2C SETTINGS\n\nblade.\n\n\nThe next job is to create an application registration within the B2C tenant:\n\n\n\n\nOpen the \nAzure AD B2C\n from your dashboard or the left hand navigation.\n\n\nIn the \nSettings\n blade, click on \nApplications\n.\n\n\n\n\n\n\n\n\nIn the \nNew application\n blade:\n\n\nEnter a unique name for the application.\n\n\nClick on \nYes\n under \nInclude web app / web API\n.\n\n\nIn the Reply URL, enter \nhttps://yoursite.azurewebsites.net/.auth/login/aad/callback\n.\n\n\nClick on \nGenerate key\n - a key will be generated (cut and paste it somewhere).\n\n\n\n\n\n\n\n\nClick on \nCreate\n.\n\n\n\n\nThere is no spinner or deployment here.  After approximately 5-10 seconds, the application registration will appear\nin the list.  Click on the application registration to see the \nApplication ID\n:\n\n\n\n\nYou will need the Application ID and App Key (which you copied earlier) later on.  The next step is to create a\nSign-in/Sign-up policy.  We'll create a policy for signing up with an email address and email confirmation, then\nsigning in with that email address:\n\n\n\n\nIn the \nSettings\n blade, click on \nSign-up or sign-in policies\n.\n\n\nClick on the \n+ Add\n button.\n\n\nGive the policy a name, like \nemailPolicy\n.\n\n\nClick on \nIdentity providers\n:\n\n\nClick on \nEmail signup / Local Account\n (a tick will appear next to the row).\n\n\nClick on \nOK\n.\n\n\nClick on \nSign-up attributes\n:\n\n\nClick on \nEmail Address\n and any other fields you want to gather.\n\n\nClick on \nOK\n.\n\n\nClick on \nApplication claims\n:\n\n\nClick on \nEmail Addresses\n and any other fields you want to provide to the application.\n\n\nClick on \nOK\n\n\nClick on \nCreate\n on the \nAdd policy\n blade.\n\n\nClick on the policy you just created.  It will be named something like \nB2C_1_emailPolicy\n. Make a note of the\n\nMetadata Endpoint for this policy\n.\n\n\n\n\n\n\nNow that your B2C tenant is configured, you can switch back to your original tenant (by clicking on your name in\nthe top-right corner and selecting the default directory).\n\n\nTo configure the App Service \nAuthentication / Authorization\n.  Open up the \nSettings\n blade, then\n\nAuthentication / Authorization\n.  Ensure the authentication service is turned on.  Click on\n\nAzure Active Directory\n. This time, we are going to select the \nAdvanced\n option.  The \nClient ID\n is\nthe application ID of your B2C application registration, and the \nIssuer Url\n is the \nMetadata Endpoint\n\nfor your sign-up policy:\n\n\n\n\nClick on \nOK\n to configure the authentication server flow, the \nSave\n to save the settings.  As before, you\ncan test your server flow by pointing your browser to \nhttps://yoursite.azurewebsites.net/.auth/login/aad\n:\n\n\n\n\nIf you have done everything right, you should be able to register an account, get the email verification code,\nand finally log in to get the happy login page.\n\n\n\n\nAll that is left to do is to configure your app for Azure Active Directory Server Flow.  We did that earlier when\ndiscussing the Enterprise Authentication flow for the mobile client.\n\n\nDrawbacks of Azure Active Directory B2C\n\u00b6\n\n\nAzure AD B2C is great for storing your users passwords and doing the sign-up and sign-in process for you.  There\nare a couple of reasons why you wouldn't want to use Azure Active Directory B2C.\n\n\nThe most obvious one is that this is built on Azure Active Directory.  That means you won't be able to, for example,\nintegrate the Facebook, Google and Twitter identity providers by utilizing their client libraries.  You also do\nnot get access to the underlying identity provider token, so you are restricted from accessing the Graph API for\nthe individual providers.  Finally, since the AAD B2C identity provider is configured with the AAD provider, you\ncan't use both a B2C provider and a regular AAD provider.\n\n\nIf you just want a sign-up / sign-in flow, then AAD B2C is probably the best way to go.  If, however, your plans\ninclude integration with other social identity providers, you should consider using the identity providers\ndirectly or via separate configuration with the Azure App Service Authentication / Authorization.\n\n\nUsing Third Party Tokens\n\u00b6\n\n\nThe final method of authenticating a user we are going to look at is a process by which you use a third party\nauthentication token.   For example, you may want to authenticate via \nGitHub\n or \nmiiCard\n or using\nan authentication provider like \nAuth0\n to get some single sign-in capabilities.\n\n\nAuthentication with third party tokens works remarkably similar to the custom authentication case.  Instead of\na username and password, you pass in the token from the other provider.\n\n\nTo look at this in example form, we are going to implement Auth0 as a provider. Your first stop should be the\n\nAuth0\n web site to sign up for a developer account. Once you have done that:\n\n\n\n\nClick on the \n+ NEW CLIENT\n button in the \nDashboard\n.\n\n\nGive your app a name, then click on \nNative\n and then \nCREATE\n.\n\n\n\n\n\n\n\n\nClick on the \nXamarin\n icon to get the Xamarin Quickstart.\n\n\nClick on \nSettings\n.\n\n\nEnter the callback URL in the \nAllowed Callback URLs\n.  The callback URL will be something like\n  \nhttps://_youraccount_.auth0.com/mobile\n and will be listed in the Quickstart page.\n\n\nScroll down to the bottom of the page and click on \nSAVE CHANGES\n.\n\n\nMake a note of the Client ID of the application.  You will need it later.\n\n\nClick on \nConnections\n.\n\n\nTurn on any connections that you want to use.  For this example, ensure you turn on the\n\nUsername-Password-Authentication\n and a couple of social providers.\n\n\n\n\nNow that the Auth0 service is configured, we can turn our attention to the mobile client.  The Xamarin.Auth0Client\nis a component, so right-click on the \nComponents\n node of a platform project and select \nGet More Components...\n.\nIn the dialog, find the \nAuth0 SDK\n, then click on \nAdd to App\n.\n\n\nFor our iOS application, we are going to integrate Auth0 into the \nServices\\iOSLoginProvider.cs\n:\n\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginAuth0Async();\n\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"auth0\", zumoPayload);\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n\n        public async Task<string> LoginAuth0Async()\n        {\n            var auth0 = new Auth0.SDK.Auth0Client(\n                \"shellmonger.auth0.com\",\n                \"lmFp5jXnwPpD9lQIYwgwwPmFeofuLpYq\");\n            var user = await auth0.LoginAsync(RootView, scope: \"openid email\");\n            return user.Auth0AccessToken;\n        }\n\n\n\n\nThe parameters for the constructor to the \nAuth0Client\n are your Auth0 domain and client ID.  You can retrieve these\nfrom the Auth0 management page for your app.  Note that I am requesting the email address.  This will become a part\nof my ZUMO token when I create it.\n\n\nSwitching our attention to our \nBackend\n project, we need a new custom authentication controller.  This is located\nin \nControllers\\Auth0Controller.cs\n:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.IdentityModel.Tokens;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Web.Http;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server.Login;\n\nnamespace Backend.Controllers\n{\n    [Route(\".auth/login/auth0\")]\n    public class Auth0Controller : ApiController\n    {\n        private JwtSecurityTokenHandler tokenHandler;\n        private string clientID, domain;\n        private string signingKey, audience, issuer;\n\n        public Auth0Controller()\n        {\n            // Information for the incoming Auth0 Token\n            domain = Environment.GetEnvironmentVariable(\"AUTH0_DOMAIN\");\n            clientID = Environment.GetEnvironmentVariable(\"AUTH0_CLIENTID\");\n\n            // Information for the outgoing ZUMO Token\n            signingKey = Environment.GetEnvironmentVariable(\"WEBSITE_AUTH_SIGNING_KEY\");\n            var website = Environment.GetEnvironmentVariable(\"WEBSITE_HOSTNAME\");\n            audience = $\"https://{website}/\";\n            issuer = $\"https://{website}/\";\n\n            // Token Handler\n            tokenHandler = new JwtSecurityTokenHandler();\n        }\n\n        [HttpPost]\n        public IHttpActionResult Post([FromBody] Auth0User body)\n        {\n            if (body == null || body.access_token == null || body.access_token.Length == 0)\n            {\n                return BadRequest();\n            }\n\n            try\n            {\n                var token = (JwtSecurityToken)tokenHandler.ReadToken(body.access_token);\n                if (!IsValidUser(token))\n                {\n                    return Unauthorized();\n                }\n\n                var subject = token.Claims.FirstOrDefault(c => c.Type.Equals(\"sub\"))?.Value;\n                var email = token.Claims.FirstOrDefault(c => c.Type.Equals(\"email\"))?.Value;\n                if (subject == null || email == null)\n                {\n                    return BadRequest();\n                }\n\n                var claims = new Claim[]\n                {\n                    new Claim(JwtRegisteredClaimNames.Sub, subject),\n                    new Claim(JwtRegisteredClaimNames.Email, email)\n                };\n\n                JwtSecurityToken zumoToken = AppServiceLoginHandler.CreateToken(\n                    claims, signingKey, audience, issuer, TimeSpan.FromDays(30));\n                return Ok(new LoginResult()\n                {\n                    AuthenticationToken = zumoToken.RawData,\n                    User = new LoginResultUser { UserId = email }\n                });\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"Auth0 JWT Exception = {ex.Message}\");\n                throw ex;\n            }\n        }\n\n        private bool IsValidUser(JwtSecurityToken token)\n        {\n            if (token == null)\n                return false;\n            var audience = token.Audiences.FirstOrDefault();\n            if (!audience.Equals(clientID))\n                return false;\n            if (!token.Issuer.Equals($\"https://{domain}/\"))\n                return false;\n            if (token.ValidTo.AddMinutes(5) < DateTime.Now)\n                return false;\n            return true;\n        }\n    }\n\n    public class Auth0User\n    {\n        public string access_token { get; set; }\n    }\n}\n\n\n\n\nNote that we are reading two new environment variables.  In the Azure App Service, you can read Application Settings\nby reading the environment variable of the same name.  We need to set the \nAUTH0_CLIENTID\n to the Client ID of\nour Auth0 application, and the \nAUTH0_DOMAIN\n to the domain of our account.  Both of these values need to match\nthe settings in the client.  These are not \"secure items\".  If using the client secret (to validate the token), then\nthat would be considered secure and should only appear on the server side.\n\n\nThe validation is that the token passed in is valid (i.e. it has the right audience, issuer and expiry times).  In\naddition, you should check the validity of the token signature.  You can do this by acquiring the token secret and\nusing \ntokenHandler.ValidateToken()\n instead of \ntokenHandler.ReadToken()\n.  My new token lasts for 30 days.  The\nZUMO token that is generated in custom authentication does not have to be the same length as the original token.\nYou can make it last for as long as you like.",
            "title": "Custom Authentication"
        },
        {
            "location": "/chapter2/custom/#custom-authentication",
            "text": "For some situations, the social or enterprise flows are not valid for the mobile client.  Perhaps you want the ability\nto provide a sign-up process with a username and password rather than using a social provider.  Perhaps you want to use\nan alternate provider that is not one of the supported five providers.  Whatever the reason, Azure App Service provides\nthe ability to handle all situations.  In this section, I will look at three methods for providing a unique set of\nusernames with no connection to the social or enterprise authentication.",
            "title": "Custom authentication"
        },
        {
            "location": "/chapter2/custom/#using-an-identity-database",
            "text": "Probably the most common request is to use a custom identity database.  In general, this is desirable because you\nalready have a database of usernames and password.  However, it's probably the least desirable option because of the\nsecurity concerns that come along with this technique.  The news is rife with password leakage for very large\norganizations.  The best way to ensure you do not disclose a users password is to not have it in the first place.   Warn  I'm not going to cover the sign-up case here.  This would be an additional process and would use a regular Web API\nto insert data into the database after validation (and probably verification via email or text message).   The first thing we need to add to our project is a model for the user object.  I created the following in the  Models \nfolder of the  Backend  project:  using System.ComponentModel.DataAnnotations;\n\nnamespace Backend.Models\n{\n    public class User\n    {\n        [Key]\n        public int Id { get; set; }\n\n        public string Username { get; set; }\n\n        public string Password { get; set; }\n    }\n}  We also need to modify the  MobileServiceContext.cs  file so that the database table is included in the Entity Framework\ncontext:      public class MobileServiceContext : DbContext\n    {\n        private const string connectionStringName = \"Name=MS_TableConnectionString\";\n\n        public MobileServiceContext() : base(connectionStringName)\n        {\n        }\n\n        public DbSet<TodoItem> TodoItems { get; set; }\n        public DbSet<User> Users { get; set; }\n\n        protected override void OnModelCreating(DbModelBuilder modelBuilder)\n        {\n            modelBuilder.Conventions.Add(\n                new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n                    \"ServiceTableColumn\", (property, attributes) => attributes.Single().ColumnType.ToString()));\n        }\n    }  Finally, we probably want to put some seed data into the database when it is first created so that we can test it.\nAdjust the  MobileServiceInitializer  in the  Startup.MobileApp.cs  file:          protected override void Seed(MobileServiceContext context)\n        {\n            List<TodoItem> todoItems = new List<TodoItem>\n            {\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"First item\", Complete = false },\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"Second item\", Complete = false }\n            };\n\n            foreach (TodoItem todoItem in todoItems)\n            {\n                context.Set<TodoItem>().Add(todoItem);\n            }\n\n            List<User> users = new List<User>\n            {\n                new User { Id = 1, Username = \"adrian\", Password = \"supersecret\" }\n            };\n\n            foreach (User user in users)\n            {\n                context.Set<User>().Add(user);\n            }\n\n            base.Seed(context);\n        }  Note that we are storing the passwords in plain text.  This is most definitely frowned upon.  We should be using some\nsort of encryption.  This code is most definitely just for demonstration purposes.  Continuing the code on the backend,\nwe need to handle the request to authenticate from the client.  We will use a custom API controller for this; it is\nlocated in  Controllers\\CustomAuthController.cs :  using System;\nusing System.IdentityModel.Tokens;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Web.Http;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server.Login;\nusing Newtonsoft.Json;\n\nnamespace Backend.Controllers\n{\n    [Route(\".auth/login/custom\")]\n    public class CustomAuthController : ApiController\n    {\n        private MobileServiceContext db;\n        private string signingKey, audience, issuer;\n\n        public CustomAuthController()\n        {\n            db = new MobileServiceContext();\n            signingKey = Environment.GetEnvironmentVariable(\"WEBSITE_AUTH_SIGNING_KEY\");\n            var website = Environment.GetEnvironmentVariable(\"WEBSITE_HOSTNAME\");\n            audience = $\"https://{website}/\";\n            issuer = $\"https://{website}/\";\n        }\n\n        [HttpPost]\n        public IHttpActionResult Post([FromBody] User body)\n        {\n            if (body == null || body.Username == null || body.Password == null ||\n                body.Username.Length == 0 || body.Password.Length == 0)\n            {\n                return BadRequest(); ;\n            }\n\n            if (!IsValidUser(body))\n            {\n                return Unauthorized();\n            }\n\n            var claims = new Claim[]\n            {\n                new Claim(JwtRegisteredClaimNames.Sub, body.Username)\n            };\n\n            JwtSecurityToken token = AppServiceLoginHandler.CreateToken(\n                claims, signingKey, audience, issuer, TimeSpan.FromDays(30));\n            return Ok(new LoginResult()\n            {\n                AuthenticationToken = token.RawData,\n                User = new LoginResultUser { UserId = body.Username }\n            });\n        }\n\n        protected override void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                db.Dispose();\n            }\n            base.Dispose(disposing);\n        }\n\n        private bool IsValidUser(User user)\n        {\n            return db.Users.Count(u => u.Username.Equals(user.Username) && u.Password.Equals(user.Password)) > 0;\n        }\n    }\n\n    public class LoginResult\n    {\n        [JsonProperty(PropertyName = \"authenticationToken\")]\n        public string AuthenticationToken { get; set; }\n\n        [JsonProperty(PropertyName = \"user\")]\n        public LoginResultUser User { get; set; }\n    }\n\n    public class LoginResultUser\n    {\n        [JsonProperty(PropertyName = \"userId\")]\n        public string UserId { get; set; }\n    }\n}  There is a lot going on here:   The constructor reads the signing key and other information that we need for constructing the JWT.  Note that the\n  signing key is only available if you have the Authentication / Authorization is turned on.  The  LoginResult  and  LoginResultUser  provide the response to the client, when serialized by the JSON serializer.  The  Post()  method is where the work happens.  It verifies that you have a valid object, then checks that the\n  username and password match something in the user database.  It then constructs the JWT and returns the required\n  JSON object.  The  IsValidUser()  method actually validates the username and password provided in the request with the users in\n  the database.  This version is very simplistic.  I expect your version to at least include encryption of the password.    Warn  You must turn on Authentication / Authorization in your App Service.  Set the  Action to take when request\nis not authenticated  to  Allow Request (no action)  and do not configure any of the supported authentication\nproviders.   You can add additional claims in the token that is passed back to the client by adding additional rows to the  claims \nobject.  For example:      var claims = new Claim[]\n    {\n        new Claim(JwtRegisteredClaimNames.Sub, body.Username),\n        new Claim(\"foo\", \"Value for Foo\")\n    };  For example, you could do a custom authentication that includes group information, permissions structures, or\nadditional information about the user from the directory.  Claim names are normally three letters and the value\nis always a string.  It is normal to create a class (just like the  JwtRegisteredClaimNames ) with the strings\nin it that can be shared between the client and server projects:  public static class LocalClaimNames\n{\n    public string MainUser => \"mus\"\n};  The only claim that  must  be present is the \"sub\" claim (referenced here by  JwtRegisteredClaimNames.Sub  claim\ntype).  The token, when encoded, must fit in a HTTP header.  For Windows systems based on IIS, the maximum size\nof a header is 16Kb.  For Linux systems based on Apache, the maximum size of a header is 8Kb.  The server will\nreturn  413 Entity Too Large  if the header is too long.  The token is also transmitted with every single\nrequest so you should make efforts to reduce the size of the token.  It is better to make two requests initially\n(one request for the token followed by an authenticated request for the extra information) than to include the\nextra information in the token.  Next, we need to wire the custom authentication controller so that it appears in the same place as all the other\nauthenticators.  We are going to access it via the  /.auth/login/custom  endpoint.  The normal ASP.NET methods can be\napplied for this.  In this project, we can enable  attribute routing :  public static void ConfigureMobileApp(IAppBuilder app)\n{\n    HttpConfiguration config = new HttpConfiguration();\n\n    new MobileAppConfiguration()\n        .AddTablesWithEntityFramework()\n        .ApplyTo(config);\n\n    // Map routes by attribute\n    config.MapHttpAttributeRoutes();\n\n    // Use Entity Framework Code First to create database tables based on your DbContext\n    Database.SetInitializer(new MobileServiceInitializer());\n\n    MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();\n\n    if (string.IsNullOrEmpty(settings.HostName))\n    {\n        app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions\n        {\n            SigningKey = ConfigurationManager.AppSettings[\"SigningKey\"],\n            ValidAudiences = new[] { ConfigurationManager.AppSettings[\"ValidAudience\"] },\n            ValidIssuers = new[] { ConfigurationManager.AppSettings[\"ValidIssuer\"] },\n            TokenHandler = config.GetAppServiceTokenHandler()\n        });\n    }\n\n    app.UseWebApi(config);\n}  At this point, we can deploy the backend to the App Service and send a suitably formed POST request to\nthe backend.  I use [Postman][19] for this purpose. The request:   A successful POST will return the token and user ID in the response:   Any other request (such as no body or a wrong username or password) should produce the right response.  If the body is\ncorrect, but the information is wrong, then a 401 Unauthorized response should be produced.  If the body is invalid, then\n400 Bad Request should be produced.   Info  The format of the response is exactly the same as the token response we saw earlier when we were discussing\nthe contents of a JWT.   We can now turn our attention to the mobile client.  Custom Authentication is always implemented using a client-flow\nmechanism. To implement this, we are going to adjust the entry page so that the username and password fields are\ndisplayed.  The gathered username and password will then be passed to a new ICloudService  LoginAsync()  method.\nAll of the UI work is done in the shared project.  To start, we need a copy of the  User.cs  model from the backend project.  Unlike Data Transfer Objects, this model is\nthe same:  namespace TaskList.Models\n{\n    public class User\n    {\n        public string Username { get; set; }\n        public string Password { get; set; }\n    }\n}  The abstraction we use for the cloud service needs to be adjusted so that we can pass the user object into the login\nmethod.  This is the  Abstractions\\ICloudService.cs  interface:  using System.Threading.Tasks;\nusing TaskList.Models;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n\n        Task LoginAsync(User user);\n    }\n}  I am adding a new version of the  LoginAsync()  method.  The concrete version of this method no longer has to go\nthrough the dependency service since I can use shared code.  Here is the definition of our new  LoginAsync() \nmethod in  Services\\AzureCloudService.cs :          public Task LoginAsync(User user)\n        {\n            return client.LoginAsync(\"custom\", JObject.FromObject(user));\n        }  Finally, we need to update the view-model  ViewModels\\EntryPageViewModel.cs  so that we can store the username and\npassword in the model.  We will also update the call to the  LoginAsync()  method of the cloud service so it calls\nour new method:  using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class EntryPageViewModel : BaseViewModel\n    {\n        public EntryPageViewModel()\n        {\n            Title = \"Task List\";\n            User = new Models.User { Username = \"\", Password = \"\" };\n        }\n\n        Command loginCmd;\n        public Command LoginCommand => loginCmd ?? (loginCmd = new Command(async () => await ExecuteLoginCommand()));\n\n        public Models.User User { get; set; }\n\n        async Task ExecuteLoginCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                var cloudService = ServiceLocator.Instance.Resolve<ICloudService>();\n                await cloudService.LoginAsync(User);\n                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[ExecuteLoginCommand] Error = {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}  There are three new pieces here.  Firstly, we have the User property (for holding the username and password in our\nform).  Next, the constructor initializes the user object to an empty object.  Finally, the call to  LoginAsync() \npasses the user object to the cloud service.  We also need some UI changes.  Specifically, we need a couple of fields for the username and password added to the Pages\\EntryPage.xaml  file:  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage x:Class=\"TaskList.Pages.EntryPage\"\n             xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <StackLayout HorizontalOptions=\"Center\"\n                     Orientation=\"Vertical\"\n                     VerticalOptions=\"Center\">\n            <Label Text=\"Username?\" />\n            <Entry Text=\"{Binding User.Username}\" />\n            <Label Text=\"Password?\" />\n            <Entry IsPassword=\"True\" Text=\"{Binding User.Password}\" />\n\n            <Button BackgroundColor=\"Teal\"\n                    BorderRadius=\"10\"\n                    Command=\"{Binding LoginCommand}\"\n                    Text=\"Enter The App\"\n                    TextColor=\"White\" />\n        </StackLayout>\n    </ContentPage.Content>\n</ContentPage>  There is lots to complain about in this demonstration (including lack of encryption, storage of passwords, and a\ngenerally bad UI).  However, it serves to demonstrate the salient points for using a (perhaps pre-existing) identity\ndatabase for authentication of the users.",
            "title": "Using an Identity Database."
        },
        {
            "location": "/chapter2/custom/#using-azure-active-directory-b2c",
            "text": "Custom authentication allows you to really customize the process, but I like to reduce the amount of code I write by\nusing services or libraries.   The whole sign-in and sign-up process is ripe for this.  The code needed for building\nthe sign-in / sign-up process is boiler-plate code.  It also introduces problems that I have to deal with going forward.\nI have to store passwords and profile information, which introduces a security concern.  I have to scale the database\nand ensure my app scales with it as my app gets popular.  Finally, I am being fairly inflexible and causing potential\nprivacy concerns with my users.  There are a couple of services that I can use to get around these concerns.  The first is an Azure service: Azure Active Directory B2C .  The B2C stands for Business to Consumer.  It is a mechanism by which you can add a\nsign-in and sign-up flow to your application.  The user can enter a username or password, or, at your option, add on\nsupport for one or more social providers.  In addition, there is support for branding the sign-in process, doing email\nverification of sign-ups and automatic password resets via email.  The Azure AD B2C sign-in / sign-up process is\nprimarily a server-flow proecss, so we will be able to add support in our app with just one line of code.",
            "title": "Using Azure Active Directory B2C"
        },
        {
            "location": "/chapter2/custom/#the-minimal-setup-of-azure-ad-b2c",
            "text": "Azure AD is managed from the  Classic Azure Portal , so start by logging in using your Azure\nSubscription credentials.   Click on the big  + NEW  button in the bottom left of the screen.  Select  App Services  ->  Active Directory  ->  Directory  ->  Custom Create .     Choose a name for the tenant, then choose a unique domain name (which will appear in the    onmicrosoft.com \n  domain) and country.  Ensure you check the  This is a B2C directory.     Click on the tick to create the directory.  As noted, this process will take a couple of minutes to complete.   This creates a new tenant for you to manage.  If you go back to your  Azure Portal  and click on your name\n(top right corner), you will note that there is a new DIRECTORY entry for your B2C tenant.  This is where you will be\nmanaging your B2C tenant.  It's a good idea to pin the B2C settings blade to your dashboard or navigation pane so you can access it faster.\nTo do this:   Log in to the  Azure Portal .  Switch to your B2C tenant by clicking on your name, then selecting the new tenant in the drop-down.  The portal will probably ask you to confirm your ID and password.  Click on  Browse>  in the left-hand navigation bar.  Search for  B2C .  Click on the empty star next to  Azure AD B2C .    This will make Azure AD B2C appear in your left hand navigation bar.  To place it on the dashboard, click on Azure AD B2C  in the left hand navigation bar, then click on the pin at the top of the  AZURE AD B2C SETTINGS \nblade.  The next job is to create an application registration within the B2C tenant:   Open the  Azure AD B2C  from your dashboard or the left hand navigation.  In the  Settings  blade, click on  Applications .     In the  New application  blade:  Enter a unique name for the application.  Click on  Yes  under  Include web app / web API .  In the Reply URL, enter  https://yoursite.azurewebsites.net/.auth/login/aad/callback .  Click on  Generate key  - a key will be generated (cut and paste it somewhere).     Click on  Create .   There is no spinner or deployment here.  After approximately 5-10 seconds, the application registration will appear\nin the list.  Click on the application registration to see the  Application ID :   You will need the Application ID and App Key (which you copied earlier) later on.  The next step is to create a\nSign-in/Sign-up policy.  We'll create a policy for signing up with an email address and email confirmation, then\nsigning in with that email address:   In the  Settings  blade, click on  Sign-up or sign-in policies .  Click on the  + Add  button.  Give the policy a name, like  emailPolicy .  Click on  Identity providers :  Click on  Email signup / Local Account  (a tick will appear next to the row).  Click on  OK .  Click on  Sign-up attributes :  Click on  Email Address  and any other fields you want to gather.  Click on  OK .  Click on  Application claims :  Click on  Email Addresses  and any other fields you want to provide to the application.  Click on  OK  Click on  Create  on the  Add policy  blade.  Click on the policy you just created.  It will be named something like  B2C_1_emailPolicy . Make a note of the Metadata Endpoint for this policy .    Now that your B2C tenant is configured, you can switch back to your original tenant (by clicking on your name in\nthe top-right corner and selecting the default directory).  To configure the App Service  Authentication / Authorization .  Open up the  Settings  blade, then Authentication / Authorization .  Ensure the authentication service is turned on.  Click on Azure Active Directory . This time, we are going to select the  Advanced  option.  The  Client ID  is\nthe application ID of your B2C application registration, and the  Issuer Url  is the  Metadata Endpoint \nfor your sign-up policy:   Click on  OK  to configure the authentication server flow, the  Save  to save the settings.  As before, you\ncan test your server flow by pointing your browser to  https://yoursite.azurewebsites.net/.auth/login/aad :   If you have done everything right, you should be able to register an account, get the email verification code,\nand finally log in to get the happy login page.   All that is left to do is to configure your app for Azure Active Directory Server Flow.  We did that earlier when\ndiscussing the Enterprise Authentication flow for the mobile client.",
            "title": "The Minimal Setup of Azure AD B2C"
        },
        {
            "location": "/chapter2/custom/#drawbacks-of-azure-active-directory-b2c",
            "text": "Azure AD B2C is great for storing your users passwords and doing the sign-up and sign-in process for you.  There\nare a couple of reasons why you wouldn't want to use Azure Active Directory B2C.  The most obvious one is that this is built on Azure Active Directory.  That means you won't be able to, for example,\nintegrate the Facebook, Google and Twitter identity providers by utilizing their client libraries.  You also do\nnot get access to the underlying identity provider token, so you are restricted from accessing the Graph API for\nthe individual providers.  Finally, since the AAD B2C identity provider is configured with the AAD provider, you\ncan't use both a B2C provider and a regular AAD provider.  If you just want a sign-up / sign-in flow, then AAD B2C is probably the best way to go.  If, however, your plans\ninclude integration with other social identity providers, you should consider using the identity providers\ndirectly or via separate configuration with the Azure App Service Authentication / Authorization.",
            "title": "Drawbacks of Azure Active Directory B2C"
        },
        {
            "location": "/chapter2/custom/#using-third-party-tokens",
            "text": "The final method of authenticating a user we are going to look at is a process by which you use a third party\nauthentication token.   For example, you may want to authenticate via  GitHub  or  miiCard  or using\nan authentication provider like  Auth0  to get some single sign-in capabilities.  Authentication with third party tokens works remarkably similar to the custom authentication case.  Instead of\na username and password, you pass in the token from the other provider.  To look at this in example form, we are going to implement Auth0 as a provider. Your first stop should be the Auth0  web site to sign up for a developer account. Once you have done that:   Click on the  + NEW CLIENT  button in the  Dashboard .  Give your app a name, then click on  Native  and then  CREATE .     Click on the  Xamarin  icon to get the Xamarin Quickstart.  Click on  Settings .  Enter the callback URL in the  Allowed Callback URLs .  The callback URL will be something like\n   https://_youraccount_.auth0.com/mobile  and will be listed in the Quickstart page.  Scroll down to the bottom of the page and click on  SAVE CHANGES .  Make a note of the Client ID of the application.  You will need it later.  Click on  Connections .  Turn on any connections that you want to use.  For this example, ensure you turn on the Username-Password-Authentication  and a couple of social providers.   Now that the Auth0 service is configured, we can turn our attention to the mobile client.  The Xamarin.Auth0Client\nis a component, so right-click on the  Components  node of a platform project and select  Get More Components... .\nIn the dialog, find the  Auth0 SDK , then click on  Add to App .  For our iOS application, we are going to integrate Auth0 into the  Services\\iOSLoginProvider.cs :          public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginAuth0Async();\n\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"auth0\", zumoPayload);\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n\n        public async Task<string> LoginAuth0Async()\n        {\n            var auth0 = new Auth0.SDK.Auth0Client(\n                \"shellmonger.auth0.com\",\n                \"lmFp5jXnwPpD9lQIYwgwwPmFeofuLpYq\");\n            var user = await auth0.LoginAsync(RootView, scope: \"openid email\");\n            return user.Auth0AccessToken;\n        }  The parameters for the constructor to the  Auth0Client  are your Auth0 domain and client ID.  You can retrieve these\nfrom the Auth0 management page for your app.  Note that I am requesting the email address.  This will become a part\nof my ZUMO token when I create it.  Switching our attention to our  Backend  project, we need a new custom authentication controller.  This is located\nin  Controllers\\Auth0Controller.cs :  using System;\nusing System.Diagnostics;\nusing System.IdentityModel.Tokens;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Web.Http;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server.Login;\n\nnamespace Backend.Controllers\n{\n    [Route(\".auth/login/auth0\")]\n    public class Auth0Controller : ApiController\n    {\n        private JwtSecurityTokenHandler tokenHandler;\n        private string clientID, domain;\n        private string signingKey, audience, issuer;\n\n        public Auth0Controller()\n        {\n            // Information for the incoming Auth0 Token\n            domain = Environment.GetEnvironmentVariable(\"AUTH0_DOMAIN\");\n            clientID = Environment.GetEnvironmentVariable(\"AUTH0_CLIENTID\");\n\n            // Information for the outgoing ZUMO Token\n            signingKey = Environment.GetEnvironmentVariable(\"WEBSITE_AUTH_SIGNING_KEY\");\n            var website = Environment.GetEnvironmentVariable(\"WEBSITE_HOSTNAME\");\n            audience = $\"https://{website}/\";\n            issuer = $\"https://{website}/\";\n\n            // Token Handler\n            tokenHandler = new JwtSecurityTokenHandler();\n        }\n\n        [HttpPost]\n        public IHttpActionResult Post([FromBody] Auth0User body)\n        {\n            if (body == null || body.access_token == null || body.access_token.Length == 0)\n            {\n                return BadRequest();\n            }\n\n            try\n            {\n                var token = (JwtSecurityToken)tokenHandler.ReadToken(body.access_token);\n                if (!IsValidUser(token))\n                {\n                    return Unauthorized();\n                }\n\n                var subject = token.Claims.FirstOrDefault(c => c.Type.Equals(\"sub\"))?.Value;\n                var email = token.Claims.FirstOrDefault(c => c.Type.Equals(\"email\"))?.Value;\n                if (subject == null || email == null)\n                {\n                    return BadRequest();\n                }\n\n                var claims = new Claim[]\n                {\n                    new Claim(JwtRegisteredClaimNames.Sub, subject),\n                    new Claim(JwtRegisteredClaimNames.Email, email)\n                };\n\n                JwtSecurityToken zumoToken = AppServiceLoginHandler.CreateToken(\n                    claims, signingKey, audience, issuer, TimeSpan.FromDays(30));\n                return Ok(new LoginResult()\n                {\n                    AuthenticationToken = zumoToken.RawData,\n                    User = new LoginResultUser { UserId = email }\n                });\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"Auth0 JWT Exception = {ex.Message}\");\n                throw ex;\n            }\n        }\n\n        private bool IsValidUser(JwtSecurityToken token)\n        {\n            if (token == null)\n                return false;\n            var audience = token.Audiences.FirstOrDefault();\n            if (!audience.Equals(clientID))\n                return false;\n            if (!token.Issuer.Equals($\"https://{domain}/\"))\n                return false;\n            if (token.ValidTo.AddMinutes(5) < DateTime.Now)\n                return false;\n            return true;\n        }\n    }\n\n    public class Auth0User\n    {\n        public string access_token { get; set; }\n    }\n}  Note that we are reading two new environment variables.  In the Azure App Service, you can read Application Settings\nby reading the environment variable of the same name.  We need to set the  AUTH0_CLIENTID  to the Client ID of\nour Auth0 application, and the  AUTH0_DOMAIN  to the domain of our account.  Both of these values need to match\nthe settings in the client.  These are not \"secure items\".  If using the client secret (to validate the token), then\nthat would be considered secure and should only appear on the server side.  The validation is that the token passed in is valid (i.e. it has the right audience, issuer and expiry times).  In\naddition, you should check the validity of the token signature.  You can do this by acquiring the token secret and\nusing  tokenHandler.ValidateToken()  instead of  tokenHandler.ReadToken() .  My new token lasts for 30 days.  The\nZUMO token that is generated in custom authentication does not have to be the same length as the original token.\nYou can make it last for as long as you like.",
            "title": "Using Third Party Tokens"
        },
        {
            "location": "/chapter2/authorization/",
            "text": "Claims and Authorization\n\u00b6\n\n\nNow that we have covered all the techniques for authentication, it's time to look at authorization.  While authentication\nlooked at verifying that a user is who they say they are, authorization looks at if a user is allowed to do a specific\noperation.\n\n\nAuthorization is handled within the server-side project by the \n[Authorize]\n attribute.  Our Azure Mobile Apps backend\nis leveraging this to provide authorization based on whether a user is authenticated or not.  The Authorize attribute\ncan also check to see if a user is in a list of users or roles.  However, there is a problem with this.  The user id\nis not guessable and we have no roles.  To see what I mean, run the \nBackend\n project locally and set a break point\non the \nGetAllTodoItems()\n method in the \nTodoItemController\n, then run your server and your UWP application.\n\n\n\n\nTip\n\n\nOnce you have built and deployed the UWP application, it will appear in your normal Application list.  This allows\nyou to run the application and the server at the same time on the same machine.\n\n\n\n\nOnce you have authenticated, you will be able to set a break point to take a look at \nthis.User.Identity\n:\n\n\n\n\nNote that the \nName\n property is null.  This is the property that is used when you want to authorize individual users.\nExpand the \nClaims\n property and then click on \nResults View\n:\n\n\n\n\nThe only claims are the ones in the token, and none of them match the \nRoleClaimType\n, so we can't use roles either.\nClearly, we are going to have to do something else.\n\n\nObtaining User Claims\n\u00b6\n\n\nAt some point you are going to need to deal with something other than the claims that are in the token passed for\nauthentication.  Fortunately, the Authentication / Authorization feature has an endpoint for that at \n/.auth/me\n:\n\n\n\n\nOf course, the \n/.auth/me\n endpoint is not of any use if you cannot access it.  The most use of this information is\ngained during authorization on the server and we will cover this use later on.  However, there are reasons to pull\nthis information on the client as well.  For example, we may want to make the List View title be our name instead of\n\"Tasks\".\n\n\n\n\nWarn\n\n\nYou can't use the /.auth/me endpoint when using custom authentication.\n\n\n\n\nSince identity provider claims can be anything, they are transferred as a list within a JSON object.  Before we can\ndecode the JSON object, we need to define the models.  This is done in the shared \nTaskList\n project.  I've defined\nthis in \nModels\\AppServiceIdentity.cs\n.\n\n\nusing System.Collections.Generic;\nusing Newtonsoft.Json;\n\nnamespace TaskList.Models\n{\n    public class AppServiceIdentity\n    {\n        [JsonProperty(PropertyName = \"id_token\")]\n        public string IdToken { get; set; }\n\n        [JsonProperty(PropertyName = \"provider_name\")]\n        public string ProviderName { get; set; }\n\n        [JsonProperty(PropertyName = \"user_id\")]\n        public string UserId { get; set; }\n\n        [JsonProperty(PropertyName = \"user_claims\")]\n        public List<UserClaim> UserClaims { get; set; }\n    }\n\n    public class UserClaim\n    {\n        [JsonProperty(PropertyName = \"typ\")]\n        public string Type { get; set; }\n\n        [JsonProperty(PropertyName = \"val\")]\n        public string Value { get; set; }\n    }\n}\n\n\n\n\nThis matches the JSON format from the \n/.auth/me\n call we did earlier.   This is going to be a part of the\nICloudService as follows:\n\n\nusing System.Threading.Tasks;\nusing TaskList.Models;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n\n        Task LoginAsync(User user);\n\n        Task<AppServiceIdentity> GetIdentityAsync();\n    }\n}\n\n\n\n\nFinally, we need to actually implement the concrete version in \nAzureCloudService.cs\n:\n\n\nList<AppServiceIdentity> identities = null;\n\npublic async Task<AppServiceIdentity> GetIdentityAsync()\n{\n    if (client.CurrentUser == null || client.CurrentUser?.MobileServiceAuthenticationToken == null)\n    {\n        throw new InvalidOperationException(\"Not Authenticated\");\n    }\n\n    if (identities == null)\n    {\n        identities = await client.InvokeApiAsync<List<AppServiceIdentity>>(\"/.auth/me\");\n    }\n\n    if (identities.Count > 0)\n        return identities[0];\n    return null;\n}\n\n\n\n\nNote that there is no reason to instantiate your own \nHttpClient()\n.  The Azure Mobile Apps SDK has a method for\ninvoking custom API calls (as we shall see later on).  However, if you prefix the path with a slash, it will execute\na HTTP GET for any API with any authentication that is currently in force.  We can leverage this to call the\n\n/.auth/me\n endpoint and decode the response in one line of code.  Adjust the \nExecuteRefreshCommand()\n method in\nthe \nViewModels\\TaskListViewModel.cs\n file to take advantage of this:\n\n\nasync Task ExecuteRefreshCommand()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var identity = await cloudService.GetIdentityAsync();\n        if (identity != null)\n        {\n            var name = identity.UserClaims.FirstOrDefault(c => c.Type.Equals(\"name\")).Value;\n            Title = $\"Tasks for {name}\";\n        }\n        var list = await Table.ReadAllItemsAsync();\n        Items.ReplaceRange(list);\n    }\n    catch (Exception ex)\n    {\n        await Application.Current.MainPage.DisplayAlert(\"Items Not Loaded\", ex.Message, \"OK\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}\n\n\n\n\nThe return value from the \nGetIdentityAsync()\n method is the first identity.  Normally, a user would only authenticate\nonce, so this is fairly safe.  The number of claims returned depends on the identity provider and could easily number\nin the hundreds.  Even the default configuration for Azure Active Directory returns 18 claims.  These are easily handled\nusing LINQ, however.  The \nType\n property holds the type.  This could be a short (common) name.  It could also be a\nschema name, which looks more like a URI.  The only way to know what claims are coming back for sure is to look at\nthe \n/.auth/me\n result with something like Postman.\n\n\n\n\nWarn\n\n\nIf you are using Custom Authentication (e.g. username/password or a third-party token), then the \n/.auth/me\n\nendpoint is not available to you.  You can still produce a custom API in your backend to provide this information to\nyour client, but you are responsible for the code - it's custom, after all!\n\n\n\n\nAuthorization\n\u00b6\n\n\nNow that we have covered all the techniques for authentication, it's time to look at authorization.  While authentication\nlooked at verifying that a user is who they say they are, authorization looks at if a user is allowed to do a specific\noperation.\n\n\nAuthorization is handled within the server-side project by the \n[Authorize]\n attribute.  Our Azure Mobile Apps backend\nis leveraging this to provide authorization based on whether a user is authenticated or not.  The Authorize attribute\ncan also check to see if a user is in a list of users or roles.  However, there is a problem with this.  The user id\nis not guessable and we have no roles.  To see what I mean, run the \nBackend\n project and set a break point on the\n\nGetAllTodoItems()\n method in the \nTodoItemController\n, then run your server and your UWP application.\n\n\n\n\nTip\n\n\nOnce you have built and deployed the UWP application, it will appear in your normal Application list.  This allows\nyou to run the application and the server at the same time on the same machine.  Alternatively, you can attach a\nDebugger to your Azure App Service within Visual Studio's Cloud Explorer.\n\n\n\n\nOnce you have authenticated, you will be able to set a break point to take a look at \nthis.User.Identity\n:\n\n\n\n\nNote that the \nName\n property is null.  This is the property that is used when you want to authorize individual users.\nExpand the \nClaims\n property and then click on \nResults View\n:\n\n\n\n\nThe only claims are the ones in the token, and none of them match the \nRoleClaimType\n, so we can't use roles either.\nClearly, we are going to have to do something else.  Fortunately, we already know that we can get some information\nabout the identity provider claims from the \n/.auth/me\n endpoint.  To get the extra information, we need to query\nthe \nUser\n object:\n\n\nvar identity = await User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request);\n\n\n\n\nThere is one \nCredentials\n class for each supported authentication technique - Azure Active Directory, Facebook,\nGoogle, Microsoft Account and Twitter.  These are in the \nMicrosoft.Azure.Mobile.Server.Authentication\n namespace.\nThey all follow the same pattern as the model we created for the client - there are Provider, UserId and UserClaims\nproperties.  The token and any special information will be automatically decoded for you.  For instance, the TenantId\nis pulled out of the response for Azure AD.\n\n\n\n\nTip\n\n\nYou can use the AccessToken property to do Graph API lookups for most providers in a custom API. We'll get into\nthis more in a later chapter.\n\n\n\n\nAdding Group Claims to the Request\n\u00b6\n\n\nThere are times when you want to add something else to the token that is returned from Azure AD. The most common\nrequirement is to add group information to the response so you can handle group-based authorization.\n\n\nTo add security groups to the Azure AD token:\n\n\n\n\nLog into the \nClassic Portal\n.\n\n\nClick on your directory (probably called \nDefault Directory\n) in the \nAll Items\n list.\n\n\nClick on \nAPPLICATIONS\n, then your WEB application.\n\n\nClick on \nMANAGE MANIFEST\n (at the bottom of the page), then \nDownload Manifest\n.\n\n\nClick on \nDownload manifest\n.\n\n\n\n\nThis will download a JSON file.  Edit the file with a text editor.  (I use Visual Studio Code).  At the top of the\nfile is this:\n\n\n  \"displayName\": \"webapp-for-the-book\",\n  \"errorUrl\": null,\n  \"groupMembershipClaims\": null,\n  \"homepage\": \"https://the-book.azurewebsites.net\",\n  \"identifierUris\": [\n    \"https://the-book.azurewebsites.net\"\n  ],\n  \"keyCredentials\": [],\n  \"knownClientApplications\": [],\n\n\n\n\nChange the \ngroupMembershipClaims\n to \"SecurityGroup\":\n\n\n  \"displayName\": \"webapp-for-the-book\",\n  \"errorUrl\": null,\n  \"groupMembershipClaims\": \"SecurityGroup\",\n  \"homepage\": \"https://the-book.azurewebsites.net\",\n  \"identifierUris\": [\n    \"https://the-book.azurewebsites.net\"\n  ],\n  \"keyCredentials\": [],\n  \"knownClientApplications\": [],\n\n\n\n\nSave the file.  You can now upload this again.  Go back to the WEB application, click on \nMANAGE MANIFEST\n, then\nclick on \nUpload Manifest\n.  Select the file and click on the tick.\n\n\n\n\nYou can now give the web application additional permissions:\n\n\n\n\nClick on the \nCONFIGURE\n tab.\n\n\nScroll to the bottom, click on \nDelegated Permissions\n.\n\n\nCheck the box for \nRead directory data\n.\n\n\n\n\n\n\n\n\nClick on \nSave\n.\n\n\n\n\nNow that you have configured the application to return groups as part of the claims, you should probably add a\ncouple of groups:\n\n\n\n\nClick on the back-arrow (at the top left) to return to the top level of your directory.\n\n\nClick on \nGROUPS\n.\n\n\nClick on \nADD GROUP\n.\n\n\nFill in the information, select \nSecurity\n as the group type, then click on the tick.\n\n\n\n\n\n\n\n\nClick on the new group, then click on \nPROPERTIES\n.\n\n\n\n\n\n\n\n\nMake a note of the \nOBJECT ID\n.  The claims for groups are listed by the Object ID, so you will need this to\n   refer to the group later.\n\n\n\n\nIt's a good idea to add a couple of groups for testing purposes.  If you are using the organization directory, you\nwill need to request the creation of a couple of groups for application roles.  The view of the groups will be shown\nwhen we get the identity of the user using \nUser.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request)\n:\n\n\n\n\nGroup Authorization\n\u00b6\n\n\nNow that we have group claims in the claims list for the \n/.auth/me\n endpoint, we can move forward to do authorization\nbased on these claims.  This can be done in a relatively basic manner by implementing a method to check the claims:\n\n\nasync Task<bool> IsAuthorizedAsync()\n{\n    var identity = await User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request);\n    var countofGroups = identity.UserClaims\n        .Where(c => c.Type.Equals(\"groups\") && c.Value.Equals(\"01f214a9-af1f-4bdd-938f-3f16749aef0e\"))\n        .Count();\n    return (countofGroups > 0);\n}\n\n\n\n\nThe \nUserClaims\n object is an \nIEnumerable\n that contains objects with a Type and a Value.  The Type for the group\nclaims is \ngroups\n.  Once we have this knowledge, we can use a LINQ query to obtain a count of the claims that match\nthe conditions we want to test.  The Value we use is the Object ID of the group.  This is available in the\n\nPROPERTIES\n tab of the group.\n\n\nWe can prevent a new record being added by adjusting the \nPostTodoItem()\n method:\n\n\npublic async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n{\n    if (!await IsAuthorizedAsync())\n    {\n        return Unauthorized();\n    }\n    TodoItem current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}\n\n\n\n\nUnfortunately, most of the table controller methods do not return an \nIHttpActionResult\n, so this has limited value.\nWhat would be better would be an \n[Authorize]\n attribute that tests the claims for us.  For instance, we should be\nable to do the following:\n\n\n[AuthorizeClaims(\"groups\", \"01f214a9-af1f-4bdd-938f-3f16749aef0e\")]\npublic async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n{\n    TodoItem current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}\n\n\n\n\nThe \n[AuthorizeClaims()]\n attribute does not exist, so we have to provide it ourselves:\n\n\nusing System.Linq;\nusing System.Net;\nusing System.Security.Principal;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.Filters;\nusing Microsoft.Azure.Mobile.Server.Authentication;\n\nnamespace Backend.Helpers\n{\n    public class AuthorizeClaimsAttribute : AuthorizationFilterAttribute\n    {\n        string Type { get; }\n        string Value { get; }\n\n        public AuthorizeClaimsAttribute(string type, string value)\n        {\n            Type = type;\n            Value = value;\n        }\n\n        public override async Task OnAuthorizationAsync(HttpActionContext actionContext, CancellationToken cancellationToken)\n        {\n            var request = actionContext.Request;\n            var user = actionContext.RequestContext.Principal;\n            if (user != null)\n            {\n                var identity = await user.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(request);\n                var countOfMatchingClaims = identity.UserClaims\n                    .Where(c => c.Type.Equals(Type) && c.Value.Equals(Value))\n                    .Count();\n                if (countOfMatchingClaims > 0) return;\n\n            }\n            throw new HttpResponseException(HttpStatusCode.Unauthorized);\n        }\n    }\n}\n\n\n\n\nThis is the same type of authorization filter attribute that the officially provided \nAuthorizeAttribute\n is based\non.  However, the AuthorizeAttribute is synchronous.  We require an asynchronous version of the attribute, so we\ncannot use a sub-class of the AuthorizeAttribute.  Aside from that note, this uses virtually the same code that we\nused in the \nIsAythorizedAsync()\n method we developped earlier.\n\n\nWe can now use this attribute for testing any claim.  For example, our claims has the identity provider as a claim.\nWe can use the following:\n\n\n[AuthorizeClaims(\"http://schemas.microsoft.com/identity/claims/identityprovider\", \"live.com\")]\n\n\n\n\n\n\nTip\n\n\nIf you want to test other claims that are not provided, you can enable the \nRead Directory Data\n permission in\nthe Azure Active Directory permissions and do a query against the Azure Active Directory.  You should think about\ncaching results or minting a new ZUMO token (just like we did in the custom authentication case) for\nperformance reasons.",
            "title": "Claims and Authorization"
        },
        {
            "location": "/chapter2/authorization/#claims-and-authorization",
            "text": "Now that we have covered all the techniques for authentication, it's time to look at authorization.  While authentication\nlooked at verifying that a user is who they say they are, authorization looks at if a user is allowed to do a specific\noperation.  Authorization is handled within the server-side project by the  [Authorize]  attribute.  Our Azure Mobile Apps backend\nis leveraging this to provide authorization based on whether a user is authenticated or not.  The Authorize attribute\ncan also check to see if a user is in a list of users or roles.  However, there is a problem with this.  The user id\nis not guessable and we have no roles.  To see what I mean, run the  Backend  project locally and set a break point\non the  GetAllTodoItems()  method in the  TodoItemController , then run your server and your UWP application.   Tip  Once you have built and deployed the UWP application, it will appear in your normal Application list.  This allows\nyou to run the application and the server at the same time on the same machine.   Once you have authenticated, you will be able to set a break point to take a look at  this.User.Identity :   Note that the  Name  property is null.  This is the property that is used when you want to authorize individual users.\nExpand the  Claims  property and then click on  Results View :   The only claims are the ones in the token, and none of them match the  RoleClaimType , so we can't use roles either.\nClearly, we are going to have to do something else.",
            "title": "Claims and Authorization"
        },
        {
            "location": "/chapter2/authorization/#obtaining-user-claims",
            "text": "At some point you are going to need to deal with something other than the claims that are in the token passed for\nauthentication.  Fortunately, the Authentication / Authorization feature has an endpoint for that at  /.auth/me :   Of course, the  /.auth/me  endpoint is not of any use if you cannot access it.  The most use of this information is\ngained during authorization on the server and we will cover this use later on.  However, there are reasons to pull\nthis information on the client as well.  For example, we may want to make the List View title be our name instead of\n\"Tasks\".   Warn  You can't use the /.auth/me endpoint when using custom authentication.   Since identity provider claims can be anything, they are transferred as a list within a JSON object.  Before we can\ndecode the JSON object, we need to define the models.  This is done in the shared  TaskList  project.  I've defined\nthis in  Models\\AppServiceIdentity.cs .  using System.Collections.Generic;\nusing Newtonsoft.Json;\n\nnamespace TaskList.Models\n{\n    public class AppServiceIdentity\n    {\n        [JsonProperty(PropertyName = \"id_token\")]\n        public string IdToken { get; set; }\n\n        [JsonProperty(PropertyName = \"provider_name\")]\n        public string ProviderName { get; set; }\n\n        [JsonProperty(PropertyName = \"user_id\")]\n        public string UserId { get; set; }\n\n        [JsonProperty(PropertyName = \"user_claims\")]\n        public List<UserClaim> UserClaims { get; set; }\n    }\n\n    public class UserClaim\n    {\n        [JsonProperty(PropertyName = \"typ\")]\n        public string Type { get; set; }\n\n        [JsonProperty(PropertyName = \"val\")]\n        public string Value { get; set; }\n    }\n}  This matches the JSON format from the  /.auth/me  call we did earlier.   This is going to be a part of the\nICloudService as follows:  using System.Threading.Tasks;\nusing TaskList.Models;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n\n        Task LoginAsync(User user);\n\n        Task<AppServiceIdentity> GetIdentityAsync();\n    }\n}  Finally, we need to actually implement the concrete version in  AzureCloudService.cs :  List<AppServiceIdentity> identities = null;\n\npublic async Task<AppServiceIdentity> GetIdentityAsync()\n{\n    if (client.CurrentUser == null || client.CurrentUser?.MobileServiceAuthenticationToken == null)\n    {\n        throw new InvalidOperationException(\"Not Authenticated\");\n    }\n\n    if (identities == null)\n    {\n        identities = await client.InvokeApiAsync<List<AppServiceIdentity>>(\"/.auth/me\");\n    }\n\n    if (identities.Count > 0)\n        return identities[0];\n    return null;\n}  Note that there is no reason to instantiate your own  HttpClient() .  The Azure Mobile Apps SDK has a method for\ninvoking custom API calls (as we shall see later on).  However, if you prefix the path with a slash, it will execute\na HTTP GET for any API with any authentication that is currently in force.  We can leverage this to call the /.auth/me  endpoint and decode the response in one line of code.  Adjust the  ExecuteRefreshCommand()  method in\nthe  ViewModels\\TaskListViewModel.cs  file to take advantage of this:  async Task ExecuteRefreshCommand()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var identity = await cloudService.GetIdentityAsync();\n        if (identity != null)\n        {\n            var name = identity.UserClaims.FirstOrDefault(c => c.Type.Equals(\"name\")).Value;\n            Title = $\"Tasks for {name}\";\n        }\n        var list = await Table.ReadAllItemsAsync();\n        Items.ReplaceRange(list);\n    }\n    catch (Exception ex)\n    {\n        await Application.Current.MainPage.DisplayAlert(\"Items Not Loaded\", ex.Message, \"OK\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}  The return value from the  GetIdentityAsync()  method is the first identity.  Normally, a user would only authenticate\nonce, so this is fairly safe.  The number of claims returned depends on the identity provider and could easily number\nin the hundreds.  Even the default configuration for Azure Active Directory returns 18 claims.  These are easily handled\nusing LINQ, however.  The  Type  property holds the type.  This could be a short (common) name.  It could also be a\nschema name, which looks more like a URI.  The only way to know what claims are coming back for sure is to look at\nthe  /.auth/me  result with something like Postman.   Warn  If you are using Custom Authentication (e.g. username/password or a third-party token), then the  /.auth/me \nendpoint is not available to you.  You can still produce a custom API in your backend to provide this information to\nyour client, but you are responsible for the code - it's custom, after all!",
            "title": "Obtaining User Claims"
        },
        {
            "location": "/chapter2/authorization/#authorization",
            "text": "Now that we have covered all the techniques for authentication, it's time to look at authorization.  While authentication\nlooked at verifying that a user is who they say they are, authorization looks at if a user is allowed to do a specific\noperation.  Authorization is handled within the server-side project by the  [Authorize]  attribute.  Our Azure Mobile Apps backend\nis leveraging this to provide authorization based on whether a user is authenticated or not.  The Authorize attribute\ncan also check to see if a user is in a list of users or roles.  However, there is a problem with this.  The user id\nis not guessable and we have no roles.  To see what I mean, run the  Backend  project and set a break point on the GetAllTodoItems()  method in the  TodoItemController , then run your server and your UWP application.   Tip  Once you have built and deployed the UWP application, it will appear in your normal Application list.  This allows\nyou to run the application and the server at the same time on the same machine.  Alternatively, you can attach a\nDebugger to your Azure App Service within Visual Studio's Cloud Explorer.   Once you have authenticated, you will be able to set a break point to take a look at  this.User.Identity :   Note that the  Name  property is null.  This is the property that is used when you want to authorize individual users.\nExpand the  Claims  property and then click on  Results View :   The only claims are the ones in the token, and none of them match the  RoleClaimType , so we can't use roles either.\nClearly, we are going to have to do something else.  Fortunately, we already know that we can get some information\nabout the identity provider claims from the  /.auth/me  endpoint.  To get the extra information, we need to query\nthe  User  object:  var identity = await User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request);  There is one  Credentials  class for each supported authentication technique - Azure Active Directory, Facebook,\nGoogle, Microsoft Account and Twitter.  These are in the  Microsoft.Azure.Mobile.Server.Authentication  namespace.\nThey all follow the same pattern as the model we created for the client - there are Provider, UserId and UserClaims\nproperties.  The token and any special information will be automatically decoded for you.  For instance, the TenantId\nis pulled out of the response for Azure AD.   Tip  You can use the AccessToken property to do Graph API lookups for most providers in a custom API. We'll get into\nthis more in a later chapter.",
            "title": "Authorization"
        },
        {
            "location": "/chapter2/authorization/#adding-group-claims-to-the-request",
            "text": "There are times when you want to add something else to the token that is returned from Azure AD. The most common\nrequirement is to add group information to the response so you can handle group-based authorization.  To add security groups to the Azure AD token:   Log into the  Classic Portal .  Click on your directory (probably called  Default Directory ) in the  All Items  list.  Click on  APPLICATIONS , then your WEB application.  Click on  MANAGE MANIFEST  (at the bottom of the page), then  Download Manifest .  Click on  Download manifest .   This will download a JSON file.  Edit the file with a text editor.  (I use Visual Studio Code).  At the top of the\nfile is this:    \"displayName\": \"webapp-for-the-book\",\n  \"errorUrl\": null,\n  \"groupMembershipClaims\": null,\n  \"homepage\": \"https://the-book.azurewebsites.net\",\n  \"identifierUris\": [\n    \"https://the-book.azurewebsites.net\"\n  ],\n  \"keyCredentials\": [],\n  \"knownClientApplications\": [],  Change the  groupMembershipClaims  to \"SecurityGroup\":    \"displayName\": \"webapp-for-the-book\",\n  \"errorUrl\": null,\n  \"groupMembershipClaims\": \"SecurityGroup\",\n  \"homepage\": \"https://the-book.azurewebsites.net\",\n  \"identifierUris\": [\n    \"https://the-book.azurewebsites.net\"\n  ],\n  \"keyCredentials\": [],\n  \"knownClientApplications\": [],  Save the file.  You can now upload this again.  Go back to the WEB application, click on  MANAGE MANIFEST , then\nclick on  Upload Manifest .  Select the file and click on the tick.   You can now give the web application additional permissions:   Click on the  CONFIGURE  tab.  Scroll to the bottom, click on  Delegated Permissions .  Check the box for  Read directory data .     Click on  Save .   Now that you have configured the application to return groups as part of the claims, you should probably add a\ncouple of groups:   Click on the back-arrow (at the top left) to return to the top level of your directory.  Click on  GROUPS .  Click on  ADD GROUP .  Fill in the information, select  Security  as the group type, then click on the tick.     Click on the new group, then click on  PROPERTIES .     Make a note of the  OBJECT ID .  The claims for groups are listed by the Object ID, so you will need this to\n   refer to the group later.   It's a good idea to add a couple of groups for testing purposes.  If you are using the organization directory, you\nwill need to request the creation of a couple of groups for application roles.  The view of the groups will be shown\nwhen we get the identity of the user using  User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request) :",
            "title": "Adding Group Claims to the Request"
        },
        {
            "location": "/chapter2/authorization/#group-authorization",
            "text": "Now that we have group claims in the claims list for the  /.auth/me  endpoint, we can move forward to do authorization\nbased on these claims.  This can be done in a relatively basic manner by implementing a method to check the claims:  async Task<bool> IsAuthorizedAsync()\n{\n    var identity = await User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request);\n    var countofGroups = identity.UserClaims\n        .Where(c => c.Type.Equals(\"groups\") && c.Value.Equals(\"01f214a9-af1f-4bdd-938f-3f16749aef0e\"))\n        .Count();\n    return (countofGroups > 0);\n}  The  UserClaims  object is an  IEnumerable  that contains objects with a Type and a Value.  The Type for the group\nclaims is  groups .  Once we have this knowledge, we can use a LINQ query to obtain a count of the claims that match\nthe conditions we want to test.  The Value we use is the Object ID of the group.  This is available in the PROPERTIES  tab of the group.  We can prevent a new record being added by adjusting the  PostTodoItem()  method:  public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n{\n    if (!await IsAuthorizedAsync())\n    {\n        return Unauthorized();\n    }\n    TodoItem current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}  Unfortunately, most of the table controller methods do not return an  IHttpActionResult , so this has limited value.\nWhat would be better would be an  [Authorize]  attribute that tests the claims for us.  For instance, we should be\nable to do the following:  [AuthorizeClaims(\"groups\", \"01f214a9-af1f-4bdd-938f-3f16749aef0e\")]\npublic async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n{\n    TodoItem current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}  The  [AuthorizeClaims()]  attribute does not exist, so we have to provide it ourselves:  using System.Linq;\nusing System.Net;\nusing System.Security.Principal;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.Filters;\nusing Microsoft.Azure.Mobile.Server.Authentication;\n\nnamespace Backend.Helpers\n{\n    public class AuthorizeClaimsAttribute : AuthorizationFilterAttribute\n    {\n        string Type { get; }\n        string Value { get; }\n\n        public AuthorizeClaimsAttribute(string type, string value)\n        {\n            Type = type;\n            Value = value;\n        }\n\n        public override async Task OnAuthorizationAsync(HttpActionContext actionContext, CancellationToken cancellationToken)\n        {\n            var request = actionContext.Request;\n            var user = actionContext.RequestContext.Principal;\n            if (user != null)\n            {\n                var identity = await user.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(request);\n                var countOfMatchingClaims = identity.UserClaims\n                    .Where(c => c.Type.Equals(Type) && c.Value.Equals(Value))\n                    .Count();\n                if (countOfMatchingClaims > 0) return;\n\n            }\n            throw new HttpResponseException(HttpStatusCode.Unauthorized);\n        }\n    }\n}  This is the same type of authorization filter attribute that the officially provided  AuthorizeAttribute  is based\non.  However, the AuthorizeAttribute is synchronous.  We require an asynchronous version of the attribute, so we\ncannot use a sub-class of the AuthorizeAttribute.  Aside from that note, this uses virtually the same code that we\nused in the  IsAythorizedAsync()  method we developped earlier.  We can now use this attribute for testing any claim.  For example, our claims has the identity provider as a claim.\nWe can use the following:  [AuthorizeClaims(\"http://schemas.microsoft.com/identity/claims/identityprovider\", \"live.com\")]   Tip  If you want to test other claims that are not provided, you can enable the  Read Directory Data  permission in\nthe Azure Active Directory permissions and do a query against the Azure Active Directory.  You should think about\ncaching results or minting a new ZUMO token (just like we did in the custom authentication case) for\nperformance reasons.",
            "title": "Group Authorization"
        },
        {
            "location": "/chapter2/realworld/",
            "text": "Caching Tokens\n\u00b6\n\n\nYou will notice that we have to log in with every start of the application.  The token that is generated has a lifetime\nthat is provided and controlled by the identity provider.  Some providers have a relatively short lifetime.  For example,\nAzure Active Directory tokens have a lifetime of 1 hour.  Others are incredibly long.  Facebook has an expiry time of\n60 days.\n\n\nIrrespective of the lifespan of the token, we will want to store it securely and re-use it when we can.  Xamarin has\nprovided a nice component, \nXamarin.Auth\n, that provides such as secure store in a cross-platform manner.  It starts\nwith an account store:\n\n\n// For iOS:\nvar accountStore = AccountStore.Create();\n// For Android:\nvar accountStore = AccountStore.Create(Context);\n\n\n\n\nWe can then store the token with the following:\n\n\naccountStore.Save(account, \"descriptor\");\n\n\n\n\nThe descriptor is a string that allows us to find the token again.  The account (which is an \nAccount\n object) is\nuniquely identified by a key composed of the account's Username property and the descriptor.  The Account class is\nprovided with Xamarin.Auth.  Storage is backed by the \nKeychain\n on iOS and the \nKeyStore\n on Android.\n\n\nTo get the token back, we use the following:\n\n\nvar accounts = accountStore.FindAccountsForService(\"descriptor\");\n\n\n\n\nWhen we receive the token back from the key store, we will want to check the expiry time to ensure the token has not\nexpired.  As a result, there is a little bit more code to caching code than one would expect.\n\n\nLet's start with the Android version in \nTaskList.Droid\n.  As with all the other login code, we are adjusting the\n\nLoginAsync()\n method in \nServices\\DroidLoginProvider.cs\n:\n\n\nusing System;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Android.App;\nusing Android.Content;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\nusing TaskList.Helpers;\nusing Xamarin.Auth;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        public Context RootView { get; private set; }\n\n        public AccountStore AccountStore { get; private set; }\n\n        public void Init(Context context)\n        {\n            RootView = context;\n            AccountStore = AccountStore.Create(context);\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Check if the token is available within the key store\n            var accounts = AccountStore.FindAccountsForService(\"tasklist\");\n            if (accounts != null)\n            {\n                foreach (var acct in accounts)\n                {\n                    string token;\n\n                    if (acct.Properties.TryGetValue(\"token\", out token))\n                    {\n                        if (!IsTokenExpired(token))\n                        {\n                            client.CurrentUser = new MobileServiceUser(acct.Username);\n                            client.CurrentUser.MobileServiceAuthenticationToken = token;\n                            return;\n                        }\n                    }\n                }\n            }\n\n            // Server Flow\n            await client.LoginAsync(RootView, \"aad\");\n\n            // Store the new token within the store\n            var account = new Account(client.CurrentUser.UserId);\n            account.Properties.Add(\"token\", client.CurrentUser.MobileServiceAuthenticationToken);\n            AccountStore.Save(account, \"tasklist\");\n        }\n\n        bool IsTokenExpired(string token)\n        {\n            // Get just the JWT part of the token (without the signature).\n            var jwt = token.Split(new Char[] { '.' })[1];\n\n            // Undo the URL encoding.\n            jwt = jwt.Replace('-', '+').Replace('_', '/');\n            switch (jwt.Length % 4)\n            {\n                case 0: break;\n                case 2: jwt += \"==\"; break;\n                case 3: jwt += \"=\"; break;\n                default:\n                    throw new ArgumentException(\"The token is not a valid Base64 string.\");\n            }\n\n            // Convert to a JSON String\n            var bytes = Convert.FromBase64String(jwt);\n            string jsonString = UTF8Encoding.UTF8.GetString(bytes, 0, bytes.Length);\n\n            // Parse as JSON object and get the exp field value,\n            // which is the expiration date as a JavaScript primative date.\n            JObject jsonObj = JObject.Parse(jsonString);\n            var exp = Convert.ToDouble(jsonObj[\"exp\"].ToString());\n\n            // Calculate the expiration by adding the exp value (in seconds) to the\n            // base date of 1/1/1970.\n            DateTime minTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);\n            var expire = minTime.AddSeconds(exp);\n            return (expire < DateTime.UtcNow);\n        }\n    }\n}\n\n\n\n\nThere are three new pieces to this code.  The first piece is to check to see if there is an existing token in the\nKeyStore.  If there is, we check the expiry time and then set up the Azure Mobile Apps client with the username and\ntoken from the KeyStore.  If there isn't, we do the normal authentication process.  If the authentication process is\nsuccessful, we reach the second piece, which is to store the token within the KeyStore.  If there is an existing entry,\nit will be overwritten.  Finally, there is a method called \nIsTokenExpired()\n whose only job is to check to see if a\ntoken is expired or not.  This same code can be used in the \nServices/iOSLoginProvider.cs\n.  The only difference is\nin the \nAccountStore.Create()\n call (as discussed earlier).\n\n\n\n\nUpdate Entitlements for iOS 10\n\n\nYou may notice that you are not able to use \nAccountStore.Save()\n in the iOS 10 Simulator.  A change to the\niOS entitlements has caused this change.  You must add keychain access to your Entitlements.plist file, and\nuse the Entitlements.plist file as a custom entitlements list.  Xamarin Studio for Mac has a really good\neditor for this, so I recommend doing this activity on the Mac.\n\n\n\n\nTo update the entitlements.plist within Xamarin Studio for Mac:\n\n\n\n\nDouble-click on the \nTaskList.iOS\n project to open the options pane.\n\n\nSelect the \niOS Bundle Signing\n menu option.\n\n\nSelect \niPhoneSimulator\n for the Platform.\n\n\nClick the \n...\n button next to \nCustom Entitlements\n.\n\n\nSelect the \nEntitlements.plist\n file, then click on \nOK\n.\n\n\nClick on \nOK\n to close the options pane.\n\n\nFind and open the \nEntitlements.plist\n file in the Xamarin Studio project.\n\n\nIn the \nKeychain\n sction, check the box next to \nEnable Keychain Access Groups\n.\n\n\nSave the file and re-build your project.\n\n\n\n\nXamarin.Auth only support iOS and Android.  We need to turn to an alternate library for token caching on Universal\nWindows.  The standard library has a package called \nPasswordVault\n that can be used identically to the\n\nKeyStore\n and \nKeychain\n libraries.  Here is the Universal Windows version of the same code in\n\nServices\\UWPLoginProvider.cs\n:\n\n\nusing System;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.UWP.Services;\nusing Windows.Security.Credentials;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public PasswordVault PasswordVault { get; private set; }\n\n        public UWPLoginProvider()\n        {\n            PasswordVault = new PasswordVault();\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Check if the token is available within the password vault\n            var acct = PasswordVault.FindAllByResource(\"tasklist\").FirstOrDefault();\n            if (acct != null)\n            {\n                var token = PasswordVault.Retrieve(\"tasklist\", acct.UserName).Password;\n                if (token != null && token.Length > 0 && !IsTokenExpired(token))\n                {\n                    client.CurrentUser = new MobileServiceUser(acct.UserName);\n                    client.CurrentUser.MobileServiceAuthenticationToken = token;\n                    return;\n                }\n            }\n\n            // Server-Flow Version\n            await client.LoginAsync(\"aad\");\n\n            // Store the token in the password vault\n            PasswordVault.Add(new PasswordCredential(\"tasklist\",\n                client.CurrentUser.UserId,\n                client.CurrentUser.MobileServiceAuthenticationToken));\n        }\n\n        bool IsTokenExpired(string token)\n        {\n            /* Copy code from DroidLoginProvider */\n        }\n    }\n}\n\n\n\n\nThe PasswordVault replaces the KeyStore (Android) and Keychain (iOS), but the concepts are the same.  All three\nmechanisms provide the basic functionality of storing client secrets securely.\n\n\nRefresh Tokens\n\u00b6\n\n\nOur token cache checks the token to see if it is expired and prompts the user if the token is no longer valid.  Since\nthe life of a token is inevitably short (maybe 1 hour), this will still mean that the user is prompted for new\ncredentials most of the time.  In addition, we have an issue when the app is running for a long time.  What happens\nif the user leaves the app running for 2 hours?  The token we received at the start of the session will be invalid\nhalfway through the session and we will have to restart the app in order to continue.  Both of these situations are\nundesirable from the point of view of the user.  Access tokens eventually expire and we need to explicitly deal with\nthis situation.\n\n\nThe first part of the solution is to request a \nRefresh Token\n.  This is something the identity provider issues when\nthe scope of the request includes an offline scope.  Only certain identity providers include the ability to request\nrefresh tokens.  For server-flow:\n\n\n\n\nGoogle: Append the \"access_type=offline\" to the request.\n\n\nMicrosoft Account: Select the wl.offline_access scope in the Azure management portal.\n\n\nAzure AD: Configure Azure AD to support access to the Graph API.\n\n\n\n\nFacebook and Twitter do not provider refresh tokens.  Once you have the refresh tokens, you can simply call the\nrefresh API in the Azure Mobile Apps SDK to refresh the token.\n\n\n\n\nInfo\n\n\nRefresh Tokens are one area that require special consideration when using Custom Authentication.  Just like with\nthe /.auth/me endpoint, you are on your own when it comes to handling token expiry for custom authentication.\n\n\n\n\nConfiguring Refresh Tokens\n\u00b6\n\n\nYou can add the additional information to a Google request with the following code snippet:\n\n\nclient.LoginAsync(\"google\", new Dictionary<string, string>\n{\n    { \"access_type\", \"offline\" }\n});\n\n\n\n\nAzure Active Directory is perhaps the trickiest to configure.\n\n\n\n\nLog on to the \nClassic Portal\n.\n\n\nNavigate to your Azure Active Directory.\n\n\nGo to \nAPPLICATIONS\n and then your WEB application.\n\n\nGo to the \nCONFIGURE\n tab.\n\n\nScroll down to the \nKeys\n section.\n\n\n\n\n\n\n\n\nIn the \nSelect duration\n drop-down, select \n2 Years\n.\n\n\nClick on \nSAVE\n.  The key will be generated for you.  Copy the key (you will need it below).\n\n\nGo back to the \nAzure Portal\n.\n\n\nGo to \nApp Services\n, then your App Service.\n\n\nClick on \nTools\n, then \nResource explorer\n, then \nGo\n.\n\n\nIn the Resource Explorer, expand \nconfig\n and select \nauthsettings\n.\n\n\nClick on \nEdit\n.\n\n\nSet the clientSecret to the key you copied from above.\n\n\nSet the additionalLoginParams to \n[\"response_type=code id_token\"]\n.\n\n\n\n\n\n\n\n\nClick the \nRead/Write\n toggle button at the top of the page.\n\n\nClick the \nPUT\n button.\n\n\n\n\nThe next time the user logs into our web app side, there will be a one-time prompt to consent to graph API access.\nOnce granted, the App Service Authentication / Authorization service will start requesting and receiving refresh\ntokens.\n\n\nOnce you go through this process and re-authenticate, you will be able to see the refresh token in the output of\nthe \n/.auth/me\n endpoint:\n\n\n\n\nRefresh tokens have a different expiry time to the identity token.  The refresh token theoretically lives forever,\nbut there are \"non-use expiry\" times. This varies by identity provider.\n\n\n\n\nGoogle: 6 months\n\n\nMicrosoft Account: 24 hours\n\n\nAzure Active Directory: 90 days\n\n\n\n\nIn addition, there may be other reasons why a token can be invalidated.  For instance, Google provides 25 refresh\ntokens per user.  If the user requests more than the limit, the oldest token is invalidated.  You should refer\nto the OAuth documentation for the identity provider.\n\n\nUsing Refresh Tokens\n\u00b6\n\n\nThe Azure Mobile Apps Client SDK has a built in method for refreshing tokens for you.  It assumes that you are using\na supported identity provider (Azure Active Directory, Google or Microsoft Account), and have configured the identity\nprovider to generate the refresh token.  To refresh a token, use:\n\n\nclient.RefreshUserAsync();\n\n\n\n\n\n\nTip\n\n\nIf you get the error \"You do not have permission to view this directory or page\" when accessing the refresh\nendpoint, there are no refresh tokens for your user in the token store.  This could be because the user has\nyet to re-authenticate (causing a new refresh token to be generated), the provider is not set up to generate\nrefresh tokens or the provider does not support refresh tokens.\n\n\n\n\nWe can easily add this to the login process in the platform-specific provider.  Rather than provide the same logic\nover and over, we can extend the \nILoginProvider\n to do the base operations for us then implement the logic once\nin the \nAzureCloudService\n.  The \nAbstractions\\ILoginProvider.cs\n interface now looks like this:\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\n\nnamespace TaskList.Abstractions\n{\n    public interface ILoginProvider\n    {\n        MobileServiceUser RetrieveTokenFromSecureStore();\n\n        void StoreTokenInSecureStore(MobileServiceUser user);\n\n        Task<MobileServiceUser> LoginAsync(MobileServiceClient client);\n    }\n}\n\n\n\n\nSince the \nRefreshUserAsync()\n method is purely contained within the Azure Mobile Apps Client SDK and requires\nno changes between platforms, we don't need a special platform-specific version.  Each method of the interface\nis one of the primitives we have already discussed.  For example, the Android version in  \nServices\\DroidLoginProvider.cs\n\nnow looks like this:\n\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        #region ILoginProvider Interface\n        public MobileServiceUser RetrieveTokenFromSecureStore()\n        {\n            var accounts = AccountStore.FindAccountsForService(\"tasklist\");\n            if (accounts != null)\n            {\n                foreach (var acct in accounts)\n                {\n                    string token;\n\n                    if (acct.Properties.TryGetValue(\"token\", out token))\n                    {\n                        return new MobileServiceUser(acct.Username)\n                        {\n                            MobileServiceAuthenticationToken = token\n                        };\n                    }\n                }\n            }\n            return null;\n        }\n\n        public void StoreTokenInSecureStore(MobileServiceUser user)\n        {\n            var account = new Account(user.UserId);\n            account.Properties.Add(\"token\", user.MobileServiceAuthenticationToken);\n            AccountStore.Save(account, \"tasklist\");\n        }\n\n        public async Task<MobileServiceUser> LoginAsync(MobileServiceClient client)\n        {\n            // Server Flow\n            return await client.LoginAsync(RootView, \"aad\");\n        }\n        #endregion\n\n        public Context RootView { get; private set; }\n\n        public AccountStore AccountStore { get; private set; }\n\n        public void Init(Context context)\n        {\n            RootView = context;\n            AccountStore = AccountStore.Create(context);\n        }\n    }\n}\n\n\n\n\nThe iOS version is practically the same because we are using the common Xamarin.Auth portable library.  The\ndifference is in the methods outside of the ILoginProvider interface:\n\n\npublic UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n\npublic AccountStore AccountStore { get; private set; }\n\npublic iOSLoginProvider()\n{\n    AccountStore = AccountStore.Create();\n}\n\n\n\n\nFinally, the Universal Windows version (in \nServices\\UWPLoginProvider.cs\n) is significantly different in the\nsecure store implementation:\n\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public PasswordVault PasswordVault { get; private set; }\n\n        public UWPLoginProvider()\n        {\n            PasswordVault = new PasswordVault();\n        }\n\n        #region ILoginProvider Interface\n        public MobileServiceUser RetrieveTokenFromSecureStore()\n        {\n            try\n            {\n                // Check if the token is available within the password vault\n                var acct = PasswordVault.FindAllByResource(\"tasklist\").FirstOrDefault();\n                if (acct != null)\n                {\n                    var token = PasswordVault.Retrieve(\"tasklist\", acct.UserName).Password;\n                    if (token != null && token.Length > 0)\n                    {\n                        return new MobileServiceUser(acct.UserName)\n                        {\n                            MobileServiceAuthenticationToken = token\n                        };\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"Error retrieving existing token: {ex.Message}\");\n            }\n            return null;\n        }\n\n        public void StoreTokenInSecureStore(MobileServiceUser user)\n        {\n            PasswordVault.Add(new PasswordCredential(\"tasklist\", user.UserId, user.MobileServiceAuthenticationToken));\n        }\n\n        public async Task<MobileServiceUser> LoginAsync(MobileServiceClient client)\n        {\n            // Server-Flow Version\n            return await client.LoginAsync(\"aad\");\n        }\n        #endregion\n    }\n}\n\n\n\n\nWe can swap out the server-flow Azure Active Directory login method with any of the client-flow, server-flow or\ncustom flows that we have been discussing thus far across all three platform-specific implementations.\n\n\nThe common flow handles all the logic for us.  This is the \nLoginAsync()\n method in the \nServices\\AzureCloudService.cs\n\nclass:\n\n\npublic async Task<MobileServiceUser> LoginAsync()\n{\n    var loginProvider = DependencyService.Get<ILoginProvider>();\n\n    client.CurrentUser = loginProvider.RetrieveTokenFromSecureStore();\n    if (client.CurrentUser != null)\n    {\n        // User has previously been authenticated - try to Refresh the token\n        try\n        {\n            var refreshed = await client.RefreshUserAsync();\n            if (refreshed != null)\n            {\n                loginProvider.StoreTokenInSecureStore(refreshed);\n                return refreshed;\n            }\n        }\n        catch (Exception refreshException)\n        {\n            Debug.WriteLine($\"Could not refresh token: {refreshException.Message}\");\n        }\n    }\n\n    if (client.CurrentUser != null && !IsTokenExpired(client.CurrentUser.MobileServiceAuthenticationToken))\n    {\n        // User has previously been authenticated, no refresh is required\n        return client.CurrentUser;\n    }\n\n    // We need to ask for credentials at this point\n    await loginProvider.LoginAsync(client);\n    if (client.CurrentUser != null)\n    {\n        // We were able to successfully log in\n        loginProvider.StoreTokenInSecureStore(client.CurrentUser);\n    }\n    return client.CurrentUser;\n}\n\n\n\n\nFor full disclosure, I've also moved the \nIsTokenExpired()\n method from the platform-specific code to the\nshared project, and updated the \nICloudService.cs\n to match the new signature of \nLoginAsync()\n.  The process\nfollows the best practices:\n\n\n\n\nCheck for a stored token - if one exists, try to refresh it.\n\n\nIf the token (that potentially just got refreshed) is not expired, continue using it.\n\n\nIf not, ask the user for credentials.\n\n\nIf we get a valid token back, store it in the secure store for next time.\n\n\n\n\nThere is another place that we must consider refresh tokens.  During a HTTP request to our mobile backend, it is\npossible that the token has expired since our last request.  The request will return a 401 Unauthorized response\nin this case.  We need to trap that and perform a login request.  The login request will either refresh the\ntoken or prompt the user for new credentials.  We can then continue with the request as before.\n\n\nThe Azure Mobile Apps SDK contains a mechanism for hooking into the HTTP workflow using a \nDelegatingHandler\n. A\ndelegating handler is a base type for a HTTP handler that allows us to process the request and response from the\nHTTP client object before (and after) it finally get processed.  It's used for adding additional headers to the\nrequest or logging the request and response, for example.  We are going to use it to validate the response and\nre-submit the request (after login) if the request comes back as a 401 Unauthorized.\n\n\nWe start with the adjustment to the \nServices\\AzureCloudService.cs\n constructor:\n\n\npublic AzureCloudService()\n{\n    client = new MobileServiceClient(Locations.AppServiceUrl, new AuthenticationDelegatingHandler());\n\n    if (Locations.AlternateLoginHost != null)\n        client.AlternateLoginHost = new Uri(Locations.AlternateLoginHost);\n}\n\n\n\n\nThe \nAuthenticationDelegatingHandler()\n is the new piece here.  This is the delegating handler that we are going\nto implement to handle the re-try logic.  I've placed the code in \nHelpers\\AuthenticationDelegatingHandler.cs\n:\n\n\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Helpers\n{\n    class AuthenticationDelegatingHandler : DelegatingHandler\n    {\n        protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n        {\n            // Clone the request, in case we need to re-issue it\n            var clone = await CloneHttpRequestMessageAsync(request);\n            // Now do the request\n            var response = await base.SendAsync(request, cancellationToken);\n\n            if (response.StatusCode == HttpStatusCode.Unauthorized)\n            {\n                // The request resulted in a 401 Unauthorized.  We need to do a LoginAsync,\n                // which will do the Refresh if appropriate, or ask for credentials if not.\n                var user = await ServiceLocator.Instance.Resolve<ICloudService>().LoginAsync();\n\n                // Now, retry the request with the cloned request.  The only thing we have\n                // to do is replace the X-ZUMO-AUTH header with the new auth token.\n                clone.Headers.Remove(\"X-ZUMO-AUTH\");\n                clone.Headers.Add(\"X-ZUMO-AUTH\", user.MobileServiceAuthenticationToken);\n                response = await base.SendAsync(clone, cancellationToken);\n            }\n\n            return response;\n        }\n\n        /// <summary>\n        /// Clone a HttpRequestMessage\n        /// Credit: http://stackoverflow.com/questions/25044166/how-to-clone-a-httprequestmessage-when-the-original-request-has-content\n        /// </summary>\n        /// <param name=\"req\">The request</param>\n        /// <returns>A copy of the request</returns>\n        public static async Task<HttpRequestMessage> CloneHttpRequestMessageAsync(HttpRequestMessage req)\n        {\n            HttpRequestMessage clone = new HttpRequestMessage(req.Method, req.RequestUri);\n\n            // Copy the request's content (via a MemoryStream) into the cloned object\n            var ms = new MemoryStream();\n            if (req.Content != null)\n            {\n                await req.Content.CopyToAsync(ms).ConfigureAwait(false);\n                ms.Position = 0;\n                clone.Content = new StreamContent(ms);\n\n                // Copy the content headers\n                if (req.Content.Headers != null)\n                    foreach (var h in req.Content.Headers)\n                        clone.Content.Headers.Add(h.Key, h.Value);\n            }\n\n\n            clone.Version = req.Version;\n\n            foreach (KeyValuePair<string, object> prop in req.Properties)\n                clone.Properties.Add(prop);\n\n            foreach (KeyValuePair<string, IEnumerable<string>> header in req.Headers)\n                clone.Headers.TryAddWithoutValidation(header.Key, header.Value);\n\n            return clone;\n        }\n    }\n}\n\n\n\n\nThere is no in-built method for cloning a \nHttpRequestMessage\n object.  Fortunately \nStack Overflow\n provided\nan answer that seems to work.  Running this code will now pass every single non-login request through the delegating\nhandler.  If we get an Unauthorized at any point, the login flow (which includes an implicit refresh token) will\nbe triggered.\n\n\n\n\nInfo\n\n\nThere are two HTTPClient objects created inside of the \nMobileServiceClient\n object. One is for all the non-login\nflows and it supports the delegating handlers.  However there is another one for login flows.  The one for login\nflows does not support delegating handlers.  This means you don't have to worry about cyclical references within the\ndelegating handler (where a login flow triggers another login flow).\n\n\n\n\nLogging out\n\u00b6\n\n\nThere is a dirty little secret within the Azure Mobile Apps Client SDK.  Calling \nLogoutAsync()\n does not actually\ninvalidate the token you are using.  It simply removes it from the \nMobileServiceClient\n context.  Don't believe\nme?  Here is \nthe code\n:\n\n\n        /// <summary>\n        /// Log a user out.\n        /// </summary>\n        public Task LogoutAsync()\n        {\n            this.CurrentUser = null;\n            return Task.FromResult(0);\n        }\n\n\n\n\nWhen you actually think about it, this makes sense.  You can get logged in via five different supported identity\nproviders via a web-flow.  In this case, you are logging your \nbrowser\n out of the identity provider.  Do you\nreally want to log out of Facebook when you log out of your app?\n\n\nSo, how do you log out?  You should:\n\n\n\n\nCall the identity provider logout method (if appropriate).  Many identity providers don't provide this.\n\n\nInvalidate the token on the mobile backend.\n\n\nRemove the token from the local secure cache store.\n\n\nFinally, call the \nLogoutAsync()\n method on the \nMobileServiceClient\n.\n\n\n\n\nInvalidating the token on the mobile backend.\n\u00b6\n\n\nCalling the \n/.auth/logout\n endpoint on the Azure App Service mobile backend will remove the entry\non the token store.  However, it does not (currently) invalidate the token.  The token, if submitted,\nwill still authorize the user.  The refresh token is stored in the token store. The user submitting the\ntoken will be unable to refresh the token.  Once the ZUMO token has expired (which happens an hour after\nit was created), the logout is complete.\n\n\nWe need to do a HTTP client call for this purpose:\n\n\n// Invalidate the token on the mobile backend\nvar authUri = new Uri($\"{client.MobileAppUri}/.auth/logout\");\nusing (var httpClient = new HttpClient())\n{\n    httpClient.DefaultRequestHeaders.Add(\"X-ZUMO-AUTH\", client.CurrentUser.MobileServiceAuthenticationToken);\n    await httpClient.GetAsync(authUri);\n}\n\n\n\n\nRemoving the token from the local secure cache store.\n\u00b6\n\n\nFor this part of the process, We can add a new method to the \nILoginProvider.cs\n interface:\n\n\nvoid RemoveTokenFromSecureStore();\n\n\n\n\nFor Android and iOS, the concrete implementation looks like this:\n\n\npublic void RemoveTokenFromSecureStore()\n{\n    var accounts = AccountStore.FindAccountsForService(\"tasklist\");\n    if (accounts != null)\n    {\n        foreach (var acct in accounts)\n        {\n            AccountStore.Delete(acct, \"tasklist\");\n        }\n    }\n}\n\n\n\n\nFor Universal Windows, the concrete implementation is a bit different:\n\n\npublic void RemoveTokenFromSecureStore()\n{\n    try\n    {\n        // Check if the token is available within the password vault\n        var acct = PasswordVault.FindAllByResource(\"tasklist\").FirstOrDefault();\n        if (acct != null)\n        {\n            PasswordVault.Remove(acct);\n        }\n    }\n    catch (Exception ex)\n    {\n        Debug.WriteLine($\"Error retrieving existing token: {ex.Message}\");\n    }\n}\n\n\n\n\nImplementing a LogoutAsync() method.\n\u00b6\n\n\nI've added the following to the \nICloudService\n interface:\n\n\nTask LogoutAsync();\n\n\n\n\nThis has a concrete implementation in \nServices\\AzureCloudService.cs\n:\n\n\npublic async Task LogoutAsync()\n{\n    if (client.CurrentUser == null || client.CurrentUser.MobileServiceAuthenticationToken == null)\n        return;\n\n    // Log out of the identity provider (if required)\n\n    // Invalidate the token on the mobile backend\n    var authUri = new Uri($\"{client.MobileAppUri}/.auth/logout\");\n    using (var httpClient = new HttpClient())\n    {\n        httpClient.DefaultRequestHeaders.Add(\"X-ZUMO-AUTH\", client.CurrentUser.MobileServiceAuthenticationToken);\n        await httpClient.GetAsync(authUri);\n    }\n\n    // Remove the token from the cache\n    DependencyService.Get<ILoginProvider>().RemoveTokenFromSecureStore();\n\n    // Remove the token from the MobileServiceClient\n    await client.LogoutAsync();\n}\n\n\n\n\nThis does three of the four providers.  If your identity provider supports an app-level logout, then you\nshould call that where indicated.  This is probably going to be platform-specific code, so you will want\nto add a method to the \nILoginProvider.cs\n interface and add a concrete implementation to each platform\nproject.\n\n\nI've also added a logout button to my \nPages\\TaskList.xaml\n (\nview code\n) and added the event handler\nfor the logout button to the \nViewModels\\EntryPageViewModel.cs\n (\nview code\n).",
            "title": "Tokens in Real Apps"
        },
        {
            "location": "/chapter2/realworld/#caching-tokens",
            "text": "You will notice that we have to log in with every start of the application.  The token that is generated has a lifetime\nthat is provided and controlled by the identity provider.  Some providers have a relatively short lifetime.  For example,\nAzure Active Directory tokens have a lifetime of 1 hour.  Others are incredibly long.  Facebook has an expiry time of\n60 days.  Irrespective of the lifespan of the token, we will want to store it securely and re-use it when we can.  Xamarin has\nprovided a nice component,  Xamarin.Auth , that provides such as secure store in a cross-platform manner.  It starts\nwith an account store:  // For iOS:\nvar accountStore = AccountStore.Create();\n// For Android:\nvar accountStore = AccountStore.Create(Context);  We can then store the token with the following:  accountStore.Save(account, \"descriptor\");  The descriptor is a string that allows us to find the token again.  The account (which is an  Account  object) is\nuniquely identified by a key composed of the account's Username property and the descriptor.  The Account class is\nprovided with Xamarin.Auth.  Storage is backed by the  Keychain  on iOS and the  KeyStore  on Android.  To get the token back, we use the following:  var accounts = accountStore.FindAccountsForService(\"descriptor\");  When we receive the token back from the key store, we will want to check the expiry time to ensure the token has not\nexpired.  As a result, there is a little bit more code to caching code than one would expect.  Let's start with the Android version in  TaskList.Droid .  As with all the other login code, we are adjusting the LoginAsync()  method in  Services\\DroidLoginProvider.cs :  using System;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Android.App;\nusing Android.Content;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\nusing TaskList.Helpers;\nusing Xamarin.Auth;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        public Context RootView { get; private set; }\n\n        public AccountStore AccountStore { get; private set; }\n\n        public void Init(Context context)\n        {\n            RootView = context;\n            AccountStore = AccountStore.Create(context);\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Check if the token is available within the key store\n            var accounts = AccountStore.FindAccountsForService(\"tasklist\");\n            if (accounts != null)\n            {\n                foreach (var acct in accounts)\n                {\n                    string token;\n\n                    if (acct.Properties.TryGetValue(\"token\", out token))\n                    {\n                        if (!IsTokenExpired(token))\n                        {\n                            client.CurrentUser = new MobileServiceUser(acct.Username);\n                            client.CurrentUser.MobileServiceAuthenticationToken = token;\n                            return;\n                        }\n                    }\n                }\n            }\n\n            // Server Flow\n            await client.LoginAsync(RootView, \"aad\");\n\n            // Store the new token within the store\n            var account = new Account(client.CurrentUser.UserId);\n            account.Properties.Add(\"token\", client.CurrentUser.MobileServiceAuthenticationToken);\n            AccountStore.Save(account, \"tasklist\");\n        }\n\n        bool IsTokenExpired(string token)\n        {\n            // Get just the JWT part of the token (without the signature).\n            var jwt = token.Split(new Char[] { '.' })[1];\n\n            // Undo the URL encoding.\n            jwt = jwt.Replace('-', '+').Replace('_', '/');\n            switch (jwt.Length % 4)\n            {\n                case 0: break;\n                case 2: jwt += \"==\"; break;\n                case 3: jwt += \"=\"; break;\n                default:\n                    throw new ArgumentException(\"The token is not a valid Base64 string.\");\n            }\n\n            // Convert to a JSON String\n            var bytes = Convert.FromBase64String(jwt);\n            string jsonString = UTF8Encoding.UTF8.GetString(bytes, 0, bytes.Length);\n\n            // Parse as JSON object and get the exp field value,\n            // which is the expiration date as a JavaScript primative date.\n            JObject jsonObj = JObject.Parse(jsonString);\n            var exp = Convert.ToDouble(jsonObj[\"exp\"].ToString());\n\n            // Calculate the expiration by adding the exp value (in seconds) to the\n            // base date of 1/1/1970.\n            DateTime minTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);\n            var expire = minTime.AddSeconds(exp);\n            return (expire < DateTime.UtcNow);\n        }\n    }\n}  There are three new pieces to this code.  The first piece is to check to see if there is an existing token in the\nKeyStore.  If there is, we check the expiry time and then set up the Azure Mobile Apps client with the username and\ntoken from the KeyStore.  If there isn't, we do the normal authentication process.  If the authentication process is\nsuccessful, we reach the second piece, which is to store the token within the KeyStore.  If there is an existing entry,\nit will be overwritten.  Finally, there is a method called  IsTokenExpired()  whose only job is to check to see if a\ntoken is expired or not.  This same code can be used in the  Services/iOSLoginProvider.cs .  The only difference is\nin the  AccountStore.Create()  call (as discussed earlier).   Update Entitlements for iOS 10  You may notice that you are not able to use  AccountStore.Save()  in the iOS 10 Simulator.  A change to the\niOS entitlements has caused this change.  You must add keychain access to your Entitlements.plist file, and\nuse the Entitlements.plist file as a custom entitlements list.  Xamarin Studio for Mac has a really good\neditor for this, so I recommend doing this activity on the Mac.   To update the entitlements.plist within Xamarin Studio for Mac:   Double-click on the  TaskList.iOS  project to open the options pane.  Select the  iOS Bundle Signing  menu option.  Select  iPhoneSimulator  for the Platform.  Click the  ...  button next to  Custom Entitlements .  Select the  Entitlements.plist  file, then click on  OK .  Click on  OK  to close the options pane.  Find and open the  Entitlements.plist  file in the Xamarin Studio project.  In the  Keychain  sction, check the box next to  Enable Keychain Access Groups .  Save the file and re-build your project.   Xamarin.Auth only support iOS and Android.  We need to turn to an alternate library for token caching on Universal\nWindows.  The standard library has a package called  PasswordVault  that can be used identically to the KeyStore  and  Keychain  libraries.  Here is the Universal Windows version of the same code in Services\\UWPLoginProvider.cs :  using System;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.UWP.Services;\nusing Windows.Security.Credentials;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public PasswordVault PasswordVault { get; private set; }\n\n        public UWPLoginProvider()\n        {\n            PasswordVault = new PasswordVault();\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Check if the token is available within the password vault\n            var acct = PasswordVault.FindAllByResource(\"tasklist\").FirstOrDefault();\n            if (acct != null)\n            {\n                var token = PasswordVault.Retrieve(\"tasklist\", acct.UserName).Password;\n                if (token != null && token.Length > 0 && !IsTokenExpired(token))\n                {\n                    client.CurrentUser = new MobileServiceUser(acct.UserName);\n                    client.CurrentUser.MobileServiceAuthenticationToken = token;\n                    return;\n                }\n            }\n\n            // Server-Flow Version\n            await client.LoginAsync(\"aad\");\n\n            // Store the token in the password vault\n            PasswordVault.Add(new PasswordCredential(\"tasklist\",\n                client.CurrentUser.UserId,\n                client.CurrentUser.MobileServiceAuthenticationToken));\n        }\n\n        bool IsTokenExpired(string token)\n        {\n            /* Copy code from DroidLoginProvider */\n        }\n    }\n}  The PasswordVault replaces the KeyStore (Android) and Keychain (iOS), but the concepts are the same.  All three\nmechanisms provide the basic functionality of storing client secrets securely.",
            "title": "Caching Tokens"
        },
        {
            "location": "/chapter2/realworld/#refresh-tokens",
            "text": "Our token cache checks the token to see if it is expired and prompts the user if the token is no longer valid.  Since\nthe life of a token is inevitably short (maybe 1 hour), this will still mean that the user is prompted for new\ncredentials most of the time.  In addition, we have an issue when the app is running for a long time.  What happens\nif the user leaves the app running for 2 hours?  The token we received at the start of the session will be invalid\nhalfway through the session and we will have to restart the app in order to continue.  Both of these situations are\nundesirable from the point of view of the user.  Access tokens eventually expire and we need to explicitly deal with\nthis situation.  The first part of the solution is to request a  Refresh Token .  This is something the identity provider issues when\nthe scope of the request includes an offline scope.  Only certain identity providers include the ability to request\nrefresh tokens.  For server-flow:   Google: Append the \"access_type=offline\" to the request.  Microsoft Account: Select the wl.offline_access scope in the Azure management portal.  Azure AD: Configure Azure AD to support access to the Graph API.   Facebook and Twitter do not provider refresh tokens.  Once you have the refresh tokens, you can simply call the\nrefresh API in the Azure Mobile Apps SDK to refresh the token.   Info  Refresh Tokens are one area that require special consideration when using Custom Authentication.  Just like with\nthe /.auth/me endpoint, you are on your own when it comes to handling token expiry for custom authentication.",
            "title": "Refresh Tokens"
        },
        {
            "location": "/chapter2/realworld/#configuring-refresh-tokens",
            "text": "You can add the additional information to a Google request with the following code snippet:  client.LoginAsync(\"google\", new Dictionary<string, string>\n{\n    { \"access_type\", \"offline\" }\n});  Azure Active Directory is perhaps the trickiest to configure.   Log on to the  Classic Portal .  Navigate to your Azure Active Directory.  Go to  APPLICATIONS  and then your WEB application.  Go to the  CONFIGURE  tab.  Scroll down to the  Keys  section.     In the  Select duration  drop-down, select  2 Years .  Click on  SAVE .  The key will be generated for you.  Copy the key (you will need it below).  Go back to the  Azure Portal .  Go to  App Services , then your App Service.  Click on  Tools , then  Resource explorer , then  Go .  In the Resource Explorer, expand  config  and select  authsettings .  Click on  Edit .  Set the clientSecret to the key you copied from above.  Set the additionalLoginParams to  [\"response_type=code id_token\"] .     Click the  Read/Write  toggle button at the top of the page.  Click the  PUT  button.   The next time the user logs into our web app side, there will be a one-time prompt to consent to graph API access.\nOnce granted, the App Service Authentication / Authorization service will start requesting and receiving refresh\ntokens.  Once you go through this process and re-authenticate, you will be able to see the refresh token in the output of\nthe  /.auth/me  endpoint:   Refresh tokens have a different expiry time to the identity token.  The refresh token theoretically lives forever,\nbut there are \"non-use expiry\" times. This varies by identity provider.   Google: 6 months  Microsoft Account: 24 hours  Azure Active Directory: 90 days   In addition, there may be other reasons why a token can be invalidated.  For instance, Google provides 25 refresh\ntokens per user.  If the user requests more than the limit, the oldest token is invalidated.  You should refer\nto the OAuth documentation for the identity provider.",
            "title": "Configuring Refresh Tokens"
        },
        {
            "location": "/chapter2/realworld/#using-refresh-tokens",
            "text": "The Azure Mobile Apps Client SDK has a built in method for refreshing tokens for you.  It assumes that you are using\na supported identity provider (Azure Active Directory, Google or Microsoft Account), and have configured the identity\nprovider to generate the refresh token.  To refresh a token, use:  client.RefreshUserAsync();   Tip  If you get the error \"You do not have permission to view this directory or page\" when accessing the refresh\nendpoint, there are no refresh tokens for your user in the token store.  This could be because the user has\nyet to re-authenticate (causing a new refresh token to be generated), the provider is not set up to generate\nrefresh tokens or the provider does not support refresh tokens.   We can easily add this to the login process in the platform-specific provider.  Rather than provide the same logic\nover and over, we can extend the  ILoginProvider  to do the base operations for us then implement the logic once\nin the  AzureCloudService .  The  Abstractions\\ILoginProvider.cs  interface now looks like this:  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\n\nnamespace TaskList.Abstractions\n{\n    public interface ILoginProvider\n    {\n        MobileServiceUser RetrieveTokenFromSecureStore();\n\n        void StoreTokenInSecureStore(MobileServiceUser user);\n\n        Task<MobileServiceUser> LoginAsync(MobileServiceClient client);\n    }\n}  Since the  RefreshUserAsync()  method is purely contained within the Azure Mobile Apps Client SDK and requires\nno changes between platforms, we don't need a special platform-specific version.  Each method of the interface\nis one of the primitives we have already discussed.  For example, the Android version in   Services\\DroidLoginProvider.cs \nnow looks like this:  [assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        #region ILoginProvider Interface\n        public MobileServiceUser RetrieveTokenFromSecureStore()\n        {\n            var accounts = AccountStore.FindAccountsForService(\"tasklist\");\n            if (accounts != null)\n            {\n                foreach (var acct in accounts)\n                {\n                    string token;\n\n                    if (acct.Properties.TryGetValue(\"token\", out token))\n                    {\n                        return new MobileServiceUser(acct.Username)\n                        {\n                            MobileServiceAuthenticationToken = token\n                        };\n                    }\n                }\n            }\n            return null;\n        }\n\n        public void StoreTokenInSecureStore(MobileServiceUser user)\n        {\n            var account = new Account(user.UserId);\n            account.Properties.Add(\"token\", user.MobileServiceAuthenticationToken);\n            AccountStore.Save(account, \"tasklist\");\n        }\n\n        public async Task<MobileServiceUser> LoginAsync(MobileServiceClient client)\n        {\n            // Server Flow\n            return await client.LoginAsync(RootView, \"aad\");\n        }\n        #endregion\n\n        public Context RootView { get; private set; }\n\n        public AccountStore AccountStore { get; private set; }\n\n        public void Init(Context context)\n        {\n            RootView = context;\n            AccountStore = AccountStore.Create(context);\n        }\n    }\n}  The iOS version is practically the same because we are using the common Xamarin.Auth portable library.  The\ndifference is in the methods outside of the ILoginProvider interface:  public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n\npublic AccountStore AccountStore { get; private set; }\n\npublic iOSLoginProvider()\n{\n    AccountStore = AccountStore.Create();\n}  Finally, the Universal Windows version (in  Services\\UWPLoginProvider.cs ) is significantly different in the\nsecure store implementation:  [assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public PasswordVault PasswordVault { get; private set; }\n\n        public UWPLoginProvider()\n        {\n            PasswordVault = new PasswordVault();\n        }\n\n        #region ILoginProvider Interface\n        public MobileServiceUser RetrieveTokenFromSecureStore()\n        {\n            try\n            {\n                // Check if the token is available within the password vault\n                var acct = PasswordVault.FindAllByResource(\"tasklist\").FirstOrDefault();\n                if (acct != null)\n                {\n                    var token = PasswordVault.Retrieve(\"tasklist\", acct.UserName).Password;\n                    if (token != null && token.Length > 0)\n                    {\n                        return new MobileServiceUser(acct.UserName)\n                        {\n                            MobileServiceAuthenticationToken = token\n                        };\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"Error retrieving existing token: {ex.Message}\");\n            }\n            return null;\n        }\n\n        public void StoreTokenInSecureStore(MobileServiceUser user)\n        {\n            PasswordVault.Add(new PasswordCredential(\"tasklist\", user.UserId, user.MobileServiceAuthenticationToken));\n        }\n\n        public async Task<MobileServiceUser> LoginAsync(MobileServiceClient client)\n        {\n            // Server-Flow Version\n            return await client.LoginAsync(\"aad\");\n        }\n        #endregion\n    }\n}  We can swap out the server-flow Azure Active Directory login method with any of the client-flow, server-flow or\ncustom flows that we have been discussing thus far across all three platform-specific implementations.  The common flow handles all the logic for us.  This is the  LoginAsync()  method in the  Services\\AzureCloudService.cs \nclass:  public async Task<MobileServiceUser> LoginAsync()\n{\n    var loginProvider = DependencyService.Get<ILoginProvider>();\n\n    client.CurrentUser = loginProvider.RetrieveTokenFromSecureStore();\n    if (client.CurrentUser != null)\n    {\n        // User has previously been authenticated - try to Refresh the token\n        try\n        {\n            var refreshed = await client.RefreshUserAsync();\n            if (refreshed != null)\n            {\n                loginProvider.StoreTokenInSecureStore(refreshed);\n                return refreshed;\n            }\n        }\n        catch (Exception refreshException)\n        {\n            Debug.WriteLine($\"Could not refresh token: {refreshException.Message}\");\n        }\n    }\n\n    if (client.CurrentUser != null && !IsTokenExpired(client.CurrentUser.MobileServiceAuthenticationToken))\n    {\n        // User has previously been authenticated, no refresh is required\n        return client.CurrentUser;\n    }\n\n    // We need to ask for credentials at this point\n    await loginProvider.LoginAsync(client);\n    if (client.CurrentUser != null)\n    {\n        // We were able to successfully log in\n        loginProvider.StoreTokenInSecureStore(client.CurrentUser);\n    }\n    return client.CurrentUser;\n}  For full disclosure, I've also moved the  IsTokenExpired()  method from the platform-specific code to the\nshared project, and updated the  ICloudService.cs  to match the new signature of  LoginAsync() .  The process\nfollows the best practices:   Check for a stored token - if one exists, try to refresh it.  If the token (that potentially just got refreshed) is not expired, continue using it.  If not, ask the user for credentials.  If we get a valid token back, store it in the secure store for next time.   There is another place that we must consider refresh tokens.  During a HTTP request to our mobile backend, it is\npossible that the token has expired since our last request.  The request will return a 401 Unauthorized response\nin this case.  We need to trap that and perform a login request.  The login request will either refresh the\ntoken or prompt the user for new credentials.  We can then continue with the request as before.  The Azure Mobile Apps SDK contains a mechanism for hooking into the HTTP workflow using a  DelegatingHandler . A\ndelegating handler is a base type for a HTTP handler that allows us to process the request and response from the\nHTTP client object before (and after) it finally get processed.  It's used for adding additional headers to the\nrequest or logging the request and response, for example.  We are going to use it to validate the response and\nre-submit the request (after login) if the request comes back as a 401 Unauthorized.  We start with the adjustment to the  Services\\AzureCloudService.cs  constructor:  public AzureCloudService()\n{\n    client = new MobileServiceClient(Locations.AppServiceUrl, new AuthenticationDelegatingHandler());\n\n    if (Locations.AlternateLoginHost != null)\n        client.AlternateLoginHost = new Uri(Locations.AlternateLoginHost);\n}  The  AuthenticationDelegatingHandler()  is the new piece here.  This is the delegating handler that we are going\nto implement to handle the re-try logic.  I've placed the code in  Helpers\\AuthenticationDelegatingHandler.cs :  using System.Collections.Generic;\nusing System.IO;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Helpers\n{\n    class AuthenticationDelegatingHandler : DelegatingHandler\n    {\n        protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n        {\n            // Clone the request, in case we need to re-issue it\n            var clone = await CloneHttpRequestMessageAsync(request);\n            // Now do the request\n            var response = await base.SendAsync(request, cancellationToken);\n\n            if (response.StatusCode == HttpStatusCode.Unauthorized)\n            {\n                // The request resulted in a 401 Unauthorized.  We need to do a LoginAsync,\n                // which will do the Refresh if appropriate, or ask for credentials if not.\n                var user = await ServiceLocator.Instance.Resolve<ICloudService>().LoginAsync();\n\n                // Now, retry the request with the cloned request.  The only thing we have\n                // to do is replace the X-ZUMO-AUTH header with the new auth token.\n                clone.Headers.Remove(\"X-ZUMO-AUTH\");\n                clone.Headers.Add(\"X-ZUMO-AUTH\", user.MobileServiceAuthenticationToken);\n                response = await base.SendAsync(clone, cancellationToken);\n            }\n\n            return response;\n        }\n\n        /// <summary>\n        /// Clone a HttpRequestMessage\n        /// Credit: http://stackoverflow.com/questions/25044166/how-to-clone-a-httprequestmessage-when-the-original-request-has-content\n        /// </summary>\n        /// <param name=\"req\">The request</param>\n        /// <returns>A copy of the request</returns>\n        public static async Task<HttpRequestMessage> CloneHttpRequestMessageAsync(HttpRequestMessage req)\n        {\n            HttpRequestMessage clone = new HttpRequestMessage(req.Method, req.RequestUri);\n\n            // Copy the request's content (via a MemoryStream) into the cloned object\n            var ms = new MemoryStream();\n            if (req.Content != null)\n            {\n                await req.Content.CopyToAsync(ms).ConfigureAwait(false);\n                ms.Position = 0;\n                clone.Content = new StreamContent(ms);\n\n                // Copy the content headers\n                if (req.Content.Headers != null)\n                    foreach (var h in req.Content.Headers)\n                        clone.Content.Headers.Add(h.Key, h.Value);\n            }\n\n\n            clone.Version = req.Version;\n\n            foreach (KeyValuePair<string, object> prop in req.Properties)\n                clone.Properties.Add(prop);\n\n            foreach (KeyValuePair<string, IEnumerable<string>> header in req.Headers)\n                clone.Headers.TryAddWithoutValidation(header.Key, header.Value);\n\n            return clone;\n        }\n    }\n}  There is no in-built method for cloning a  HttpRequestMessage  object.  Fortunately  Stack Overflow  provided\nan answer that seems to work.  Running this code will now pass every single non-login request through the delegating\nhandler.  If we get an Unauthorized at any point, the login flow (which includes an implicit refresh token) will\nbe triggered.   Info  There are two HTTPClient objects created inside of the  MobileServiceClient  object. One is for all the non-login\nflows and it supports the delegating handlers.  However there is another one for login flows.  The one for login\nflows does not support delegating handlers.  This means you don't have to worry about cyclical references within the\ndelegating handler (where a login flow triggers another login flow).",
            "title": "Using Refresh Tokens"
        },
        {
            "location": "/chapter2/realworld/#logging-out",
            "text": "There is a dirty little secret within the Azure Mobile Apps Client SDK.  Calling  LogoutAsync()  does not actually\ninvalidate the token you are using.  It simply removes it from the  MobileServiceClient  context.  Don't believe\nme?  Here is  the code :          /// <summary>\n        /// Log a user out.\n        /// </summary>\n        public Task LogoutAsync()\n        {\n            this.CurrentUser = null;\n            return Task.FromResult(0);\n        }  When you actually think about it, this makes sense.  You can get logged in via five different supported identity\nproviders via a web-flow.  In this case, you are logging your  browser  out of the identity provider.  Do you\nreally want to log out of Facebook when you log out of your app?  So, how do you log out?  You should:   Call the identity provider logout method (if appropriate).  Many identity providers don't provide this.  Invalidate the token on the mobile backend.  Remove the token from the local secure cache store.  Finally, call the  LogoutAsync()  method on the  MobileServiceClient .",
            "title": "Logging out"
        },
        {
            "location": "/chapter2/realworld/#invalidating-the-token-on-the-mobile-backend",
            "text": "Calling the  /.auth/logout  endpoint on the Azure App Service mobile backend will remove the entry\non the token store.  However, it does not (currently) invalidate the token.  The token, if submitted,\nwill still authorize the user.  The refresh token is stored in the token store. The user submitting the\ntoken will be unable to refresh the token.  Once the ZUMO token has expired (which happens an hour after\nit was created), the logout is complete.  We need to do a HTTP client call for this purpose:  // Invalidate the token on the mobile backend\nvar authUri = new Uri($\"{client.MobileAppUri}/.auth/logout\");\nusing (var httpClient = new HttpClient())\n{\n    httpClient.DefaultRequestHeaders.Add(\"X-ZUMO-AUTH\", client.CurrentUser.MobileServiceAuthenticationToken);\n    await httpClient.GetAsync(authUri);\n}",
            "title": "Invalidating the token on the mobile backend."
        },
        {
            "location": "/chapter2/realworld/#removing-the-token-from-the-local-secure-cache-store",
            "text": "For this part of the process, We can add a new method to the  ILoginProvider.cs  interface:  void RemoveTokenFromSecureStore();  For Android and iOS, the concrete implementation looks like this:  public void RemoveTokenFromSecureStore()\n{\n    var accounts = AccountStore.FindAccountsForService(\"tasklist\");\n    if (accounts != null)\n    {\n        foreach (var acct in accounts)\n        {\n            AccountStore.Delete(acct, \"tasklist\");\n        }\n    }\n}  For Universal Windows, the concrete implementation is a bit different:  public void RemoveTokenFromSecureStore()\n{\n    try\n    {\n        // Check if the token is available within the password vault\n        var acct = PasswordVault.FindAllByResource(\"tasklist\").FirstOrDefault();\n        if (acct != null)\n        {\n            PasswordVault.Remove(acct);\n        }\n    }\n    catch (Exception ex)\n    {\n        Debug.WriteLine($\"Error retrieving existing token: {ex.Message}\");\n    }\n}",
            "title": "Removing the token from the local secure cache store."
        },
        {
            "location": "/chapter2/realworld/#implementing-a-logoutasync-method",
            "text": "I've added the following to the  ICloudService  interface:  Task LogoutAsync();  This has a concrete implementation in  Services\\AzureCloudService.cs :  public async Task LogoutAsync()\n{\n    if (client.CurrentUser == null || client.CurrentUser.MobileServiceAuthenticationToken == null)\n        return;\n\n    // Log out of the identity provider (if required)\n\n    // Invalidate the token on the mobile backend\n    var authUri = new Uri($\"{client.MobileAppUri}/.auth/logout\");\n    using (var httpClient = new HttpClient())\n    {\n        httpClient.DefaultRequestHeaders.Add(\"X-ZUMO-AUTH\", client.CurrentUser.MobileServiceAuthenticationToken);\n        await httpClient.GetAsync(authUri);\n    }\n\n    // Remove the token from the cache\n    DependencyService.Get<ILoginProvider>().RemoveTokenFromSecureStore();\n\n    // Remove the token from the MobileServiceClient\n    await client.LogoutAsync();\n}  This does three of the four providers.  If your identity provider supports an app-level logout, then you\nshould call that where indicated.  This is probably going to be platform-specific code, so you will want\nto add a method to the  ILoginProvider.cs  interface and add a concrete implementation to each platform\nproject.  I've also added a logout button to my  Pages\\TaskList.xaml  ( view code ) and added the event handler\nfor the logout button to the  ViewModels\\EntryPageViewModel.cs  ( view code ).",
            "title": "Implementing a LogoutAsync() method."
        },
        {
            "location": "/chapter2/bestpractices/",
            "text": "Best Practices\n\u00b6\n\n\nWe've covered a lot of ground with authentication and authorization, so I wanted to cover some of the\nbest practices that I generally advise when thinking about this topic.\n\n\nDon't store passwords\n\u00b6\n\n\nI can't really advise on which identity provider is best for your mobile application.  However, I can\nclearly say that delegating the security of the identity database to someone who has that as their full\ntime job is an excellent idea.\n\n\nChoosing an identity provider is not easy.  Here are my choices:\n\n\n\n\nIf you need enterprise authentication, use \nAzure Active Directory\n.\n\n\nIf you need a specific social identity provider (for example, Facebook or Google), use that.\n\n\nIf you need multiple social identity providers, \nAuth0\n is an excellent choice.\n\n\nIf you need usernames and password, use \nAzure Active Directory B2C\n.\n\n\n\n\nStoring usernames and passwords in your own database is a bad idea and should be avoided.\n\n\nUse the client SDK provided by the Identity Provider\n\u00b6\n\n\nYour first step should be getting an access token from the identity provider itself.  You will see the\nmost integrated experience if you use their SDK.\n\n\n\n\nFor \nAzure Active Directory\n, that SDK is \nADAL\n.\n\n\nFor \nFacebook\n, check out \nXamarin.Facebook.iOS\n or \nXamarin.Facebook.Android\n.\n\n\nFor \nGoogle\n, check out \nGoogle APIs Core Client Library\n.\n\n\nFor \nAuth0\n, check out the \nAuth0 Xamarin Component\n.\n\n\nFor \nAzure Active Directory B2C\n, use \nADAL\n.\n\n\n\n\nSwap the Identity Provider access token for a ZUMO token.\n\u00b6\n\n\nNever use the token provided by the identity provider for anything other than requesting access to\nthe resource.  Use a short lived token (an hour is the standard) that is minted just for the purpose\nof providing that access.  If you are not using an identity provider that is explicitly supported\nby Azure App Service, use a custom authentication provider to mint your own token.\n\n\nEnforce Security at the Server\n\u00b6\n\n\nThere is no easy way to say this.  There are bad guys out there, and they are after your data.  You\nshould not assume that someone is using your client.  It could just be someone with a REST client.\nEnsure you enforce security on your server.  You can do this easily by using the \n[Authorize]\n\nattribute, the \n[AuthorizeClaims()]\n attribute we developed in the Authorization section or your\nown custom authorization attribute.\n\n\nMonitoring the server is just as important as enforcing security.  The Azure App Service Authentication\nservice outputs quite a bit of logging about who is logging in (and who is denied), so you can get some\ngood intelligence out of the logs when you mine them properly.\n\n\nSecurely Store Tokens\n\u00b6\n\n\nThe decisions we make are always a trade-off between convenience and security.  One such decision is\nif we should store tokens with the app.  On the one hand, it's convenient to allow the app to remember\nthe login and to not ask us to log in again with each app start.  On the other hand, that fact opens\nup a security hole that a determined hacker can exploit.  We can have convenience while still having\nsecurity by utilizing the secure stores that each platform provides to store secrets like the access\ntoken.\n\n\nUse https only\n\u00b6\n\n\nThis should go without saying.  Always use https communication.  Most security professionals start off\ntheir security career with learning \"Security at Rest & Security in Transit\".  In practical terms, storing\nsecrets (like tokens) securely and using HTTPS as a transport mechanism satisfies both claims.\n\n\nDon't stop with security there though.  HTTPS is just a medium through which secure communications can\ntake place.  There are a wide range of protocols and ciphers that can be used to encrypt the traffic.\nSome are  considered less secure and not to be used.  Azure App Service provides a default set of protocols\nand ciphers to support backwards compatibility with older browsers.  You can adjust the ciphers in use\nby your App Service.  For information on this, refer to the \nAzure Documentation\n.\n\n\nHandle Expiring Tokens\n\u00b6\n\n\nUnless you are using an identity provider that doesn't support refresh tokens (like Facebook or Twitter),\nyou should handle refresh tokens by silently calling the refresh action.  Tokens are going to expire.\nThis is a fact of the token specifications.  You need to deal with expiring tokens and act accordingly.\n\n\nIf you do need to use an identity provider that does not support refresh tokens, you are going to have\nto ask for credentials whenever the token expires.  You don't get out of determining the user experience\nwhen tokens expire just because you are using Facebook or Twitter.\n\n\nAuthenticating Your App\n\u00b6\n\n\nMy final word on authentication has to do with authenticating your app.  I get the same request every\nweek.  How do I implement an API key for my app?  When I probe a little, I get a few reasons for this\nrequest:\n\n\n\n\nI want to ensure my app is the only one accessing my backend because the data is important.\n\n\nI don't want my users to log in as it is inconvenient.\n\n\nI want to monetize my app, and I can't do that if anyone can copy it.\n\n\n\n\nAPI keys are used by multi-tenant systems to route requests for data to the appropriate data store.  For\nexample, the very popular \nParse Server\n used to have an API key because all clients connected to the\nsame \nparse.com\n service.  Once the \nParse Server\n was open-sourced, the API key went away.  It was no\nlonger needed to route the request.  In the same way, the Azure App Service has a unique name - the URL\nof the service, so it doesn't need an API key to route the information.\n\n\nAn API key does not prevent a rogue client from accessing your data.  If you did use an API key for security,\nyou can easily get the API key for the app by putting together a \"man in the middle proxy\".  One such proxy\nis \nTelerik Fiddler\n.  One of its features is \"Security Testing\" which amounts to a man-in-the-middle\ndecryption technique.  This \nworks with the Android emulator\n as well.  For iOS, you can use \nCharles\n.\n\n\nSo, how do you authenticate your app?  Step back a moment.  What are you monetizing or protecting?  It's\nlikely the data within the mobile backend.  Protect that data by authenticating your users.   If you absolutely\nmust monetize your app, then there are ways to do it, and we will discuss those later in the book.",
            "title": "Best Practices"
        },
        {
            "location": "/chapter2/bestpractices/#best-practices",
            "text": "We've covered a lot of ground with authentication and authorization, so I wanted to cover some of the\nbest practices that I generally advise when thinking about this topic.",
            "title": "Best Practices"
        },
        {
            "location": "/chapter2/bestpractices/#dont-store-passwords",
            "text": "I can't really advise on which identity provider is best for your mobile application.  However, I can\nclearly say that delegating the security of the identity database to someone who has that as their full\ntime job is an excellent idea.  Choosing an identity provider is not easy.  Here are my choices:   If you need enterprise authentication, use  Azure Active Directory .  If you need a specific social identity provider (for example, Facebook or Google), use that.  If you need multiple social identity providers,  Auth0  is an excellent choice.  If you need usernames and password, use  Azure Active Directory B2C .   Storing usernames and passwords in your own database is a bad idea and should be avoided.",
            "title": "Don't store passwords"
        },
        {
            "location": "/chapter2/bestpractices/#use-the-client-sdk-provided-by-the-identity-provider",
            "text": "Your first step should be getting an access token from the identity provider itself.  You will see the\nmost integrated experience if you use their SDK.   For  Azure Active Directory , that SDK is  ADAL .  For  Facebook , check out  Xamarin.Facebook.iOS  or  Xamarin.Facebook.Android .  For  Google , check out  Google APIs Core Client Library .  For  Auth0 , check out the  Auth0 Xamarin Component .  For  Azure Active Directory B2C , use  ADAL .",
            "title": "Use the client SDK provided by the Identity Provider"
        },
        {
            "location": "/chapter2/bestpractices/#swap-the-identity-provider-access-token-for-a-zumo-token",
            "text": "Never use the token provided by the identity provider for anything other than requesting access to\nthe resource.  Use a short lived token (an hour is the standard) that is minted just for the purpose\nof providing that access.  If you are not using an identity provider that is explicitly supported\nby Azure App Service, use a custom authentication provider to mint your own token.",
            "title": "Swap the Identity Provider access token for a ZUMO token."
        },
        {
            "location": "/chapter2/bestpractices/#enforce-security-at-the-server",
            "text": "There is no easy way to say this.  There are bad guys out there, and they are after your data.  You\nshould not assume that someone is using your client.  It could just be someone with a REST client.\nEnsure you enforce security on your server.  You can do this easily by using the  [Authorize] \nattribute, the  [AuthorizeClaims()]  attribute we developed in the Authorization section or your\nown custom authorization attribute.  Monitoring the server is just as important as enforcing security.  The Azure App Service Authentication\nservice outputs quite a bit of logging about who is logging in (and who is denied), so you can get some\ngood intelligence out of the logs when you mine them properly.",
            "title": "Enforce Security at the Server"
        },
        {
            "location": "/chapter2/bestpractices/#securely-store-tokens",
            "text": "The decisions we make are always a trade-off between convenience and security.  One such decision is\nif we should store tokens with the app.  On the one hand, it's convenient to allow the app to remember\nthe login and to not ask us to log in again with each app start.  On the other hand, that fact opens\nup a security hole that a determined hacker can exploit.  We can have convenience while still having\nsecurity by utilizing the secure stores that each platform provides to store secrets like the access\ntoken.",
            "title": "Securely Store Tokens"
        },
        {
            "location": "/chapter2/bestpractices/#use-https-only",
            "text": "This should go without saying.  Always use https communication.  Most security professionals start off\ntheir security career with learning \"Security at Rest & Security in Transit\".  In practical terms, storing\nsecrets (like tokens) securely and using HTTPS as a transport mechanism satisfies both claims.  Don't stop with security there though.  HTTPS is just a medium through which secure communications can\ntake place.  There are a wide range of protocols and ciphers that can be used to encrypt the traffic.\nSome are  considered less secure and not to be used.  Azure App Service provides a default set of protocols\nand ciphers to support backwards compatibility with older browsers.  You can adjust the ciphers in use\nby your App Service.  For information on this, refer to the  Azure Documentation .",
            "title": "Use https only"
        },
        {
            "location": "/chapter2/bestpractices/#handle-expiring-tokens",
            "text": "Unless you are using an identity provider that doesn't support refresh tokens (like Facebook or Twitter),\nyou should handle refresh tokens by silently calling the refresh action.  Tokens are going to expire.\nThis is a fact of the token specifications.  You need to deal with expiring tokens and act accordingly.  If you do need to use an identity provider that does not support refresh tokens, you are going to have\nto ask for credentials whenever the token expires.  You don't get out of determining the user experience\nwhen tokens expire just because you are using Facebook or Twitter.",
            "title": "Handle Expiring Tokens"
        },
        {
            "location": "/chapter2/bestpractices/#authenticating-your-app",
            "text": "My final word on authentication has to do with authenticating your app.  I get the same request every\nweek.  How do I implement an API key for my app?  When I probe a little, I get a few reasons for this\nrequest:   I want to ensure my app is the only one accessing my backend because the data is important.  I don't want my users to log in as it is inconvenient.  I want to monetize my app, and I can't do that if anyone can copy it.   API keys are used by multi-tenant systems to route requests for data to the appropriate data store.  For\nexample, the very popular  Parse Server  used to have an API key because all clients connected to the\nsame  parse.com  service.  Once the  Parse Server  was open-sourced, the API key went away.  It was no\nlonger needed to route the request.  In the same way, the Azure App Service has a unique name - the URL\nof the service, so it doesn't need an API key to route the information.  An API key does not prevent a rogue client from accessing your data.  If you did use an API key for security,\nyou can easily get the API key for the app by putting together a \"man in the middle proxy\".  One such proxy\nis  Telerik Fiddler .  One of its features is \"Security Testing\" which amounts to a man-in-the-middle\ndecryption technique.  This  works with the Android emulator  as well.  For iOS, you can use  Charles .  So, how do you authenticate your app?  Step back a moment.  What are you monetizing or protecting?  It's\nlikely the data within the mobile backend.  Protect that data by authenticating your users.   If you absolutely\nmust monetize your app, then there are ways to do it, and we will discuss those later in the book.",
            "title": "Authenticating Your App"
        },
        {
            "location": "/chapter3/dataconcepts/",
            "text": "Data Access Concepts\n\u00b6\n\n\nAt some point in the development of your application, you are going to want to store or retrieve data.  This could be\nas simple as a key-value store for storing personal settings, or as complex as a multi-table customer relationship\ndatabase.  The key ingredient to all these scenarios is structured data.  I say \nstructured\n here deliberately.  It\nis an important concept.  Most applications you write will require data in some sort of form that your application\nunderstands.\n\n\nIt's very tempting to use an unstructured data source (like NoSQL).  I'm a big fan of NoSQL stores since they free\nme up to concentrate on the mobile client without worrying about the data format. After all, you can store whatever\nentities you want in a NoSQL data source.  However, this is really just an example of sloppy programming.  Most\ndevelopers that use NoSQL are storing structured data in that NoSQL store to get around the problem that you actually\nhave to decide what data you want to store in the database.  For this reason, I prefer a SQL database.  It ensures\nthat I am thinking about the data format up front.  It also helps to ensure that a bad actor is not going to store\ndata I don't expect in my store.\n\n\nThis isn't to say that NoSQL doesn't have its place.  There are times when you need to store structured data where\nthe data format varies between each entity that you are storing.  This tends to be an outlier situation though.\n\n\nTables, Entities and Properties\n\u00b6\n\n\nWhen we talk about data, we tend to talk in terms of \nTables\n, \nEntities\n and \nProperties\n.  These have equivalents\nin the SQL world (tables, rows and fields).  A \nTable\n is a collection of \nEntities\n that share a common format.  That\nformat is described in terms of \nProperties\n.  Properties are basic types (like strings, numbers, booleans and dates).\n\n\nWe create a \nTable Controller\n to expose the tables to a mobile client.  A \nTable Controller\n is a REST endpoint\nthat implements an \nOData v3\n interface.  OData is a standard interface to table data that allows the client to\nperform CRUD (create, read, update and delete) operations on the data.  In addition, it provides for a standard\nway for querying the data.  More normally, the \nTable Controller\n is accessed through the Azure Mobile Apps Client\nSDK.  We saw an example of this in Chapter 1 when we first introduced the mobile client.\n\n\nAzure Mobile Apps also deals with tables in a manner that enables offline synchronization of the data.  That means\nit must be opinionated about the data format.  Specifically,\n\n\n\n\nThere are four system properties on each entity.\n\n\nThere are limitations on relationships between tables.\n\n\nComplex types need special handling.\n\n\n\n\nLet's take each of these in turn.  We implemented this \nModel\n within the mobile client in Chapter 1:\n\n\nusing TaskList.Abstractions;\n\nnamespace TaskList.Models\n{\n    public class TodoItem : TableData\n    {\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n    }\n}\n\n\n\n\nIt's a fairly basic model class.  Note the \nTableData\n base class.  I often say that Azure Mobile Apps implements\nan opinionated version of OData. What I mean by that is that the protocol expects certain system fields to be present\nduring the transfer.  The \nTableData\n class is a base class that implements that specification. It looks like this:\n\n\nusing System;\n\nnamespace TaskList.Abstractions\n{\n    public abstract class TableData\n    {\n        public string Id { get; set; }\n        public DateTimeOffset? UpdatedAt { get; set; }\n        public byte[] Version { get; set; }\n    }\n}\n\n\n\n\nThe server side version adds another field - the \nDeleted\n boolean.  This is described in the \nITableData\n interface\nthat is provided with the Azure Mobile Apps Server SDK.\n\n\n\n\nInfo\n\n\nThe Azure Mobile Apps SDK uses \nDateTimeOffset\n instead of \nDateTime\n.  A DateTime object is time\nzone aware, and time zone definitions change over time.  The DateTimeOffset does not know anything\nabout time zones.  The DateTime representation can change depending on where you are.  The DateTimeOffset\nwill never change.  This makes it a better choice for these things.  You will see dates stored in UTC in\nyour database as a result of this.\n\n\n\n\nEach element of the TableData (and ITableData) has a purpose, nominally to deal with situations with Offline Sync.\n\n\nThe Id field\n\u00b6\n\n\nOne of the common questions is this:  Can I use an auto-incrementing integer as an Id field?  Let's take a look at\na simple situation.  You have two clients writing to the same table.  It might look something like this:\n\n\n\n\nDevice A inserts a new record in to the database, with ID 1.  Device B is also inserting and decides to do ID 1\nas well.  This causes an immediate conflict that must be resolved.  We could fix this by requiring that new inserts\ndo not insert an ID.  However, this can cause problems in offline cases, where you may be inserting many records\nand have to refer back to them during your offline state.\n\n\nThe compromise here is to use a globally unique ID.  The \nGUID\n is a well-known algorithm and easily generated in\noffline scenarios.  This is stored as a string during transfer.\n\n\nThe UpdatedAt field\n\u00b6\n\n\nOne of the concepts that is always top of mind is ensuring that we are a good mobile citizen.  This means that we\ncare about bandwidth utilization.  Reducing transfer size is good for your users.  They use less of their data\nallowance and save time by transferring less.  One of the key components to reduce bandwidth utilization is \nIncremental\nSync\n.  With each record, we record the date it was last updated.  This is generally done for us as a database\ntrigger, so we never have to worry about setting this value.  When we synchronize our table, only the records\nthat have been updated since the last synchronization are requested.\n\n\nThe Version field\n\u00b6\n\n\nThe version field is all about conflict detection.  Let's take two devices requesting the same table again:\n\n\n\n\nIn this diagram, Device A submits the first version of the entity.  Device B then updates the entity and posts\nit back.  This is accepted because Device B is sending the same version, so the server knows that this is an\nupdate to the latest version.  The server will send back a response with the updated version so that Device B\nknows that it has the latest version.\n\n\nLater on, Device A sends an update to the same entity.  It, however, still has version 1 of the entity.  The\nserver will reject that because of a version mismatch.\n\n\nThe Deleted field\n\u00b6\n\n\nWhen you are operating a service with an offline scope, you can't just delete entities.  If an entity is deleted\non Device A, it is then removed from the server.  The server does not know to send an update to that entity\nto Device B because it no longer exists.  For this reason, we never delete entities.  We use \nSoft Delete\n.\nSoft Delete is a feature whereby entities are marked as deleted by setting the Deleted flag to true.  When you\nquery the server, the deleted records are not shown unless you explicitly ask for them.  This is done as part\nof the offline sync process.\n\n\nThe Data Access Protocol\n\u00b6\n\n\nGiven any particular table, there are a few endpoints that are important.  Given our TodoItem table from Chapter 1:\n\n\n\n\n\n\n\n\nOperation\n\n\nEndpoint\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nGET\n\n\n/tables/todoitem\n\n\nQuery the table\n\n\n\n\n\n\nGET\n\n\n/tables/todoitem/\nid\n\n\nRetrieve a single entity\n\n\n\n\n\n\nPOST\n\n\n/tables/todoitem\n\n\nAdd a new entity\n\n\n\n\n\n\nPATCH\n\n\n/tables/todoitem/\nid\n\n\nUpdate an existing entity\n\n\n\n\n\n\nDELETE\n\n\n/tables/todoitem/\nid\n\n\nDeletes an existing entity\n\n\n\n\n\n\nPOST\n\n\n/tables/todoitem/\nid\n\n\nUndelete a previously deleted entity\n\n\n\n\n\n\n\n\nWe can take a look at each of these in turn with the Azure App Service.  These can be done with Postman easily.\n\n\n\n\nInfo\n\n\nThe first request to a new Azure App Service will take some time, especially if the site has to set up the database.\n\n\n\n\nLet's start with a basic Query operation:\n\n\n\n\nWe always get an array of elements back.  These contain five system properties.  We didn't mention createdAt\nearlier - it's optional and will be maintained for you if you don't use it.  In addition, we have the fields\nthat were in our model.  If there are no elements in a table, we get an empty array.  If the table does not\nexist, we will get a \n404 Not Found\n error.\n\n\n\n\nInfo\n\n\nAny operation can also return a \n401 Unauthorized\n if you are not allowed to do the operation with the\ncurrent authentication, \n400 Bad Request\n if you supplied bad data and \n500 Internal Server Error\n if\nthe server crashed.\n\n\n\n\nWe can also do a GET for an Id:\n\n\n\n\nThe return is the entity serialized as an object.  If the Id does not exist, then a \n404 Not Found\n is\nreturned.\n\n\nAdding an item requires a POST:\n\n\n\n\nNote that you do not need to provide all the fields.  In particular, the system fields will be automatically\nfilled in for you.  Any fields with a default value will be similarly auto-created.  It is fairly easy to\ngenerate a \n400 Bad Request\n when updating or inserting data.  For example, if you submit a string when a number\nis expected or submit a malformed date, you can expect a \n400 Bad Request\n.  On success, the response has a\nLocation field in the headers:\n\n\n\n\nThis is the URI of the entity.  You can do a GET on this location to get the entity again.  Updating an entity\ninvolves sending the updated fields to the \nId\n endpoint with the changed properties:\n\n\n\n\nNote that you do not need to send the entire entity - just the properties that are changed.  The new entity is\nreturned on success.  As with the insert operation, data format errors will result in a \n400 Bad Request\n.  Note,\nhowever, that if you do not submit a \nversion\n field, no conflict handling is done and the server just accepts\nthe record.  We can fix this with server code later on by requiring a version field on updates.\n\n\nDeletion is fairly straight forward.  The main different is that it returns a \n204 No Content\n.\n\n\n\n\nThe table controller does not support soft delete out of the box.  If you have followed the sequence, the\nrecord we just deleted is gone.  You can verify this using a SQL Browser.  To enable soft delete, you need\nto adjust the domain manager in the TodoItemController:\n\n\nprotected override void Initialize(HttpControllerContext controllerContext)\n{\n    base.Initialize(controllerContext);\n    MobileServiceContext context = new MobileServiceContext();\n    DomainManager = new EntityDomainManager<TodoItem>(context, Request, enableSoftDelete: true);\n}\n\n\n\n\nAdding the \nenableSoftDelete\n parameter and setting it to true will enable the appropriate logic in the\ndomain manager.\n\n\n\n\nInfo\n\n\nWe haven't introduced the \nDomain Manager\n yet.  Azure Mobile Apps doesn't really care what sort of\ndata store you are using on the backend.  It proxies all requests through a class that implements the\n\nIDomainManager\n interface.  Azure Mobile Apps Server SDK supplies one such domain manager - the\n\nEntityDomainManager\n uses Entity Framework underneath for this purpose.\n\n\n\n\nGo through the same process of adding and deleting an entity.  You can see the entity by using the SQL Server Object\nExplorer in Visual Studio:\n\n\n\n\nGo to \nServer Explorer\n.\n\n\nExpand \nAzure\n and \nSQL Databases\n.\n\n\nSelect your database, then right-click and select \nOpen in SQL Server Object Explorer\n.\n\n\nYou will be prompted for your username and password.  Enter them, then click \nOK\n.\n\n\nYou may be prompted to update the firewall for SQL access.  Select \nMy Client IP\n, then \nOK\n.\n\n\nExpand your database node, then \nTables\n.\n\n\nRight-click on \ndbo.TodoItems\n and select \nView Data\n.\n\n\n\n\nI find the SQL Server Object Explorer to be relatively slow when it comes to database options.  However, it doesn't\nrequire any additional installs.  You can also use SQL Server Management Studio if you have it installed.  You will\nneed to \nupdate the firewall\n for access (something the SQL Server Object Explorer will do for you).\n\n\n\n\nNote the third record has the Deleted column set to true.  We will not see that record when we do a query.  We can\nsee the deleted records only if we use the parameter \n__includeDeleted=true\n:\n\n\n\n\nWe can now undelete that record by POSTing to the \nId\n endpoint:\n\n\n\n\nA success results in a \n201 Created\n response, with a failure resulting in a \n404 Not Found\n response (assuming the\nfailure is because the Id does not exist in the table).\n\n\nFiltering Data\n\u00b6\n\n\nIf you have followed along, we have three entities in our table now.  We can do searches by utilizing the OData\n\n$filter\n operator as a query:\n\n\n\n\nThe \n$filter\n parameter takes an \nOData filter\n and returns the list of entities that match the search.  The Azure\nMobile Apps SDK supports quite a bit of the OData v3 specification that is supported by the \nMicrosoft.Data.OData\n\npackage, but not everything.  There are features of the OData package that are explicitly disabled because they\ndo not work in an offline context.  OData was defined as a method of transferring data between client and server\nin an online context so we can expect some things to work differently.\n\n\nWe can also select specific fields by using the \n$select\n clause:\n\n\n\n\nPaging Results\n\u00b6\n\n\nAt some point, we are going to bump into an in-built limit of the server.  You can clearly see this by inserting\na lot of entities then querying the results.  Once the number of entities gets above 50, paging will occur.  You\ncan adjust the paging size on the server by adding an \n[EnableQuery()]\n attribute to the class.  For example, the\nfollowing will set the page size at 10:\n\n\nnamespace Chapter3.Controllers\n{\n    [EnableQuery(PageSize=10)]\n    public class TodoItemController : TableController<TodoItem>\n    {\n\n\n\n\nYou cannot make the page size infinite, so you should always implement paging controls in your mobile client.\n\n\nWe can always receive the number of records that would have been sent if paging had not been in place by including\n\n$inlinecount=allpages\n with the query.  The query response turns into an object with two properties - the \nresults\n\nproperty contains the array of results.  This is the same response as we received before.  There is now another\nproperty called \ncount\n that contains the count of the records:\n\n\n\n\nWe can implement paging by using \n$top\n and \n$skip\n parameters. The \n$top\n parameter tells the server how many\nentities you want to return.  The \n$skip\n parameter tells the server how many entities to skip before it starts\ncounting.\n\n\nFor example, let's say you wanted to receive individual entities.  You could request:\n\n\n\n\n/tables/todoitem?$top=1&$skip=0\n\n\n/tables/todoitem?$top=1&$skip=1\n\n\n/tables/todoitem?$top=1&$skip=2\n\n\n/tables/todoitem?$top=1&$skip=3\n\n\n\n\nAt this point, no entities would be returned and you would know you are at the end.\n\n\n\n\nWarn\n\n\nAlthough it is tempting to suggest removing the limit on the number of entities that can be returned (so you\ncan receive all entities in one shot), it's better to implement paging.  The Azure App Service will run in a\nsmaller App Service Plan because it won't require as much memory.  You will be able to support more users and\nyour code will be more resilient to network issues that occur during transmission.\n\n\n\n\nOffline synchronization\n\u00b6\n\n\nOne of the many reasons that developers choose the Azure Mobile Apps SDK is that it natively supports offline\nsync.  Offline sync provides a number of benefits.  It improves app responsiveness by caching server data\nlocally on the device.  It allows the app to survive network issues including little or no connectivity, and it\nallows the developer to decide when to synchronize, thus allowing the deferral of large updates to when there\nis wifi available, for example.  The Azure Mobile Apps SDKs provide incremental sync (thereby ensuring the minimal\namount of mobile data is used), optimistic concurrency and conflict resolution.\n\n\nTo do this, Azure Mobile Apps provides a SQLite based backing store for data persistence on the mobile client.  You\ndon't have to use SQLite, but it's built in and there are very few reasons to not use it.  If you are using iOS,\nthe implementation is based on Core Data (which is itself based on SQLite).\n\n\nWhen you perform changes to an offline table, a \nSync Context\n is created along side the offline table. One of the\nelements of this sync context is an \nOperation Queue\n.  This is an ordered list of Create, Update and Delete\noperations against the offline table.  When you \nPUSH\n the Sync Context, the list of creates, updates and Deletes\nare sent one by one to the Azure App Service, which then executes them as if they were done online.  Nothing is\nsent to the Azure App Service until your call to \nPUSH\n.\n\n\nTo retrieve entities, your mobile client will perform a \nPULL\n against a query.  The query is based on the filter\nthat we reviewed earlier.  By default, all properties of all entities are pulled down.  An \nImplicit Push\n happens\nif there are entities in the operation queue at the time of a pull request.  If you specify a query name (which is\njust a text string) to the \nPullAsync()\n method, the mobile client will do an \nIncremental Sync\n.  In this case,\nthe latest \nUpdatedAt\n timestamp that the mobile client saw is recorded in the \nSync Context\n (and associated with\nthe query name).  This allows the pull operation to pick up where it left off.\n\n\n\n\nTip\n\n\nThe query name must be unique within a Sync Context for incremental sync to work.\n\n\n\n\nThe sync process implements \nOptimistic Concurrency\n.  With optimistic concurrency, the mobile client assumes that\nits change is valid.  Conflicts are handled only on push operations.  If the mobile client submits a record with\na \nversion\n field that does not match the server version field, the server will return a 409 or 412 response code.\n\n\n\n\nInfo\n\n\nWhat's the difference between 409 and 412?  Most of the time, you will see 412 Precondition Failed.  This\nmeans the ETag of the request did not match.  The ETag is a header that is equivalent to the version value.\n409 Conflict occurs when you don't submit an ETag but do submit a version field in the update.\n\n\n\n\nIf no version field (or ETag header) is submitted, the client entity is used for the create or update irrespective\nof the value on the server.",
            "title": "Concepts"
        },
        {
            "location": "/chapter3/dataconcepts/#data-access-concepts",
            "text": "At some point in the development of your application, you are going to want to store or retrieve data.  This could be\nas simple as a key-value store for storing personal settings, or as complex as a multi-table customer relationship\ndatabase.  The key ingredient to all these scenarios is structured data.  I say  structured  here deliberately.  It\nis an important concept.  Most applications you write will require data in some sort of form that your application\nunderstands.  It's very tempting to use an unstructured data source (like NoSQL).  I'm a big fan of NoSQL stores since they free\nme up to concentrate on the mobile client without worrying about the data format. After all, you can store whatever\nentities you want in a NoSQL data source.  However, this is really just an example of sloppy programming.  Most\ndevelopers that use NoSQL are storing structured data in that NoSQL store to get around the problem that you actually\nhave to decide what data you want to store in the database.  For this reason, I prefer a SQL database.  It ensures\nthat I am thinking about the data format up front.  It also helps to ensure that a bad actor is not going to store\ndata I don't expect in my store.  This isn't to say that NoSQL doesn't have its place.  There are times when you need to store structured data where\nthe data format varies between each entity that you are storing.  This tends to be an outlier situation though.",
            "title": "Data Access Concepts"
        },
        {
            "location": "/chapter3/dataconcepts/#tables-entities-and-properties",
            "text": "When we talk about data, we tend to talk in terms of  Tables ,  Entities  and  Properties .  These have equivalents\nin the SQL world (tables, rows and fields).  A  Table  is a collection of  Entities  that share a common format.  That\nformat is described in terms of  Properties .  Properties are basic types (like strings, numbers, booleans and dates).  We create a  Table Controller  to expose the tables to a mobile client.  A  Table Controller  is a REST endpoint\nthat implements an  OData v3  interface.  OData is a standard interface to table data that allows the client to\nperform CRUD (create, read, update and delete) operations on the data.  In addition, it provides for a standard\nway for querying the data.  More normally, the  Table Controller  is accessed through the Azure Mobile Apps Client\nSDK.  We saw an example of this in Chapter 1 when we first introduced the mobile client.  Azure Mobile Apps also deals with tables in a manner that enables offline synchronization of the data.  That means\nit must be opinionated about the data format.  Specifically,   There are four system properties on each entity.  There are limitations on relationships between tables.  Complex types need special handling.   Let's take each of these in turn.  We implemented this  Model  within the mobile client in Chapter 1:  using TaskList.Abstractions;\n\nnamespace TaskList.Models\n{\n    public class TodoItem : TableData\n    {\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n    }\n}  It's a fairly basic model class.  Note the  TableData  base class.  I often say that Azure Mobile Apps implements\nan opinionated version of OData. What I mean by that is that the protocol expects certain system fields to be present\nduring the transfer.  The  TableData  class is a base class that implements that specification. It looks like this:  using System;\n\nnamespace TaskList.Abstractions\n{\n    public abstract class TableData\n    {\n        public string Id { get; set; }\n        public DateTimeOffset? UpdatedAt { get; set; }\n        public byte[] Version { get; set; }\n    }\n}  The server side version adds another field - the  Deleted  boolean.  This is described in the  ITableData  interface\nthat is provided with the Azure Mobile Apps Server SDK.   Info  The Azure Mobile Apps SDK uses  DateTimeOffset  instead of  DateTime .  A DateTime object is time\nzone aware, and time zone definitions change over time.  The DateTimeOffset does not know anything\nabout time zones.  The DateTime representation can change depending on where you are.  The DateTimeOffset\nwill never change.  This makes it a better choice for these things.  You will see dates stored in UTC in\nyour database as a result of this.   Each element of the TableData (and ITableData) has a purpose, nominally to deal with situations with Offline Sync.",
            "title": "Tables, Entities and Properties"
        },
        {
            "location": "/chapter3/dataconcepts/#the-id-field",
            "text": "One of the common questions is this:  Can I use an auto-incrementing integer as an Id field?  Let's take a look at\na simple situation.  You have two clients writing to the same table.  It might look something like this:   Device A inserts a new record in to the database, with ID 1.  Device B is also inserting and decides to do ID 1\nas well.  This causes an immediate conflict that must be resolved.  We could fix this by requiring that new inserts\ndo not insert an ID.  However, this can cause problems in offline cases, where you may be inserting many records\nand have to refer back to them during your offline state.  The compromise here is to use a globally unique ID.  The  GUID  is a well-known algorithm and easily generated in\noffline scenarios.  This is stored as a string during transfer.",
            "title": "The Id field"
        },
        {
            "location": "/chapter3/dataconcepts/#the-updatedat-field",
            "text": "One of the concepts that is always top of mind is ensuring that we are a good mobile citizen.  This means that we\ncare about bandwidth utilization.  Reducing transfer size is good for your users.  They use less of their data\nallowance and save time by transferring less.  One of the key components to reduce bandwidth utilization is  Incremental\nSync .  With each record, we record the date it was last updated.  This is generally done for us as a database\ntrigger, so we never have to worry about setting this value.  When we synchronize our table, only the records\nthat have been updated since the last synchronization are requested.",
            "title": "The UpdatedAt field"
        },
        {
            "location": "/chapter3/dataconcepts/#the-version-field",
            "text": "The version field is all about conflict detection.  Let's take two devices requesting the same table again:   In this diagram, Device A submits the first version of the entity.  Device B then updates the entity and posts\nit back.  This is accepted because Device B is sending the same version, so the server knows that this is an\nupdate to the latest version.  The server will send back a response with the updated version so that Device B\nknows that it has the latest version.  Later on, Device A sends an update to the same entity.  It, however, still has version 1 of the entity.  The\nserver will reject that because of a version mismatch.",
            "title": "The Version field"
        },
        {
            "location": "/chapter3/dataconcepts/#the-deleted-field",
            "text": "When you are operating a service with an offline scope, you can't just delete entities.  If an entity is deleted\non Device A, it is then removed from the server.  The server does not know to send an update to that entity\nto Device B because it no longer exists.  For this reason, we never delete entities.  We use  Soft Delete .\nSoft Delete is a feature whereby entities are marked as deleted by setting the Deleted flag to true.  When you\nquery the server, the deleted records are not shown unless you explicitly ask for them.  This is done as part\nof the offline sync process.",
            "title": "The Deleted field"
        },
        {
            "location": "/chapter3/dataconcepts/#the-data-access-protocol",
            "text": "Given any particular table, there are a few endpoints that are important.  Given our TodoItem table from Chapter 1:     Operation  Endpoint  Description      GET  /tables/todoitem  Query the table    GET  /tables/todoitem/ id  Retrieve a single entity    POST  /tables/todoitem  Add a new entity    PATCH  /tables/todoitem/ id  Update an existing entity    DELETE  /tables/todoitem/ id  Deletes an existing entity    POST  /tables/todoitem/ id  Undelete a previously deleted entity     We can take a look at each of these in turn with the Azure App Service.  These can be done with Postman easily.   Info  The first request to a new Azure App Service will take some time, especially if the site has to set up the database.   Let's start with a basic Query operation:   We always get an array of elements back.  These contain five system properties.  We didn't mention createdAt\nearlier - it's optional and will be maintained for you if you don't use it.  In addition, we have the fields\nthat were in our model.  If there are no elements in a table, we get an empty array.  If the table does not\nexist, we will get a  404 Not Found  error.   Info  Any operation can also return a  401 Unauthorized  if you are not allowed to do the operation with the\ncurrent authentication,  400 Bad Request  if you supplied bad data and  500 Internal Server Error  if\nthe server crashed.   We can also do a GET for an Id:   The return is the entity serialized as an object.  If the Id does not exist, then a  404 Not Found  is\nreturned.  Adding an item requires a POST:   Note that you do not need to provide all the fields.  In particular, the system fields will be automatically\nfilled in for you.  Any fields with a default value will be similarly auto-created.  It is fairly easy to\ngenerate a  400 Bad Request  when updating or inserting data.  For example, if you submit a string when a number\nis expected or submit a malformed date, you can expect a  400 Bad Request .  On success, the response has a\nLocation field in the headers:   This is the URI of the entity.  You can do a GET on this location to get the entity again.  Updating an entity\ninvolves sending the updated fields to the  Id  endpoint with the changed properties:   Note that you do not need to send the entire entity - just the properties that are changed.  The new entity is\nreturned on success.  As with the insert operation, data format errors will result in a  400 Bad Request .  Note,\nhowever, that if you do not submit a  version  field, no conflict handling is done and the server just accepts\nthe record.  We can fix this with server code later on by requiring a version field on updates.  Deletion is fairly straight forward.  The main different is that it returns a  204 No Content .   The table controller does not support soft delete out of the box.  If you have followed the sequence, the\nrecord we just deleted is gone.  You can verify this using a SQL Browser.  To enable soft delete, you need\nto adjust the domain manager in the TodoItemController:  protected override void Initialize(HttpControllerContext controllerContext)\n{\n    base.Initialize(controllerContext);\n    MobileServiceContext context = new MobileServiceContext();\n    DomainManager = new EntityDomainManager<TodoItem>(context, Request, enableSoftDelete: true);\n}  Adding the  enableSoftDelete  parameter and setting it to true will enable the appropriate logic in the\ndomain manager.   Info  We haven't introduced the  Domain Manager  yet.  Azure Mobile Apps doesn't really care what sort of\ndata store you are using on the backend.  It proxies all requests through a class that implements the IDomainManager  interface.  Azure Mobile Apps Server SDK supplies one such domain manager - the EntityDomainManager  uses Entity Framework underneath for this purpose.   Go through the same process of adding and deleting an entity.  You can see the entity by using the SQL Server Object\nExplorer in Visual Studio:   Go to  Server Explorer .  Expand  Azure  and  SQL Databases .  Select your database, then right-click and select  Open in SQL Server Object Explorer .  You will be prompted for your username and password.  Enter them, then click  OK .  You may be prompted to update the firewall for SQL access.  Select  My Client IP , then  OK .  Expand your database node, then  Tables .  Right-click on  dbo.TodoItems  and select  View Data .   I find the SQL Server Object Explorer to be relatively slow when it comes to database options.  However, it doesn't\nrequire any additional installs.  You can also use SQL Server Management Studio if you have it installed.  You will\nneed to  update the firewall  for access (something the SQL Server Object Explorer will do for you).   Note the third record has the Deleted column set to true.  We will not see that record when we do a query.  We can\nsee the deleted records only if we use the parameter  __includeDeleted=true :   We can now undelete that record by POSTing to the  Id  endpoint:   A success results in a  201 Created  response, with a failure resulting in a  404 Not Found  response (assuming the\nfailure is because the Id does not exist in the table).",
            "title": "The Data Access Protocol"
        },
        {
            "location": "/chapter3/dataconcepts/#filtering-data",
            "text": "If you have followed along, we have three entities in our table now.  We can do searches by utilizing the OData $filter  operator as a query:   The  $filter  parameter takes an  OData filter  and returns the list of entities that match the search.  The Azure\nMobile Apps SDK supports quite a bit of the OData v3 specification that is supported by the  Microsoft.Data.OData \npackage, but not everything.  There are features of the OData package that are explicitly disabled because they\ndo not work in an offline context.  OData was defined as a method of transferring data between client and server\nin an online context so we can expect some things to work differently.  We can also select specific fields by using the  $select  clause:",
            "title": "Filtering Data"
        },
        {
            "location": "/chapter3/dataconcepts/#paging-results",
            "text": "At some point, we are going to bump into an in-built limit of the server.  You can clearly see this by inserting\na lot of entities then querying the results.  Once the number of entities gets above 50, paging will occur.  You\ncan adjust the paging size on the server by adding an  [EnableQuery()]  attribute to the class.  For example, the\nfollowing will set the page size at 10:  namespace Chapter3.Controllers\n{\n    [EnableQuery(PageSize=10)]\n    public class TodoItemController : TableController<TodoItem>\n    {  You cannot make the page size infinite, so you should always implement paging controls in your mobile client.  We can always receive the number of records that would have been sent if paging had not been in place by including $inlinecount=allpages  with the query.  The query response turns into an object with two properties - the  results \nproperty contains the array of results.  This is the same response as we received before.  There is now another\nproperty called  count  that contains the count of the records:   We can implement paging by using  $top  and  $skip  parameters. The  $top  parameter tells the server how many\nentities you want to return.  The  $skip  parameter tells the server how many entities to skip before it starts\ncounting.  For example, let's say you wanted to receive individual entities.  You could request:   /tables/todoitem?$top=1&$skip=0  /tables/todoitem?$top=1&$skip=1  /tables/todoitem?$top=1&$skip=2  /tables/todoitem?$top=1&$skip=3   At this point, no entities would be returned and you would know you are at the end.   Warn  Although it is tempting to suggest removing the limit on the number of entities that can be returned (so you\ncan receive all entities in one shot), it's better to implement paging.  The Azure App Service will run in a\nsmaller App Service Plan because it won't require as much memory.  You will be able to support more users and\nyour code will be more resilient to network issues that occur during transmission.",
            "title": "Paging Results"
        },
        {
            "location": "/chapter3/dataconcepts/#offline-synchronization",
            "text": "One of the many reasons that developers choose the Azure Mobile Apps SDK is that it natively supports offline\nsync.  Offline sync provides a number of benefits.  It improves app responsiveness by caching server data\nlocally on the device.  It allows the app to survive network issues including little or no connectivity, and it\nallows the developer to decide when to synchronize, thus allowing the deferral of large updates to when there\nis wifi available, for example.  The Azure Mobile Apps SDKs provide incremental sync (thereby ensuring the minimal\namount of mobile data is used), optimistic concurrency and conflict resolution.  To do this, Azure Mobile Apps provides a SQLite based backing store for data persistence on the mobile client.  You\ndon't have to use SQLite, but it's built in and there are very few reasons to not use it.  If you are using iOS,\nthe implementation is based on Core Data (which is itself based on SQLite).  When you perform changes to an offline table, a  Sync Context  is created along side the offline table. One of the\nelements of this sync context is an  Operation Queue .  This is an ordered list of Create, Update and Delete\noperations against the offline table.  When you  PUSH  the Sync Context, the list of creates, updates and Deletes\nare sent one by one to the Azure App Service, which then executes them as if they were done online.  Nothing is\nsent to the Azure App Service until your call to  PUSH .  To retrieve entities, your mobile client will perform a  PULL  against a query.  The query is based on the filter\nthat we reviewed earlier.  By default, all properties of all entities are pulled down.  An  Implicit Push  happens\nif there are entities in the operation queue at the time of a pull request.  If you specify a query name (which is\njust a text string) to the  PullAsync()  method, the mobile client will do an  Incremental Sync .  In this case,\nthe latest  UpdatedAt  timestamp that the mobile client saw is recorded in the  Sync Context  (and associated with\nthe query name).  This allows the pull operation to pick up where it left off.   Tip  The query name must be unique within a Sync Context for incremental sync to work.   The sync process implements  Optimistic Concurrency .  With optimistic concurrency, the mobile client assumes that\nits change is valid.  Conflicts are handled only on push operations.  If the mobile client submits a record with\na  version  field that does not match the server version field, the server will return a 409 or 412 response code.   Info  What's the difference between 409 and 412?  Most of the time, you will see 412 Precondition Failed.  This\nmeans the ETag of the request did not match.  The ETag is a header that is equivalent to the version value.\n409 Conflict occurs when you don't submit an ETag but do submit a version field in the update.   If no version field (or ETag header) is submitted, the client entity is used for the create or update irrespective\nof the value on the server.",
            "title": "Offline synchronization"
        },
        {
            "location": "/chapter3/server/",
            "text": "Implementing Table Controllers\n\u00b6\n\n\nThe central component for providing a table endpoint on the Azure App Service side of things occurs in your\nbackend project.  You must implement a Table Controller.  This is a specialized version of an ApiController\nthat has some similarities with an ODataController.  However, it has its own base class and the Azure Mobile\nApps SDK simplifies the process of making them.\n\n\nImplementing Code First Migrations\n\u00b6\n\n\nBefore we can get started with adding another table controller, we have to deal with modifications to our\ndatabase schema.  The default code for Azure Mobile Apps will deploy the configured schema \nonly if the\ndatabase is empty\n.  If the database is not empty, you have to do extra work.  This extra work involves\nupdating the schema of your database.\n\n\nThere are two methods of doing this.  The first we will consider is Code First Migrations.  With code first\nmigrations, we construct a code file whenever we need to change the database.  Don't worry - it's done for\nus.  Later on, we will consider Database First.  With database first, we adjust the database schema\nmanually, then write C# models to reflect that change.\n\n\nNothing causes more headaches in an Azure Mobile Apps backend than [code first migrations].  A code-first\nmigration is simply a set of configuration commands that updates the database to support the new\ndatabase model.  If you try to publish this application, you will see an \nInvalidOperationException\n\nand your service will likely crash.  If you manage to trap the error, it will say \nThe model backing\nthe 'MobileServiceContext' context has changed since the database was created. Consider using Code First\nMigrations to update the database.\n  That's fairly specific and is common to all applications based\non Entity Framework that use code-first models.\n\n\n\n\nTip\n\n\nThere is an alternative here called \nDatabase First Models\n.  In this alternative, you create the\ndatabase first then create the models to match.  However, Azure Mobile Apps requires specific configuration\nof mobile tables that you will need to take care of.  See \nthe section\n on\n\nusing existing SQL tables\n later on for details.\n\n\n\n\nThe first step is to enable migrations.  Go to \nView\n -> \nOther Windows\n -> \nPackage Manager Console\n.\nThis window will generally appear in the same place as your Output and Error List windows at the bottom\nof the screen.  Type \nenable-migrations\n in it:\n\n\n\n\nCheck out the \nMigrations\n folder that has just been created to hold the code-first migrations.  An initial\n\nConfiguration.cs\n object will be added to this folder that describes the basic configuration.  We also need\nto create an Initial migration that represents the current state of the database.  We can do this with the\ncommand \nadd-migration Initial\n.\n\n\n\n\n\n\nTip\n\n\nIf you have multiple projects in your solution, you may need to add \n-Project _projectname_\n.  For example,\n\nadd-migration -project Chapter3 Initial\n.  This applies to all the migration commands you execute in the\nPackage Manager Console.\n\n\n\n\nThe initial migration creates a few files in the \nMigrations\n folder that represent the current state of\naffairs for the database. These easily recognized by a combination of the current date and the name of the\nmigration.  Code First Migrations can be applied manually or automatically.  I personally prefer the automatic\nmethod.  To implement automated Code First Migrations, edit the \nApp_Start\\Startup.MobileApp.cs\n file:\n\n\npublic static void ConfigureMobileApp(IAppBuilder app)\n{\n    var httpConfig = new HttpConfiguration();\n    var mobileConfig = new MobileAppConfiguration();\n\n    mobileConfig\n        .AddTablesWithEntityFramework()\n        .ApplyTo(httpConfig);\n\n    // Automatic Code First Migrations\n    var migrator = new DbMigrator(new Migrations.Configuration());\n    migrator.Update();\n\n    app.UseWebApi(httpConfig);\n}\n\n\n\n\nWe have replaced the \nDbInitializer()\n (which was the method that created the database for us) with the\nautomatic database migrator code.  There is one issue that will cause some problems.  We are no longer using\na database initializer.  The database initializer is the single line of code we just replaced that creates\nthe database tables with the appropriate triggers. This means that the special system columns will no longer\nbe wired up to update their values automatically. We can fix that by configuring the SqlGenerator in\n\nMigrations\\Configuration.cs\n:\n\n\npublic Configuration()\n{\n    AutomaticMigrationsEnabled = false;\n    SetSqlGenerator(\"System.Data.SqlClient\", new EntityTableSqlGenerator());\n}\n\n\n\n\nSince we are not using a database initializer, our seed data has also gone.  You may as well delete the\n\nMobileServiceInitializer\n class in the \nApp_Start\\Startup.MobileApp.cs\n as it isn't doing anything\nany more.  You can move the seed data to the \nMigrations\\Configuration.cs\n file though:\n\n\nnamespace Chapter3.Migrations\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Data.Entity.Migrations;\n    using DataObjects;\n    using Microsoft.Azure.Mobile.Server.Tables;\n\n    internal sealed class Configuration : DbMigrationsConfiguration<Chapter3.Models.MobileServiceContext>\n    {\n        public Configuration()\n        {\n            AutomaticMigrationsEnabled = false;\n            SetSqlGenerator(\"System.Data.SqlClient\", new EntityTableSqlGenerator());\n        }\n\n        protected override void Seed(Chapter3.Models.MobileServiceContext context)\n        {\n            List<TodoItem> todoItems = new List<TodoItem>\n            {\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"First item\", Complete = false },\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"Second item\", Complete = false }\n            };\n\n            foreach (TodoItem todoItem in todoItems)\n            {\n                context.Set<TodoItem>().Add(todoItem);\n            }\n\n            base.Seed(context);\n        }\n    }\n}\n\n\n\n\nThe contents of the \nSeed\n method are a cut-and-paste from the \nMobileServiceInitializer\n version.\n\n\nIf all goes well, you can clear your database (or delete it and re-create it), then publish this project\nand do a GET of the \n/tables/todoitem\n endpoint.  You should still see your data.  You should do a little\nmore investigation however.\n\n\n\n\nOpen the database in the \nSQL Server Object Explorer\n.\n\n\nExpand the \nTables\n node.\n\n\nRight-click on the \ndbo.__MigrationHistory\n table and select \nView Data\n.\n\n\n\n\n\n\nThere should be one row with a name that indicates it is the initial migration.\n\n\nThe final step is to apply the migration to the local system.  In the Package Manager Console, enter\nthe command \nupdate-database\n to apply the existing migration.\n\n\nAdding a SQL Table Controller\n\u00b6\n\n\nBefore we can use a table controller, we need to add one.  This has three steps:\n\n\n\n\nCreate a Data Transfer Object (DTO)\n\n\nCreate a Table Controller\n\n\nCreate a Code-First Migration\n\n\n\n\nCreating a Data Transfer Object\n\u00b6\n\n\nA Data Transfer Object (or DTO as it is commonly known) is the wire representation of the model for your\ntable.  It must inherit from a concrete implementation of \nITableData\n.  The Azure Mobile Apps SDK includes\n\nEntityData\n for this reason.  EntityData is a concrete implementation that works with Entity Framework.\n\n\n\n\nWarn\n\n\nYou can't just assume EntityData will work with other data stores.  There are Entity Framework specific\nattributes decorating the properties for EntityData that will likely be different for other stores.\n\n\n\n\nThe default Azure Mobile Apps project that is supplied with the Azure SDK provides a folder for storing\nDTOs called \nDataObjects\n.  Let's create a DTO by right-clicking on the \nDataObjects\n folder, then\nusing \nAdd\n -> \nClass...\n:\n\n\nusing System;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Chapter3.DataObjects\n{\n    public class Example : EntityData\n    {\n        public string StringField { get; set; }\n        public int IntField { get; set; }\n        public double DoubleField { get; set; }\n        public DateTimeOffset DateTimeField { get; set; }\n    }\n}\n\n\n\n\n\n\nTip\n\n\nDon't call your model \nSomethingDTO\n.  This ends up as a \n/tables/somethingDTO\n endpoint and a \nSomethingDTO\n\ntable in your database.  Just call it \nSomething\n.  All the names will then line up properly.\n\n\n\n\nI've included several field types, including a complex type.  The basic requirement for a field is that it\nmust be serialized into a simple JSON type during transfer between the server and the mobile client.  Complex\ntypes (that is, any type that can be serialized to an object or array) will always require special handling\nand may not be able to be used at all.\n\n\nCreate a Table Controller\n\u00b6\n\n\nVisual Studio with the Azure SDK provides some help in creating a table controller.  Right-click on the\n\nControllers\n node and select \nAdd\n -> \nController...\n.\n\n\n\n\nThe Azure SDK provides scaffolding for a new table controller.  Select it and then click on \nAdd\n.\n\n\n\n\nThe dialog asks for the model (which is actually a DTO) and the data context (which is already created).\nOnce you select the model, the controller name is created for you.  You can change it if you like, but\nit's common practice to not do this.\n\n\nOnce the scaffolding is finished, you can look at your newly created table controller.  We do want to\ndo one change.  We want to enable soft delete so that our table controller supports offline sync\nscenarios properly.  To do this, go into the \nInitialize()\n method and change the constructor of the\n\nEntityDomainManager\n.  The completed table controller looks like this:\n\n\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Microsoft.Azure.Mobile.Server;\nusing Chapter3.DataObjects;\nusing Chapter3.Models;\n\nnamespace Chapter3.Controllers\n{\n    public class ExampleController : TableController<Example>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<Example>(context, Request, enableSoftDelete: true);\n        }\n\n        // GET tables/Example\n        public IQueryable<Example> GetAllExample()\n        {\n            return Query();\n        }\n\n        // GET tables/Example/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<Example> GetExample(string id)\n        {\n            return Lookup(id);\n        }\n\n        // PATCH tables/Example/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task<Example> PatchExample(string id, Delta<Example> patch)\n        {\n             return UpdateAsync(id, patch);\n        }\n\n        // POST tables/Example\n        public async Task<IHttpActionResult> PostExample(Example item)\n        {\n            Example current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/Example/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteExample(string id)\n        {\n             return DeleteAsync(id);\n        }\n    }\n}\n\n\n\n\nCreating a Code-First Migration\n\u00b6\n\n\nYou must add a code first migration to update the database when it is published. Use the \nadd-migration\n\ncommand in the Package Manager Console.  The \nadd-migration\n command will request a name - it just has\nto be unique, but it's a good idea to make the name descriptive:\n\n\n\n\nYou should also use \nupdate-database\n to apply the change to the local database (if any):\n\n\n\n\nOnce this is done, you can publish the project.  Right-click on the project and select \nPublish...\n.  Once\nthe project is published, you should be able to send a query to the \n/tables/example\n endpoint using Postman\nand get an empty array.  You should also be able to insert, update and delete entities as you can with the\n\nTodoItem\n table.\n\n\nHandling Publish Failures\n\u00b6\n\n\nSometimes, the publish fails.  It seems that whenever I start with code-first migrations, my publish fails.\nI get a nice error screen, but no actual error.  At least half the time, the problem is not my code-first\nmigration, but something else.  For instance, one of the things I tend to do is update my NuGet packages.\nThis inevitably breaks something.\n\n\nFortunately, once the error message is known, it's generally trivial to correct the error.  You can turn\ncustom error messages off (and thus expose the original error message) by editing the Web.config file.\nLocate the \n<system.web>\n section and add the \n<customErrors mode=\"Off\"/>\n line:\n\n\n  <system.web>\n    <httpRuntime targetFramework=\"4.6\" />\n    <compilation debug=\"true\" targetFramework=\"4.6\" />\n    <customErrors mode=\"Off\" />\n  </system.web>\n\n\n\n\nThen republish your project and the response from the server is much more informative.\n\n\nTurning on Diagnostic Logs\n\u00b6\n\n\nYou can log all the SQL statements that Entity Framework executes on your behalf by adding a Database\nLog.  Edit the \nModels\\MobileServiceContext.cs\n file:\n\n\npublic class MobileServiceContext : DbContext\n{\n    private const string connectionStringName = \"Name=MS_TableConnectionString\";\n\n    public MobileServiceContext() : base(connectionStringName)\n    {\n        Database.Log = s => WriteLog(s);\n    }\n\n    public void WriteLog(string msg)\n    {\n        System.Diagnostics.Debug.WriteLine(msg);\n    }\n\n    protected override void OnModelCreating(DbModelBuilder modelBuilder)\n    {\n        modelBuilder.Conventions.Add(\n            new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n                \"ServiceTableColumn\", (property, attributes) => attributes.Single().ColumnType.ToString()));\n    }\n\n    public DbSet<DataObjects.TodoItem> TodoItems { get; set; }\n    public DbSet<DataObjects.Example> Examples { get; set; }\n}\n\n\n\n\nYou have to use a real method.  System.Diagnostics.Debug is removed from the context when DEBUG is not\ndefined, so you can't just use it directly.   Using an interim method works around that problem. Azure App\nService captures the output from the console and places it into the log viewer for you.\n\n\nTo turn on diagnostic logging:\n\n\n\n\nLog in to the \nAzure Portal\n.\n\n\nClick on \nApp Services\n then your App Service.\n\n\nFind \nDiagnostic Logs\n in the list of settings (you can use the search box).\n\n\nTurn on \nApplication Logging (Filesystem)\n with a level of \nVerbose\n.\n\n\nClick on \nSave\n.\n\n\n\n\nTo view the diagnostic logs in the portal, find \nLog Stream\n in the list of settings (again, you can\nuse the search box).  You can also get the diagnostic logs within Visual Studio.\n\n\n\n\nOpen the \nServer Explorer\n.\n\n\nExpand \nAzure\n, \nApp Service\n, your resource group.\n\n\nRight-click on the your App Service and select \nView Streaming Logs\n.\n\n\n\n\n\n\nUsing an existing SQL Table\n\u00b6\n\n\nThere are times when a \"Database First\" approach is needed.  If you are trying to expose an existing\nSQL database table, for example, you want to use a \"Database First\" approach.  You may also like the\nseparation of the database table from the mobile system columns.\n\n\n\n\nWarn\n\n\nThe Database First and Code First approaches to Entity Framework are mutually exclusive.  You need\nto decide which one you want to use and stick with it.\n\n\n\n\nTo use \"Database First\", you first set up the database.  Then you create a Model and update the DbContext\nobject.  For example, out \nExample\n model from before can be represented by the following database\nschema:\n\n\nCREATE TABLE [dbo].[Examples] (\n    -- This must be a string suitable for a GUID\n    [Id]            NVARCHAR (128)     NOT NULL,\n\n    -- These are the system properties\n    [Version]       ROWVERSION         NOT NULL,\n    [CreatedAt]     DATETIMEOFFSET (7) NOT NULL,\n    [UpdatedAt]     DATETIMEOFFSET (7) NULL,\n    [Deleted]       BIT                NOT NULL\n\n    -- These are the properties of our DTO not included in EntityFramework\n    [StringField]   NVARCHAR (MAX)     NULL,\n    [IntField]      INT                NOT NULL,\n    [DoubleField]   FLOAT (53)         NOT NULL,\n    [DateTimeField] DATETIMEOFFSET (7) NOT NULL,\n);\n\nCREATE CLUSTERED INDEX [IX_CreatedAt]\n    ON [dbo].[Examples]([CreatedAt] ASC);\n\nALTER TABLE [dbo].[Examples]\n    ADD CONSTRAINT [PK_dbo.Examples] PRIMARY KEY NONCLUSTERED ([Id] ASC);\n\nCREATE TRIGGER [TR_dbo_Examples_InsertUpdateDelete] ON [dbo].[Examples]\n    AFTER INSERT, UPDATE, DELETE AS\n    BEGIN\n        UPDATE [dbo].[Examples]\n            SET [dbo].[Examples].[UpdatedAt] = CONVERT(DATETIMEOFFSET, SYSUTCDATETIME())\n            FROM INSERTED WHERE inserted.[Id] = [dbo].[Examples].[Id]\n    END;\n\n\n\n\nThe system properties are added to the schema.  We can (and do) use a trigger to update the UpdatedAt\ncolumn when the data is updated.  Placing this logic within the SQL Server schema definition means\nwe can use this SQL table outside of the mobile context and it will still work for the mobile application.\n\n\n\n\nInfo\n\n\nWe use the CreatedAt field to create a clustered index.  In older versions of SQL Server, this was\nrequired to increase performance on the table as a whole.  It may not be required now and may be removed\nin future versions of Azure Mobile Apps.\n\n\n\n\nIf you can update an existing table to match this schema, then you should do so.  Note that the Id field is\nnot set by default.  If you want to set a default, set it to \nNEWID()\n:\n\n\nALTER TABLE [dbo].[Examples]\n    ALTER COLUMN [Id] SET DEFAULT CONVERT(NVARCHAR(128), NEWID());\n\n\n\n\nOnce you have set up the database and created the models, you must also turn off the database initializer.\nThis is done in \nApp_Start\\Startup.MobileApp.cs\n:\n\n\npublic static void ConfigureMobileApp(IAppBuilder app)\n{\n    var httpConfig = new HttpConfiguration();\n    var mobileConfig = new MobileAppConfiguration();\n\n    mobileConfig\n        .AddTablesWithEntityFramework()\n        .ApplyTo(httpConfig);\n\n    // Automatic Code First Migrations\n    // var migrator = new DbMigrator(new Migrations.Configuration());\n    // migrator.Update();\n\n    // Database First\n    Database.SetInitializer<MobileDbContext>(null);\n\n    app.UseWebApi(httpConfig);\n}\n\n\n\n\nThere are a lot of times when the existing table is not suitable for this sort of schema adjustment.  The\nprimary reason will be that the existing table has an auto-incrementing integer Id column and you can't\nchange that.  Quite often, I see developers needing to integrate the SQL schema of an existing application\nlike a Customer Relationship Management system with this constraint, for example.\n\n\nLet's take an example.  Suppose you have a table called [dbo].[TodoItems].  This is fairly basic and\ndefined like this:\n\n\nCREATE TABLE [dbo].[TodoItems] (\n  [id]       BIGINT NOT NULL IDENTITY(1,1) PRIMARY KEY,\n  [UserId]   NVARCHAR(255) NOT NULL,\n  [Title]    NVARCHAR(255) NOT NULL,\n  [Complete] BIT\n);\n\n\n\n\nThis is the sort of SQL table that is very common within existing web applications, for instance.  We have\nan auto-incrementing id column and some fields.  It isn't complex (no relationships, for example), so we\ndon't have to worry about \nreferential integrity\n of the table.\n\n\n\n\nTip\n\n\nI recommend placing the \"mobile views\" that we will discuss below in a separate schema (for example,\n\n[mobile]\n) so that they don't interfere with your existing database schema.\n\n\n\n\nLet's take a look at creating a VIEW of the data that is \"mobile ready\".  This is an Entity Relationship\nDiagram of what we are going to do:\n\n\n\n\nwe are going to create a separate table for the system properties, called \n[mobile].[SysProps_TodoItems]\n.\nThis will hold the five fields that Azure Mobile Apps requires, plus a reference to the TodoItem id:\n\n\nCREATE TABLE [mobile].[SysProps_TodoItems] (\n  [Id]        NVARCHAR(128) CONSTRAINT [DF_todoitem_id] DEFAULT (CONVERT([NVARCHAR](255),NEWID(),(0))) NOT NULL,\n  [CreatedAt] DATETIMEOFFSET(7) CONSTRAINT [DF_todoitem_createdAt] DEFAULT (CONVERT([DATETIMEOFFSET](7),SYSUTCDATETIME(),(0))) NOT NULL,\n  [UpdatedAt] DATETIMEOFFSET(7) NULL,\n  [Version]   ROWVERSION NOT NULL,\n  [Deleted]   BIT DEFAULT ((0)) NOT NULL,\n  [Item_Id]   BIGINT NOT NULL\n  PRIMARY KEY NONCLUSTERED ([id] ASC)\n);\n\n\n\n\nThen we will create a SQL VIEW that maps to this:\n\n\nCREATE VIEW [mobile].[TodoItems] AS\nSELECT\n    [mobile].[SysProps_TodoItems].[Id],\n    [mobile].[SysProps_TodoItems].[CreatedAt],\n    [mobile].[SysProps_TodoItems].[UpdatedAt],\n    [mobile].[SysProps_TodoItems].[Version],\n    [mobile].[SysProps_TodoItems].[Deleted],\n    [mobile].[SysProps_TodoItems].[Item_Id],\n    [dbo].[TodoItems].[UserId],\n    [dbo].[TodoItems].[Title],\n    [dbo].[TodoItems].[Complete]\nFROM\n    [dbo].[TodoItems],\n    [mobile].[SysProps_TodoItems]\nWHERE\n    [dbo].[TodoItems].[id] = [mobile].[SysProps_TodoItems].[Item_Id];\n\n\n\n\nThis view is still only a combination of the two tables.  I want specific logic so that when a row\nis changed (inserted, updated or deleted) in the \n[dbo].[TodoItems]\n table, a similar change is made\nto the \n[mobile].[SysProps_TodoItems]\n table.  This is achieved through the use of triggers:\n\n\nCREATE TRIGGER\n    [dbo].[TRG_TodoItem_Insert]\nON\n    [dbo].[TodoItems]\nAFTER\n    INSERT\nAS BEGIN\n    DECLARE @itemid AS BIGINT\n    SELECT @itemid = inserted.id FROM inserted\n    INSERT INTO [mobile].[SysProps_TodoItems] ([Item_Id], [UpdatedAt])\n        VALUES (@itemid, CONVERT(DATETIMEOFFSET(7), SYSUTCDATETIME()));\nEND\nGO\n\nCREATE TRIGGER\n    [dbo].[TRG_TodoItem_Update]\nON\n    [dbo].[TodoItems]\nAFTER\n    UPDATE\nAS BEGIN\n    UPDATE\n        [mobile].[SysProps_TodoItems]\n    SET\n        [UpdatedAt] = CONVERT(DATETIMEOFFSET(7), SYSUTCDATETIME())\n    FROM\n        INSERTED\n    WHERE\n        INSERTED.id = [mobile].[SysProps_TodoItems].[Item_Id]\nEND\nGO\n\nCREATE TRIGGER\n    [dbo].[TRG_TodoItem_Delete]\nON\n    [dbo].[TodoItems]\nAFTER\n    DELETE\nAS BEGIN\n    DECLARE @itemid AS BIGINT\n    SELECT @itemid = deleted.id from deleted\n    DELETE FROM [mobile].[SysProps_TodoItems] WHERE [Item_Id] = @itemid\nEND\nGO\n\n\n\n\n\n\nTip\n\n\nYou may want to set the \nDeleted\n flag to 1 (or true) in the Delete trigger.  This will enable soft\ndelete on the system properties table, ensuring that mobile clients remove the row from their offline\ncache.\n\n\n\n\nSimilarly, when changes are made by the mobile backend to the VIEW, we need to propagate those changes\nto the underlying tables.  This is also done with triggers:\n\n\nCREATE TRIGGER\n    [mobile].[TRG_Mobile_TodoItem_Insert]\nON\n    [mobile].[TodoItems]\nINSTEAD OF\n    INSERT\nAS BEGIN\n    DECLARE @userid AS NVARCHAR(255)\n    SELECT @userid = inserted.UserId FROM inserted\n    DECLARE @title AS NVARCHAR(255)\n    SELECT @title = inserted.Title FROM inserted\n    DECLARE @complete AS BIT\n    SELECT @complete = inserted.Complete FROM inserted\n\n\n    INSERT INTO\n        [dbo].[TodoItems] ([UserId], [Title], [Complete])\n    VALUES\n        (@userid, @title, @complete)\n\n    IF UPDATE(Id) BEGIN\n        DECLARE @itemid AS BIGINT\n        SELECT @itemid = @@identity\n        DECLARE @id AS NVARCHAR(255)\n        SELECT @id = inserted.Id FROM inserted\n        UPDATE [mobile].[SysProps_TodoItems] SET [Id] = @id WHERE [item_id] = @itemid\n    END\nEND;\nGO\n\nCREATE TRIGGER\n    [mobile].[TRG_Mobile_TodoItem_Update]\nON\n    [mobile].[TodoItems]\nINSTEAD OF\n    UPDATE\nAS BEGIN\n    DECLARE @id AS NVARCHAR(255)\n    SELECT @id = inserted.id FROM inserted\n    DECLARE @itemid AS BIGINT\n    SELECT @itemid = [item_id] FROM [mobile].[SysProps_TodoItems] WHERE [id] = @id\n\n    IF UPDATE(UserId) BEGIN\n        DECLARE @userid AS NVARCHAR(255)\n        SELECT @userid = inserted.UserId FROM inserted\n        UPDATE [dbo].[TodoItems] SET [UserId] = @userid WHERE [id] = @itemid\n    END\n    IF UPDATE(Title) BEGIN\n        DECLARE @title AS NVARCHAR(255)\n        SELECT @title = inserted.Title FROM inserted\n        UPDATE [dbo].[TodoItems] SET [Title] = @title WHERE [id] = @itemid\n    END\n    IF UPDATE(Complete) BEGIN\n        DECLARE @complete AS BIT\n        SELECT @complete = inserted.Complete FROM inserted\n        UPDATE [dbo].[TodoItems] SET [Complete] = @complete WHERE [id] = @itemid\n    END\n    IF UPDATE(deleted) BEGIN\n        DECLARE @deleted AS BIT\n        SELECT @deleted = inserted.deleted FROM inserted\n        UPDATE [mobile].[SysProps_TodoItems] SET [deleted] = @deleted WHERE [item_id] = @itemid\n    END\nEND\nGO\n\nCREATE TRIGGER\n    [mobile].[TRG_Mobile_TodoItem_Delete]\nON\n    [mobile].[TodoItems]\nINSTEAD OF\n    DELETE\nAS BEGIN\n    DECLARE @id AS NVARCHAR(255)\n    SELECT @id = deleted.id FROM deleted\n    DECLARE @itemid AS BIGINT\n    SELECT @itemid = [item_id] FROM [mobile].[SysProps_TodoItems] WHERE [id] = @id\n\n    DELETE FROM [dbo].[TodoItems] WHERE [id] = @itemid\n    DELETE FROM [mobile].[SysProps_TodoItems] WHERE [id] = @id\nEND\nGO\n\n\n\n\nA standard SQL view is read-only.  We made the view read/write by using triggers to trap the\ncall and replace it with two calls instead.\n\n\n\n\nWarn\n\n\nThis version does not support soft delete.  If you wish to support soft delete, set the\n\nDeleted\n flag in the `[mobile].[SysProps_TodoItems] table instead of deleting the row.\n\n\n\n\nChanging the Mobile Schema\n\u00b6\n\n\nWe stored our mobile representation of the table in a different schema.  Azure Mobile Apps looks\nfor tables (and views) in the \n[dbo]\n schema by default.  There are two places you can modify the\nschema that Entity Framework uses to access the database.  The first is by changing the default\nschema that Entity Framework uses.  This will affect all the tables that we are exposing via a\ntable controller.  This is done in the \nModels\\MobileDbContext.cs\n class:\n\n\nprotected override void OnModelCreating(DbModelBuilder modelBuilder)\n{\n    modelBuilder.HasDefaultSchema(\"mobile\");\n    modelBuilder.Conventions.Add(\n        new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n            \"ServiceTableColumn\",\n            (property, attributes) => attributes.Single().ColumnType.ToString()\n        )\n    );\n}\n\n\n\n\nWe can also do this on the model as an annotation.  For example, here is the TodoItem model suitably\nadjusted:\n\n\nusing Microsoft.Azure.Mobile.Server;\nusing Newtonsoft.Json;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace Backend.DataObjects\n{\n    [Table(\"TodoItems\", Schema=\"mobile\")]\n    public class TodoItem : EntityData\n    {\n        public string UserId { get; set; }\n\n        public string Title { get; set; }\n\n        public bool Complete { get; set; }\n    }\n}\n\n\n\n\n\n\nInfo\n\n\nEntity Framework adds an \ns\n onto the end of the model to create the table name.  If you\nhave a model named \nTodoItem\n, the table is called \nTodoItems\n in the database.  You can use this\nsame annotation to adjust the table name if it is not to your liking.\n\n\n\n\nBest Practices\n\u00b6\n\n\nHere is a summary of what I consider best practices for table controllers:\n\n\n\n\nUse Code First when you are in a green-field database situation.\n\n\nUse Database First when you have to integrate an existing database.\n\n\nOnly expose the data that you need for the mobile client.\n\n\nSet up Automatic Code First Migrations as early as possible.\n\n\nThink about what happens to existing clients when you update the schema.\n\n\n\n\nThis last point is an important one.  Let's say you have a v1 mobile client of your awesome mobile\napplication.  This works with v1 mobile backend.  You've set up the schema and ensured that everything\nworks.  Then you want to release v2 mobile client.  It has a new feature and needs some extra data.\nSo you update to v2 mobile backend that provides that data.\n\n\nYou need to ensure that the schema changes provided by the v2 mobile backend are optional.  In other\nwords, the v1 mobile client can continue to work against the v2 mobile backend.  You should test this\ncase.  Users do not upgrade instantly.  In fact, many users don't upgrade at all.  At every release\nof your app, you are going to have to ensure that ALL versions of your mobile client work against\nyour mobile backend.",
            "title": "Implementing Table Controllers"
        },
        {
            "location": "/chapter3/server/#implementing-table-controllers",
            "text": "The central component for providing a table endpoint on the Azure App Service side of things occurs in your\nbackend project.  You must implement a Table Controller.  This is a specialized version of an ApiController\nthat has some similarities with an ODataController.  However, it has its own base class and the Azure Mobile\nApps SDK simplifies the process of making them.",
            "title": "Implementing Table Controllers"
        },
        {
            "location": "/chapter3/server/#implementing-code-first-migrations",
            "text": "Before we can get started with adding another table controller, we have to deal with modifications to our\ndatabase schema.  The default code for Azure Mobile Apps will deploy the configured schema  only if the\ndatabase is empty .  If the database is not empty, you have to do extra work.  This extra work involves\nupdating the schema of your database.  There are two methods of doing this.  The first we will consider is Code First Migrations.  With code first\nmigrations, we construct a code file whenever we need to change the database.  Don't worry - it's done for\nus.  Later on, we will consider Database First.  With database first, we adjust the database schema\nmanually, then write C# models to reflect that change.  Nothing causes more headaches in an Azure Mobile Apps backend than [code first migrations].  A code-first\nmigration is simply a set of configuration commands that updates the database to support the new\ndatabase model.  If you try to publish this application, you will see an  InvalidOperationException \nand your service will likely crash.  If you manage to trap the error, it will say  The model backing\nthe 'MobileServiceContext' context has changed since the database was created. Consider using Code First\nMigrations to update the database.   That's fairly specific and is common to all applications based\non Entity Framework that use code-first models.   Tip  There is an alternative here called  Database First Models .  In this alternative, you create the\ndatabase first then create the models to match.  However, Azure Mobile Apps requires specific configuration\nof mobile tables that you will need to take care of.  See  the section  on using existing SQL tables  later on for details.   The first step is to enable migrations.  Go to  View  ->  Other Windows  ->  Package Manager Console .\nThis window will generally appear in the same place as your Output and Error List windows at the bottom\nof the screen.  Type  enable-migrations  in it:   Check out the  Migrations  folder that has just been created to hold the code-first migrations.  An initial Configuration.cs  object will be added to this folder that describes the basic configuration.  We also need\nto create an Initial migration that represents the current state of the database.  We can do this with the\ncommand  add-migration Initial .    Tip  If you have multiple projects in your solution, you may need to add  -Project _projectname_ .  For example, add-migration -project Chapter3 Initial .  This applies to all the migration commands you execute in the\nPackage Manager Console.   The initial migration creates a few files in the  Migrations  folder that represent the current state of\naffairs for the database. These easily recognized by a combination of the current date and the name of the\nmigration.  Code First Migrations can be applied manually or automatically.  I personally prefer the automatic\nmethod.  To implement automated Code First Migrations, edit the  App_Start\\Startup.MobileApp.cs  file:  public static void ConfigureMobileApp(IAppBuilder app)\n{\n    var httpConfig = new HttpConfiguration();\n    var mobileConfig = new MobileAppConfiguration();\n\n    mobileConfig\n        .AddTablesWithEntityFramework()\n        .ApplyTo(httpConfig);\n\n    // Automatic Code First Migrations\n    var migrator = new DbMigrator(new Migrations.Configuration());\n    migrator.Update();\n\n    app.UseWebApi(httpConfig);\n}  We have replaced the  DbInitializer()  (which was the method that created the database for us) with the\nautomatic database migrator code.  There is one issue that will cause some problems.  We are no longer using\na database initializer.  The database initializer is the single line of code we just replaced that creates\nthe database tables with the appropriate triggers. This means that the special system columns will no longer\nbe wired up to update their values automatically. We can fix that by configuring the SqlGenerator in Migrations\\Configuration.cs :  public Configuration()\n{\n    AutomaticMigrationsEnabled = false;\n    SetSqlGenerator(\"System.Data.SqlClient\", new EntityTableSqlGenerator());\n}  Since we are not using a database initializer, our seed data has also gone.  You may as well delete the MobileServiceInitializer  class in the  App_Start\\Startup.MobileApp.cs  as it isn't doing anything\nany more.  You can move the seed data to the  Migrations\\Configuration.cs  file though:  namespace Chapter3.Migrations\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Data.Entity.Migrations;\n    using DataObjects;\n    using Microsoft.Azure.Mobile.Server.Tables;\n\n    internal sealed class Configuration : DbMigrationsConfiguration<Chapter3.Models.MobileServiceContext>\n    {\n        public Configuration()\n        {\n            AutomaticMigrationsEnabled = false;\n            SetSqlGenerator(\"System.Data.SqlClient\", new EntityTableSqlGenerator());\n        }\n\n        protected override void Seed(Chapter3.Models.MobileServiceContext context)\n        {\n            List<TodoItem> todoItems = new List<TodoItem>\n            {\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"First item\", Complete = false },\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"Second item\", Complete = false }\n            };\n\n            foreach (TodoItem todoItem in todoItems)\n            {\n                context.Set<TodoItem>().Add(todoItem);\n            }\n\n            base.Seed(context);\n        }\n    }\n}  The contents of the  Seed  method are a cut-and-paste from the  MobileServiceInitializer  version.  If all goes well, you can clear your database (or delete it and re-create it), then publish this project\nand do a GET of the  /tables/todoitem  endpoint.  You should still see your data.  You should do a little\nmore investigation however.   Open the database in the  SQL Server Object Explorer .  Expand the  Tables  node.  Right-click on the  dbo.__MigrationHistory  table and select  View Data .    There should be one row with a name that indicates it is the initial migration.  The final step is to apply the migration to the local system.  In the Package Manager Console, enter\nthe command  update-database  to apply the existing migration.",
            "title": "Implementing Code First Migrations"
        },
        {
            "location": "/chapter3/server/#adding-a-sql-table-controller",
            "text": "Before we can use a table controller, we need to add one.  This has three steps:   Create a Data Transfer Object (DTO)  Create a Table Controller  Create a Code-First Migration",
            "title": "Adding a SQL Table Controller"
        },
        {
            "location": "/chapter3/server/#creating-a-data-transfer-object",
            "text": "A Data Transfer Object (or DTO as it is commonly known) is the wire representation of the model for your\ntable.  It must inherit from a concrete implementation of  ITableData .  The Azure Mobile Apps SDK includes EntityData  for this reason.  EntityData is a concrete implementation that works with Entity Framework.   Warn  You can't just assume EntityData will work with other data stores.  There are Entity Framework specific\nattributes decorating the properties for EntityData that will likely be different for other stores.   The default Azure Mobile Apps project that is supplied with the Azure SDK provides a folder for storing\nDTOs called  DataObjects .  Let's create a DTO by right-clicking on the  DataObjects  folder, then\nusing  Add  ->  Class... :  using System;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Chapter3.DataObjects\n{\n    public class Example : EntityData\n    {\n        public string StringField { get; set; }\n        public int IntField { get; set; }\n        public double DoubleField { get; set; }\n        public DateTimeOffset DateTimeField { get; set; }\n    }\n}   Tip  Don't call your model  SomethingDTO .  This ends up as a  /tables/somethingDTO  endpoint and a  SomethingDTO \ntable in your database.  Just call it  Something .  All the names will then line up properly.   I've included several field types, including a complex type.  The basic requirement for a field is that it\nmust be serialized into a simple JSON type during transfer between the server and the mobile client.  Complex\ntypes (that is, any type that can be serialized to an object or array) will always require special handling\nand may not be able to be used at all.",
            "title": "Creating a Data Transfer Object"
        },
        {
            "location": "/chapter3/server/#create-a-table-controller",
            "text": "Visual Studio with the Azure SDK provides some help in creating a table controller.  Right-click on the Controllers  node and select  Add  ->  Controller... .   The Azure SDK provides scaffolding for a new table controller.  Select it and then click on  Add .   The dialog asks for the model (which is actually a DTO) and the data context (which is already created).\nOnce you select the model, the controller name is created for you.  You can change it if you like, but\nit's common practice to not do this.  Once the scaffolding is finished, you can look at your newly created table controller.  We do want to\ndo one change.  We want to enable soft delete so that our table controller supports offline sync\nscenarios properly.  To do this, go into the  Initialize()  method and change the constructor of the EntityDomainManager .  The completed table controller looks like this:  using System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Microsoft.Azure.Mobile.Server;\nusing Chapter3.DataObjects;\nusing Chapter3.Models;\n\nnamespace Chapter3.Controllers\n{\n    public class ExampleController : TableController<Example>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<Example>(context, Request, enableSoftDelete: true);\n        }\n\n        // GET tables/Example\n        public IQueryable<Example> GetAllExample()\n        {\n            return Query();\n        }\n\n        // GET tables/Example/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<Example> GetExample(string id)\n        {\n            return Lookup(id);\n        }\n\n        // PATCH tables/Example/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task<Example> PatchExample(string id, Delta<Example> patch)\n        {\n             return UpdateAsync(id, patch);\n        }\n\n        // POST tables/Example\n        public async Task<IHttpActionResult> PostExample(Example item)\n        {\n            Example current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/Example/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteExample(string id)\n        {\n             return DeleteAsync(id);\n        }\n    }\n}",
            "title": "Create a Table Controller"
        },
        {
            "location": "/chapter3/server/#creating-a-code-first-migration",
            "text": "You must add a code first migration to update the database when it is published. Use the  add-migration \ncommand in the Package Manager Console.  The  add-migration  command will request a name - it just has\nto be unique, but it's a good idea to make the name descriptive:   You should also use  update-database  to apply the change to the local database (if any):   Once this is done, you can publish the project.  Right-click on the project and select  Publish... .  Once\nthe project is published, you should be able to send a query to the  /tables/example  endpoint using Postman\nand get an empty array.  You should also be able to insert, update and delete entities as you can with the TodoItem  table.",
            "title": "Creating a Code-First Migration"
        },
        {
            "location": "/chapter3/server/#handling-publish-failures",
            "text": "Sometimes, the publish fails.  It seems that whenever I start with code-first migrations, my publish fails.\nI get a nice error screen, but no actual error.  At least half the time, the problem is not my code-first\nmigration, but something else.  For instance, one of the things I tend to do is update my NuGet packages.\nThis inevitably breaks something.  Fortunately, once the error message is known, it's generally trivial to correct the error.  You can turn\ncustom error messages off (and thus expose the original error message) by editing the Web.config file.\nLocate the  <system.web>  section and add the  <customErrors mode=\"Off\"/>  line:    <system.web>\n    <httpRuntime targetFramework=\"4.6\" />\n    <compilation debug=\"true\" targetFramework=\"4.6\" />\n    <customErrors mode=\"Off\" />\n  </system.web>  Then republish your project and the response from the server is much more informative.",
            "title": "Handling Publish Failures"
        },
        {
            "location": "/chapter3/server/#turning-on-diagnostic-logs",
            "text": "You can log all the SQL statements that Entity Framework executes on your behalf by adding a Database\nLog.  Edit the  Models\\MobileServiceContext.cs  file:  public class MobileServiceContext : DbContext\n{\n    private const string connectionStringName = \"Name=MS_TableConnectionString\";\n\n    public MobileServiceContext() : base(connectionStringName)\n    {\n        Database.Log = s => WriteLog(s);\n    }\n\n    public void WriteLog(string msg)\n    {\n        System.Diagnostics.Debug.WriteLine(msg);\n    }\n\n    protected override void OnModelCreating(DbModelBuilder modelBuilder)\n    {\n        modelBuilder.Conventions.Add(\n            new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n                \"ServiceTableColumn\", (property, attributes) => attributes.Single().ColumnType.ToString()));\n    }\n\n    public DbSet<DataObjects.TodoItem> TodoItems { get; set; }\n    public DbSet<DataObjects.Example> Examples { get; set; }\n}  You have to use a real method.  System.Diagnostics.Debug is removed from the context when DEBUG is not\ndefined, so you can't just use it directly.   Using an interim method works around that problem. Azure App\nService captures the output from the console and places it into the log viewer for you.  To turn on diagnostic logging:   Log in to the  Azure Portal .  Click on  App Services  then your App Service.  Find  Diagnostic Logs  in the list of settings (you can use the search box).  Turn on  Application Logging (Filesystem)  with a level of  Verbose .  Click on  Save .   To view the diagnostic logs in the portal, find  Log Stream  in the list of settings (again, you can\nuse the search box).  You can also get the diagnostic logs within Visual Studio.   Open the  Server Explorer .  Expand  Azure ,  App Service , your resource group.  Right-click on the your App Service and select  View Streaming Logs .",
            "title": "Turning on Diagnostic Logs"
        },
        {
            "location": "/chapter3/server/#using-an-existing-sql-table",
            "text": "There are times when a \"Database First\" approach is needed.  If you are trying to expose an existing\nSQL database table, for example, you want to use a \"Database First\" approach.  You may also like the\nseparation of the database table from the mobile system columns.   Warn  The Database First and Code First approaches to Entity Framework are mutually exclusive.  You need\nto decide which one you want to use and stick with it.   To use \"Database First\", you first set up the database.  Then you create a Model and update the DbContext\nobject.  For example, out  Example  model from before can be represented by the following database\nschema:  CREATE TABLE [dbo].[Examples] (\n    -- This must be a string suitable for a GUID\n    [Id]            NVARCHAR (128)     NOT NULL,\n\n    -- These are the system properties\n    [Version]       ROWVERSION         NOT NULL,\n    [CreatedAt]     DATETIMEOFFSET (7) NOT NULL,\n    [UpdatedAt]     DATETIMEOFFSET (7) NULL,\n    [Deleted]       BIT                NOT NULL\n\n    -- These are the properties of our DTO not included in EntityFramework\n    [StringField]   NVARCHAR (MAX)     NULL,\n    [IntField]      INT                NOT NULL,\n    [DoubleField]   FLOAT (53)         NOT NULL,\n    [DateTimeField] DATETIMEOFFSET (7) NOT NULL,\n);\n\nCREATE CLUSTERED INDEX [IX_CreatedAt]\n    ON [dbo].[Examples]([CreatedAt] ASC);\n\nALTER TABLE [dbo].[Examples]\n    ADD CONSTRAINT [PK_dbo.Examples] PRIMARY KEY NONCLUSTERED ([Id] ASC);\n\nCREATE TRIGGER [TR_dbo_Examples_InsertUpdateDelete] ON [dbo].[Examples]\n    AFTER INSERT, UPDATE, DELETE AS\n    BEGIN\n        UPDATE [dbo].[Examples]\n            SET [dbo].[Examples].[UpdatedAt] = CONVERT(DATETIMEOFFSET, SYSUTCDATETIME())\n            FROM INSERTED WHERE inserted.[Id] = [dbo].[Examples].[Id]\n    END;  The system properties are added to the schema.  We can (and do) use a trigger to update the UpdatedAt\ncolumn when the data is updated.  Placing this logic within the SQL Server schema definition means\nwe can use this SQL table outside of the mobile context and it will still work for the mobile application.   Info  We use the CreatedAt field to create a clustered index.  In older versions of SQL Server, this was\nrequired to increase performance on the table as a whole.  It may not be required now and may be removed\nin future versions of Azure Mobile Apps.   If you can update an existing table to match this schema, then you should do so.  Note that the Id field is\nnot set by default.  If you want to set a default, set it to  NEWID() :  ALTER TABLE [dbo].[Examples]\n    ALTER COLUMN [Id] SET DEFAULT CONVERT(NVARCHAR(128), NEWID());  Once you have set up the database and created the models, you must also turn off the database initializer.\nThis is done in  App_Start\\Startup.MobileApp.cs :  public static void ConfigureMobileApp(IAppBuilder app)\n{\n    var httpConfig = new HttpConfiguration();\n    var mobileConfig = new MobileAppConfiguration();\n\n    mobileConfig\n        .AddTablesWithEntityFramework()\n        .ApplyTo(httpConfig);\n\n    // Automatic Code First Migrations\n    // var migrator = new DbMigrator(new Migrations.Configuration());\n    // migrator.Update();\n\n    // Database First\n    Database.SetInitializer<MobileDbContext>(null);\n\n    app.UseWebApi(httpConfig);\n}  There are a lot of times when the existing table is not suitable for this sort of schema adjustment.  The\nprimary reason will be that the existing table has an auto-incrementing integer Id column and you can't\nchange that.  Quite often, I see developers needing to integrate the SQL schema of an existing application\nlike a Customer Relationship Management system with this constraint, for example.  Let's take an example.  Suppose you have a table called [dbo].[TodoItems].  This is fairly basic and\ndefined like this:  CREATE TABLE [dbo].[TodoItems] (\n  [id]       BIGINT NOT NULL IDENTITY(1,1) PRIMARY KEY,\n  [UserId]   NVARCHAR(255) NOT NULL,\n  [Title]    NVARCHAR(255) NOT NULL,\n  [Complete] BIT\n);  This is the sort of SQL table that is very common within existing web applications, for instance.  We have\nan auto-incrementing id column and some fields.  It isn't complex (no relationships, for example), so we\ndon't have to worry about  referential integrity  of the table.   Tip  I recommend placing the \"mobile views\" that we will discuss below in a separate schema (for example, [mobile] ) so that they don't interfere with your existing database schema.   Let's take a look at creating a VIEW of the data that is \"mobile ready\".  This is an Entity Relationship\nDiagram of what we are going to do:   we are going to create a separate table for the system properties, called  [mobile].[SysProps_TodoItems] .\nThis will hold the five fields that Azure Mobile Apps requires, plus a reference to the TodoItem id:  CREATE TABLE [mobile].[SysProps_TodoItems] (\n  [Id]        NVARCHAR(128) CONSTRAINT [DF_todoitem_id] DEFAULT (CONVERT([NVARCHAR](255),NEWID(),(0))) NOT NULL,\n  [CreatedAt] DATETIMEOFFSET(7) CONSTRAINT [DF_todoitem_createdAt] DEFAULT (CONVERT([DATETIMEOFFSET](7),SYSUTCDATETIME(),(0))) NOT NULL,\n  [UpdatedAt] DATETIMEOFFSET(7) NULL,\n  [Version]   ROWVERSION NOT NULL,\n  [Deleted]   BIT DEFAULT ((0)) NOT NULL,\n  [Item_Id]   BIGINT NOT NULL\n  PRIMARY KEY NONCLUSTERED ([id] ASC)\n);  Then we will create a SQL VIEW that maps to this:  CREATE VIEW [mobile].[TodoItems] AS\nSELECT\n    [mobile].[SysProps_TodoItems].[Id],\n    [mobile].[SysProps_TodoItems].[CreatedAt],\n    [mobile].[SysProps_TodoItems].[UpdatedAt],\n    [mobile].[SysProps_TodoItems].[Version],\n    [mobile].[SysProps_TodoItems].[Deleted],\n    [mobile].[SysProps_TodoItems].[Item_Id],\n    [dbo].[TodoItems].[UserId],\n    [dbo].[TodoItems].[Title],\n    [dbo].[TodoItems].[Complete]\nFROM\n    [dbo].[TodoItems],\n    [mobile].[SysProps_TodoItems]\nWHERE\n    [dbo].[TodoItems].[id] = [mobile].[SysProps_TodoItems].[Item_Id];  This view is still only a combination of the two tables.  I want specific logic so that when a row\nis changed (inserted, updated or deleted) in the  [dbo].[TodoItems]  table, a similar change is made\nto the  [mobile].[SysProps_TodoItems]  table.  This is achieved through the use of triggers:  CREATE TRIGGER\n    [dbo].[TRG_TodoItem_Insert]\nON\n    [dbo].[TodoItems]\nAFTER\n    INSERT\nAS BEGIN\n    DECLARE @itemid AS BIGINT\n    SELECT @itemid = inserted.id FROM inserted\n    INSERT INTO [mobile].[SysProps_TodoItems] ([Item_Id], [UpdatedAt])\n        VALUES (@itemid, CONVERT(DATETIMEOFFSET(7), SYSUTCDATETIME()));\nEND\nGO\n\nCREATE TRIGGER\n    [dbo].[TRG_TodoItem_Update]\nON\n    [dbo].[TodoItems]\nAFTER\n    UPDATE\nAS BEGIN\n    UPDATE\n        [mobile].[SysProps_TodoItems]\n    SET\n        [UpdatedAt] = CONVERT(DATETIMEOFFSET(7), SYSUTCDATETIME())\n    FROM\n        INSERTED\n    WHERE\n        INSERTED.id = [mobile].[SysProps_TodoItems].[Item_Id]\nEND\nGO\n\nCREATE TRIGGER\n    [dbo].[TRG_TodoItem_Delete]\nON\n    [dbo].[TodoItems]\nAFTER\n    DELETE\nAS BEGIN\n    DECLARE @itemid AS BIGINT\n    SELECT @itemid = deleted.id from deleted\n    DELETE FROM [mobile].[SysProps_TodoItems] WHERE [Item_Id] = @itemid\nEND\nGO   Tip  You may want to set the  Deleted  flag to 1 (or true) in the Delete trigger.  This will enable soft\ndelete on the system properties table, ensuring that mobile clients remove the row from their offline\ncache.   Similarly, when changes are made by the mobile backend to the VIEW, we need to propagate those changes\nto the underlying tables.  This is also done with triggers:  CREATE TRIGGER\n    [mobile].[TRG_Mobile_TodoItem_Insert]\nON\n    [mobile].[TodoItems]\nINSTEAD OF\n    INSERT\nAS BEGIN\n    DECLARE @userid AS NVARCHAR(255)\n    SELECT @userid = inserted.UserId FROM inserted\n    DECLARE @title AS NVARCHAR(255)\n    SELECT @title = inserted.Title FROM inserted\n    DECLARE @complete AS BIT\n    SELECT @complete = inserted.Complete FROM inserted\n\n\n    INSERT INTO\n        [dbo].[TodoItems] ([UserId], [Title], [Complete])\n    VALUES\n        (@userid, @title, @complete)\n\n    IF UPDATE(Id) BEGIN\n        DECLARE @itemid AS BIGINT\n        SELECT @itemid = @@identity\n        DECLARE @id AS NVARCHAR(255)\n        SELECT @id = inserted.Id FROM inserted\n        UPDATE [mobile].[SysProps_TodoItems] SET [Id] = @id WHERE [item_id] = @itemid\n    END\nEND;\nGO\n\nCREATE TRIGGER\n    [mobile].[TRG_Mobile_TodoItem_Update]\nON\n    [mobile].[TodoItems]\nINSTEAD OF\n    UPDATE\nAS BEGIN\n    DECLARE @id AS NVARCHAR(255)\n    SELECT @id = inserted.id FROM inserted\n    DECLARE @itemid AS BIGINT\n    SELECT @itemid = [item_id] FROM [mobile].[SysProps_TodoItems] WHERE [id] = @id\n\n    IF UPDATE(UserId) BEGIN\n        DECLARE @userid AS NVARCHAR(255)\n        SELECT @userid = inserted.UserId FROM inserted\n        UPDATE [dbo].[TodoItems] SET [UserId] = @userid WHERE [id] = @itemid\n    END\n    IF UPDATE(Title) BEGIN\n        DECLARE @title AS NVARCHAR(255)\n        SELECT @title = inserted.Title FROM inserted\n        UPDATE [dbo].[TodoItems] SET [Title] = @title WHERE [id] = @itemid\n    END\n    IF UPDATE(Complete) BEGIN\n        DECLARE @complete AS BIT\n        SELECT @complete = inserted.Complete FROM inserted\n        UPDATE [dbo].[TodoItems] SET [Complete] = @complete WHERE [id] = @itemid\n    END\n    IF UPDATE(deleted) BEGIN\n        DECLARE @deleted AS BIT\n        SELECT @deleted = inserted.deleted FROM inserted\n        UPDATE [mobile].[SysProps_TodoItems] SET [deleted] = @deleted WHERE [item_id] = @itemid\n    END\nEND\nGO\n\nCREATE TRIGGER\n    [mobile].[TRG_Mobile_TodoItem_Delete]\nON\n    [mobile].[TodoItems]\nINSTEAD OF\n    DELETE\nAS BEGIN\n    DECLARE @id AS NVARCHAR(255)\n    SELECT @id = deleted.id FROM deleted\n    DECLARE @itemid AS BIGINT\n    SELECT @itemid = [item_id] FROM [mobile].[SysProps_TodoItems] WHERE [id] = @id\n\n    DELETE FROM [dbo].[TodoItems] WHERE [id] = @itemid\n    DELETE FROM [mobile].[SysProps_TodoItems] WHERE [id] = @id\nEND\nGO  A standard SQL view is read-only.  We made the view read/write by using triggers to trap the\ncall and replace it with two calls instead.   Warn  This version does not support soft delete.  If you wish to support soft delete, set the Deleted  flag in the `[mobile].[SysProps_TodoItems] table instead of deleting the row.",
            "title": "Using an existing SQL Table"
        },
        {
            "location": "/chapter3/server/#changing-the-mobile-schema",
            "text": "We stored our mobile representation of the table in a different schema.  Azure Mobile Apps looks\nfor tables (and views) in the  [dbo]  schema by default.  There are two places you can modify the\nschema that Entity Framework uses to access the database.  The first is by changing the default\nschema that Entity Framework uses.  This will affect all the tables that we are exposing via a\ntable controller.  This is done in the  Models\\MobileDbContext.cs  class:  protected override void OnModelCreating(DbModelBuilder modelBuilder)\n{\n    modelBuilder.HasDefaultSchema(\"mobile\");\n    modelBuilder.Conventions.Add(\n        new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n            \"ServiceTableColumn\",\n            (property, attributes) => attributes.Single().ColumnType.ToString()\n        )\n    );\n}  We can also do this on the model as an annotation.  For example, here is the TodoItem model suitably\nadjusted:  using Microsoft.Azure.Mobile.Server;\nusing Newtonsoft.Json;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace Backend.DataObjects\n{\n    [Table(\"TodoItems\", Schema=\"mobile\")]\n    public class TodoItem : EntityData\n    {\n        public string UserId { get; set; }\n\n        public string Title { get; set; }\n\n        public bool Complete { get; set; }\n    }\n}   Info  Entity Framework adds an  s  onto the end of the model to create the table name.  If you\nhave a model named  TodoItem , the table is called  TodoItems  in the database.  You can use this\nsame annotation to adjust the table name if it is not to your liking.",
            "title": "Changing the Mobile Schema"
        },
        {
            "location": "/chapter3/server/#best-practices",
            "text": "Here is a summary of what I consider best practices for table controllers:   Use Code First when you are in a green-field database situation.  Use Database First when you have to integrate an existing database.  Only expose the data that you need for the mobile client.  Set up Automatic Code First Migrations as early as possible.  Think about what happens to existing clients when you update the schema.   This last point is an important one.  Let's say you have a v1 mobile client of your awesome mobile\napplication.  This works with v1 mobile backend.  You've set up the schema and ensured that everything\nworks.  Then you want to release v2 mobile client.  It has a new feature and needs some extra data.\nSo you update to v2 mobile backend that provides that data.  You need to ensure that the schema changes provided by the v2 mobile backend are optional.  In other\nwords, the v1 mobile client can continue to work against the v2 mobile backend.  You should test this\ncase.  Users do not upgrade instantly.  In fact, many users don't upgrade at all.  At every release\nof your app, you are going to have to ensure that ALL versions of your mobile client work against\nyour mobile backend.",
            "title": "Best Practices"
        },
        {
            "location": "/chapter3/projection/",
            "text": "Projecting a Data Set\n\u00b6\n\n\nWe have thus far looked at what it takes to project a whole SQL database table into the mobile world.  We\ncan easily do both pre-existing and greenfield databases with code-first and database-first methodologies.\nThe next logical thing is to see what we can do to adjust the transfer of data.  How do we filter and\ntransform the data as requests are sent to the server.\n\n\nThere are two places where adjustment of the transfer is accomplished.  I recommend spending time on the\nserver adjusting the table controller so that security policies are assured.  The set of data that a\nmobile client can see should be the complete set of data that the user of that mobile device is allowed\nto see.  We can then adjust the view of that data at the client.\n\n\nFor example, let's say that the user is a sales person.  They are allowed to see the information for\ntheir accounts, but only wants to see the records for the accounts that have planned to visit within\nthe next week.  We would place the limitation on what records they can see on the server, but place\nthe date range manipulation on the client.\n\n\nIn this section, we will look at all the things one can do on in the table controller on the server.\n\n\nBasics of Projection\n\u00b6\n\n\nThere are four basic things we will want to do with table controllers:\n\n\nFilters\n adjust the data that the requesting user can see.  We would normally apply a filter to all\nmethods EXCEPT the \nCreate\n or \nInsert\n method.  This is the most common adjustment that is coded in\nthe table controller as filtering is the key to enforcing security policy.\n\n\nTransforms\n adjust the data that is being sent to the table controller before it is stored.  It is\nused in two areas.  First, it is used to automatically inject necessary fields for ensuring the security\nfilters can be applied.  For instance, if we wish to have a per-user data store (where a user can only\nsee their own records), then we will need to store the user ID of the requesting user.  Secondly, it is\nused to insert point-in-time lookups into a record.  For instance, if we wish to record the current price\nof an item at the time the record was inserted into the table, we would do this with a transform.\n\n\nValidations\n do not adjust the data.  Validations ensure that the data is correct according to the\nserver model.  Your data may, for example, store an age indirectly by storing the year of birth.  It's\nhighly unlikely that you will want to support the entire range of possible years.  You definitely don't\nwant to support years in the future.\n\n\nFinally, \nHooks\n allow another piece of code to be triggered either before or after the request has been\nprocessed.  For example, we may wish to send a push notification on a valid insert, or kick off an order\nprocessing work flow when a record is updated with an approval to ship.  We won't be covering hooks in\nthis chapter as we have a whole chapter on \ncustomized requests\n later on.\n\n\nProjection Recipes\n\u00b6\n\n\nThere are a few \"standard\" projects we see all the time and these are great ways to learn how to do\nprojections.\n\n\nPer-User Data\n\u00b6\n\n\nThe first projection that pretty much everyone implements is the \nPer-User Data\n projection.  In this\nrecipe, we want the user to only see records that they have inserted.  For example, let's update our\nTodoItem table to support per-user data.  This involves three parts:\n\n\n\n\nA \nFilter\n that limits data to only the logged in user.\n\n\nA \nTransform\n that updates an inserted record with the logged in user.\n\n\nA \nValidation\n that ensures an updated or deleted record is owned by the user.\n\n\n\n\nThe logged in user is available as the User object, but you have to cast it to a \nClaimsPrinicipal\n to\naccess the claims that are sent inside the identity token.  I tend to use a public property as an\nimplementation:\n\n\npublic string UserId\n{\n    get\n    {\n        var principal = this.User as ClaimsPrincipal;\n        return principal.FindFirst(ClaimTypes.NameIdentifier).Value;\n    }\n}\n\n\n\n\n\n\nTip\n\n\nIt's generally a good idea to use the SID as the user ID for the authenticated user in security\napplications.  The user can change the email address or username associated with the account, but\nthe SID never changes.\n\n\n\n\nWe need an extra property in the \nDataObjects\\TodoItem.cs\n class (in the \nBackend\n project) to hold\nthe extra security claim that we will be adding later:\n\n\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Chapter3.DataObjects\n{\n    public class TodoItem : EntityData\n    {\n        public string UserId { get; set; }\n\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n    }\n}\n\n\n\n\nRemember to do a code-first migration if you are doing this on an existing service.  Let's take a look\nat the \nPostTodoItem()\n first.  This requires the \nTransform\n to ensure the UserId field is filled\nin.  We've already defined the \nUserId\n field, so we can inject that in the inbound object:\n\n\n// POST tables/TodoItem\npublic async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n{\n    item.UserId = UserId;\n    TodoItem current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}\n\n\n\n\nTransforms tend to be short.  This is deliberate.  We don't want any of our code in a table controller\nto do too much work.  The heavy lifting is done by the database, with the ASP.NET table controller being\na conduit for translating requests into responses.  This allows us to support more users on less virtual\nhardware.\n\n\nThe \nFilter\n is a relatively simple affair in this case.  We ensure that the only records returned\nare those that belong to the user.  For example, here is a simplistic filter applied to the \nGetAll\n\nmethod:\n\n\n// GET tables/TodoItem\npublic IQueryable<TodoItem> GetAllTodoItems()\n{\n    return Query().Where(item => item.UserId.Equals(UserId));\n}\n\n\n\n\nThe \nQuery()\n and \nLookup(id).Queryable\n methods return \nIQueryable\n objects.  The IQueryable is used\nto represent a query, so we can alter it with LINQ.  A filter is merely a LINQ expression to limit the\nrecords being returned.  There might be another filter sent by the client, in which case this filter will\nbe tacked on the end of the request.  For instance, let's say that the client requests only records where\n\nComplete == False\n.  When this comes through the \nGetAllTodoItems()\n method, the resulting SQL code will\nlook something like this:\n\n\nSELECT * FROM [dbo].[TodoItems]\n    WHERE (Complete = false) AND (UserId = @0);\n\n\n\n\nThe \n@0\n parameter will be replaced by the users SID.\n\n\n\n\nWarn\n\n\nIf a user is not logged in (i.e. you forgot to add the \n[Authorize]\n attribute), the User object will\nbe null and the server will produce a 500 Internal Server Error back to the client.\n\n\n\n\nThis can get a little unwieldy for complex filters, however.  Since the filters are applied in two\ndifferent places (and are generally used for validation as well), I like to abstract them into a\n\nLINQ extension method\n.  Create a class in \nExtensions\\TodoItemExtensions.cs\n (you will have to create\nthe \nExtensions\n directory) with the following contents:\n\n\nusing System.Linq;\nusing Chapter3.DataObjects;\n\nnamespace Chapter3.Extensions\n{\n    public static class TodoItemExtensions\n    {\n        public static IQueryable<TodoItem> PerUserFilter(this IQueryable<TodoItem> query, string userid)\n        {\n            return query.Where(item => item.UserId.Equals(userid));\n        }\n    }\n}\n\n\n\n\nWe can use this to simplify our filters and make them more readable:\n\n\n// GET tables/TodoItem\npublic IQueryable<TodoItem> GetAllTodoItems()\n{\n    return Query().PerUserFilter(UserId);\n}\n\n// GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\npublic SingleResult<TodoItem> GetTodoItem(string id)\n{\n    return new SingleResult<TodoItem>(Lookup(id).Queryable.PerUserFilter(UserId));\n}\n\n\n\n\nNote that we need to apply the filter we have written to both the Get methods.\n\n\nWhen we look at the \nDelete\n and \nPatch\n methods, we only have to validate that the UserId owns the\nid we are updating.  For that, I write a custom validation method.  This method is in the table controller:\n\n\npublic void ValidateOwner(string id)\n{\n    var result = Lookup(id).Queryable.PerUserFilter(UserId).FirstOrDefault<TodoItem>();\n    if (result == null)\n    {\n        throw new HttpResponseException(HttpStatusCode.NotFound);\n    }\n}\n\n\n\n\nThe validation method must throw an appropriate \nHttpResponseException\n if the validation fails.  It's common\nto return a 404 Not Found error rather than a 403 Forbidden error for security reasons.  Returning a\n403 Forbidden error confirms that the Id exists, which is a data leakage.  Returning a 404 Not Found\nerror means that a rogue client cannot tell the difference between \"I can't access the record\" and\n\"the record doesn't exist\".  We can use this validation method in each method that requires it:\n\n\n// PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\npublic Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch)\n{\n    ValidateOwner(id);\n    return UpdateAsync(id, patch);\n}\n\n// DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\npublic Task DeleteTodoItem(string id)\n{\n    ValidateOwner(id);\n    return DeleteAsync(id);\n}\n\n\n\n\nAlthough this is a very basic example of a filtered table, we can see three different techniques:\n\n\n\n\nA \nFilter\n implemented as a LINQ query in an \nIQueryable\n extension method, applied to both \nGet\n methods.\n\n\nA \nTransform\n implemented inside the \nPost\n method.\n\n\nA \nValidation\n implemented using the filter as a method in the table controller, applied to \nPatch\n and \nDelete\n methods.\n\n\n\n\nI set up a copy of the TaskList from Chapter 2 with Azure Active Directory Client Flow for authentication.\nWe can look at the SQL table contents after we log in with this client and add a new task:\n\n\n\n\nNote that the UserId is the security ID of the authenticated user.  The security ID is a stable ID for\nthe user.  The security ID does not change if the user changes their username or email address.\n\n\nPer-Group Data\n\u00b6\n\n\nLet's say we have a mobile client that a sales person uses to enter data about sales.  He might be able\nto pick from a list of industries that the account is in.  The enterprise may further organize those\nindustries as groups, with several people within the organization able to view the accounts associated\nwith a specific industry.\n\n\nIn this case:\n\n\n\n\nWe want to limit the mobile client to only view accounts for groups to which he belongs.\n\n\nWe want to allow the mobile client to submit new accounts for any group to which he belongs.\n\n\nUpdates and Deletes should not adjust the group field.\n\n\n\n\nThe limit will be implemented as a filter.  The update and insert methods will require a\nvalidation method (comparing the submitted group with the list of groups to which the user\nbelongs).\n\n\nWe have another table in \nDataObjects\\Example.cs\n.  Let's extend it to support a GroupId:\n\n\nusing System;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Chapter3.DataObjects\n{\n    public class Example : EntityData\n    {\n        public string GroupId { get; set; }\n        public string StringField { get; set; }\n        public int IntField { get; set; }\n        public double DoubleField { get; set; }\n        public DateTimeOffset DateTimeField { get; set; }\n    }\n}\n\n\n\n\nWe'll store the group ID in the additional field.  Don't forget to use a code-first migration to update the database.\nEach of the validations and filters requires a list of the groups the user belongs to.  This can be achieved using\na claim lookup:\n\n\n/// <summary>\n/// Get the list of groups from the claims\n/// </summary>\n/// <returns>The list of groups</returns>\npublic async Task<List<string>> GetGroups()\n{\n    var creds = await User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request);\n    return creds.UserClaims\n        .Where(claim => claim.Type.Equals(\"groups\"))\n        .Select(claim => claim.Value)\n        .ToList();\n}\n\n\n\n\n\n\nTip\n\n\nIf you are using claims as part of your security model, you should add the claims that you are\nusing to the identity token that is used for authentication.  You can do this with custom authentication\nby calling LoginAsync() twice - once for the standard login method and the second time to adjust the\ntoken through the custom auth.\n\n\n\n\nOur filter is defined as a LINQ extension (just like in the per-user filter) in \nExtensions\\ExampleExtensions.cs\n:\n\n\nusing System.Collections.Generic;\nusing System.Linq;\nusing Chapter3.DataObjects;\n\nnamespace Chapter3.Extensions\n{\n    public static class ExampleExtensions\n    {\n        public static IQueryable<Example> PerGroupFilter(this IQueryable<Example> query, List<string> groups)\n        {\n            return query.Where(item => groups.Contains(item.GroupId));\n        }\n    }\n}\n\n\n\n\nWe can use this LINQ extension on the retrieval methods:\n\n\n// GET tables/Example\npublic async Task<IQueryable<Example>> GetAllExample()\n{\n    var groups = await GetGroups();\n    return Query().PerGroupFilter(groups);\n}\n\n// GET tables/Example/48D68C86-6EA6-4C25-AA33-223FC9A27959\npublic async Task<SingleResult<Example>> GetExample(string id)\n{\n    var groups = await GetGroups();\n    return new SingleResult<Example>(Lookup(id).Queryable.PerGroupFilter(groups));\n}\n\n\n\n\nWe have to convert each of the methods to a async method so that we can check the groups.  Retrieving the group\nlist for a user is an async method and this trickles down to the method being called.\n\n\nThe validation method is also an async method (for the same reason).  The Post and Patch methods look like\nthis:\n\n\n/// <summary>\n/// Validator to determine if the provided group is in the list of groups\n/// </summary>\n/// <param name=\"group\">The group name</param>\npublic async Task ValidateGroup(string group)\n{\n    var groups = await GetGroups();\n    if (!groups.Contains(group))\n    {\n        throw new HttpResponseException(HttpStatusCode.BadRequest);\n    }\n}\n\n// PATCH tables/Example/48D68C86-6EA6-4C25-AA33-223FC9A27959\npublic async Task<Example> PatchExample(string id, Delta<Example> patch)\n{\n    await ValidateGroup(patch.GetEntity().GroupId);\n    return await UpdateAsync(id, patch);\n}\n\n// POST tables/Example\npublic async Task<IHttpActionResult> PostExample(Example item)\n{\n    await ValidateGroup(item.GroupId);\n    Example current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}\n\n\n\n\nIt's appropriate to throw a 400 Bad Request for a validation error in this case as the user is\nauthenticated at this point.  The user is not being exposed by the response.\n\n\nThere is no transform in this recipe as the group ID is being sent on each update request.\n\n\nFriends Data\n\u00b6\n\n\nOne of the common social patterns is a \"friends feed\". We can post to our feed and we can see\nboth our messages and our friends messages. In this recipe, we will have three tables.  The\nfirst is the \nUsers\n table with the following model:\n\n\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Chapter3.DataObjects\n{\n    public class User : EntityData\n    {\n        public string EmailAddress { get; set; }\n        public string Name { get; set; }\n    }\n}\n\n\n\n\n\n\nTip\n\n\nDon't forget to add a \nDbSet<>\n for each table to the \nMobileServiceContext\n to add the table.\n\n\n\n\nIn our application, we will update the \nUsers\n table via a \ncustom authentication controller\n.\nAfter we have logged in via Azure Active Directory, we call the \nInvokeApiAsync()\n method\nto call the custom authentication controller and get a new token with some extra information\nin it.  We'll cover custom authentication controllers in a later chapter.\n\n\nusing System;\nusing System.Data.Entity.Migrations;\nusing System.IdentityModel.Tokens;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Security.Principal;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing Chapter3.DataObjects;\nusing Chapter3.Models;\nusing Microsoft.Azure.Mobile.Server.Authentication;\nusing Microsoft.Azure.Mobile.Server.Login;\nusing Newtonsoft.Json;\n\nnamespace Chapter3.Controllers\n{\n    [Authorize]\n    [Route(\"auth/login/custom\")]\n    public class CustomAuthController : ApiController\n    {\n        MobileServiceContext dbContext;\n\n        public CustomAuthController()\n        {\n            dbContext = new MobileServiceContext();\n\n            string website = Environment.GetEnvironmentVariable(\"WEBSITE_HOSTNAME\");\n            Audience = $\"https://{website}/\";\n            Issuer = $\"https://{website}/\";\n            SigningKey = Environment.GetEnvironmentVariable(\"WEBSITE_AUTH_SIGNING_KEY\");\n        }\n\n        public string Audience { get; set; }\n        public string Issuer { get; set; }\n        public string SigningKey { get; set; }\n\n        [HttpPost]\n        public async Task<IHttpActionResult> Post()\n        {\n            var creds = await User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request);\n            var sid = ((ClaimsPrincipal)User).FindFirst(ClaimTypes.NameIdentifier).Value;\n            var email = creds.UserClaims\n                .FirstOrDefault(claim => claim.Type.EndsWith(\"emailaddress\"))\n                .Value;\n            var name = creds.UserClaims\n                .FirstOrDefault(claim => claim.Type.EndsWith(\"name\"))\n                .Value;\n\n            // Insert the record information into the database\n            User user = new User()\n            {\n                Id = sid,\n                Name = name,\n                EmailAddress = email\n            };\n            dbContext.Users.AddOrUpdate(user);\n            dbContext.SaveChanges();\n\n            // Mind a new token based on the old one plus the new information\n            var newClaims = new Claim[]\n            {\n                new Claim(JwtRegisteredClaimNames.Sub, sid),\n                new Claim(JwtRegisteredClaimNames.Email, email),\n                new Claim(\"name\", name)\n            };\n            JwtSecurityToken token = AppServiceLoginHandler.CreateToken(\n                newClaims, SigningKey, Audience, Issuer, TimeSpan.FromDays(30));\n\n            // Return the token and user ID to the client\n            return Ok(new LoginResult()\n            {\n                AuthenticationToken = token.RawData,\n                UserId = sid\n            });\n        }\n    }\n\n    public class LoginResult\n    {\n        [JsonProperty(PropertyName = \"authenticationToken\")]\n        public string AuthenticationToken { get; set; }\n\n        [JsonProperty(PropertyName = \"user_id\")]\n        public string UserId { get; set; }\n    }\n}\n\n\n\n\nThe actual database update is done by Entity Framework.  The ASP.NET service is just\na regular ASP.NET service using Entity Framework, so all the same facilities are\navailable as that configuration.  In this case, we take the provided token (which\nis the same token that Azure Active Directory client-flow returns) and return a\nmodified token that includes a couple of extra fields.  During this process, we\nupdate the database by adding or inserting (also known as upserting) a record with\nthe Id field set to the security ID and the additional fields we need.\n\n\nI need a table to implement the \"friends\" relationship.  My friends are not stored\nin Azure Active Directory.  If I were using a social provider, I could use the\nfriends feed from that social provider by doing a Graph API lookup.  In this case,\nI'm going to use the following model:\n\n\nnamespace Chapter3.DataObjects\n{\n    public class Friend\n    {\n        public string UserId { get; set; }\n        public string FriendId { get; set; }\n    }\n}\n\n\n\n\nThis is not based on \nEntityData\n because I am not going to expose this table to the\nmobile client.  It's purely for determining what records I am going to show to the\nmobile client.  In this example, I will maintain the data in this table manually.\nA \"real\" application would have some sort of custom workflow to add friends and get\nthe friends to approve the connection.\n\n\nTo get the list of \"friends I can see\", I will request a list of the \nFriendId\n field\nwhere the \nUserId\n is my UserId.\n\n\nThe final table in the trio is the \nMessages\n table.  This will be downloaded to the\nmobile client so it has to be based on the \nEntityData\n base class.  In addition, the\ninserts for this table are going to look a lot like a per-user table.  I need the\n\nUserId\n field to properly maintain the security model.\n\n\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Chapter3.DataObjects\n{\n    public class Message : EntityData\n    {\n        public string UserId { get; set; }\n        public string Text { get; set; }\n    }\n}\n\n\n\n\nLet's think about the security model we want to implement in the \nMessages\n table controller:\n\n\n\n\nA \nfilter\n will allow the viewing of the users own data or any data that has an association in the Friends table.\n\n\nA \ntransform\n will set the owner of the record to my UserId\n\n\nWe will remove the ability to update or delete records since this is a write-once read-many table.\n\n\n\n\nLet's look at the \nPostMessage()\n method for the \nMessageController\n first.  This is\npractically identical to the \nPostTodoItem()\n method in the per-user recipe:\n\n\npublic string UserId => ((ClaimsPrincipal)User).FindFirst(ClaimTypes.NameIdentifier).Value;\n\n// POST tables/Message\npublic async Task<IHttpActionResult> PostMessage(Message item)\n{\n    item.UserId = UserId;\n    Message current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}\n\n\n\n\nThe filter is a little harder.  We are going to use the \nFluent Syntax\n for LINQ to provide the right logic.\nThe Fluent Syntax is also known as \"Query Syntax\" or the \"declarative syntax\", depending on the author.  The extension\nmethod looks like this:\n\n\nusing Chapter3.DataObjects;\nusing System.Data.Entity;\nusing System.Linq;\n\nnamespace Chapter3.Extensions\n{\n    public static class MessageExtensions\n    {\n        public static IQueryable<Message> OwnedByFriends(this IQueryable<Message> query, DbSet<Friend> friends, string userId)\n        {\n            var myPosts = from m in query\n                          let fr = (from f in friends where f.FriendId == userId select f.UserId)\n                          where m.UserId == userId || fr.Contains(m.UserId)\n                          select m;\n            return myPosts;\n        }\n    }\n}\n\n\n\n\nThe LINQ query selects the messages from the \nMessages\n table where the author is either the mobile client user or the mobile client\nuser is listed as a friend of the author.  My query methods in the table controller now look similar to the per-user data:\n\n\npublic string UserId => ((ClaimsPrincipal)User).FindFirst(ClaimTypes.NameIdentifier).Value;\n\n// GET tables/Message\npublic IQueryable<Message> GetAllMessage()\n{\n    return Query().OwnedByFriends(context.Friends, UserId);\n}\n\n// GET tables/Message/48D68C86-6EA6-4C25-AA33-223FC9A27959\npublic SingleResult<Message> GetMessage(string id)\n{\n    return new SingleResult<Message>(Lookup(id).Queryable.OwnedByFriends(context.Friends, UserId));\n}\n\n\n\n\nUsing LINQPad to test LINQ Queries\n\u00b6\n\n\nI tend to struggle with LINQ queries.  Fortunately, there are a plethora of blogs, tutorials and tools out there to assist.  One\nof my favorite tools is \nLINQPad\n.  LINQPad gives you an interactive playground for testing your LINQ queries.  In this case, I\ncreated a new query with the following contents:\n\n\npublic class Message {\n   public string UserId;\n   public string Text;\n}\n\npublic class Friend {\n   public string UserId;\n   public string FollowerId;\n}\n\nvoid Main()\n{\n\n\nList<Friend> friends = new List<Friend>() {\n   new Friend() { UserId = \"adrian\", FollowerId = \"donna\" },\n   new Friend() { UserId = \"fabio\", FollowerId = \"donna\" },\n   new Friend() { UserId = \"fabio\", FollowerId = \"adrian\" }\n};\n\nList<Message> messages = new List<Message>() {\n   new Message() { UserId = \"adrian\", Text = \"message 1\" },\n   new Message() { UserId = \"donna\", Text = \"message 2\" },\n   new Message() { UserId = \"fabio\", Text = \"message 3\" }\n};\nvar user = \"fabio\";\n\nvar q = from m in messages\n        let fr = (from f in friends where f.FollowerId == user select f.UserId)\n        where m.UserId == user || fr.Contains(m.UserId)\n        select m;\n\nq.Dump();\n\n}\n\n\n\n\nI have a friends table and a messages table.  User \"donna\" should be able to see three messages, user \"adrian\"\nshould be able to see two messages and user \"fabio\" should be able to see just one message.  By changing the\nvalue of the \nuser\n variable, I can test the query I am writing.  I don't need to set up a database (although\nLINQPad supports that as well).\n\n\n\n\nBest Practices\n\u00b6\n\n\nThere are a number of best practices that I think are important in developing table controllers:\n\n\n\n\nOptimize Operations\n\n\n\n\nYou should always optimize the CRUD operations that are implemented in a table controller.  This means limiting\n  the code so that only \nfilters\n, \ntransforms\n and \nvalidators\n are used.  You can use \nhooks\n as an\n  asynchronous way to handle custom code if something else needs to happen when a mobile client inserts, updates\n  or deletes a record.  (We will be delving into hooks during the custom code chapter later on).\n\n\nYou should \nNOT\n insert custom code into a table controller that runs synchronously.\n\n\n\n\nImplement Security Policy with Filters\n\n\n\n\nThe mobile backend should be concerned with security.  What can the connecting user see?  Use \nfilters\n to\n  ensure that the connecting user can only see the data that they are allowed to see.  There are several examples\n  of bad filters.  For example, if a user normally wants to see the last 7 days worth of messages, but is allowed\n  to see all messages.  I would implement this particular case as a client-side filter as it has nothing to do\n  with security.\n\n\n\n\nUse LINQ Extension Methods\n\n\n\n\nLINQ extension methods can be used to great effect to make your CRUD methods more readable.  I love readable\n  code.  For example, consider the following two code snippets from the last recipe:\n\n\npublic IQueryable<Message> GetAllMessage()\n{\n  // Recipe #1\n  return Query().OwnedByFriends(context.Friends, UserId);\n\n  // Recipe #2\n  return from m in Query()\n    let fr = (from f in context.Friends where f.FriendId == UserId select f.UserId)\n    where m.UserId == UserId || fr.Contains(m.UserId)\n    select m;\n}\n\n\n\n\nThe first recipe makes the intent of the filter very clear.  I have to work at understanding the specific implementation\n  of the second method.",
            "title": "Data Projection and Queries"
        },
        {
            "location": "/chapter3/projection/#projecting-a-data-set",
            "text": "We have thus far looked at what it takes to project a whole SQL database table into the mobile world.  We\ncan easily do both pre-existing and greenfield databases with code-first and database-first methodologies.\nThe next logical thing is to see what we can do to adjust the transfer of data.  How do we filter and\ntransform the data as requests are sent to the server.  There are two places where adjustment of the transfer is accomplished.  I recommend spending time on the\nserver adjusting the table controller so that security policies are assured.  The set of data that a\nmobile client can see should be the complete set of data that the user of that mobile device is allowed\nto see.  We can then adjust the view of that data at the client.  For example, let's say that the user is a sales person.  They are allowed to see the information for\ntheir accounts, but only wants to see the records for the accounts that have planned to visit within\nthe next week.  We would place the limitation on what records they can see on the server, but place\nthe date range manipulation on the client.  In this section, we will look at all the things one can do on in the table controller on the server.",
            "title": "Projecting a Data Set"
        },
        {
            "location": "/chapter3/projection/#basics-of-projection",
            "text": "There are four basic things we will want to do with table controllers:  Filters  adjust the data that the requesting user can see.  We would normally apply a filter to all\nmethods EXCEPT the  Create  or  Insert  method.  This is the most common adjustment that is coded in\nthe table controller as filtering is the key to enforcing security policy.  Transforms  adjust the data that is being sent to the table controller before it is stored.  It is\nused in two areas.  First, it is used to automatically inject necessary fields for ensuring the security\nfilters can be applied.  For instance, if we wish to have a per-user data store (where a user can only\nsee their own records), then we will need to store the user ID of the requesting user.  Secondly, it is\nused to insert point-in-time lookups into a record.  For instance, if we wish to record the current price\nof an item at the time the record was inserted into the table, we would do this with a transform.  Validations  do not adjust the data.  Validations ensure that the data is correct according to the\nserver model.  Your data may, for example, store an age indirectly by storing the year of birth.  It's\nhighly unlikely that you will want to support the entire range of possible years.  You definitely don't\nwant to support years in the future.  Finally,  Hooks  allow another piece of code to be triggered either before or after the request has been\nprocessed.  For example, we may wish to send a push notification on a valid insert, or kick off an order\nprocessing work flow when a record is updated with an approval to ship.  We won't be covering hooks in\nthis chapter as we have a whole chapter on  customized requests  later on.",
            "title": "Basics of Projection"
        },
        {
            "location": "/chapter3/projection/#projection-recipes",
            "text": "There are a few \"standard\" projects we see all the time and these are great ways to learn how to do\nprojections.",
            "title": "Projection Recipes"
        },
        {
            "location": "/chapter3/projection/#per-user-data",
            "text": "The first projection that pretty much everyone implements is the  Per-User Data  projection.  In this\nrecipe, we want the user to only see records that they have inserted.  For example, let's update our\nTodoItem table to support per-user data.  This involves three parts:   A  Filter  that limits data to only the logged in user.  A  Transform  that updates an inserted record with the logged in user.  A  Validation  that ensures an updated or deleted record is owned by the user.   The logged in user is available as the User object, but you have to cast it to a  ClaimsPrinicipal  to\naccess the claims that are sent inside the identity token.  I tend to use a public property as an\nimplementation:  public string UserId\n{\n    get\n    {\n        var principal = this.User as ClaimsPrincipal;\n        return principal.FindFirst(ClaimTypes.NameIdentifier).Value;\n    }\n}   Tip  It's generally a good idea to use the SID as the user ID for the authenticated user in security\napplications.  The user can change the email address or username associated with the account, but\nthe SID never changes.   We need an extra property in the  DataObjects\\TodoItem.cs  class (in the  Backend  project) to hold\nthe extra security claim that we will be adding later:  using Microsoft.Azure.Mobile.Server;\n\nnamespace Chapter3.DataObjects\n{\n    public class TodoItem : EntityData\n    {\n        public string UserId { get; set; }\n\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n    }\n}  Remember to do a code-first migration if you are doing this on an existing service.  Let's take a look\nat the  PostTodoItem()  first.  This requires the  Transform  to ensure the UserId field is filled\nin.  We've already defined the  UserId  field, so we can inject that in the inbound object:  // POST tables/TodoItem\npublic async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n{\n    item.UserId = UserId;\n    TodoItem current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}  Transforms tend to be short.  This is deliberate.  We don't want any of our code in a table controller\nto do too much work.  The heavy lifting is done by the database, with the ASP.NET table controller being\na conduit for translating requests into responses.  This allows us to support more users on less virtual\nhardware.  The  Filter  is a relatively simple affair in this case.  We ensure that the only records returned\nare those that belong to the user.  For example, here is a simplistic filter applied to the  GetAll \nmethod:  // GET tables/TodoItem\npublic IQueryable<TodoItem> GetAllTodoItems()\n{\n    return Query().Where(item => item.UserId.Equals(UserId));\n}  The  Query()  and  Lookup(id).Queryable  methods return  IQueryable  objects.  The IQueryable is used\nto represent a query, so we can alter it with LINQ.  A filter is merely a LINQ expression to limit the\nrecords being returned.  There might be another filter sent by the client, in which case this filter will\nbe tacked on the end of the request.  For instance, let's say that the client requests only records where Complete == False .  When this comes through the  GetAllTodoItems()  method, the resulting SQL code will\nlook something like this:  SELECT * FROM [dbo].[TodoItems]\n    WHERE (Complete = false) AND (UserId = @0);  The  @0  parameter will be replaced by the users SID.   Warn  If a user is not logged in (i.e. you forgot to add the  [Authorize]  attribute), the User object will\nbe null and the server will produce a 500 Internal Server Error back to the client.   This can get a little unwieldy for complex filters, however.  Since the filters are applied in two\ndifferent places (and are generally used for validation as well), I like to abstract them into a LINQ extension method .  Create a class in  Extensions\\TodoItemExtensions.cs  (you will have to create\nthe  Extensions  directory) with the following contents:  using System.Linq;\nusing Chapter3.DataObjects;\n\nnamespace Chapter3.Extensions\n{\n    public static class TodoItemExtensions\n    {\n        public static IQueryable<TodoItem> PerUserFilter(this IQueryable<TodoItem> query, string userid)\n        {\n            return query.Where(item => item.UserId.Equals(userid));\n        }\n    }\n}  We can use this to simplify our filters and make them more readable:  // GET tables/TodoItem\npublic IQueryable<TodoItem> GetAllTodoItems()\n{\n    return Query().PerUserFilter(UserId);\n}\n\n// GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\npublic SingleResult<TodoItem> GetTodoItem(string id)\n{\n    return new SingleResult<TodoItem>(Lookup(id).Queryable.PerUserFilter(UserId));\n}  Note that we need to apply the filter we have written to both the Get methods.  When we look at the  Delete  and  Patch  methods, we only have to validate that the UserId owns the\nid we are updating.  For that, I write a custom validation method.  This method is in the table controller:  public void ValidateOwner(string id)\n{\n    var result = Lookup(id).Queryable.PerUserFilter(UserId).FirstOrDefault<TodoItem>();\n    if (result == null)\n    {\n        throw new HttpResponseException(HttpStatusCode.NotFound);\n    }\n}  The validation method must throw an appropriate  HttpResponseException  if the validation fails.  It's common\nto return a 404 Not Found error rather than a 403 Forbidden error for security reasons.  Returning a\n403 Forbidden error confirms that the Id exists, which is a data leakage.  Returning a 404 Not Found\nerror means that a rogue client cannot tell the difference between \"I can't access the record\" and\n\"the record doesn't exist\".  We can use this validation method in each method that requires it:  // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\npublic Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch)\n{\n    ValidateOwner(id);\n    return UpdateAsync(id, patch);\n}\n\n// DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\npublic Task DeleteTodoItem(string id)\n{\n    ValidateOwner(id);\n    return DeleteAsync(id);\n}  Although this is a very basic example of a filtered table, we can see three different techniques:   A  Filter  implemented as a LINQ query in an  IQueryable  extension method, applied to both  Get  methods.  A  Transform  implemented inside the  Post  method.  A  Validation  implemented using the filter as a method in the table controller, applied to  Patch  and  Delete  methods.   I set up a copy of the TaskList from Chapter 2 with Azure Active Directory Client Flow for authentication.\nWe can look at the SQL table contents after we log in with this client and add a new task:   Note that the UserId is the security ID of the authenticated user.  The security ID is a stable ID for\nthe user.  The security ID does not change if the user changes their username or email address.",
            "title": "Per-User Data"
        },
        {
            "location": "/chapter3/projection/#per-group-data",
            "text": "Let's say we have a mobile client that a sales person uses to enter data about sales.  He might be able\nto pick from a list of industries that the account is in.  The enterprise may further organize those\nindustries as groups, with several people within the organization able to view the accounts associated\nwith a specific industry.  In this case:   We want to limit the mobile client to only view accounts for groups to which he belongs.  We want to allow the mobile client to submit new accounts for any group to which he belongs.  Updates and Deletes should not adjust the group field.   The limit will be implemented as a filter.  The update and insert methods will require a\nvalidation method (comparing the submitted group with the list of groups to which the user\nbelongs).  We have another table in  DataObjects\\Example.cs .  Let's extend it to support a GroupId:  using System;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Chapter3.DataObjects\n{\n    public class Example : EntityData\n    {\n        public string GroupId { get; set; }\n        public string StringField { get; set; }\n        public int IntField { get; set; }\n        public double DoubleField { get; set; }\n        public DateTimeOffset DateTimeField { get; set; }\n    }\n}  We'll store the group ID in the additional field.  Don't forget to use a code-first migration to update the database.\nEach of the validations and filters requires a list of the groups the user belongs to.  This can be achieved using\na claim lookup:  /// <summary>\n/// Get the list of groups from the claims\n/// </summary>\n/// <returns>The list of groups</returns>\npublic async Task<List<string>> GetGroups()\n{\n    var creds = await User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request);\n    return creds.UserClaims\n        .Where(claim => claim.Type.Equals(\"groups\"))\n        .Select(claim => claim.Value)\n        .ToList();\n}   Tip  If you are using claims as part of your security model, you should add the claims that you are\nusing to the identity token that is used for authentication.  You can do this with custom authentication\nby calling LoginAsync() twice - once for the standard login method and the second time to adjust the\ntoken through the custom auth.   Our filter is defined as a LINQ extension (just like in the per-user filter) in  Extensions\\ExampleExtensions.cs :  using System.Collections.Generic;\nusing System.Linq;\nusing Chapter3.DataObjects;\n\nnamespace Chapter3.Extensions\n{\n    public static class ExampleExtensions\n    {\n        public static IQueryable<Example> PerGroupFilter(this IQueryable<Example> query, List<string> groups)\n        {\n            return query.Where(item => groups.Contains(item.GroupId));\n        }\n    }\n}  We can use this LINQ extension on the retrieval methods:  // GET tables/Example\npublic async Task<IQueryable<Example>> GetAllExample()\n{\n    var groups = await GetGroups();\n    return Query().PerGroupFilter(groups);\n}\n\n// GET tables/Example/48D68C86-6EA6-4C25-AA33-223FC9A27959\npublic async Task<SingleResult<Example>> GetExample(string id)\n{\n    var groups = await GetGroups();\n    return new SingleResult<Example>(Lookup(id).Queryable.PerGroupFilter(groups));\n}  We have to convert each of the methods to a async method so that we can check the groups.  Retrieving the group\nlist for a user is an async method and this trickles down to the method being called.  The validation method is also an async method (for the same reason).  The Post and Patch methods look like\nthis:  /// <summary>\n/// Validator to determine if the provided group is in the list of groups\n/// </summary>\n/// <param name=\"group\">The group name</param>\npublic async Task ValidateGroup(string group)\n{\n    var groups = await GetGroups();\n    if (!groups.Contains(group))\n    {\n        throw new HttpResponseException(HttpStatusCode.BadRequest);\n    }\n}\n\n// PATCH tables/Example/48D68C86-6EA6-4C25-AA33-223FC9A27959\npublic async Task<Example> PatchExample(string id, Delta<Example> patch)\n{\n    await ValidateGroup(patch.GetEntity().GroupId);\n    return await UpdateAsync(id, patch);\n}\n\n// POST tables/Example\npublic async Task<IHttpActionResult> PostExample(Example item)\n{\n    await ValidateGroup(item.GroupId);\n    Example current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}  It's appropriate to throw a 400 Bad Request for a validation error in this case as the user is\nauthenticated at this point.  The user is not being exposed by the response.  There is no transform in this recipe as the group ID is being sent on each update request.",
            "title": "Per-Group Data"
        },
        {
            "location": "/chapter3/projection/#friends-data",
            "text": "One of the common social patterns is a \"friends feed\". We can post to our feed and we can see\nboth our messages and our friends messages. In this recipe, we will have three tables.  The\nfirst is the  Users  table with the following model:  using Microsoft.Azure.Mobile.Server;\n\nnamespace Chapter3.DataObjects\n{\n    public class User : EntityData\n    {\n        public string EmailAddress { get; set; }\n        public string Name { get; set; }\n    }\n}   Tip  Don't forget to add a  DbSet<>  for each table to the  MobileServiceContext  to add the table.   In our application, we will update the  Users  table via a  custom authentication controller .\nAfter we have logged in via Azure Active Directory, we call the  InvokeApiAsync()  method\nto call the custom authentication controller and get a new token with some extra information\nin it.  We'll cover custom authentication controllers in a later chapter.  using System;\nusing System.Data.Entity.Migrations;\nusing System.IdentityModel.Tokens;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Security.Principal;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing Chapter3.DataObjects;\nusing Chapter3.Models;\nusing Microsoft.Azure.Mobile.Server.Authentication;\nusing Microsoft.Azure.Mobile.Server.Login;\nusing Newtonsoft.Json;\n\nnamespace Chapter3.Controllers\n{\n    [Authorize]\n    [Route(\"auth/login/custom\")]\n    public class CustomAuthController : ApiController\n    {\n        MobileServiceContext dbContext;\n\n        public CustomAuthController()\n        {\n            dbContext = new MobileServiceContext();\n\n            string website = Environment.GetEnvironmentVariable(\"WEBSITE_HOSTNAME\");\n            Audience = $\"https://{website}/\";\n            Issuer = $\"https://{website}/\";\n            SigningKey = Environment.GetEnvironmentVariable(\"WEBSITE_AUTH_SIGNING_KEY\");\n        }\n\n        public string Audience { get; set; }\n        public string Issuer { get; set; }\n        public string SigningKey { get; set; }\n\n        [HttpPost]\n        public async Task<IHttpActionResult> Post()\n        {\n            var creds = await User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request);\n            var sid = ((ClaimsPrincipal)User).FindFirst(ClaimTypes.NameIdentifier).Value;\n            var email = creds.UserClaims\n                .FirstOrDefault(claim => claim.Type.EndsWith(\"emailaddress\"))\n                .Value;\n            var name = creds.UserClaims\n                .FirstOrDefault(claim => claim.Type.EndsWith(\"name\"))\n                .Value;\n\n            // Insert the record information into the database\n            User user = new User()\n            {\n                Id = sid,\n                Name = name,\n                EmailAddress = email\n            };\n            dbContext.Users.AddOrUpdate(user);\n            dbContext.SaveChanges();\n\n            // Mind a new token based on the old one plus the new information\n            var newClaims = new Claim[]\n            {\n                new Claim(JwtRegisteredClaimNames.Sub, sid),\n                new Claim(JwtRegisteredClaimNames.Email, email),\n                new Claim(\"name\", name)\n            };\n            JwtSecurityToken token = AppServiceLoginHandler.CreateToken(\n                newClaims, SigningKey, Audience, Issuer, TimeSpan.FromDays(30));\n\n            // Return the token and user ID to the client\n            return Ok(new LoginResult()\n            {\n                AuthenticationToken = token.RawData,\n                UserId = sid\n            });\n        }\n    }\n\n    public class LoginResult\n    {\n        [JsonProperty(PropertyName = \"authenticationToken\")]\n        public string AuthenticationToken { get; set; }\n\n        [JsonProperty(PropertyName = \"user_id\")]\n        public string UserId { get; set; }\n    }\n}  The actual database update is done by Entity Framework.  The ASP.NET service is just\na regular ASP.NET service using Entity Framework, so all the same facilities are\navailable as that configuration.  In this case, we take the provided token (which\nis the same token that Azure Active Directory client-flow returns) and return a\nmodified token that includes a couple of extra fields.  During this process, we\nupdate the database by adding or inserting (also known as upserting) a record with\nthe Id field set to the security ID and the additional fields we need.  I need a table to implement the \"friends\" relationship.  My friends are not stored\nin Azure Active Directory.  If I were using a social provider, I could use the\nfriends feed from that social provider by doing a Graph API lookup.  In this case,\nI'm going to use the following model:  namespace Chapter3.DataObjects\n{\n    public class Friend\n    {\n        public string UserId { get; set; }\n        public string FriendId { get; set; }\n    }\n}  This is not based on  EntityData  because I am not going to expose this table to the\nmobile client.  It's purely for determining what records I am going to show to the\nmobile client.  In this example, I will maintain the data in this table manually.\nA \"real\" application would have some sort of custom workflow to add friends and get\nthe friends to approve the connection.  To get the list of \"friends I can see\", I will request a list of the  FriendId  field\nwhere the  UserId  is my UserId.  The final table in the trio is the  Messages  table.  This will be downloaded to the\nmobile client so it has to be based on the  EntityData  base class.  In addition, the\ninserts for this table are going to look a lot like a per-user table.  I need the UserId  field to properly maintain the security model.  using Microsoft.Azure.Mobile.Server;\n\nnamespace Chapter3.DataObjects\n{\n    public class Message : EntityData\n    {\n        public string UserId { get; set; }\n        public string Text { get; set; }\n    }\n}  Let's think about the security model we want to implement in the  Messages  table controller:   A  filter  will allow the viewing of the users own data or any data that has an association in the Friends table.  A  transform  will set the owner of the record to my UserId  We will remove the ability to update or delete records since this is a write-once read-many table.   Let's look at the  PostMessage()  method for the  MessageController  first.  This is\npractically identical to the  PostTodoItem()  method in the per-user recipe:  public string UserId => ((ClaimsPrincipal)User).FindFirst(ClaimTypes.NameIdentifier).Value;\n\n// POST tables/Message\npublic async Task<IHttpActionResult> PostMessage(Message item)\n{\n    item.UserId = UserId;\n    Message current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}  The filter is a little harder.  We are going to use the  Fluent Syntax  for LINQ to provide the right logic.\nThe Fluent Syntax is also known as \"Query Syntax\" or the \"declarative syntax\", depending on the author.  The extension\nmethod looks like this:  using Chapter3.DataObjects;\nusing System.Data.Entity;\nusing System.Linq;\n\nnamespace Chapter3.Extensions\n{\n    public static class MessageExtensions\n    {\n        public static IQueryable<Message> OwnedByFriends(this IQueryable<Message> query, DbSet<Friend> friends, string userId)\n        {\n            var myPosts = from m in query\n                          let fr = (from f in friends where f.FriendId == userId select f.UserId)\n                          where m.UserId == userId || fr.Contains(m.UserId)\n                          select m;\n            return myPosts;\n        }\n    }\n}  The LINQ query selects the messages from the  Messages  table where the author is either the mobile client user or the mobile client\nuser is listed as a friend of the author.  My query methods in the table controller now look similar to the per-user data:  public string UserId => ((ClaimsPrincipal)User).FindFirst(ClaimTypes.NameIdentifier).Value;\n\n// GET tables/Message\npublic IQueryable<Message> GetAllMessage()\n{\n    return Query().OwnedByFriends(context.Friends, UserId);\n}\n\n// GET tables/Message/48D68C86-6EA6-4C25-AA33-223FC9A27959\npublic SingleResult<Message> GetMessage(string id)\n{\n    return new SingleResult<Message>(Lookup(id).Queryable.OwnedByFriends(context.Friends, UserId));\n}",
            "title": "Friends Data"
        },
        {
            "location": "/chapter3/projection/#using-linqpad-to-test-linq-queries",
            "text": "I tend to struggle with LINQ queries.  Fortunately, there are a plethora of blogs, tutorials and tools out there to assist.  One\nof my favorite tools is  LINQPad .  LINQPad gives you an interactive playground for testing your LINQ queries.  In this case, I\ncreated a new query with the following contents:  public class Message {\n   public string UserId;\n   public string Text;\n}\n\npublic class Friend {\n   public string UserId;\n   public string FollowerId;\n}\n\nvoid Main()\n{\n\n\nList<Friend> friends = new List<Friend>() {\n   new Friend() { UserId = \"adrian\", FollowerId = \"donna\" },\n   new Friend() { UserId = \"fabio\", FollowerId = \"donna\" },\n   new Friend() { UserId = \"fabio\", FollowerId = \"adrian\" }\n};\n\nList<Message> messages = new List<Message>() {\n   new Message() { UserId = \"adrian\", Text = \"message 1\" },\n   new Message() { UserId = \"donna\", Text = \"message 2\" },\n   new Message() { UserId = \"fabio\", Text = \"message 3\" }\n};\nvar user = \"fabio\";\n\nvar q = from m in messages\n        let fr = (from f in friends where f.FollowerId == user select f.UserId)\n        where m.UserId == user || fr.Contains(m.UserId)\n        select m;\n\nq.Dump();\n\n}  I have a friends table and a messages table.  User \"donna\" should be able to see three messages, user \"adrian\"\nshould be able to see two messages and user \"fabio\" should be able to see just one message.  By changing the\nvalue of the  user  variable, I can test the query I am writing.  I don't need to set up a database (although\nLINQPad supports that as well).",
            "title": "Using LINQPad to test LINQ Queries"
        },
        {
            "location": "/chapter3/projection/#best-practices",
            "text": "There are a number of best practices that I think are important in developing table controllers:   Optimize Operations   You should always optimize the CRUD operations that are implemented in a table controller.  This means limiting\n  the code so that only  filters ,  transforms  and  validators  are used.  You can use  hooks  as an\n  asynchronous way to handle custom code if something else needs to happen when a mobile client inserts, updates\n  or deletes a record.  (We will be delving into hooks during the custom code chapter later on).  You should  NOT  insert custom code into a table controller that runs synchronously.   Implement Security Policy with Filters   The mobile backend should be concerned with security.  What can the connecting user see?  Use  filters  to\n  ensure that the connecting user can only see the data that they are allowed to see.  There are several examples\n  of bad filters.  For example, if a user normally wants to see the last 7 days worth of messages, but is allowed\n  to see all messages.  I would implement this particular case as a client-side filter as it has nothing to do\n  with security.   Use LINQ Extension Methods   LINQ extension methods can be used to great effect to make your CRUD methods more readable.  I love readable\n  code.  For example, consider the following two code snippets from the last recipe:  public IQueryable<Message> GetAllMessage()\n{\n  // Recipe #1\n  return Query().OwnedByFriends(context.Friends, UserId);\n\n  // Recipe #2\n  return from m in Query()\n    let fr = (from f in context.Friends where f.FriendId == UserId select f.UserId)\n    where m.UserId == UserId || fr.Contains(m.UserId)\n    select m;\n}  The first recipe makes the intent of the filter very clear.  I have to work at understanding the specific implementation\n  of the second method.",
            "title": "Best Practices"
        },
        {
            "location": "/chapter3/client/",
            "text": "Handling Data in Mobile Clients\n\u00b6\n\n\nPretty much any non-trivial mobile client will require access to data.  Although we have already brushed on handling data within the client, this\nsection will go deeper into the data handling aspects on the client.  We will cover how to get and process data, how to deal with performance and\nreliability and some of the quirks that one must deal with when dealing with offline data.\n\n\nAn Online Client\n\u00b6\n\n\nWe've already seen an example of an online client in our online \nTaskList\n project.  There is a method for obtaining a reference to an online table:\n\n\nvar table = client.GetTable<Model>();\n\n\n\n\nThis method relies on the fact that the table name is the same as the model.  One must have a consistent naming scheme - the model on the server,\ntable controller on the server, model on the client and table on the client must all be based on the same root name.  This is definitely a best\npractice.  You can produce an un-typed table:\n\n\nvar table = client.GetTable(\"todoitem\");\n\n\n\n\nThis version of the method returns an untyped table.  Whereas a typed table is based on a concrete model, an untyped table is based on a JSON\nobject.  This allows one to access data when the model is unknown or hard to represent in a model.  You should never use an untyped table unless\nthere is no other way of achieving whatever operation you need.\n\n\nAll tables implement the \nIMobileServiceTable\n interface:\n\n\n\n\nReadAsync()\n performs reads against the table.\n\n\nLookupAsync()\n reads a single record in the table, identified by its id.\n\n\nInsertAsync()\n inserts a new record into the table.\n\n\nUpdateAsync()\n updates an existing record in the table.\n\n\nDeleteAsync()\n deletes a record in the table.\n\n\nUndeleteAsync()\n un-deletes a deleted record (if soft-delete is turned on).\n\n\n\n\nWhen developing my interface, I tend to wrap my table interface into another class.  This isn't because I like wrapping classes.  Rather it is\nbecause the return values from many of the methods are not compatible with the general patterns used when working with a UI.  For instance, the\nReadAsync() method returns an \nIEnumerable<>\n type.  However, the standard list management in Xamarin and UWP applications use an\n\nObservableCollection<>\n instead.  One has to do a conversion from one to the other.\n\n\nLet's look at a standard table wrapper:\n\n\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudTable<T> : ICloudTable<T> where T : TableData\n    {\n        IMobileServiceTable<T> table;\n\n        public AzureCloudTable(MobileServiceClient client)\n        {\n            this.table = client.GetTable<T>();\n        }\n\n        #region ICloudTable interface\n        public async Task<T> CreateItemAsync(T item)\n        {\n            await table.InsertAsync(item);\n            return item;\n        }\n\n        public async Task<T> UpsertItemAsync(T item)\n        {\n            return (item.Id == null) ?\n                await CreateItemAsync(item) :\n                await UpdateItemAsync(item);\n        }\n\n        public async Task DeleteItemAsync(T item)\n            => await table.DeleteAsync(item);\n\n        public async Task<ICollection<T>> ReadAllItemsAsync()\n            => await table.ToListAsync();\n\n        public async Task<T> ReadItemAsync(string id)\n            => await table.LookupAsync(id);\n\n        public async Task<T> UpdateItemAsync(T item)\n        {\n            await table.UpdateAsync(item);\n            return item;\n        }\n        #endregion\n    }\n}\n\n\n\n\nThis is the \nAzureCloudTable\n class that our task list has been using thus far.  It's actually got a few bugs in it.  Let's go\nover them.\n\n\nProbably the most egregious bug is that the \nReadAllItemsAsync()\n method does not handle paging.  If you have more than 50 items,\nthen the \nToListAsync()\n method will do a single GET operation and then return the results.  The Azure Mobile Apps Server SDK implements\nenforced paging.  This protects two things.  Firstly, the client cannot tie up the UI thread and cause a significant delay in the\nresponsiveness of the app.  More importantly, a rogue client cannot tie up the server for a long period thus helping with dealing\nwith denial of service attacks.  Paging is a good thing.\n\n\nTo test this:\n\n\n\n\nInsert over 50 records into the \nTodoItems\n table in your database using a SQL client.\n\n\nPut a break point at the \nItems.ReplaceRange(list);\n (line 78 approximately) in \nViewModels\\TaskListViewModel.cs\n.\n\n\nRun the UWP project.\n\n\n\n\n\n\nNote that even though there are more than 50 records, you will only see 50 records in the list.  There are multiple ways to fix\nthis and it depends on your final expectation.  In the class of \"probably not what we want\", we can keep on reading records until\nthere are no more records to read. This is the simplest to implement.  In the \nServices\\AzureCloudTable.cs\n file, replace the\n\nReadAllItemsAsync()\n method with the following:\n\n\npublic async Task<ICollection<T>> ReadAllItemsAsync()\n{\n    List<T> allItems = new List<T>();\n\n    var pageSize = 50;\n    var hasMore = true;\n    while (hasMore)\n    {\n        var pageOfItems = await table.Skip(allItems.Count).Take(pageSize).ToListAsync();\n        if (pageOfItems.Count > 0)\n        {\n            allItems.AddRange(pageOfItems);\n        }\n        else\n        {\n            hasMore = false;\n        }\n    }\n    return allItems;\n}\n\n\n\n\nThis code will always make a minimum of 2 requests if there is any data.  If you have 75 records, three requests will be made - the\nfirst will bring down 50 records, the second 25 records and the third no reocrds.  Why not stop at the second request?  We expect this\ncode to run on a live system.  The OData subsystem is allowed to return less than the requested value and it will do so for a variety\nof reasons.  For example, it may be configured with a maximum transfer size and the records won't fit into the transfer buffer.  The\nonly way of knowing for sure that you have received all the records is to do a request and be told there is no more.\n\n\nThis code could be simplified quite a bit.  The reason I am not doing so is that this is not how you would want to do the transfer\nof items in a real application.  Doing this will tie up the UI thread of your application for quite a while as the \nAzureCloudTable\n\ndownloads all the data.  Consider if there were thousands of entries?  This method would be problematic very quickly.\n\n\nThe alternative is to incrementally load the data as it is needed.  This means that your UI thread will pause as the data is loaded,\nbut the resulting UI will be less memory hungry and overall more responsive.  We start by adjusting our \nAbstractions\\ICloudTable.cs\n\nto add a method signature for returning paged data:\n\n\npublic interface ICloudTable<T> where T : TableData\n{\n    Task<T> CreateItemAsync(T item);\n    Task<T> ReadItemAsync(string id);\n    Task<T> UpdateItemAsync(T item);\n    Task<T> UpsertItemAsync(T item);\n    Task DeleteItemAsync(T item);\n    Task<ICollection<T>> ReadAllItemsAsync();\n    Task<ICollection<T>> ReadItemsAsync(int start, int count);\n}\n\n\n\n\nThe \nReadItemsAsync()\n method is our new method here.  The concrete implementation usese \n.Skip()\n and \n.Take()\n to return just the\ndata that is required:\n\n\npublic async Task<ICollection<T>> ReadItemsAsync(int start, int count)\n{\n    return await table.Skip(start).Take(count).ToListAsync();\n}\n\n\n\n\nNow that we have a method for paging through the contents of our table, we need to be able to wire that up to our \nListView\n.  Xamarin Forms\nhas a concept called \nBehaviors\n that lets us add functionality to user interface controls without having to completely re-write them or\nsub-class them.  We can use a behavior to implement a reusable paging control for a ListView.  Xamarin provides a sample for this called\n\nEventToCommandBehavior\n (along with an \nexplanation\n). We are going to be using the \nItemAppearing\n event and that event uses the\n\nItemVisibilityEventArgs\n as a parameter.  We need a converter for the EventToCommandBehavior class (in \nConverters\\ItemVisibilityConverter.cs\n):\n\n\nusing System;\nusing System.Globalization;\nusing Xamarin.Forms;\n\nnamespace TaskList.Converters\n{\n    public class ItemVisibilityConverter : IValueConverter\n    {\n        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n        {\n            var eventArgs = value as ItemVisibilityEventArgs;\n            return eventArgs.Item;\n        }\n\n        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n        {\n            throw new NotImplementedException();\n        }\n    }\n}\n\n\n\n\nThis is wired up with some XAML code in \nPages\\TaskList.xaml.cs\n.  There are two pieces.  Firstly, we must define the ItemVisibilityConverter\nthat we just wrote.  This is done at the top of the file:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage x:Class=\"TaskList.Pages.TaskList\"\n             xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             xmlns:behaviors=\"clr-namespace:TaskList.Behaviors;assembly=TaskList\"\n             xmlns:converters=\"clr-namespace:TaskList.Converters;assembly=TaskList\"\n             Title=\"{Binding Title}\">\n\n    <ContentPage.Resources>\n        <ResourceDictionary>\n            <converters:ItemVisibilityConverter x:Key=\"ItemVisibilityConverter\" />\n        </ResourceDictionary>\n    </ContentPage.Resources>\n\n\n\n\nNext, we must define the behavior for the ListView:\n\n\n<ListView CachingStrategy=\"RecycleElement\"\n            IsPullToRefreshEnabled=\"True\"\n            IsRefreshing=\"{Binding IsBusy,\n                                    Mode=OneWay}\"\n            ItemsSource=\"{Binding Items}\"\n            RefreshCommand=\"{Binding RefreshCommand}\"\n            RowHeight=\"50\"\n            SelectedItem=\"{Binding SelectedItem,\n                                    Mode=TwoWay}\">\n    <ListView.Behaviors>\n        <behaviors:EventToCommandBehavior Command=\"{Binding LoadMoreCommand}\"\n                                                Converter=\"{StaticResource ItemVisibilityConverter\"\n                                                EventName=\"ItemAppearing\" />\n    </ListView.Behaviors>\n\n\n\n\nFinally, we need to add a new command to our \nTaskListViewModel\n to load more items.  This involves\nfirstly defining the new command:\n\n\npublic TaskListViewModel()\n{\n    CloudTable = CloudService.GetTable<TodoItem>();\n\n    Title = \"Task List\";\n\n    RefreshCommand = new Command(async () => await Refresh());\n    AddNewItemCommand = new Command(async () => await AddNewItem());\n    LogoutCommand = new Command(async () => await Logout());\n    LoadMoreCommand = new Command<TodoItem> (async (TodoItem item) => await LoadMore(item));\n\n    // Subscribe to events from the Task Detail Page\n    MessagingCenter.Subscribe<TaskDetailViewModel>(this, \"ItemsChanged\", async (sender) =>\n    {\n        await Refresh();\n    });\n\n    // Execute the refresh command\n    RefreshCommand.Execute(null);\n}\n\npublic ICommand LoadMoreCommand { get; }\n\n\n\n\nWe also need to define the actual command code:\n\n\nbool hasMoreItems = true;\n\nasync Task LoadMore(TodoItem item)\n{\n    if (IsBusy)\n    {\n        Debug.WriteLine($\"LoadMore: bailing because IsBusy = true\");\n        return;\n    }\n\n    // If we are not displaying the last one in the list, then return.\n    if (!Items.Last().Id.Equals(item.Id))\n    {\n        Debug.WriteLine($\"LoadMore: bailing because this id is not the last id in the list\");\n        return;\n    }\n\n    // If we don't have more items, return\n    if (!hasMoreItems)\n    {\n        Debug.WriteLine($\"LoadMore: bailing because we don't have any more items\");\n        return;\n    }\n\n    IsBusy = true;\n    try\n    {\n        var list = await CloudTable.ReadItemsAsync(Items.Count, 20);\n        if (list.Count > 0)\n        {\n            Debug.WriteLine($\"LoadMore: got {list.Count} more items\");\n            Items.AddRange(list);\n        }\n        else\n        {\n            Debug.WriteLine($\"LoadMore: no more items: setting hasMoreItems= false\");\n            hasMoreItems = false;\n        }\n    }\n    catch (Exception ex)\n    {\n        await Application.Current.MainPage.DisplayAlert(\"LoadMore Failed\", ex.Message, \"OK\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}\n\n\n\n\nI've added a whole bunch of debug output because this command is called a lot, so I can scroll back through the\noutput window instead of setting a breakpoint and clicking Continue a lot.\n\n\nAs the UI displays each cell, it calls our command.  The command figures out if the record being displayed is the\nlast one in the list.  If it is, it asks for more records.  Once no more records are available, it sets the\nflag \nhasMoreItems\n to false so it can short-circuit the network request.\n\n\n\n\nTip\n\n\nBe careful when using \nOrderBy()\n with online data.  Earlier pages may change, causing duplicated data or\nmissed data in your result set.  There is little you can do about this other than pulling down all the data\nordered by the \nCreatedAt\n field (which is the default).\n\n\n\n\nFinally, our current implementation of the \nRefresh()\n method loads all the items.  We need to adjust it\nto only load the first page:\n\n\nasync Task Refresh()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var identity = await CloudService.GetIdentityAsync();\n        if (identity != null)\n        {\n            var name = identity.UserClaims.FirstOrDefault(c => c.Type.Equals(\"name\")).Value;\n            Title = $\"Tasks for {name}\";\n        }\n        var list = await CloudTable.ReadItemsAsync(0, 20);\n        Items.ReplaceRange(list);\n        hasMoreItems = true;\n    }\n    catch (Exception ex)\n    {\n        await Application.Current.MainPage.DisplayAlert(\"Items Not Loaded\", ex.Message, \"OK\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}\n\n\n\n\nWe've done two things here.\n\n\n\n\nWe have altered the first request so that only the first 20 records are retrieved.\n\n\nWe have set \nhasMoreItems\n to true so that the \nLoadMore()\n command will do network requests again.\n\n\n\n\nQuery Support in Online Clients\n\u00b6\n\n\nWhen using an online client, you can also use an OData query to look for records.  The following code\nsnippet, for example, will only return records that are incomplete:\n\n\nreturn await table\n    .Where(item => item.Complete == false)\n    .ToListAsync()\n\n\n\n\nThis is a standard LINQ query.  Just as the LINQ query was used to adjust the SQL that is generated in\nthe server-side code, the LINQ query here is used to adjust the OData query that is generated to call\nthe server.  This particular query will generate the follow HTTP call:\n\n\nGET /tables/todoitem?$filter=(complete+eq+false) HTTP/1.1\n\n\n\n\nLINQ queries are very useful in dealing with online data.  In general they should take a specific forms\n\n\ntable                           // start with the table reference\n    .Where(filter)              // filter the results\n    .Select(filter)             // Only return certain fields\n    .Skip(start).Take(count)    // paging support\n    .ToListAsync()              // convert to something we can use\n\n\n\n\nThis format allows you to be very specific about what you want to return from the server, thus allowing\nyou to balance the optimization of bandwidth with the responsiveness of the UI.\n\n\nAn Offline Client\n\u00b6\n\n\nAnother method of optimizing bandwidth utilization with an added benefit of providing a resilient data\nconnection is to use an offline sync database.   The Azure Mobile Apps Client SDK has a built-in offline\nmode that allows for the common requirements of bandwidth optimization, connection resliency, and\nperformance optimization.\n\n\n\n\nAn offline capable table uses \nIncremental Sync\n to only bring down new records from the server.\n\n\nConnection detection allows you to defer requests until after a connection is available.\n\n\nIn-built \nConflict Resolution\n provides a robust mechanism for handling changes while your client was offline.\n\n\nSince the data is always local, the UI will be much more responsive to changes.\n\n\n\n\nAll of this comes at a cost.  We need to maintain an offline sync database for the tables you wish\nto provide offline, which takes up memory.  It may result in large data transfers (especially in the\ncases of the first sync operation and rapidly changing tables).  Finally, there is more complexity.  We\nhave to deal with the offline table maintenance and conflict resolution patterns.\n\n\n\n\nAzure Mobile Apps v3.0\n\n\nAzure Mobile Apps introduced a breaking change in how SQLite was used in v3.0 of the Client SDK.  The\nbreaking change ensured support for Android Nougat.  This book covers the v3.0 release of Azure Mobile\nApps.\n\n\n\n\nThere are three stages to using an offline client:\n\n\n\n\nInitialize the local SQLite database before use.\n\n\nSet up push / pull logic to maintain the contents of the SQLite database.\n\n\nConfigure appropriate conflict resolution.\n\n\n\n\nThe actual code for your mobile client that deals with tables remains identical to the online case.\n\n\nTo effect the offline sync, the Azure Mobile Apps client SDK keeps a table in the local SQLite database called\nthe \nOperations Queue\n.  An entry is placed in the operations queue whenever a modification is done to a sync\ntable.  These modifications are collapsed.  Later modifications to the same record in a sync table will be collapsed\ninto a single update when transmitted to the mobile backend.\n\n\nConfiguring the Local SQLite database\n\u00b6\n\n\nWe must initialize the local database before we can use it.  This happens on start up and the Azure Mobile\nApps SDK knows enough of the models to understand the basics of maintaining the database.  Initializing the\ndatabase is deceptively simple.  Install the \nMirosoft.Azure.Mobile.Client.SQLiteStore\n package to all the\nclient projects.\n\n\n\n\nTip\n\n\nThe \nMicrosoft.Azure.Mobile.Client\n package v3.0.2 drastically improved the startup experience for\noffline sync. Make sure you are using it.  If you are using an earlier version, additional steps are\nrequired for initializing your offline cache.\n\n\n\n\nIn the \nServices\\AzureCloudService.cs\n file, add the following method:\n\n\n    #region Offline Sync Initialization\n    async Task InitializeAsync()\n    {\n        // Short circuit - local database is already initialized\n        if (Client.SyncContext.IsInitialized)\n            return;\n\n        // Create a reference to the local sqlite store\n        var store = new MobileServiceSQLiteStore(\"offlinecache.db\");\n\n        // Define the database schema\n        store.DefineTable<TodoItem>();\n\n        // Actually create the store and update the schema\n        await Client.SyncContext.InitializeAsync(store);\n    }\n    #endregion\n\n\n\n\n\n\nTip\n\n\nThe \nMicrosoft.Azure.Mobile.Client\n package does not support Android API versions earlier than API 19.\nTo set this, right-click on the \nTaskList.Droid\n project and ensure the \nMinimum Android version to target\n\nis set to a minimum of API level 19.\n\n\n\n\nWe need to ensure the initialization is carried out before we use the local database. The best place to do this is\nin the \nGetTable<>\n method:\n\n\n    /// <summary>\n    /// Returns a link to the specific table.\n    /// </summary>\n    /// <typeparam name=\"T\">The model</typeparam>\n    /// <returns>The table reference</returns>\n    public async Task<ICloudTable<T>> GetTableAsync<T>() where T : TableData\n    {\n        await InitializeAsync();\n        return new AzureCloudTable<T>(Client);\n    }\n\n\n\n\nNote that we made the routine async during this process.  Adjust the \nICloudService\n interface and the calls to\n\nGetTable<>\n in the rest of the code to compensate for this.\n\n\nUpdating the Sync tables\n\u00b6\n\n\nWe also need to add some routines to our \nICloudTable<>\n and \nAzureCloudTable<>\n classes to effect a synchronization.\nThe first method is added to the  \nICloudTable<>\n interface and pulls data from the mobile backend:\n\n\n    public interface ICloudTable<T> where T : TableData\n    {\n        Task<T> CreateItemAsync(T item);\n        Task<T> ReadItemAsync(string id);\n        Task<T> UpdateItemAsync(T item);\n        Task<T> UpsertItemAsync(T item);\n        Task DeleteItemAsync(T item);\n        Task<ICollection<T>> ReadAllItemsAsync();\n        Task<ICollection<T>> ReadItemsAsync(int start, int count);\n        Task PullAsync();\n    }\n\n\n\n\nThe new method is \nPullAsync()\n which will do the \"pull data from the server\" operation.  The \nAzureCloudTable<>\n\nclass has the concrete implementation:\n\n\n        IMobileServiceSyncTable<T> table;\n\n        public AzureCloudTable(MobileServiceClient client)\n        {\n            table = client.GetSyncTable<T>();\n        }\n\n        public async Task PullAsync()\n        {\n            string queryName = $\"incsync_{typeof(T).Name}\";\n            await table.PullAsync(queryName, table.CreateQuery());\n        }\n\n\n\n\nNote that we have changed the call to get the table reference.  It's now a \nSyncTable\n.  You can test to see if the\nsync table has been defined with the following:\n\n\nif (client.IsSyncTable(typeof(T).Name)) {\n    // There is a sync table defined\n}\n\n\n\n\nThis can be used to have a single \nAzureCloudTable\n implementation for both the online and offline capabilities.  The\nconcrete implementation of the \nPullAsync()\n method implements incremental sync.  If we set the queryName to \nnull\n,\nthen the entire table is pulled across each time.  By setting a queryName, the last updated time for the table is stored\nand associated with the queryName.  The last updated time is used to request only records that have changed since the\nlast updated time when doing the pull from the backend.\n\n\nThe push of the operations queue up to the mobile backend is handled by a single call in the \nAzureCloudService\n class:\n\n\n    public async Task SyncOfflineCacheAsync()\n    {\n        await InitializeAsync();\n\n        // Push the Operations Queue to the mobile backend\n        await Client.SyncContext.PushAsync();\n\n        // Pull each sync table\n        var taskTable = await GetTableAsync<TodoItem>(); await taskTable.PullAsync();\n    }\n\n\n\n\nnote that if the mobile client tries to pull data while there are pending operations in the operations quuee, the Azure\nMobile Apps client SDK will perform an implicit push.  You can check the state of the operations queue with:\n\n\nif (Client.SyncContext.PendingOperations > 0) {\n    // There are pending operations\n}\n\nThe only thing left to do now is to decide when to synchronize the local database on the mobile device.  In this example,\nI am going to synchronize the database during the refresh command of the `TaskListViewModel` and on saving or deleting\nan item in the `TaskDetailViewModel`.  Each synchronization will be called with the following:\n\n```csharp\nawait CloudService.SyncOfflineCacheAsync();\n\n\n\n\n\n\nInfo\n\n\nThe offline sync cache automatically handles paging of results during the transfer for you so you never have to worry\nabout it.\n\n\n\n\nAdditional Steps on Universal Windows\n\u00b6\n\n\nIf you are compiling the Universal Windows (UWP) project, there is an extra step.  You must Add a reference for SQLite\nto the project.  Open the \nTaskList.UWP\n project, then right-click on the \nReferences\n node and select \nAdd Reference\n.\nSelect \nUniversal Windows\n -> \nExtensions\n and place a check mark next to the \nSQLite for Universal Windows\n and\n\nVisual C++ 2015 Runtime for Universal Windows\n components.\n\n\n\n\nIf you don't do this, you will get the rather cryptic error message \"Unable to set temporary directory\" when running the\napplication.\n\n\nDetecting Connection State\n\u00b6\n\n\nXamarin has a rather cool plugin called the Connectivity Plugin for testing connectivity state.  We can install it by\ninstalling the \nXam.Plugin.Connectivity\n NuGet package.  Once that is installed, we can update our \nSyncOfflineCacheAsync()\n\nmethod to use it:\n\n\n    public async Task SyncOfflineCacheAsync()\n    {\n        await InitializeAsync();\n\n        if (!(await CrossConnectivity.Current.IsRemoteReachable(Client.MobileAppUri.Host, 443)))\n        {\n            Debug.WriteLine($\"Cannot connect to {Client.MobileAppUri} right now - offline\");\n            return;\n        }\n\n        // Push the Operations Queue to the mobile backend\n        await Client.SyncContext.PushAsync();\n\n        // Pull each sync table\n        var taskTable = await GetTableAsync<TodoItem>(); await taskTable.PullAsync();\n    }\n\n\n\n\nThe Connectivity Plugin (which is accessible through \nCrossConnectivity.Current\n) has other parameters that allow the mobile\nclient to test for specific types of connectivity.  For example, let's say you only wanted to pull one of the tables over\nwifi.  You could do this as follows:\n\n\nvar connections = CrossConnectivity.Current.ConnectionTypes;\nif (connections.Contains(ConnectionType.Wifi)) {\n    var largeTable = await GetTableAsync<LargeModel>();\n    largeTable.PullAsync();\n}\n\n\n\n\nThe Connectivity plugin when paired with the Azure Mobile Apps Client SDK gives you a lot of flexibility in deciding what to\nsync and over what type of connection you should sync.\n\n\nHandling Conflict Resolution\n\u00b6\n\n\nWhen the mobile client submits a modification to the mobile backend, it's generally done as a two-step process:\n\n\n\n\nA \"pre-condition check\" is done, comparing the Version to the ETag of the record (which is derived from the Version of the record).\n\n\nThe actual request is done, where the Version of the mobile client is compared to the Version of the record on the mobile backend.\n\n\n\n\nIf the version of the record being submitted is different from the version on the server, the test will fail.  In the case of the first\ncheck, a \n412 Precondition Failed\n will be returned for the modification.  If the second test fails, a \n409 Conflict\n response is\nreturned.  Normally, you will see the \n412 Precondition Failed\n response, but you should be prepared for either response.\n\n\nBoth responses indicate a conflict that needs to be resolved before continuing.  Programatically, when doing a modification in\nan online table (such as an Insert, Update, Delete), you should be capture the \nMobileServicePreconditionFailedException<>\n Exception\nto handle the conflict.  In an offline sync table, you should capture the \nMobileServicePushFailedException\n during the\n\nPushAsync()\n operation.  This will potentially have an array of conflicts for you to deal with.\n\n\nFor the online case, the code would look like this:\n\n\ntry\n{\n    await CloudService.InsertAsync(item);\n}\ncatch (MobileServicePreconditionFailedException<TodoItem> ex)\n{\n    await ResolveConflictAsync(item, ex.Item);\n}\n\n\n\n\nFor the offline case, the code would look like this:\n\n\ntry\n{\n    await CloudService.PushAsync();\n}\ncatch (MobileServicePushFailedException ex)\n{\n    if (ex.PushResult != null)\n    {\n        foreach (var error in ex.PushResult.Errors)\n        {\n            await ResolveConflictAsync(error);\n        }\n    }\n}\n\n\n\n\nIn both cases, the \nResolveConflictAsync()\n method is called for each conflict in turn.  Resolving the conflict involves\ndeciding between the two options or making corrections to the item.\n\n\n\n\nIf you wish to keep the client copy, set the client Version property to the server Version value and re-submit.\n\n\nIf you wish to keep the server copy, discard the update.\n\n\nIf you wish to do something else, create a new copy of the record, set the Version to be the same as the server Version, then re-submit.\n\n\n\n\n\n\nInfo\n\n\nIf the model on your mobile client does not have a Version field, the policy is \"last write wins\".\n\n\n\n\nThe online case is relatively simple as you are going to be ignoring the old request and creating a new request.  Here is\nsome template code that implements both client-wins and server-wins strategies for the offline case:\n\n\nsync Task ResolveConflictAsync(MobileServiceTableOperationError error)\n{\n    var serverItem = error.Result.ToObject<T>();\n    var localItem = error.Item.ToObject<T>();\n\n    // Note that you need to implement the public override Equals(TodoItem item)\n    // method in the Model for this to work\n    if (serverItem.Equals(localItem))\n    {\n        // Items are the same, so ignore the conflict\n        await error.CancelAndDiscardItemAsync();\n        return;\n    }\n\n    // Client Always Wins\n    localItem.Version = serverItem.Version;\n    await error.UpdateOperationAsync(JObject.FromObject(localItem));\n\n    // Server Always Wins\n    // await error.CancelAndDiscardItemAsync();\n}\n\n\n\n\nYou could also ask the user as an option.  Finally, you could do some processing.  For example, let's say that you wanted\nto keep the local version of the Text, but keep the server version of Complete:\n\n\nlocalItem.Complete = serverItem.Complete;\nlocalItem.Version = serverItem.Version;\nawait error.UpdateOperationAsync(JObject.FromObject(serverItem));\n\n\n\n\nThere are many ways to resolve a conflict.  You should consider your requirements carefully.  Asking the user should\nalways be the last resort for conflict resolution.  In the majority of applications, most users will click the\n\"keep my version\" button to resolve conflicts, so the UI for resolving conflicts should do more than just ask the\nuser to decide between a server and a client version.\n\n\nQuery Management\n\u00b6\n\n\nRecord selection is based on two factors:\n\n\n\n\nSecurity policy is enforced at the server.\n\n\nUser preference is enabled at the client.\n\n\n\n\nWe've already discussed security policy in depth in \nthe last section\n.  We've also discussed\nuser queries for online usage.  We just use LINQ to affect a change in the query sent to the server.  However,\nwhat about offline cases? There are situations where you want to keep a smaller subset of the data that you are\nallowed to see for offline usage.  A common request, for example, is to have the last X days of records available\noffline.\n\n\nIn our \nPullAsync()\n call for the table, we use \ntable.CreateQuery()\n to create a query that is designed to get\nall the records available to the user from the server.  This is not always appropriate and can be adjusted.  Let's\nadjust it to only obtain the records for our TodoItem table where either of the following conditions apply:\n\n\n\n\nThe record has been updated within the last day.\n\n\nThe task is incomplete.\n\n\n\n\nOnce the task is marked completed, it will remain in the cache for 1 day, then be removed automatically.  You can\nstill obtain the task while online.  The \ntable.CreateQuery()\n method produces an \nIMobileServiceTableQuery<>\n\nobject.  This can be dealt with via LINQ:\n\n\nvar queryName = $\"incsync:r:{typeof(T).Name}\";\nvar query = table.CreateQuery()\n    .Where(r => !r.Complete || r.UpdatedAt < DateTimeOffset.Now.AddDays(-1));\nawait table.PullAsync(queryName, query);\n\n\n\n\nNote that I am using a different query name in this case.  The maximum value of UpdatedAt for the records is stored\nand associated with the query name.  If the same query name is used, then only the records updated since the stored\ndate will be retrieved.  If you change the query, then change the query name.\n\n\nAnother common request is to restrict the properties that are in the local cache.  For instance, maybe you have\na particularly large text blob that you want to make available online, but not offline:\n\n\nvar queryName = $\"incsync:s:{typeof(T).Name}\";\nvar query = table.CreateQuery()\n    .Select(r => new { r.Text, r.Complete, r.UpdatedAt, r.Version });\nawait table.PullAsync(queryName, query);\n\n\n\n\nYou can also use the Fluent syntax:\n\n\nvar query =\n    from r in table.CreateQuery()\n    select new { r.Text, r.Complete, r.UpdatedAt, r.Version };\n\n\n\n\nYou should always construct the object including the \nUpdatedAt\n and \nVersion\n properties.  \nUpdatedAt\n is used\nfor incremental sync and \nVersion\n is used for conflict resolution.\n\n\nBoth of these cases use standard LINQ syntax to adjust the query being sent to the mobile backend in exactly the\nsame way that we adjusted the query when we were doing online searches.  An offline \"pull\" is exactly the same\nas an online \"query\".\n\n\n\n\nTip\n\n\nThere are times when you want to download two different queries.  Avoid this if at all possible as it will\ncause additional requests to the backend that are un-necessary.  Construct your query such that all records\nthat you want to download to the offline cache are requested at once.\n\n\n\n\nDealing with Historical Data\n\u00b6\n\n\nLet's continue our example with a small extension.  Let's say you want to have the last 7 days worth of records\navailable offline, but you still want the ability to do a historical search.  In this case, you can create two\ntable references to the same table - one online for historical searches and one offline for the normal use case:\n\n\nvar table = client.GetSyncTable<Message>();\nvar historicalTable = client.GetTable<Message>();\n\n\n\n\nIn this case, the \ntable\n reference is used to access the offline data.   However, you could implement a search\ncapability that does a query against the \nhistoricalTable\n instead.  They both point to the same table.  In one\ncase, the server is referenced (and only available online) and in the other, the local cache is referenced\n(and available offline).\n\n\nPurging the Local Cache\n\u00b6\n\n\nIt will be inevitable that you will want to clear the local cache at some point.\n\n\n\n\nYou have just changed the model and underlying data and need to re-establish a baseline.\n\n\nYou only cache newer data and want to remove historical data.\n\n\nThings got corrupt for some reason and you need to refresh everything.\n\n\n\n\nWhatever the reason, clearing the cache is one of those infrequent things that is going to be a necessity.  There\nare three forms of this operation:\n\n\nDeleting the backing store\n\u00b6\n\n\nThe major requirement during development is that you want to delete the SQLite file that backs the offline cache.\nIt's likely that the model evolves over time during development.  Add test data that can sometimes cause things\nto go wrong and you have a recipe for bugs that are only there because you are developing.  If you suspect bad\ndata in the offline cache, the first thing you want to do is start afresh.\n\n\nEach platform stores the offline cache in a different place and the mechanism for removing it is different in each\ncase.  For Universal Windows projects, the offline cache is stored in the Local AppData folder for the application.\nThis is a dedicated area that each Universal Windows app has access to for anything from temporary files to settings\nand cache files.  To find the location of the file, open the \nTaskList.UWP\n project and open the \nPackage.appxmanifest\n\nfile.  Go to the \nPackaging\n tab.\n\n\n\n\nNote the long \nPackage family name\n field.  Your backing file is in your home directory under \nAppData\\Local\\Packages\\{family_name}\\LocalState\n.\nYou specified the name of the file when you created the store.\n\n\nYou need to find the \nPackage Name\n for Android.  Right-click on the \nTaskList.Droid\n project and select \nProperties\n,\nthen select the \nAndroid Manifest\n tab.\n\n\n\n\nThe database will be located in \n/data/data/{package_name}/files\n directory on the emulator.  Google has provided utilities\nfor handling developer connections to devices (including emulators).  In this case, we can use the \nadb\n utility.  First, start\nyour emulator of choice through the \nTools\n -> \nVisual Studio Emulator for Android\n menu option.  Click on the \nPlay\n\nbutton next to the emulator that you have been using.  Ensure the emulator is fully started before continuing.  The \nadb\n utility\ncan be accessed through a shell prompt (I use PowerShell normally) and it is located in \n$ANDROID_SDK/platform-tools\n.  On Windows,\nthis is probably \nC:\\Program Files (x86)\\Android\\android-sdk\\platform-tools\n.  It's a good idea to add this to your PATH.\n\n\nStart at your Visual Studio Emulator for Android.  Click on the \nTools\n button (it looks like a pair of right-facing\nchevrons) and select the \nNetwork\n tab.\n\n\n\n\nYou want the network address of the \nWindows Phone Emulator Internal Switch\n.  In this case, it's 169.254.138.177.  The\n169.254 address range is a private switch between the host computer (the one you are developing on) and the emulators.\nOpen up a shell prompt and type:\n\n\nadb connect 169.254.138.177:5555\nadb shell\n\n\n\n\n\n\nTip\n\n\nIf you are only running one emulator and have no connected real devices, you don't need the \nadb connect\n command.  Visual\nStudio will have already set up the connection for you.  Use \nadb devices\n to determine if you need to connect.\n\n\n\n\nThis opens up a Linux-like shell onto the Android device.  You can use normal Linux commands to move around.   You can remove\nthe entire private data area for your package using the following:\n\n\n**root@donatello:/#** cd /data/data/Tasklist.Droid.TaskList.Droid\n**root@donatollo:/#** find . -name tasklist.db -print | xargs rm\n\n\n\n\nThe database will normally be in the \nfiles\n directory.  Use \nexit\n to close the shell prompt on the Android device.  Each disk\nimage file is independent.  You must remove the database file on each emulator individually.\n\n\n\n\nTip\n\n\nYou can use the same \nadb\n commands to connect to a real Android device connected via USB.  Ensure \nUSB Debugging\n is\nenabled on the device.  Use \nadb devices\n to find the device.  For more information, see \nthe Android documentation\n.\n\n\n\n\nThe iOS Simulator does not use an image files.  Instead, it stores files on your Mac disk in \n~/Library/Developer/CoreSimulator/Devices\n.\nThere is a file called \ndevice_set.plist\n that contains the list of devices that are defined and their location.  It is most easy to find\na specific device.  For example, if you are testing on the iPhone 6x simulator:\n\n\n$ grep -B 1 'iPhone-6s<' device_set.plist\n<string>A3536AA4-0678-43CC-BA21-DD997B89778A</string>\n<key>com.apple.CoreSimulator.SimDeviceType.iPhone-6s</key>\n--\n<string>83D08BC0-2F9A-4479-ABBD-A69858819E93</string>\n<key>com.apple.CoreSimulator.SimDeviceType.iPhone-6s</key>\n--\n<string>ECAE441D-93F8-4D7A-BF14-7FA2D11BC152</string>\n<key>com.apple.CoreSimulator.SimDeviceType.iPhone-6s</key>\n\n\n\n\nEach one of these corresponds to a different OS version.  You can find the ordering like this:\n\n\n$ grep SimRuntime.iOS device_set.plist\n<key>com.apple.CoreSimulator.SimRuntime.iOS-9-1</key>\n<key>com.apple.CoreSimulator.SimRuntime.iOS-9-2</key>\n<key>com.apple.CoreSimulator.SimRuntime.iOS-9-3</key>\n\n\n\n\nMy simulator is an iPhone 6s running iOS 9.3, so I can see the GUID is the third one: \nECAE441D-93F8-4D7A-BF14-7FA2D11BC152\n.  This\nGUID is a directory in the same directory as the \ndevice_set.plist\n file.  You can use normal UNIX style commands to\nremove the backing store:\n\n\n$ cd ECAE441D-93F8-4D7A-BF14-7FA2D11BC152\n$ find . -name 'tasklist.db' -print | xargs rm\n\n\n\n\nYou can also use the normal Finder utilities to search for and remove the database file for your app.\n\n\nPurging Records from the Offline Cache\n\u00b6\n\n\nThe \nIMobileServiceSyncTable\n interface also includes a capability for purging records that are stored in the offline sync by query.  This\nis done in code like this:\n\n\nvar lowerBound = DateTimeOffset.Now.AddDays(-7);\nvar query = syncTable.CreateQuery().Where(item => item.UpdatedAt < lowerBound);\nvar force = true;\nawait syncTable.PurgeAsync(\"incsync_Tag\", query, force);\n\n\n\n\nThere are four parameters for the \nPurgeAsync\n call:\n\n\n\n\nA query name.\n\n\nAn OData query.\n\n\nA boolean for forcing the operation.\n\n\nA cancellation token (for the async operation).\n\n\n\n\nEach incremental sync query has a unique name that is specified during the \nPullAsync()\n method call.  If you use the same name during the\n\nPurgeAsync()\n call, then the date associated with the incremental sync query is reset, causing a full refresh of the data.  This allows\nyou to do a \"purge and refresh\" operation.  If you don't want this to happen, set the query name to null.\n\n\nThe OData query is a similar query format to the incremental sync query that we used with \nPullAsync()\n.  In this case, it selects the\nrecords that should be purged from the offline sync cache.  If we wished to purge everything, we could just use \nsyncTable.CreateQuery()\n.\nIf we want to purge only certain records, then we can adjust the query with a \n.Where()\n LINQ query.  In the example above, records that\nhave not been updated within the last 7 days are purged.\n\n\nFinally, the \nPurgeAsync()\n call will fail (and generate an exception) if there are any operations pending in the operations queue.  If we\nspecify \nforce = true\n, then the operations queue check is bypassed and pending operations in the operations queue are flushed without being\nuploaded.  It is important that this option is used only when absolutely required.  You can leave your database in an inconsistent\nstate if you expect referential integrity between different tables.  Use \nSyncContext.PushAsync()\n to push the operations queue\nto the remote server before calling \nPurgeAsync()\n.   If you use \nforce = true\n, then also specify a query name to reset the incremental\nsync state.\n\n\nDebugging the Offline Cache\n\u00b6\n\n\nOne of the most difficult parts of the offline cache is that it is opaque - you can't really see what is going on.  Fortunately, the\n\nSQLiteStore\n that is used is relatively straight forward to sub-class so we can add logging to it.  The following helper method can\nbe substituted for a \nSQLiteStore\n in any code.\n\n\npublic class MobileServiceSQLiteStoreWithLogging : MobileServiceSQLiteStore\n{\n    private bool logResults;\n    private bool logParameters;\n\n    public MobileServiceSQLiteStoreWithLogging(string fileName, bool logResults = false, bool logParameters = false)\n        : base(fileName)\n    {\n        this.logResults = logResults;\n        this.logParameters = logParameters;\n    }\n\n    protected override IList<Newtonsoft.Json.Linq.JObject> ExecuteQuery(string tableName, string sql, IDictionary<string, object> parameters)\n    {\n        Console.WriteLine (sql);\n\n        if(logParameters)\n            PrintDictionary (parameters);\n\n        var result = base.ExecuteQuery(tableName, sql, parameters);\n\n        if (logResults && result != null)\n        {\n            foreach (var token in result)\n                Console.WriteLine (token);\n        }\n\n        return result;\n    }\n\n    protected override void ExecuteNonQuery(string sql, IDictionary<string, object> parameters)\n    {\n        Console.WriteLine (sql);\n\n        if(logParameters)\n            PrintDictionary (parameters);\n\n        base.ExecuteNonQuery(sql, parameters);\n    }\n\n    private void PrintDictionary(IDictionary<string,object> dictionary)\n    {\n        if (dictionary == null)\n            return;\n\n        foreach (var pair in dictionary)\n            Console.WriteLine (\"{0}:{1}\", pair.Key, pair.Value);\n    }\n}\n\npublic class LoggingHandler : DelegatingHandler\n{\n    private bool logRequestResponseBody;\n\n    public LoggingHandler(bool logRequestResponseBody = false)\n    {\n        this.logRequestResponseBody = logRequestResponseBody;\n    }\n\n    protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, System.Threading.CancellationToken cancellationToken)\n    {\n        Console.WriteLine(\"Request: {0} {1}\", request.Method, request.RequestUri.ToString());\n\n        if (logRequestResponseBody && request.Content != null)\n        {\n            var requestContent = await request.Content.ReadAsStringAsync ();\n            Console.WriteLine (requestContent);\n        }\n\n        var response = await base.SendAsync(request, cancellationToken);\n\n        Console.WriteLine (\"Response: {0}\", response.StatusCode);\n\n        if (logRequestResponseBody)\n        {\n            var responseContent = await response.Content.ReadAsStringAsync ();\n            Console.WriteLine (responseContent);\n        }\n\n        return response;\n    }\n}\n\n\n\n\nUsing this class will print all the SQL commands that are executed against the SQLite store.  Ensure you are capturing the console somewhere\nso that you can see the debug messages as you are running your application.",
            "title": "The Mobile Client"
        },
        {
            "location": "/chapter3/client/#handling-data-in-mobile-clients",
            "text": "Pretty much any non-trivial mobile client will require access to data.  Although we have already brushed on handling data within the client, this\nsection will go deeper into the data handling aspects on the client.  We will cover how to get and process data, how to deal with performance and\nreliability and some of the quirks that one must deal with when dealing with offline data.",
            "title": "Handling Data in Mobile Clients"
        },
        {
            "location": "/chapter3/client/#an-online-client",
            "text": "We've already seen an example of an online client in our online  TaskList  project.  There is a method for obtaining a reference to an online table:  var table = client.GetTable<Model>();  This method relies on the fact that the table name is the same as the model.  One must have a consistent naming scheme - the model on the server,\ntable controller on the server, model on the client and table on the client must all be based on the same root name.  This is definitely a best\npractice.  You can produce an un-typed table:  var table = client.GetTable(\"todoitem\");  This version of the method returns an untyped table.  Whereas a typed table is based on a concrete model, an untyped table is based on a JSON\nobject.  This allows one to access data when the model is unknown or hard to represent in a model.  You should never use an untyped table unless\nthere is no other way of achieving whatever operation you need.  All tables implement the  IMobileServiceTable  interface:   ReadAsync()  performs reads against the table.  LookupAsync()  reads a single record in the table, identified by its id.  InsertAsync()  inserts a new record into the table.  UpdateAsync()  updates an existing record in the table.  DeleteAsync()  deletes a record in the table.  UndeleteAsync()  un-deletes a deleted record (if soft-delete is turned on).   When developing my interface, I tend to wrap my table interface into another class.  This isn't because I like wrapping classes.  Rather it is\nbecause the return values from many of the methods are not compatible with the general patterns used when working with a UI.  For instance, the\nReadAsync() method returns an  IEnumerable<>  type.  However, the standard list management in Xamarin and UWP applications use an ObservableCollection<>  instead.  One has to do a conversion from one to the other.  Let's look at a standard table wrapper:  using System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudTable<T> : ICloudTable<T> where T : TableData\n    {\n        IMobileServiceTable<T> table;\n\n        public AzureCloudTable(MobileServiceClient client)\n        {\n            this.table = client.GetTable<T>();\n        }\n\n        #region ICloudTable interface\n        public async Task<T> CreateItemAsync(T item)\n        {\n            await table.InsertAsync(item);\n            return item;\n        }\n\n        public async Task<T> UpsertItemAsync(T item)\n        {\n            return (item.Id == null) ?\n                await CreateItemAsync(item) :\n                await UpdateItemAsync(item);\n        }\n\n        public async Task DeleteItemAsync(T item)\n            => await table.DeleteAsync(item);\n\n        public async Task<ICollection<T>> ReadAllItemsAsync()\n            => await table.ToListAsync();\n\n        public async Task<T> ReadItemAsync(string id)\n            => await table.LookupAsync(id);\n\n        public async Task<T> UpdateItemAsync(T item)\n        {\n            await table.UpdateAsync(item);\n            return item;\n        }\n        #endregion\n    }\n}  This is the  AzureCloudTable  class that our task list has been using thus far.  It's actually got a few bugs in it.  Let's go\nover them.  Probably the most egregious bug is that the  ReadAllItemsAsync()  method does not handle paging.  If you have more than 50 items,\nthen the  ToListAsync()  method will do a single GET operation and then return the results.  The Azure Mobile Apps Server SDK implements\nenforced paging.  This protects two things.  Firstly, the client cannot tie up the UI thread and cause a significant delay in the\nresponsiveness of the app.  More importantly, a rogue client cannot tie up the server for a long period thus helping with dealing\nwith denial of service attacks.  Paging is a good thing.  To test this:   Insert over 50 records into the  TodoItems  table in your database using a SQL client.  Put a break point at the  Items.ReplaceRange(list);  (line 78 approximately) in  ViewModels\\TaskListViewModel.cs .  Run the UWP project.    Note that even though there are more than 50 records, you will only see 50 records in the list.  There are multiple ways to fix\nthis and it depends on your final expectation.  In the class of \"probably not what we want\", we can keep on reading records until\nthere are no more records to read. This is the simplest to implement.  In the  Services\\AzureCloudTable.cs  file, replace the ReadAllItemsAsync()  method with the following:  public async Task<ICollection<T>> ReadAllItemsAsync()\n{\n    List<T> allItems = new List<T>();\n\n    var pageSize = 50;\n    var hasMore = true;\n    while (hasMore)\n    {\n        var pageOfItems = await table.Skip(allItems.Count).Take(pageSize).ToListAsync();\n        if (pageOfItems.Count > 0)\n        {\n            allItems.AddRange(pageOfItems);\n        }\n        else\n        {\n            hasMore = false;\n        }\n    }\n    return allItems;\n}  This code will always make a minimum of 2 requests if there is any data.  If you have 75 records, three requests will be made - the\nfirst will bring down 50 records, the second 25 records and the third no reocrds.  Why not stop at the second request?  We expect this\ncode to run on a live system.  The OData subsystem is allowed to return less than the requested value and it will do so for a variety\nof reasons.  For example, it may be configured with a maximum transfer size and the records won't fit into the transfer buffer.  The\nonly way of knowing for sure that you have received all the records is to do a request and be told there is no more.  This code could be simplified quite a bit.  The reason I am not doing so is that this is not how you would want to do the transfer\nof items in a real application.  Doing this will tie up the UI thread of your application for quite a while as the  AzureCloudTable \ndownloads all the data.  Consider if there were thousands of entries?  This method would be problematic very quickly.  The alternative is to incrementally load the data as it is needed.  This means that your UI thread will pause as the data is loaded,\nbut the resulting UI will be less memory hungry and overall more responsive.  We start by adjusting our  Abstractions\\ICloudTable.cs \nto add a method signature for returning paged data:  public interface ICloudTable<T> where T : TableData\n{\n    Task<T> CreateItemAsync(T item);\n    Task<T> ReadItemAsync(string id);\n    Task<T> UpdateItemAsync(T item);\n    Task<T> UpsertItemAsync(T item);\n    Task DeleteItemAsync(T item);\n    Task<ICollection<T>> ReadAllItemsAsync();\n    Task<ICollection<T>> ReadItemsAsync(int start, int count);\n}  The  ReadItemsAsync()  method is our new method here.  The concrete implementation usese  .Skip()  and  .Take()  to return just the\ndata that is required:  public async Task<ICollection<T>> ReadItemsAsync(int start, int count)\n{\n    return await table.Skip(start).Take(count).ToListAsync();\n}  Now that we have a method for paging through the contents of our table, we need to be able to wire that up to our  ListView .  Xamarin Forms\nhas a concept called  Behaviors  that lets us add functionality to user interface controls without having to completely re-write them or\nsub-class them.  We can use a behavior to implement a reusable paging control for a ListView.  Xamarin provides a sample for this called EventToCommandBehavior  (along with an  explanation ). We are going to be using the  ItemAppearing  event and that event uses the ItemVisibilityEventArgs  as a parameter.  We need a converter for the EventToCommandBehavior class (in  Converters\\ItemVisibilityConverter.cs ):  using System;\nusing System.Globalization;\nusing Xamarin.Forms;\n\nnamespace TaskList.Converters\n{\n    public class ItemVisibilityConverter : IValueConverter\n    {\n        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n        {\n            var eventArgs = value as ItemVisibilityEventArgs;\n            return eventArgs.Item;\n        }\n\n        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n        {\n            throw new NotImplementedException();\n        }\n    }\n}  This is wired up with some XAML code in  Pages\\TaskList.xaml.cs .  There are two pieces.  Firstly, we must define the ItemVisibilityConverter\nthat we just wrote.  This is done at the top of the file:  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage x:Class=\"TaskList.Pages.TaskList\"\n             xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             xmlns:behaviors=\"clr-namespace:TaskList.Behaviors;assembly=TaskList\"\n             xmlns:converters=\"clr-namespace:TaskList.Converters;assembly=TaskList\"\n             Title=\"{Binding Title}\">\n\n    <ContentPage.Resources>\n        <ResourceDictionary>\n            <converters:ItemVisibilityConverter x:Key=\"ItemVisibilityConverter\" />\n        </ResourceDictionary>\n    </ContentPage.Resources>  Next, we must define the behavior for the ListView:  <ListView CachingStrategy=\"RecycleElement\"\n            IsPullToRefreshEnabled=\"True\"\n            IsRefreshing=\"{Binding IsBusy,\n                                    Mode=OneWay}\"\n            ItemsSource=\"{Binding Items}\"\n            RefreshCommand=\"{Binding RefreshCommand}\"\n            RowHeight=\"50\"\n            SelectedItem=\"{Binding SelectedItem,\n                                    Mode=TwoWay}\">\n    <ListView.Behaviors>\n        <behaviors:EventToCommandBehavior Command=\"{Binding LoadMoreCommand}\"\n                                                Converter=\"{StaticResource ItemVisibilityConverter\"\n                                                EventName=\"ItemAppearing\" />\n    </ListView.Behaviors>  Finally, we need to add a new command to our  TaskListViewModel  to load more items.  This involves\nfirstly defining the new command:  public TaskListViewModel()\n{\n    CloudTable = CloudService.GetTable<TodoItem>();\n\n    Title = \"Task List\";\n\n    RefreshCommand = new Command(async () => await Refresh());\n    AddNewItemCommand = new Command(async () => await AddNewItem());\n    LogoutCommand = new Command(async () => await Logout());\n    LoadMoreCommand = new Command<TodoItem> (async (TodoItem item) => await LoadMore(item));\n\n    // Subscribe to events from the Task Detail Page\n    MessagingCenter.Subscribe<TaskDetailViewModel>(this, \"ItemsChanged\", async (sender) =>\n    {\n        await Refresh();\n    });\n\n    // Execute the refresh command\n    RefreshCommand.Execute(null);\n}\n\npublic ICommand LoadMoreCommand { get; }  We also need to define the actual command code:  bool hasMoreItems = true;\n\nasync Task LoadMore(TodoItem item)\n{\n    if (IsBusy)\n    {\n        Debug.WriteLine($\"LoadMore: bailing because IsBusy = true\");\n        return;\n    }\n\n    // If we are not displaying the last one in the list, then return.\n    if (!Items.Last().Id.Equals(item.Id))\n    {\n        Debug.WriteLine($\"LoadMore: bailing because this id is not the last id in the list\");\n        return;\n    }\n\n    // If we don't have more items, return\n    if (!hasMoreItems)\n    {\n        Debug.WriteLine($\"LoadMore: bailing because we don't have any more items\");\n        return;\n    }\n\n    IsBusy = true;\n    try\n    {\n        var list = await CloudTable.ReadItemsAsync(Items.Count, 20);\n        if (list.Count > 0)\n        {\n            Debug.WriteLine($\"LoadMore: got {list.Count} more items\");\n            Items.AddRange(list);\n        }\n        else\n        {\n            Debug.WriteLine($\"LoadMore: no more items: setting hasMoreItems= false\");\n            hasMoreItems = false;\n        }\n    }\n    catch (Exception ex)\n    {\n        await Application.Current.MainPage.DisplayAlert(\"LoadMore Failed\", ex.Message, \"OK\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}  I've added a whole bunch of debug output because this command is called a lot, so I can scroll back through the\noutput window instead of setting a breakpoint and clicking Continue a lot.  As the UI displays each cell, it calls our command.  The command figures out if the record being displayed is the\nlast one in the list.  If it is, it asks for more records.  Once no more records are available, it sets the\nflag  hasMoreItems  to false so it can short-circuit the network request.   Tip  Be careful when using  OrderBy()  with online data.  Earlier pages may change, causing duplicated data or\nmissed data in your result set.  There is little you can do about this other than pulling down all the data\nordered by the  CreatedAt  field (which is the default).   Finally, our current implementation of the  Refresh()  method loads all the items.  We need to adjust it\nto only load the first page:  async Task Refresh()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var identity = await CloudService.GetIdentityAsync();\n        if (identity != null)\n        {\n            var name = identity.UserClaims.FirstOrDefault(c => c.Type.Equals(\"name\")).Value;\n            Title = $\"Tasks for {name}\";\n        }\n        var list = await CloudTable.ReadItemsAsync(0, 20);\n        Items.ReplaceRange(list);\n        hasMoreItems = true;\n    }\n    catch (Exception ex)\n    {\n        await Application.Current.MainPage.DisplayAlert(\"Items Not Loaded\", ex.Message, \"OK\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}  We've done two things here.   We have altered the first request so that only the first 20 records are retrieved.  We have set  hasMoreItems  to true so that the  LoadMore()  command will do network requests again.",
            "title": "An Online Client"
        },
        {
            "location": "/chapter3/client/#query-support-in-online-clients",
            "text": "When using an online client, you can also use an OData query to look for records.  The following code\nsnippet, for example, will only return records that are incomplete:  return await table\n    .Where(item => item.Complete == false)\n    .ToListAsync()  This is a standard LINQ query.  Just as the LINQ query was used to adjust the SQL that is generated in\nthe server-side code, the LINQ query here is used to adjust the OData query that is generated to call\nthe server.  This particular query will generate the follow HTTP call:  GET /tables/todoitem?$filter=(complete+eq+false) HTTP/1.1  LINQ queries are very useful in dealing with online data.  In general they should take a specific forms  table                           // start with the table reference\n    .Where(filter)              // filter the results\n    .Select(filter)             // Only return certain fields\n    .Skip(start).Take(count)    // paging support\n    .ToListAsync()              // convert to something we can use  This format allows you to be very specific about what you want to return from the server, thus allowing\nyou to balance the optimization of bandwidth with the responsiveness of the UI.",
            "title": "Query Support in Online Clients"
        },
        {
            "location": "/chapter3/client/#an-offline-client",
            "text": "Another method of optimizing bandwidth utilization with an added benefit of providing a resilient data\nconnection is to use an offline sync database.   The Azure Mobile Apps Client SDK has a built-in offline\nmode that allows for the common requirements of bandwidth optimization, connection resliency, and\nperformance optimization.   An offline capable table uses  Incremental Sync  to only bring down new records from the server.  Connection detection allows you to defer requests until after a connection is available.  In-built  Conflict Resolution  provides a robust mechanism for handling changes while your client was offline.  Since the data is always local, the UI will be much more responsive to changes.   All of this comes at a cost.  We need to maintain an offline sync database for the tables you wish\nto provide offline, which takes up memory.  It may result in large data transfers (especially in the\ncases of the first sync operation and rapidly changing tables).  Finally, there is more complexity.  We\nhave to deal with the offline table maintenance and conflict resolution patterns.   Azure Mobile Apps v3.0  Azure Mobile Apps introduced a breaking change in how SQLite was used in v3.0 of the Client SDK.  The\nbreaking change ensured support for Android Nougat.  This book covers the v3.0 release of Azure Mobile\nApps.   There are three stages to using an offline client:   Initialize the local SQLite database before use.  Set up push / pull logic to maintain the contents of the SQLite database.  Configure appropriate conflict resolution.   The actual code for your mobile client that deals with tables remains identical to the online case.  To effect the offline sync, the Azure Mobile Apps client SDK keeps a table in the local SQLite database called\nthe  Operations Queue .  An entry is placed in the operations queue whenever a modification is done to a sync\ntable.  These modifications are collapsed.  Later modifications to the same record in a sync table will be collapsed\ninto a single update when transmitted to the mobile backend.",
            "title": "An Offline Client"
        },
        {
            "location": "/chapter3/client/#configuring-the-local-sqlite-database",
            "text": "We must initialize the local database before we can use it.  This happens on start up and the Azure Mobile\nApps SDK knows enough of the models to understand the basics of maintaining the database.  Initializing the\ndatabase is deceptively simple.  Install the  Mirosoft.Azure.Mobile.Client.SQLiteStore  package to all the\nclient projects.   Tip  The  Microsoft.Azure.Mobile.Client  package v3.0.2 drastically improved the startup experience for\noffline sync. Make sure you are using it.  If you are using an earlier version, additional steps are\nrequired for initializing your offline cache.   In the  Services\\AzureCloudService.cs  file, add the following method:      #region Offline Sync Initialization\n    async Task InitializeAsync()\n    {\n        // Short circuit - local database is already initialized\n        if (Client.SyncContext.IsInitialized)\n            return;\n\n        // Create a reference to the local sqlite store\n        var store = new MobileServiceSQLiteStore(\"offlinecache.db\");\n\n        // Define the database schema\n        store.DefineTable<TodoItem>();\n\n        // Actually create the store and update the schema\n        await Client.SyncContext.InitializeAsync(store);\n    }\n    #endregion   Tip  The  Microsoft.Azure.Mobile.Client  package does not support Android API versions earlier than API 19.\nTo set this, right-click on the  TaskList.Droid  project and ensure the  Minimum Android version to target \nis set to a minimum of API level 19.   We need to ensure the initialization is carried out before we use the local database. The best place to do this is\nin the  GetTable<>  method:      /// <summary>\n    /// Returns a link to the specific table.\n    /// </summary>\n    /// <typeparam name=\"T\">The model</typeparam>\n    /// <returns>The table reference</returns>\n    public async Task<ICloudTable<T>> GetTableAsync<T>() where T : TableData\n    {\n        await InitializeAsync();\n        return new AzureCloudTable<T>(Client);\n    }  Note that we made the routine async during this process.  Adjust the  ICloudService  interface and the calls to GetTable<>  in the rest of the code to compensate for this.",
            "title": "Configuring the Local SQLite database"
        },
        {
            "location": "/chapter3/client/#updating-the-sync-tables",
            "text": "We also need to add some routines to our  ICloudTable<>  and  AzureCloudTable<>  classes to effect a synchronization.\nThe first method is added to the   ICloudTable<>  interface and pulls data from the mobile backend:      public interface ICloudTable<T> where T : TableData\n    {\n        Task<T> CreateItemAsync(T item);\n        Task<T> ReadItemAsync(string id);\n        Task<T> UpdateItemAsync(T item);\n        Task<T> UpsertItemAsync(T item);\n        Task DeleteItemAsync(T item);\n        Task<ICollection<T>> ReadAllItemsAsync();\n        Task<ICollection<T>> ReadItemsAsync(int start, int count);\n        Task PullAsync();\n    }  The new method is  PullAsync()  which will do the \"pull data from the server\" operation.  The  AzureCloudTable<> \nclass has the concrete implementation:          IMobileServiceSyncTable<T> table;\n\n        public AzureCloudTable(MobileServiceClient client)\n        {\n            table = client.GetSyncTable<T>();\n        }\n\n        public async Task PullAsync()\n        {\n            string queryName = $\"incsync_{typeof(T).Name}\";\n            await table.PullAsync(queryName, table.CreateQuery());\n        }  Note that we have changed the call to get the table reference.  It's now a  SyncTable .  You can test to see if the\nsync table has been defined with the following:  if (client.IsSyncTable(typeof(T).Name)) {\n    // There is a sync table defined\n}  This can be used to have a single  AzureCloudTable  implementation for both the online and offline capabilities.  The\nconcrete implementation of the  PullAsync()  method implements incremental sync.  If we set the queryName to  null ,\nthen the entire table is pulled across each time.  By setting a queryName, the last updated time for the table is stored\nand associated with the queryName.  The last updated time is used to request only records that have changed since the\nlast updated time when doing the pull from the backend.  The push of the operations queue up to the mobile backend is handled by a single call in the  AzureCloudService  class:      public async Task SyncOfflineCacheAsync()\n    {\n        await InitializeAsync();\n\n        // Push the Operations Queue to the mobile backend\n        await Client.SyncContext.PushAsync();\n\n        // Pull each sync table\n        var taskTable = await GetTableAsync<TodoItem>(); await taskTable.PullAsync();\n    }  note that if the mobile client tries to pull data while there are pending operations in the operations quuee, the Azure\nMobile Apps client SDK will perform an implicit push.  You can check the state of the operations queue with:  if (Client.SyncContext.PendingOperations > 0) {\n    // There are pending operations\n}\n\nThe only thing left to do now is to decide when to synchronize the local database on the mobile device.  In this example,\nI am going to synchronize the database during the refresh command of the `TaskListViewModel` and on saving or deleting\nan item in the `TaskDetailViewModel`.  Each synchronization will be called with the following:\n\n```csharp\nawait CloudService.SyncOfflineCacheAsync();   Info  The offline sync cache automatically handles paging of results during the transfer for you so you never have to worry\nabout it.",
            "title": "Updating the Sync tables"
        },
        {
            "location": "/chapter3/client/#additional-steps-on-universal-windows",
            "text": "If you are compiling the Universal Windows (UWP) project, there is an extra step.  You must Add a reference for SQLite\nto the project.  Open the  TaskList.UWP  project, then right-click on the  References  node and select  Add Reference .\nSelect  Universal Windows  ->  Extensions  and place a check mark next to the  SQLite for Universal Windows  and Visual C++ 2015 Runtime for Universal Windows  components.   If you don't do this, you will get the rather cryptic error message \"Unable to set temporary directory\" when running the\napplication.",
            "title": "Additional Steps on Universal Windows"
        },
        {
            "location": "/chapter3/client/#detecting-connection-state",
            "text": "Xamarin has a rather cool plugin called the Connectivity Plugin for testing connectivity state.  We can install it by\ninstalling the  Xam.Plugin.Connectivity  NuGet package.  Once that is installed, we can update our  SyncOfflineCacheAsync() \nmethod to use it:      public async Task SyncOfflineCacheAsync()\n    {\n        await InitializeAsync();\n\n        if (!(await CrossConnectivity.Current.IsRemoteReachable(Client.MobileAppUri.Host, 443)))\n        {\n            Debug.WriteLine($\"Cannot connect to {Client.MobileAppUri} right now - offline\");\n            return;\n        }\n\n        // Push the Operations Queue to the mobile backend\n        await Client.SyncContext.PushAsync();\n\n        // Pull each sync table\n        var taskTable = await GetTableAsync<TodoItem>(); await taskTable.PullAsync();\n    }  The Connectivity Plugin (which is accessible through  CrossConnectivity.Current ) has other parameters that allow the mobile\nclient to test for specific types of connectivity.  For example, let's say you only wanted to pull one of the tables over\nwifi.  You could do this as follows:  var connections = CrossConnectivity.Current.ConnectionTypes;\nif (connections.Contains(ConnectionType.Wifi)) {\n    var largeTable = await GetTableAsync<LargeModel>();\n    largeTable.PullAsync();\n}  The Connectivity plugin when paired with the Azure Mobile Apps Client SDK gives you a lot of flexibility in deciding what to\nsync and over what type of connection you should sync.",
            "title": "Detecting Connection State"
        },
        {
            "location": "/chapter3/client/#handling-conflict-resolution",
            "text": "When the mobile client submits a modification to the mobile backend, it's generally done as a two-step process:   A \"pre-condition check\" is done, comparing the Version to the ETag of the record (which is derived from the Version of the record).  The actual request is done, where the Version of the mobile client is compared to the Version of the record on the mobile backend.   If the version of the record being submitted is different from the version on the server, the test will fail.  In the case of the first\ncheck, a  412 Precondition Failed  will be returned for the modification.  If the second test fails, a  409 Conflict  response is\nreturned.  Normally, you will see the  412 Precondition Failed  response, but you should be prepared for either response.  Both responses indicate a conflict that needs to be resolved before continuing.  Programatically, when doing a modification in\nan online table (such as an Insert, Update, Delete), you should be capture the  MobileServicePreconditionFailedException<>  Exception\nto handle the conflict.  In an offline sync table, you should capture the  MobileServicePushFailedException  during the PushAsync()  operation.  This will potentially have an array of conflicts for you to deal with.  For the online case, the code would look like this:  try\n{\n    await CloudService.InsertAsync(item);\n}\ncatch (MobileServicePreconditionFailedException<TodoItem> ex)\n{\n    await ResolveConflictAsync(item, ex.Item);\n}  For the offline case, the code would look like this:  try\n{\n    await CloudService.PushAsync();\n}\ncatch (MobileServicePushFailedException ex)\n{\n    if (ex.PushResult != null)\n    {\n        foreach (var error in ex.PushResult.Errors)\n        {\n            await ResolveConflictAsync(error);\n        }\n    }\n}  In both cases, the  ResolveConflictAsync()  method is called for each conflict in turn.  Resolving the conflict involves\ndeciding between the two options or making corrections to the item.   If you wish to keep the client copy, set the client Version property to the server Version value and re-submit.  If you wish to keep the server copy, discard the update.  If you wish to do something else, create a new copy of the record, set the Version to be the same as the server Version, then re-submit.    Info  If the model on your mobile client does not have a Version field, the policy is \"last write wins\".   The online case is relatively simple as you are going to be ignoring the old request and creating a new request.  Here is\nsome template code that implements both client-wins and server-wins strategies for the offline case:  sync Task ResolveConflictAsync(MobileServiceTableOperationError error)\n{\n    var serverItem = error.Result.ToObject<T>();\n    var localItem = error.Item.ToObject<T>();\n\n    // Note that you need to implement the public override Equals(TodoItem item)\n    // method in the Model for this to work\n    if (serverItem.Equals(localItem))\n    {\n        // Items are the same, so ignore the conflict\n        await error.CancelAndDiscardItemAsync();\n        return;\n    }\n\n    // Client Always Wins\n    localItem.Version = serverItem.Version;\n    await error.UpdateOperationAsync(JObject.FromObject(localItem));\n\n    // Server Always Wins\n    // await error.CancelAndDiscardItemAsync();\n}  You could also ask the user as an option.  Finally, you could do some processing.  For example, let's say that you wanted\nto keep the local version of the Text, but keep the server version of Complete:  localItem.Complete = serverItem.Complete;\nlocalItem.Version = serverItem.Version;\nawait error.UpdateOperationAsync(JObject.FromObject(serverItem));  There are many ways to resolve a conflict.  You should consider your requirements carefully.  Asking the user should\nalways be the last resort for conflict resolution.  In the majority of applications, most users will click the\n\"keep my version\" button to resolve conflicts, so the UI for resolving conflicts should do more than just ask the\nuser to decide between a server and a client version.",
            "title": "Handling Conflict Resolution"
        },
        {
            "location": "/chapter3/client/#query-management",
            "text": "Record selection is based on two factors:   Security policy is enforced at the server.  User preference is enabled at the client.   We've already discussed security policy in depth in  the last section .  We've also discussed\nuser queries for online usage.  We just use LINQ to affect a change in the query sent to the server.  However,\nwhat about offline cases? There are situations where you want to keep a smaller subset of the data that you are\nallowed to see for offline usage.  A common request, for example, is to have the last X days of records available\noffline.  In our  PullAsync()  call for the table, we use  table.CreateQuery()  to create a query that is designed to get\nall the records available to the user from the server.  This is not always appropriate and can be adjusted.  Let's\nadjust it to only obtain the records for our TodoItem table where either of the following conditions apply:   The record has been updated within the last day.  The task is incomplete.   Once the task is marked completed, it will remain in the cache for 1 day, then be removed automatically.  You can\nstill obtain the task while online.  The  table.CreateQuery()  method produces an  IMobileServiceTableQuery<> \nobject.  This can be dealt with via LINQ:  var queryName = $\"incsync:r:{typeof(T).Name}\";\nvar query = table.CreateQuery()\n    .Where(r => !r.Complete || r.UpdatedAt < DateTimeOffset.Now.AddDays(-1));\nawait table.PullAsync(queryName, query);  Note that I am using a different query name in this case.  The maximum value of UpdatedAt for the records is stored\nand associated with the query name.  If the same query name is used, then only the records updated since the stored\ndate will be retrieved.  If you change the query, then change the query name.  Another common request is to restrict the properties that are in the local cache.  For instance, maybe you have\na particularly large text blob that you want to make available online, but not offline:  var queryName = $\"incsync:s:{typeof(T).Name}\";\nvar query = table.CreateQuery()\n    .Select(r => new { r.Text, r.Complete, r.UpdatedAt, r.Version });\nawait table.PullAsync(queryName, query);  You can also use the Fluent syntax:  var query =\n    from r in table.CreateQuery()\n    select new { r.Text, r.Complete, r.UpdatedAt, r.Version };  You should always construct the object including the  UpdatedAt  and  Version  properties.   UpdatedAt  is used\nfor incremental sync and  Version  is used for conflict resolution.  Both of these cases use standard LINQ syntax to adjust the query being sent to the mobile backend in exactly the\nsame way that we adjusted the query when we were doing online searches.  An offline \"pull\" is exactly the same\nas an online \"query\".   Tip  There are times when you want to download two different queries.  Avoid this if at all possible as it will\ncause additional requests to the backend that are un-necessary.  Construct your query such that all records\nthat you want to download to the offline cache are requested at once.",
            "title": "Query Management"
        },
        {
            "location": "/chapter3/client/#dealing-with-historical-data",
            "text": "Let's continue our example with a small extension.  Let's say you want to have the last 7 days worth of records\navailable offline, but you still want the ability to do a historical search.  In this case, you can create two\ntable references to the same table - one online for historical searches and one offline for the normal use case:  var table = client.GetSyncTable<Message>();\nvar historicalTable = client.GetTable<Message>();  In this case, the  table  reference is used to access the offline data.   However, you could implement a search\ncapability that does a query against the  historicalTable  instead.  They both point to the same table.  In one\ncase, the server is referenced (and only available online) and in the other, the local cache is referenced\n(and available offline).",
            "title": "Dealing with Historical Data"
        },
        {
            "location": "/chapter3/client/#purging-the-local-cache",
            "text": "It will be inevitable that you will want to clear the local cache at some point.   You have just changed the model and underlying data and need to re-establish a baseline.  You only cache newer data and want to remove historical data.  Things got corrupt for some reason and you need to refresh everything.   Whatever the reason, clearing the cache is one of those infrequent things that is going to be a necessity.  There\nare three forms of this operation:",
            "title": "Purging the Local Cache"
        },
        {
            "location": "/chapter3/client/#deleting-the-backing-store",
            "text": "The major requirement during development is that you want to delete the SQLite file that backs the offline cache.\nIt's likely that the model evolves over time during development.  Add test data that can sometimes cause things\nto go wrong and you have a recipe for bugs that are only there because you are developing.  If you suspect bad\ndata in the offline cache, the first thing you want to do is start afresh.  Each platform stores the offline cache in a different place and the mechanism for removing it is different in each\ncase.  For Universal Windows projects, the offline cache is stored in the Local AppData folder for the application.\nThis is a dedicated area that each Universal Windows app has access to for anything from temporary files to settings\nand cache files.  To find the location of the file, open the  TaskList.UWP  project and open the  Package.appxmanifest \nfile.  Go to the  Packaging  tab.   Note the long  Package family name  field.  Your backing file is in your home directory under  AppData\\Local\\Packages\\{family_name}\\LocalState .\nYou specified the name of the file when you created the store.  You need to find the  Package Name  for Android.  Right-click on the  TaskList.Droid  project and select  Properties ,\nthen select the  Android Manifest  tab.   The database will be located in  /data/data/{package_name}/files  directory on the emulator.  Google has provided utilities\nfor handling developer connections to devices (including emulators).  In this case, we can use the  adb  utility.  First, start\nyour emulator of choice through the  Tools  ->  Visual Studio Emulator for Android  menu option.  Click on the  Play \nbutton next to the emulator that you have been using.  Ensure the emulator is fully started before continuing.  The  adb  utility\ncan be accessed through a shell prompt (I use PowerShell normally) and it is located in  $ANDROID_SDK/platform-tools .  On Windows,\nthis is probably  C:\\Program Files (x86)\\Android\\android-sdk\\platform-tools .  It's a good idea to add this to your PATH.  Start at your Visual Studio Emulator for Android.  Click on the  Tools  button (it looks like a pair of right-facing\nchevrons) and select the  Network  tab.   You want the network address of the  Windows Phone Emulator Internal Switch .  In this case, it's 169.254.138.177.  The\n169.254 address range is a private switch between the host computer (the one you are developing on) and the emulators.\nOpen up a shell prompt and type:  adb connect 169.254.138.177:5555\nadb shell   Tip  If you are only running one emulator and have no connected real devices, you don't need the  adb connect  command.  Visual\nStudio will have already set up the connection for you.  Use  adb devices  to determine if you need to connect.   This opens up a Linux-like shell onto the Android device.  You can use normal Linux commands to move around.   You can remove\nthe entire private data area for your package using the following:  **root@donatello:/#** cd /data/data/Tasklist.Droid.TaskList.Droid\n**root@donatollo:/#** find . -name tasklist.db -print | xargs rm  The database will normally be in the  files  directory.  Use  exit  to close the shell prompt on the Android device.  Each disk\nimage file is independent.  You must remove the database file on each emulator individually.   Tip  You can use the same  adb  commands to connect to a real Android device connected via USB.  Ensure  USB Debugging  is\nenabled on the device.  Use  adb devices  to find the device.  For more information, see  the Android documentation .   The iOS Simulator does not use an image files.  Instead, it stores files on your Mac disk in  ~/Library/Developer/CoreSimulator/Devices .\nThere is a file called  device_set.plist  that contains the list of devices that are defined and their location.  It is most easy to find\na specific device.  For example, if you are testing on the iPhone 6x simulator:  $ grep -B 1 'iPhone-6s<' device_set.plist\n<string>A3536AA4-0678-43CC-BA21-DD997B89778A</string>\n<key>com.apple.CoreSimulator.SimDeviceType.iPhone-6s</key>\n--\n<string>83D08BC0-2F9A-4479-ABBD-A69858819E93</string>\n<key>com.apple.CoreSimulator.SimDeviceType.iPhone-6s</key>\n--\n<string>ECAE441D-93F8-4D7A-BF14-7FA2D11BC152</string>\n<key>com.apple.CoreSimulator.SimDeviceType.iPhone-6s</key>  Each one of these corresponds to a different OS version.  You can find the ordering like this:  $ grep SimRuntime.iOS device_set.plist\n<key>com.apple.CoreSimulator.SimRuntime.iOS-9-1</key>\n<key>com.apple.CoreSimulator.SimRuntime.iOS-9-2</key>\n<key>com.apple.CoreSimulator.SimRuntime.iOS-9-3</key>  My simulator is an iPhone 6s running iOS 9.3, so I can see the GUID is the third one:  ECAE441D-93F8-4D7A-BF14-7FA2D11BC152 .  This\nGUID is a directory in the same directory as the  device_set.plist  file.  You can use normal UNIX style commands to\nremove the backing store:  $ cd ECAE441D-93F8-4D7A-BF14-7FA2D11BC152\n$ find . -name 'tasklist.db' -print | xargs rm  You can also use the normal Finder utilities to search for and remove the database file for your app.",
            "title": "Deleting the backing store"
        },
        {
            "location": "/chapter3/client/#purging-records-from-the-offline-cache",
            "text": "The  IMobileServiceSyncTable  interface also includes a capability for purging records that are stored in the offline sync by query.  This\nis done in code like this:  var lowerBound = DateTimeOffset.Now.AddDays(-7);\nvar query = syncTable.CreateQuery().Where(item => item.UpdatedAt < lowerBound);\nvar force = true;\nawait syncTable.PurgeAsync(\"incsync_Tag\", query, force);  There are four parameters for the  PurgeAsync  call:   A query name.  An OData query.  A boolean for forcing the operation.  A cancellation token (for the async operation).   Each incremental sync query has a unique name that is specified during the  PullAsync()  method call.  If you use the same name during the PurgeAsync()  call, then the date associated with the incremental sync query is reset, causing a full refresh of the data.  This allows\nyou to do a \"purge and refresh\" operation.  If you don't want this to happen, set the query name to null.  The OData query is a similar query format to the incremental sync query that we used with  PullAsync() .  In this case, it selects the\nrecords that should be purged from the offline sync cache.  If we wished to purge everything, we could just use  syncTable.CreateQuery() .\nIf we want to purge only certain records, then we can adjust the query with a  .Where()  LINQ query.  In the example above, records that\nhave not been updated within the last 7 days are purged.  Finally, the  PurgeAsync()  call will fail (and generate an exception) if there are any operations pending in the operations queue.  If we\nspecify  force = true , then the operations queue check is bypassed and pending operations in the operations queue are flushed without being\nuploaded.  It is important that this option is used only when absolutely required.  You can leave your database in an inconsistent\nstate if you expect referential integrity between different tables.  Use  SyncContext.PushAsync()  to push the operations queue\nto the remote server before calling  PurgeAsync() .   If you use  force = true , then also specify a query name to reset the incremental\nsync state.",
            "title": "Purging Records from the Offline Cache"
        },
        {
            "location": "/chapter3/client/#debugging-the-offline-cache",
            "text": "One of the most difficult parts of the offline cache is that it is opaque - you can't really see what is going on.  Fortunately, the SQLiteStore  that is used is relatively straight forward to sub-class so we can add logging to it.  The following helper method can\nbe substituted for a  SQLiteStore  in any code.  public class MobileServiceSQLiteStoreWithLogging : MobileServiceSQLiteStore\n{\n    private bool logResults;\n    private bool logParameters;\n\n    public MobileServiceSQLiteStoreWithLogging(string fileName, bool logResults = false, bool logParameters = false)\n        : base(fileName)\n    {\n        this.logResults = logResults;\n        this.logParameters = logParameters;\n    }\n\n    protected override IList<Newtonsoft.Json.Linq.JObject> ExecuteQuery(string tableName, string sql, IDictionary<string, object> parameters)\n    {\n        Console.WriteLine (sql);\n\n        if(logParameters)\n            PrintDictionary (parameters);\n\n        var result = base.ExecuteQuery(tableName, sql, parameters);\n\n        if (logResults && result != null)\n        {\n            foreach (var token in result)\n                Console.WriteLine (token);\n        }\n\n        return result;\n    }\n\n    protected override void ExecuteNonQuery(string sql, IDictionary<string, object> parameters)\n    {\n        Console.WriteLine (sql);\n\n        if(logParameters)\n            PrintDictionary (parameters);\n\n        base.ExecuteNonQuery(sql, parameters);\n    }\n\n    private void PrintDictionary(IDictionary<string,object> dictionary)\n    {\n        if (dictionary == null)\n            return;\n\n        foreach (var pair in dictionary)\n            Console.WriteLine (\"{0}:{1}\", pair.Key, pair.Value);\n    }\n}\n\npublic class LoggingHandler : DelegatingHandler\n{\n    private bool logRequestResponseBody;\n\n    public LoggingHandler(bool logRequestResponseBody = false)\n    {\n        this.logRequestResponseBody = logRequestResponseBody;\n    }\n\n    protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, System.Threading.CancellationToken cancellationToken)\n    {\n        Console.WriteLine(\"Request: {0} {1}\", request.Method, request.RequestUri.ToString());\n\n        if (logRequestResponseBody && request.Content != null)\n        {\n            var requestContent = await request.Content.ReadAsStringAsync ();\n            Console.WriteLine (requestContent);\n        }\n\n        var response = await base.SendAsync(request, cancellationToken);\n\n        Console.WriteLine (\"Response: {0}\", response.StatusCode);\n\n        if (logRequestResponseBody)\n        {\n            var responseContent = await response.Content.ReadAsStringAsync ();\n            Console.WriteLine (responseContent);\n        }\n\n        return response;\n    }\n}  Using this class will print all the SQL commands that are executed against the SQLite store.  Ensure you are capturing the console somewhere\nso that you can see the debug messages as you are running your application.",
            "title": "Debugging the Offline Cache"
        },
        {
            "location": "/chapter3/relationships/",
            "text": "Relationships\n\u00b6\n\n\nOne of the biggest benefits to using a SQL database over a NoSQL store is relationships between entities.  Relationships\nprovide the ability to normalize the data, allowing you to store the minimal amount of data for a specific use case on\nthe mobile device.  This reduces bandwidth usage and memory usage on the device.  Relationships are a good thing.\n\n\nUnfortunately, relationships between tables are hard when one is working within an offline context.  This is primarily\ncaused by the need for resilience.  Because we can do many updates to the tables on the offline client, the transactions\nthat update the tables need to be co-ordinated.  This is practically impossible in an offline context where one of the\ngoals in bandwidth performance.\n\n\nAzure Mobile Apps, when used in an offline context, has an operations table.  As you do each operation against a table,\nan entry is made in the operations table.  The operations table is then replayed in order to the mobile backend to\neffect changes in the remote database.  However, this also has the effect that we do not have transactions to allow the\nupdating of multiple tables within the database at the same time.  Each record in each table is updated individually.\nThe push process that offline sync uses has major ramifications for how relationships between tables work.  Specifically,\nonly 1-way relationships will work in an offline sync world.\n\n\n\n\n1-Way Relationships\n\n\nYou can define relationships in Entity Framework with or without a virtual back-reference.  Relationships \nwithout the virtual back-reference are known as 2-way relationships (because you can get back to the original \nmodel).  Relationships with only a forward reference (and no knowledge of the original model) are said to have \na 1-way relationship.  A database model with only 1-way relationships can generally be represented with a tree \nstructure.\n\n\n\n\nLet's take a quick example.  We've been using the \"task list\" scenario for our testing thus far.  Let's say that each\ntask could be assigned a tag from a list of tags.   We can use a 1-way 1:1 relationship between the tasks and the tags.\nTo do that, we would store the Id of the tag in the task model.  If, however, we could attach many tags to a single\ntask, that would be a 1:Many relationship.\n\n\n1:1 Relationships\n\u00b6\n\n\nLet's take a look at our task list example, from the perspective of the models on the server side:\n\n\nusing Microsoft.Azure.Mobile.Server;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace ComplexTypes.DataObjects\n{\n    public class Tag : EntityData\n    {\n        public string TagName { get; set; }\n    }\n\n    public class TodoItem : EntityData\n    {\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n\n        #region Relationships\n        public string TagId { get; set; }\n\n        [ForeignKey(\"TagId\")]\n        public Tag Tag { get; set; }\n        #endregion\n    }\n}\n\n\n\n\n1:1 relationships are defined using a foreign key in the SQL database.  We can use Entity Framework to define the foreign\nkey relationship easily.  In this case, our \nTodoItem\n model will, have a TagId that contains the Id field of the tag.  I\nalso created a pair of table controllers for these models in the normal manner.  Finally, I've created some records using\nthe \nSeed()\n method within the \nApp_Start\\Startup.MobileApp.cs\n file to give us some test data.\n\n\nIf we take a look at records through Postman, we will get the following:\n\n\n\n\nNote that the first item has a reference to a tag, by virtue of the TagId.  The second item does not have a tag assigned,\nso the value of TagId is null.\n\n\nWhen we implement the client, we are going to download these tables indepdendently.  The linkage and relationships between\nthe tables is lost when going from the backend to the offline client.  We have to link them together ourselves.  This is\nwhy the \"1-way\" relationship is necessary.  In a 2-way relationship, a tag and task would have to be created at the same\ntime as part of an SQL transaction.  In a 1-way relationship, the tag can be created THEN the task that has the relationship\nis created\n\n\n\n\nTip\n\n\nWhen you think of all the mobile applications you own, you will realize that 1-way relationships are the normal state of\naffairs.  Very few data models for mobile apps actually require a two-way relationship.\n\n\n\n\nWhen you are developing the mobile client, the \nTag\n is removed from the model:\n\n\nusing TaskList.Helpers;\n\nnamespace TaskList.Models\n{\n    public class Tag : TableData\n    {\n        public string TagName { get; set; }\n    }\n\n    public class TodoItem : TableData\n    {\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n\n        public string TagId { get; set; }\n    }\n}\n\n\n\n\nOne can easily retrieve the tag information with a LINQ query on the Tag table:\n\n\nvar tag = tagTable.FirstOrDefault(tag => tag.Id.Equals(task.TagId)).Value;\n\n\n\n\nThere are a couple of rules you must follow within your client code:\n\n\n\n\nYou need to ensure that you create a tag before associating that tag with a task.\n\n\nYou need to store the TagId with the task, not the \nTag\n object (as you would normally do within Entity Framework).\n\n\n\n\nThe former is generally handled for you.  If you \nInsertAsync\n a tag in offline mode, it will be placed into the\noperations queue prior to anything that uses it.  Since the operations queue is processed in order, the tag will\nbe sent to the backend prior to any record updates that would use it.\n\n\n1:Many Relationships\n\u00b6\n\n\nWhat if we had a list of messages and wanted to assign more than one tag to each record?  In this case, we would\nneed a 1:Many relationship.  Setting up a 1:Many relationship on the backend again relies on Entity Framework syntax:\n\n\nusing Microsoft.Azure.Mobile.Server;\nusing System.Collections.Generic;\n\nnamespace TaskList.Models\n{\n    public class Tag : EntityData\n    {\n        public string TagName { get; set; }\n    }\n\n    public class Message : EntityData\n    {\n        public string UserId { get; set; }\n        public string Text { get; set; }\n        public virtual ICollection<Tag> Tags { get; set; }\n    }\n}\n\n\n\n\nWe can seed some information into this database to simulate relationships with a standard initializer:\n\n\npublic class MobileServiceInitializer : CreateDatabaseIfNotExists<MobileServiceContext>\n{\n    protected override void Seed(MobileServiceContext context)\n    {\n        List<Tag> tags = new List<Tag>\n        {\n            new Tag { Id = NewGuid(), TagName = \"Tag-1\" },\n            new Tag { Id = NewGuid(), TagName = \"Tag-2\" },\n            new Tag { Id = NewGuid(), TagName = \"Tag-3\" }\n        };\n        context.Set<Tag>().AddRange(tags);\n\n        List<Message> messages = new List<Message>\n        {\n            new Message { Id = NewGuid(), Text = \"Message-1\", Tags = tags },\n            new Message { Id = NewGuid(), Text = \"message-2\", Tags = new List<Tag>() }\n        };\n        context.Set<Message>().AddRange(messages);\n\n        base.Seed(context);\n    }\n\n    private string NewGuid()\n    {\n        return Guid.NewGuid().ToString();\n    }\n}\n\n\n\n\nIf we use Postman to do a GET /tables/Message, we get the following:\n\n\n\n\nNote that the \ntags\n field is not even produced.  The Azure Mobile Apps Server SDK depends on multiple frameworks.  It\nuses Entity Framework for data access, for instance.  It also uses the standard Microsoft OData server to translate\nOData queries into results.  This has a side effect that the rules of the Microsoft OData server must be followed.\n\nSpecifically, this means that collections, such as the list of tags, will not be produced unless you explicitly expand\nthem.  You can do this on the URL by using the \n$expand\n parameter:\n\n\nGET /tables/Message?$expand=tags\n\n\n\n\nThis will result in the following output:\n\n\n\n\nNote that the tags are fully expanded and embedded in the object.  This has some serious consequences that must be\nconsidered:\n\n\n\n\nThe table becomes read-only through the controller.  Inserts, Updates and Deletes must have special code handling.\n\n\nThe data takes up more space on the client as the tags will be duplicated whenever used.\n\n\nYou cannot use offline sync since the data model is no longer flat.\n\n\n\n\nIn addition to these three points, you need to be able to add the \n$expand\n property to the request.  This is not done\nby the SDK.  You can automatically add the \n$expand\n property on the server-side by using an attribute for the purpose:\n\n\nusing System;\nusing System.Linq;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.Filters;\n\nnamespace Chapter3.Extensions\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    public class ExpandPropertyAttribute : ActionFilterAttribute\n    {\n        string propertyName;\n\n        public ExpandPropertyAttribute(string propertyName)\n        {\n            this.propertyName = propertyName;\n        }\n\n        public override void OnActionExecuting(HttpActionContext actionContext)\n        {\n            base.OnActionExecuting(actionContext);\n            var uriBuilder = new UriBuilder(actionContext.Request.RequestUri);\n            var queryParams = uriBuilder.Query.TrimStart('?').Split(new[] { '&' }, StringSplitOptions.RemoveEmptyEntries).ToList();\n            int expandIndex = -1;\n            for (var i = 0; i < queryParams.Count; i++)\n            {\n                if (queryParams[i].StartsWith(\"$expand\", StringComparison.Ordinal))\n                {\n                    expandIndex = i;\n                    break;\n                }\n            }\n\n            if (expandIndex < 0)\n            {\n                queryParams.Add(\"$expand=\" + this.propertyName);\n            }\n            else\n            {\n                queryParams[expandIndex] = queryParams[expandIndex] + \",\" + propertyName;\n            }\n\n            uriBuilder.Query = string.Join(\"&\", queryParams);\n            actionContext.Request.RequestUri = uriBuilder.Uri;\n        }\n    }\n}\n\n\n\n\nThis is used in the controller:\n\n\npublic class MessageController : TableController<Message>\n{\n    private MobileServiceContext context;\n\n    protected override void Initialize(HttpControllerContext controllerContext)\n    {\n        base.Initialize(controllerContext);\n        context = new MobileServiceContext();\n        DomainManager = new EntityDomainManager<Message>(context, Request);\n    }\n\n    public string UserId => ((ClaimsPrincipal)User).FindFirst(ClaimTypes.NameIdentifier).Value;\n\n    // GET tables/Message\n    [ExpandProperty(\"tags\")]\n    public IQueryable<Message> GetAllMessage()\n    {\n        return Query();\n        //return Query().OwnedByFriends(context.Friends, UserId);\n    }\n\n    // GET tables/Message/48D68C86-6EA6-4C25-AA33-223FC9A27959\n    [ExpandProperty(\"tags\")]\n    public SingleResult<Message> GetMessage(string id)\n    {\n        return new SingleResult<Message>(Lookup(id).Queryable);\n        //return new SingleResult<Message>(Lookup(id).Queryable.OwnedByFriends(context.Friends, UserId));\n    }\n\n    // POST tables/Message\n    public async Task<IHttpActionResult> PostMessageAsync(Message item)\n    {\n        item.UserId = UserId;\n        Message current = await InsertAsync(item);\n        return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n    }\n}\n\n\n\n\nGiven this is not recommended, what are the alternatives?  There are two alternatives. The first alternative is to\nuse a third table that joins the Messages and Tags together in a loose manner:\n\n\nusing Microsoft.Azure.Mobile.Server;\nusing System.Collections.Generic;\n\nnamespace TaskList.Models\n{\n    public class Tag : EntityData\n    {\n        public string TagName { get; set; }\n    }\n\n    public class Message : EntityData\n    {\n        public string UserId { get; set; }\n        public string Text { get; set; }\n    }\n\n    public class MessageTag : EntityData\n    {\n        public string MessageId { get; set; }\n        public string TagId { get; set; }\n    }\n}\n\n\n\n\nWe can now create a \nMessageTagController\n to retrieve the information.  This data can be stored offline since the model\nis now flat.  Obtaining the list of tags for a message is a single LINQ query:\n\n\nvar tags = from tag in tagTable\n           let tl = (from mt in messageTags where mt.MessageId == messageId select mt.TagId)\n           where tl.Contains(tag.Id)\n           select tag;\n\n\n\n\nYou may recognize this LINQ query as it is very similar to the LINQ query used for the friends filter.  A similar query\ncan be used to find the messages associated with a tag:\n\n\nvar msgs = from message in messageTable\n           let tl = (from mt in messageTags where mt.TagId == tagId select mt.MessageId)\n           where tl.Contains(message.Id)\n           orderby message.CreatedAtRoute\n           select message;\n\n\n\n\nThe second alternative is to use an alternative DomainManager that implements the relationships for you.  We will cover this\nin the next section.",
            "title": "Relationships"
        },
        {
            "location": "/chapter3/relationships/#relationships",
            "text": "One of the biggest benefits to using a SQL database over a NoSQL store is relationships between entities.  Relationships\nprovide the ability to normalize the data, allowing you to store the minimal amount of data for a specific use case on\nthe mobile device.  This reduces bandwidth usage and memory usage on the device.  Relationships are a good thing.  Unfortunately, relationships between tables are hard when one is working within an offline context.  This is primarily\ncaused by the need for resilience.  Because we can do many updates to the tables on the offline client, the transactions\nthat update the tables need to be co-ordinated.  This is practically impossible in an offline context where one of the\ngoals in bandwidth performance.  Azure Mobile Apps, when used in an offline context, has an operations table.  As you do each operation against a table,\nan entry is made in the operations table.  The operations table is then replayed in order to the mobile backend to\neffect changes in the remote database.  However, this also has the effect that we do not have transactions to allow the\nupdating of multiple tables within the database at the same time.  Each record in each table is updated individually.\nThe push process that offline sync uses has major ramifications for how relationships between tables work.  Specifically,\nonly 1-way relationships will work in an offline sync world.   1-Way Relationships  You can define relationships in Entity Framework with or without a virtual back-reference.  Relationships \nwithout the virtual back-reference are known as 2-way relationships (because you can get back to the original \nmodel).  Relationships with only a forward reference (and no knowledge of the original model) are said to have \na 1-way relationship.  A database model with only 1-way relationships can generally be represented with a tree \nstructure.   Let's take a quick example.  We've been using the \"task list\" scenario for our testing thus far.  Let's say that each\ntask could be assigned a tag from a list of tags.   We can use a 1-way 1:1 relationship between the tasks and the tags.\nTo do that, we would store the Id of the tag in the task model.  If, however, we could attach many tags to a single\ntask, that would be a 1:Many relationship.",
            "title": "Relationships"
        },
        {
            "location": "/chapter3/relationships/#11-relationships",
            "text": "Let's take a look at our task list example, from the perspective of the models on the server side:  using Microsoft.Azure.Mobile.Server;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace ComplexTypes.DataObjects\n{\n    public class Tag : EntityData\n    {\n        public string TagName { get; set; }\n    }\n\n    public class TodoItem : EntityData\n    {\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n\n        #region Relationships\n        public string TagId { get; set; }\n\n        [ForeignKey(\"TagId\")]\n        public Tag Tag { get; set; }\n        #endregion\n    }\n}  1:1 relationships are defined using a foreign key in the SQL database.  We can use Entity Framework to define the foreign\nkey relationship easily.  In this case, our  TodoItem  model will, have a TagId that contains the Id field of the tag.  I\nalso created a pair of table controllers for these models in the normal manner.  Finally, I've created some records using\nthe  Seed()  method within the  App_Start\\Startup.MobileApp.cs  file to give us some test data.  If we take a look at records through Postman, we will get the following:   Note that the first item has a reference to a tag, by virtue of the TagId.  The second item does not have a tag assigned,\nso the value of TagId is null.  When we implement the client, we are going to download these tables indepdendently.  The linkage and relationships between\nthe tables is lost when going from the backend to the offline client.  We have to link them together ourselves.  This is\nwhy the \"1-way\" relationship is necessary.  In a 2-way relationship, a tag and task would have to be created at the same\ntime as part of an SQL transaction.  In a 1-way relationship, the tag can be created THEN the task that has the relationship\nis created   Tip  When you think of all the mobile applications you own, you will realize that 1-way relationships are the normal state of\naffairs.  Very few data models for mobile apps actually require a two-way relationship.   When you are developing the mobile client, the  Tag  is removed from the model:  using TaskList.Helpers;\n\nnamespace TaskList.Models\n{\n    public class Tag : TableData\n    {\n        public string TagName { get; set; }\n    }\n\n    public class TodoItem : TableData\n    {\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n\n        public string TagId { get; set; }\n    }\n}  One can easily retrieve the tag information with a LINQ query on the Tag table:  var tag = tagTable.FirstOrDefault(tag => tag.Id.Equals(task.TagId)).Value;  There are a couple of rules you must follow within your client code:   You need to ensure that you create a tag before associating that tag with a task.  You need to store the TagId with the task, not the  Tag  object (as you would normally do within Entity Framework).   The former is generally handled for you.  If you  InsertAsync  a tag in offline mode, it will be placed into the\noperations queue prior to anything that uses it.  Since the operations queue is processed in order, the tag will\nbe sent to the backend prior to any record updates that would use it.",
            "title": "1:1 Relationships"
        },
        {
            "location": "/chapter3/relationships/#1many-relationships",
            "text": "What if we had a list of messages and wanted to assign more than one tag to each record?  In this case, we would\nneed a 1:Many relationship.  Setting up a 1:Many relationship on the backend again relies on Entity Framework syntax:  using Microsoft.Azure.Mobile.Server;\nusing System.Collections.Generic;\n\nnamespace TaskList.Models\n{\n    public class Tag : EntityData\n    {\n        public string TagName { get; set; }\n    }\n\n    public class Message : EntityData\n    {\n        public string UserId { get; set; }\n        public string Text { get; set; }\n        public virtual ICollection<Tag> Tags { get; set; }\n    }\n}  We can seed some information into this database to simulate relationships with a standard initializer:  public class MobileServiceInitializer : CreateDatabaseIfNotExists<MobileServiceContext>\n{\n    protected override void Seed(MobileServiceContext context)\n    {\n        List<Tag> tags = new List<Tag>\n        {\n            new Tag { Id = NewGuid(), TagName = \"Tag-1\" },\n            new Tag { Id = NewGuid(), TagName = \"Tag-2\" },\n            new Tag { Id = NewGuid(), TagName = \"Tag-3\" }\n        };\n        context.Set<Tag>().AddRange(tags);\n\n        List<Message> messages = new List<Message>\n        {\n            new Message { Id = NewGuid(), Text = \"Message-1\", Tags = tags },\n            new Message { Id = NewGuid(), Text = \"message-2\", Tags = new List<Tag>() }\n        };\n        context.Set<Message>().AddRange(messages);\n\n        base.Seed(context);\n    }\n\n    private string NewGuid()\n    {\n        return Guid.NewGuid().ToString();\n    }\n}  If we use Postman to do a GET /tables/Message, we get the following:   Note that the  tags  field is not even produced.  The Azure Mobile Apps Server SDK depends on multiple frameworks.  It\nuses Entity Framework for data access, for instance.  It also uses the standard Microsoft OData server to translate\nOData queries into results.  This has a side effect that the rules of the Microsoft OData server must be followed. \nSpecifically, this means that collections, such as the list of tags, will not be produced unless you explicitly expand\nthem.  You can do this on the URL by using the  $expand  parameter:  GET /tables/Message?$expand=tags  This will result in the following output:   Note that the tags are fully expanded and embedded in the object.  This has some serious consequences that must be\nconsidered:   The table becomes read-only through the controller.  Inserts, Updates and Deletes must have special code handling.  The data takes up more space on the client as the tags will be duplicated whenever used.  You cannot use offline sync since the data model is no longer flat.   In addition to these three points, you need to be able to add the  $expand  property to the request.  This is not done\nby the SDK.  You can automatically add the  $expand  property on the server-side by using an attribute for the purpose:  using System;\nusing System.Linq;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.Filters;\n\nnamespace Chapter3.Extensions\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\n    public class ExpandPropertyAttribute : ActionFilterAttribute\n    {\n        string propertyName;\n\n        public ExpandPropertyAttribute(string propertyName)\n        {\n            this.propertyName = propertyName;\n        }\n\n        public override void OnActionExecuting(HttpActionContext actionContext)\n        {\n            base.OnActionExecuting(actionContext);\n            var uriBuilder = new UriBuilder(actionContext.Request.RequestUri);\n            var queryParams = uriBuilder.Query.TrimStart('?').Split(new[] { '&' }, StringSplitOptions.RemoveEmptyEntries).ToList();\n            int expandIndex = -1;\n            for (var i = 0; i < queryParams.Count; i++)\n            {\n                if (queryParams[i].StartsWith(\"$expand\", StringComparison.Ordinal))\n                {\n                    expandIndex = i;\n                    break;\n                }\n            }\n\n            if (expandIndex < 0)\n            {\n                queryParams.Add(\"$expand=\" + this.propertyName);\n            }\n            else\n            {\n                queryParams[expandIndex] = queryParams[expandIndex] + \",\" + propertyName;\n            }\n\n            uriBuilder.Query = string.Join(\"&\", queryParams);\n            actionContext.Request.RequestUri = uriBuilder.Uri;\n        }\n    }\n}  This is used in the controller:  public class MessageController : TableController<Message>\n{\n    private MobileServiceContext context;\n\n    protected override void Initialize(HttpControllerContext controllerContext)\n    {\n        base.Initialize(controllerContext);\n        context = new MobileServiceContext();\n        DomainManager = new EntityDomainManager<Message>(context, Request);\n    }\n\n    public string UserId => ((ClaimsPrincipal)User).FindFirst(ClaimTypes.NameIdentifier).Value;\n\n    // GET tables/Message\n    [ExpandProperty(\"tags\")]\n    public IQueryable<Message> GetAllMessage()\n    {\n        return Query();\n        //return Query().OwnedByFriends(context.Friends, UserId);\n    }\n\n    // GET tables/Message/48D68C86-6EA6-4C25-AA33-223FC9A27959\n    [ExpandProperty(\"tags\")]\n    public SingleResult<Message> GetMessage(string id)\n    {\n        return new SingleResult<Message>(Lookup(id).Queryable);\n        //return new SingleResult<Message>(Lookup(id).Queryable.OwnedByFriends(context.Friends, UserId));\n    }\n\n    // POST tables/Message\n    public async Task<IHttpActionResult> PostMessageAsync(Message item)\n    {\n        item.UserId = UserId;\n        Message current = await InsertAsync(item);\n        return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n    }\n}  Given this is not recommended, what are the alternatives?  There are two alternatives. The first alternative is to\nuse a third table that joins the Messages and Tags together in a loose manner:  using Microsoft.Azure.Mobile.Server;\nusing System.Collections.Generic;\n\nnamespace TaskList.Models\n{\n    public class Tag : EntityData\n    {\n        public string TagName { get; set; }\n    }\n\n    public class Message : EntityData\n    {\n        public string UserId { get; set; }\n        public string Text { get; set; }\n    }\n\n    public class MessageTag : EntityData\n    {\n        public string MessageId { get; set; }\n        public string TagId { get; set; }\n    }\n}  We can now create a  MessageTagController  to retrieve the information.  This data can be stored offline since the model\nis now flat.  Obtaining the list of tags for a message is a single LINQ query:  var tags = from tag in tagTable\n           let tl = (from mt in messageTags where mt.MessageId == messageId select mt.TagId)\n           where tl.Contains(tag.Id)\n           select tag;  You may recognize this LINQ query as it is very similar to the LINQ query used for the friends filter.  A similar query\ncan be used to find the messages associated with a tag:  var msgs = from message in messageTable\n           let tl = (from mt in messageTags where mt.TagId == tagId select mt.MessageId)\n           where tl.Contains(message.Id)\n           orderby message.CreatedAtRoute\n           select message;  The second alternative is to use an alternative DomainManager that implements the relationships for you.  We will cover this\nin the next section.",
            "title": "1:Many Relationships"
        },
        {
            "location": "/chapter3/domainmgr/",
            "text": "The Domain Manager\n\u00b6\n\n\nAs a request comes in to the mobile backend, it is processed through several layers.  First, ASP.NET\nprocesses the request, handling things like Authentication and Authorization.  It is then processed\nthrough the \nMicrosoft.Web.Http.OData\n controller, which compiles the requested query.  Then it is \npassed to the Domain Manager, which is responsible for converting the request into a response.  The\nresponse is then passed back up the stack to be finally given back to the mobile client.\n\n\nThe Domain Manager is a central part of this process.  It is a class that implements the \nIDomainManager\n\ninterface:\n\n\nnamespace Microsoft.Azure.Mobile.Server.Tables\n{\n    public interface IDomainManager<TData> where TData : class, ITableData\n    {\n        IQueryable<TData> Query();\n        SingleResult<TData> Lookup(string id);\n        Task<IEnumerable<TData>> QueryAsync(ODataQueryOptions query);\n        Task<SingleResult<TData>> LookupAsync(string id);\n        Task<TData> InsertAsync(TData data);\n        Task<TData> UpdateAsync(string id, Delta<TData> patch);\n        Task<TData> ReplaceAsync(string id, TData data);\n        Task<bool> DeleteAsync(string id);\n    }\n}\n\n\n\n\nThis looks deceptively simple.  Just 8 methods.  In reality, this is anything but simple.  The major issue\nthat a prospective domain manager implementor has to grapple with is the translation of an \nIQueryable\n into\nsomething that the backend data source can understand.\n\n\nLet's take a look at a couple of domain managers that solve specific problems that crop up from time to time\nduring development.  It should be noted that \nNEITHER\n of these domain managers are recommended as a generalized\nsolution.  They both have significant caveats to their use and you should understand those caveats before\nembarking on integrating them.\n\n\nExisting Table Relationships with the MappedEntityDomainManager\n\u00b6\n\n\nOne of the key areas that is weak when using the default \nEntityDomainManager\n is handling existing tables.  The\ngenerally accepted method of dealing with relationships is through loose coupling and manual relationship management\nin the client. Relationships are core to the SQL database world and we sometimes want to project those relationships \ninto the mobile client, allowing the backend to preserve any relationships that have been configured while still \nusing the standard offline client capabilities.  If you have existing SQL relationships, you can use a combination\nof AutoMattper and the \nMappedEntityDomainManager\n.  \n\n\nThe \nMappedEntityDomainManager\n is an abstract \nIDomainManager\n implementation targetting SQL as the backend store where\nthere is not a 1:1 mapping between the data object (DTO) exposed through the TableController and the domain model managed \nby Entity Framework.  If there is a 1:1 mapping, use \nEntityDomainManager\n.  The \nMappedEntityDomainManager\n uses \n\nAutoMapper\n to map between the DTO and the domain model.  It assumes that AutoMapper has already been initialized with \nappropriate mappings that map from DTO to domain model and from the domain model to the DTO.\n\n\nLet's take a small example.  If I am producing an enterprise mobile app that field engineers can use - the ones\nthat, for example, visit your house to install cable.  I can define an Entity Framework model map as follows:\n\n\n[Table(\"Customers\")]\npublic class Customer\n{\n    public Customer()\n    {\n        this.Jobs = new HashSet<Job>();\n    }\n\n    [StringLength(50)]\n    public string Id { get; set; }\n\n    [StringLength(50)]\n    public string FullName { get; set; }\n\n    [StringLength(250)]\n    public string Address { get; set; \n\n    public decimal? Latitude { get; set; }\n\n    public decimal? Longitude { get; set; }\n\n    public ICollection<Job> Jobs { get; set; }\n}\n\n[Table(\"Equipment\")]\npublic class Equipment : ITableData\n{\n    public Equipment()\n    {\n        this.Jobs = new HashSet<Job>();\n    }\n\n    [StringLength(50)]\n    public string Name { get; set; }\n\n    [StringLength(28)]\n    public string Asset { get; set; }\n\n    [StringLength(250)]\n    public string Description { get; set; }\n\n    #region ITableData\n    public DateTimeOffset? CreatedAt { get; set; }\n    public bool Deleted { get; set; }\n\n    [DatabaseGenerated(DatabaseGeneratedOption.Computed)]\n    public DateTimeOffset? UpdatedAt { get; set; }\n\n    [Timestamp]\n    public byte[] Version { get; set; }\n    #endregion\n\n    public ICollection<Job> Jobs { get; set; }\n}\n\n[Table(\"Jobs\")]\npublic class Job : ITableData\n{\n    public Job()\n    {\n        this.Equipments = new HashSet<Equipment>();\n    }\n\n    [StringLength(50)]\n    public string CustomerId { get; set; }\n\n    [StringLength(50)]\n    public string AgentId { get; set; }\n\n    public DateTimeOffset? StartTime { get; set; }\n\n    public DateTimeOffset? EndTime { get; set; }\n\n    [StringLength(50)]\n    public string Status { get; set; }\n\n    [StringLength(250)]\n    public string Description { get; set; }\n\n    #region ITableData\n    public DateTimeOffset? CreatedAt { get; set; }\n    public bool Deleted { get; set; }\n\n    [DatabaseGenerated(DatabaseGeneratedOption.Computed)]\n    public DateTimeOffset? UpdatedAt { get; set; }\n\n    [Timestamp]\n    public byte[] Version { get; set; }\n    #endregion\n\n    public ICollection<Equipment> Equipments { get; set; }\n}\n\n\n\n\nThis is the representation of the tables within the database.  They don't have to map to what the client\nrequires.  We can wire up the relationships in the normal \nEntity Framework way\n, within the \nDbContext\n:\n\n\npublic partial class ExistingDbContext : DbContext\n{\n    public FieldDbContext() : base(\"name=MS_TableConnectionString\")\n    {            \n    }\n\n    public virtual DbSet<Customer> Customers { get; set; }\n    public virtual DbSet<Equipment> Equipments { get; set; }\n    public virtual DbSet<Job> Jobs { get; set; } \n\n    protected override void OnModelCreating(DbModelBuilder modelBuilder)\n    {            \n        modelBuilder.HasDefaultSchema(\"dbo\");\n        modelBuilder.Conventions.Add(\n            new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n            \"ServiceTableColumn\", (property, attributes) => attributes.Single().ColumnType.ToString()));\n\n        modelBuilder.Entity<Customer>().Property(e => e.Address).IsUnicode(false);\n        modelBuilder.Entity<Customer>().Property(e => e.FullName).IsUnicode(false);\n        modelBuilder.Entity<Customer>().Property(e => e.Id).IsUnicode(false);\n        modelBuilder.Entity<Customer>().Property(e => e.Latitude).HasPrecision(9, 6);\n        modelBuilder.Entity<Customer>().Property(e => e.Longitude).HasPrecision(9, 6);\n\n        modelBuilder.Entity<Equipment>().Property(e => e.Asset).IsUnicode(false);\n        modelBuilder.Entity<Equipment>().Property(e => e.Description).IsUnicode(false);\n        modelBuilder.Entity<Equipment>().Property(e => e.Name).IsUnicode(false);\n        modelBuilder.Entity<Equipment>().Property(e => e.Id).IsUnicode(false);\n\n        modelBuilder.Entity<Job>().Property(e => e.CustomerId).IsUnicode(false);\n        modelBuilder.Entity<Job>().Property(e => e.AgentId).IsUnicode(false);\n        modelBuilder.Entity<Job>().Property(e => e.Id).IsUnicode(false);\n        modelBuilder.Entity<Job>().Property(e => e.Status).IsUnicode(false);\n        modelBuilder.Entity<Job>().Property(e => e.Description).IsUnicode(false);\n\n        modelBuilder.Entity<Equipment>()\n            .HasMany(e => e.Jobs)\n            .WithMany(e => e.Equipments)\n            .Map(m => m.ToTable(\"EquipmentIds\").MapLeftKey(\"EquipmentId\").MapRightKey(\"JobId\"));\n    }\n}\n\n\n\n\nWe can see the relationship (a Many:Many relationship) at the end of the \nmodelBuilder\n within\nthe DbContext.  The 1:Many and 1:1 relationships are handled within the models themselves, per the\nnormal Entity Framework methods. This is pure Entity Framework thus far - we have defined the\nstructure of the database.\n\n\nTo translate this into a mobile client, we need to define Data Transfer Objects.  These don't\nhave to be the same shape as the models that Entity Framework is using.  For example:\n\n\npublic class CustomerDTO\n{\n    public string FullName { get; set; }\n    public string Address { get; set; \n    public decimal? Latitude { get; set; }\n    public decimal? Longitude { get; set; }\n}\n\npublic class EquipmentDTO\n{\n    public string Name { get; set; }\n    public string Asset { get; set; }\n    public string Description { get; set; }\n}\n\npublic class JobDTO : EntityData\n{\n    public string AgentId { get; set; }\n    public DateTimeOffset? StartTime { get; set; }\n    public DateTimeOffset? EndTime { get; set; }\n    public string Status { get; set; }\n    public string Description { get; set; }  \n\n    public virtual CustomerDTO Customer { get; set; }\n    public virtual List<EquipmentDTO> Equipments { get; set; }\n}\n\n\n\n\nNote that the DTOs are similar, but definitely not the same.  They don't have the same relationships between\nthe records, for example.  \nMappedEntityDomainManager\n requires that AutoMapper is already configured and\ninitialized, so that's the next step.  Set up an AutoMapper configuration in the \nApp_Start\n directory:\n\n\nusing AutoMapper;\nusing FieldEngineer.Service.DataObjects;\nusing FieldEngineer.Service.Models;\n\nnamespace FieldEngineer.Service\n{\n    public class AutomapperConfiguration\n    {\n        public static void CreateMapping(IConfiguration cfg)\n        {\n            // Apply some name changes from the entity to the DTO\n            cfg.CreateMap<Job, JobDTO>()                \n                .ForMember(jobDTO => jobDTO.Equipments, map => map.MapFrom(job => job.Equipments));\n\n            // For incoming requests, ignore the relationships\n            cfg.CreateMap<JobDTO, Job>()                                            \n                .ForMember(job => job.Customer, map => map.Ignore())\n                .ForMember(job => job.Equipments, map => map.Ignore());\n\n            cfg.CreateMap<Customer, CustomerDTO>();            \n            cfg.CreateMap<Equipment, EquipmentDTO>();\n        }\n    }\n}\n\n\n\n\nYou will also need to initialize the AutoMapper - this can be done where you also configure the Azure Mobile Apps:\n\n\nusing System;\nusing System.Web.Http;\nusing AutoMapper;\nusing Microsoft.WindowsAzure.Mobile.Service;\n\nnamespace FieldEngineer.Service\n{\n    public static class WebApiConfig\n    {\n        public static void Register()\n        {\n            // Use this class to set configuration options for your mobile service\n            ConfigOptions options = new ConfigOptions();\n\n            // Use this class to set WebAPI configuration options\n            HttpConfiguration config = ServiceConfig.Initialize(new ConfigBuilder(options));\n\n            // To display errors in the browser during development, uncomment the following\n            // line. Comment it out again when you deploy your service for production use.\n            config.IncludeErrorDetailPolicy = IncludeErrorDetailPolicy.Always;\n\n            // This is the line that initializes AutoMapper\n            Mapper.Initialize(cfg => { AutomapperConfiguration.CreateMapping(cfg); });                                \n        }\n    }\n}\n\n\n\n\nFinally, we can create a controller that allows the receipt and update of jobs:\n\n\nnamespace FieldEngineer.Service.Controllers\n{\n    [Authorize]  \n    public class JobController : TableController<JobDTO>\n    {      \n        private FieldDbContext context;        \n\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            this.context = new FieldDbContext();\n\n            this.DomainManager = new DefaultMappedEntityDomainManager<JobDTO,Job>(this.context, Request, Services);            \n        }\n\n        [ExpandProperty(\"Customer\")]\n        [ExpandProperty(\"Equipments\")]\n        public async Task<IQueryable<JobDTO>> GetAllJobs()\n        {                        \n            var jobs = this.context.Jobs\n                .Include(\"Customer\")\n                .Include(\"Equipments\")\n                .Project().To<JobDTO>();            \n            return jobs;\n        }\n\n        [ExpandProperty(\"Customer\")]\n        [ExpandProperty(\"Equipments\")]\n        public SingleResult<JobDTO> GetJob(string id)\n        {\n            return this.Lookup(id);\n        }\n\n        public async Task<JobDTO> PatchJob(string id, Delta<JobDTO> patch)\n        {\n            return await this.UpdateAsync(id, patch);                   \n        }        \n    }\n}\n\n\n\n\nWe are using \n[ExpandProperty]\n to expand the Customer and Equipment data so that it is transferred with the Job object.\nThe \nMappedEntityDomainManager\n is an abstract type, so we have to create a concrete implementation.  Fortunately, most\nof the work is done for us.  There are already concrete versions of most of the methods we require (like insert, delete\nand lookup). The \nMappedEntityDomainManager\n needs help to deal with replacements nor optimistic concurrency - features \nwe want.  We can use the \nDefaultMappedEntityDomainManager\nto handle this for us:\n\n\nnamespace FieldEngineerLite.Service.Helpers\n{\n    public class DefaultMappedEntityDomainManager<TData, TModel>\n            : MappedEntityDomainManager<TData, TModel>\n        where TData : class, ITableData\n        where TModel : class, ITableData\n    {\n        public DefaultMappedEntityDomainManager(DbContext context, HttpRequestMessage request, ApiServices services)\n            : base(context, request, services)\n        {            \n        }\n\n        public override Task<bool> DeleteAsync(string id)\n        {\n            return this.DeleteItemAsync(id);\n        }\n\n        public override Task<TData> UpdateAsync(string id, Delta<TData> patch)\n        {\n            return this.UpdateEntityAsync(patch, id);\n        }\n\n        public override SingleResult<TData> Lookup(string id)\n        {\n            return this.LookupEntity(model => model.Id == id);\n        }\n\n        protected override void SetOriginalVersion(TModel model, byte[] version)\n        {            \n            this.Context.Entry(model).OriginalValues[\"Version\"] = version;\n        }\n    }\n}\n\n\n\n\nThe primary thing that the \nDefaultMappedEntityDomainManager\n does that the original doesn't is in the \nSetOriginalVersion\n\nmethod.  This causes the model to be updated with a new version, allowing for conflict detection in the domain manager.\n\n\nIf we move now to the models on the mobile client, we see some fairly standard models:\n\n\npublic class Customer\n{\n    public string Id { get; set; }\n    public string FullName { get; set; }\n    public string Address { get; set; \n    public decimal? Latitude { get; set; }\n    public decimal? Longitude { get; set; }\n}\n\npublic class Equipment\n{\n    public string Id { get; set; }\n    public string Name { get; set; }\n    public string Asset { get; set; }\n    public string Description { get; set; }\n}\n\npublic class Job\n{\n    public const string CompleteStatus = \"Completed\";\n    public const string InProgressStatus = \"On Site\";\n    public const string PendingStatus = \"Not Started\";\n\n    public string Id { get; set; }\n    public string AgentId { get; set; }\n    public DateTimeOffset? StartTime { get; set; }\n    public DateTimeOffSet? EndTime { get; set; }\n    public string Status { get; set; }\n    public string Description { get; set; }\n\n    public Customer Customer { get; set; }\n    public List<Equipment> Equipments { get; set; }\n\n    [Version]\n    public string Version { get; set; }\n}\n\n\n\n\nIn this case, we only need to sync the Job table, so we can define it in the \nInitializeAsync()\n method on the client:\n\n\npublic async Task InitializeAsync()\n{\n        var store = new MobileServiceSQLiteStore(\"localdata.db\");\n        store.DefineTable<Job>();\n        await MobileService.SyncContext.InitializeAsync(store);\n}\n\n\n\n\nYou can use \nGetSyncTable<Job>()\n to get a reference to the table and deal with it as you normally would.  I'd expect in this\ncase that the Customer and Equipment would be handled elsewhere - maybe a separate web application that customer service\nagents use, for example.\n\n\nSo, what are the caveats?  The first is that the Job, Customer and Equipment data all comes down as one record.  This has a \nside effect of ensuring that the Customer and Equipment data is read-only.  You can only update the information in the Job\ntable.  This is also a very time consuming process to set up properly.  Automapper is known as a fairly picky piece of \nsoftware to integrate, so extra time must be allotted to make it work correctly.\n\n\nIn the end, I prefer handling tables individually and handling relationship management on the mobile client manually.  This\ncauses more code on the mobile client but makes the server much simpler by avoiding most of the complexity of relationships.\n\n\nNoSQL Storage with the StorageDomainManager\n\u00b6\n\n\nWhat if you don't want to use a SQL backend for your service?  Relationships between entities are not that important in the mobile\nclient and Azure Table Storage costs significantly less than SQL Azure.  There are always trade-offs between various storage\nproviders.  A Domain Manager enables you to swap out the storage for one of your own choosing.  Azure Mobile Apps provides \na domain manager for Azure Table Storage.  Azure Table Storage is Microsoft's NOSQL key/attribute store.  It has a schemaless\ndesign, which (at least theoretically) enables you to adapt your data models as the application evolves without having to worry\nabout the schema.\n\n\nTo see this in action, let's rework the existing data store (which has tags and todoitems as tables) to use Table Storage.  First\nup, we need to set up a suitable environment.  This involves:\n\n\n\n\nCreate a Resource Group\n\n\nCreate an Azure App Service\n\n\nSet up authentication on the Azure App Service\n\n\nCreate a Storage Account\n\n\nLink the Storage Account to the Azure App Service.\n\n\n\n\nWe've already covered the first three items in previous chapters.  The important element here is that we do not create a SQL\ndatabase.  We are going to be using Table Storage instead so we don't need it.  To create a Storage Account:\n\n\n\n\nLog on to the \nAzure portal\n.\n\n\nClick the big \n+ NEW\n button in the top left corner.\n\n\nClick \nData + Storage\n, then \nStorage account\n.\n\n\nFill in the form:\n\n\nThe name can only contain letters and numbers and must be unique.  A GUID without the dashes is a good choice.\n\n\nThe \nDeployment model\n should be set to \nResource manager\n.\n\n\nThe \nAccount kind\n should be set to \nGeneral purpose\n.\n\n\nThe \nPerformance\n should be set to \nStandard\n for this example.\n\n\nThe \nReplication\n should be set to \nLocally-redundant storage (LRS)\n.\n\n\nSet the \nResource group\n to your existing resource group.\n\n\nSet the \nLocation\n to the same location as your App Service.\n\n\n\n\n\n\nClick \nCreate\n.\n\n\n\n\nJust like SQL Azure, Azure Storage has some great scalability and redundancy features if your backend takes advantage of them.\nWe have selected the slowest performance and least redundant options here to keep the cost down on your service.\n\n\n\n\nWarn\n\n\nThere is no \"free\" option for Azure Storage.  You pay by the kilobyte depending on the performance and redundancy selected.\n\n\n\n\nOnce the Azure Storage account is deployed, you can link the storage account to your App Service:\n\n\n\n\nOpen your App Service in the \nAzure portal\n.\n\n\nClick  \nData Connections\n under the \nMOBILE\n section in the settings menu.\n\n\nClick \n+ ADD\n\n\nIn the \nAdd data connection\n blade:\n\n\nSet the Type to \nStorage\n.\n\n\nClick the \nStorage\n link.\n\n\nIn the \nStorage Account\n selector, click the storage account you just created.\n\n\nClick the \nConnection string\n.\n\n\nIn the \nConnection string\n selector, make a note of the \nName\n field.\n\n\nClick \nOK\n.\n\n\nClick \nOK\n to close the \nAdd data connection\n blade.\n\n\n\n\n\n\n\n\nClick on the \nApplication Settings\n menu option, then scroll down to the \nConnection Strings\n section.  Note that the portal\nhas created the connection string as an App Setting for you with the right value:\n\n\nDefaultEndpointsProtocol=https;AccountName=thebook;AccountKey=<key1>\n\n\n\n\nThe key is the access key for the storage.  When a storage account is created, two keys are also created.  If you re-generate the\nstorage access keys, remember to update your connection string.  By default, the connection string is called \nMS_AzureStorageAccountConnectionString\n\nand we will use that throughout.\n\n\nNow that our resources are set up, let's look at the Backend project.  This started off as a standard Azure Mobile Apps template.\nThe template assumes you are going to use SQL Azure, so there is quite a bit of work to convert the provided template to use\nAzure Table Storage.  Let's start with the \nApp_Start\\Startup.MobileApp.cs\n file.  There is no Entity Framework, so that needs to\nbe stripped out:\n\n\nusing System.Configuration;\nusing System.Web.Http;\nusing Microsoft.Azure.Mobile.Server;\nusing Microsoft.Azure.Mobile.Server.Authentication;\nusing Microsoft.Azure.Mobile.Server.Config;\nusing Owin;\n\nnamespace Backend\n{\n    public partial class Startup\n    {\n        public static void ConfigureMobileApp(IAppBuilder app)\n        {\n            HttpConfiguration config = new HttpConfiguration();\n\n            new MobileAppConfiguration()\n                .AddTables()\n                .ApplyTo(config);\n\n            app.UseWebApi(config);\n        }\n    }\n}\n\n\n\n\nWe've made three changes:\n\n\n\n\nWe've removed the database seeding.\n\n\nWe've removed the database initializer.\n\n\nWe've changed \nAddTablesWithEntityFramework()\n to \nAddTables()\n.\n\n\n\n\nThere is extra work needed with Entity Framework.  Since we aren't using it, we don't need the additional work.  We do, however,\nneed to create the ASP.NET routes to the table controllers.\n\n\n\n\nTip\n\n\nYou must add the \nMicrosoft.Azure.Mobile.Server.Storage\n package from NuGet. \n\n\n\n\nLet's move onto the DataObjects.  These are very similar:\n\n\nnamespace Backend.DataObjects\n{\n    public class TodoItem : StorageData\n    {\n        public string Text { get; set; }\n        public bool Complete { get; set; }\n    }\n}\n\n\n\n\nEach storage implementation will likely need their own implementation of the \nITableData\n interface.  The \nStorageData\n class \nperforms the same duties as the \nEntityData\n class for Entity Framework based backends.\n\n\n\n\nTip\n\n\nYou can remove the \nModels\n directory and the \nDbContext\n for the project.  These are only needed when working with Entity Framework.\n\n\n\n\nThe Azure Table Storage SDK is completely async driven.  Fortunately, the domain manager specification (codified in the definition\nof \nIDomainManager\n) allows both async and synchronous usage.  This does require a change to our controller:\n\n\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing System.Web.Http.OData.Query;\nusing Backend.DataObjects;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController<TodoItem>\n    {\n        const string connectionString = \"MS_AzureStorageAccountConnectionString\";\n        const string tableName = \"TodoItem\";\n\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            DomainManager = new StorageDomainManager<TodoItem>(connectionString, tableName, Request, enableSoftDelete: true);\n        }\n\n        // GET tables/TodoItem\n        public async Task<IEnumerable<TodoItem>> GetAllTodoItemsAsync(ODataQueryOptions query)\n        {\n            return await QueryAsync(query);\n        }\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public async Task<SingleResult<TodoItem>> GetTodoItemAsync(string id)\n        {\n            return await LookupAsync(id);\n        }\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public async Task<TodoItem> PatchTodoItemAsync(string id, Delta<TodoItem> patch)\n        {\n            return await UpdateAsync(id, patch);\n        }\n\n        // POST tables/TodoItem\n        public async Task<IHttpActionResult> PostTodoItemAsync(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public async Task DeleteTodoItemAsync(string id)\n        {\n            await DeleteAsync(id);\n        }\n    }\n}\n\n\n\n\nNote how we instantiate the storage domain controller.  This requires a connection string and the name of the table.  We\nhave created the connection string in the portal, but we have not exposed that connection string to our ASP.NET application.\nWe need to edit the \nWeb.config\n file as well:\n\n\n<connectionStrings>\n    <add name=\"MS_AzureStorageAccountConnectionString\" connectionString=\"UseDevelopmentStorage=true\"/>\n</connectionStrings>\n\n\n\n\nThis will be overwritten by the connection string in the portal.  If you are running the service locally, you can use this\nsetting with the Azure Storage Emulator.  If you don't add this line to the \nWeb.config\n, you will not be able to run this\nserver locally.\n\n\nThis backend can now be published and we can work with Postman to test it out.  For instance, let's try adding a simple test\nof getting some data:\n\n\n\n\nThis is exactly the same response as we got when we don't have any data from the Entity Framework version.  Let's add a \nrecord:\n\n\n\n\nThere are a couple of things to note here.  Firstly, the Id must be specified.  It also must be of a specific form.  There\nare two numbers.  The first is a partition key and the second is a row key.  Tables are partitioned to support load balancing\nacross storage notes.  It can be anything you wish it to be.  Similarly, the row key is unique within a partition.  We can\nuse this information to generate a suitable Id if one is not provided:\n\n\n// POST tables/TodoItem\npublic async Task<IHttpActionResult> PostTodoItemAsync(TodoItem item)\n{\n    if (item.Id == null || item.Id == \"'',''\")\n    {\n        item.Id = GenerateUniqueId();\n    }\n    TodoItem current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}\n\nprivate string GenerateUniqueId()\n{\n    var partitionId = \"1\";\n    var rowId = Guid.NewGuid().ToString(\"N\");\n    return $\"'{partitionId}','{rowId}'\";\n}\n\n\n\n\nThe value \n'',''\n is the default value of the Id column.  However, that is not good enough to get a successful store.  This code\ngenerates a unique identifier in the right format.  A single partition is reasonable for most applications.  If you intend on\nstoring massive amounts of data, the data partitioning scheme will require some consideration (just like any other NoSQL application).\n\n\n\n\nTip\n\n\nYou will need a copy of the \nGenerateUniqueId()\n method if you generate unique identifiers for your records within \nyour mobile client.  The partition key and row key are returned as part of the record.  \n\n\n\n\nYou can use the \nCloud Explorer\n if you wish to see the data stored in Azure Table Storage.  Expand the \nStorage Accounts\n node,\nthen expand the appropriate nodes: your storage account, \nTables\n, \nTodoItem\n.  You can open the table editor or delete the table\nfrom there.  \n\n\n\n\nWithin the table editor, you can right-click on any row to delete or edit values.  This will update the time stamp and etag, ensuring\nthat your mobile clients are updated as well.\n\n\nThere are, of course, caveats to working in Azure Mobile Apps with Azure Table Storage.   There are three major caveats that you should\nbe aware of.\n\n\n\n\nThere are no relationships possible with Azure Table Storage.\n\n\nOnly \n$filter\n, \n$top\n and \n$select\n are supported in the URI.\n\n\nOffline sync only supports flat objects.\n\n\n\n\nLet's take a look at each in turn.\n\n\n1. There are no relationhips\n\u00b6\n\n\nYou have to work at relationships and relationships between entities are severely restricted in Entity Framework.  However, they are\npossible.  Not so with Azure Table Storage.  The NoSQL store has no concept of a relationship of any description.  This is not a major\ncaveat since your mobile client similarly has no notion of relationships.  Just treat every table as distinct.\n\n\n2. Limited support for OData query options\n\u00b6\n\n\nOnly \n$filter\n, \n$top\n and \n$select\n are \nsupported by the OData interface\n.  Since the Azure Table Storage Domain Manager passes the \nincoming OData query to the Storage driver intact, this limitation is passed on to the OData interface for Azure Mobile Apps.  Specifically, \nthis means paging is handled differently.  With the \nEntityDomainManager\n, paging was accomplished by using \n$skip\n and \n$top\n to get more\nrecords until zero records were returned.  With the \nStorageDomainManager\n, a \nLink\n header is returned when there are more records.\n\n\n\n\nThe \nLink\n header contains the URI that you need to retrieve to get the next page of the results.  This has implications for how you \nreceive more than 50 records.\n\n\n3. Offline sync only supports \"flat\" objects\n\u00b6\n\n\nOne of the common reasons for using NoSQL stores is that you can store pretty much any document you wish.  You just have to have a JSON\nrepresentation of the object cross the wire.  If you have complex objects stored in Azure Table Storage, they won't be able to be stored\nin the offline cache.  The offline cache is based on SQLite and inherits the limitations of that resource.  In particular, this means no\ncomplex types.\n\n\nUsing a NoSQL store seems like a great idea.  However, the limitations of the platform make Azure Table Storage a poor choice for this\nparticular function.  The Azure Table Storage is ill-suited to the demands of a mobile client backend.\n\n\nOne of the great uses of the Azure Table Storage Domain Manager is to see how you can write your own domain manager.  The \ncode\n for\nthe domain manager (and the ITableData interface) is relatively simple since it passes through the OData query to Azure Storage.  This\nallows you to see what is truly involved in writing a domain manager.",
            "title": "The Domain Manager"
        },
        {
            "location": "/chapter3/domainmgr/#the-domain-manager",
            "text": "As a request comes in to the mobile backend, it is processed through several layers.  First, ASP.NET\nprocesses the request, handling things like Authentication and Authorization.  It is then processed\nthrough the  Microsoft.Web.Http.OData  controller, which compiles the requested query.  Then it is \npassed to the Domain Manager, which is responsible for converting the request into a response.  The\nresponse is then passed back up the stack to be finally given back to the mobile client.  The Domain Manager is a central part of this process.  It is a class that implements the  IDomainManager \ninterface:  namespace Microsoft.Azure.Mobile.Server.Tables\n{\n    public interface IDomainManager<TData> where TData : class, ITableData\n    {\n        IQueryable<TData> Query();\n        SingleResult<TData> Lookup(string id);\n        Task<IEnumerable<TData>> QueryAsync(ODataQueryOptions query);\n        Task<SingleResult<TData>> LookupAsync(string id);\n        Task<TData> InsertAsync(TData data);\n        Task<TData> UpdateAsync(string id, Delta<TData> patch);\n        Task<TData> ReplaceAsync(string id, TData data);\n        Task<bool> DeleteAsync(string id);\n    }\n}  This looks deceptively simple.  Just 8 methods.  In reality, this is anything but simple.  The major issue\nthat a prospective domain manager implementor has to grapple with is the translation of an  IQueryable  into\nsomething that the backend data source can understand.  Let's take a look at a couple of domain managers that solve specific problems that crop up from time to time\nduring development.  It should be noted that  NEITHER  of these domain managers are recommended as a generalized\nsolution.  They both have significant caveats to their use and you should understand those caveats before\nembarking on integrating them.",
            "title": "The Domain Manager"
        },
        {
            "location": "/chapter3/domainmgr/#existing-table-relationships-with-the-mappedentitydomainmanager",
            "text": "One of the key areas that is weak when using the default  EntityDomainManager  is handling existing tables.  The\ngenerally accepted method of dealing with relationships is through loose coupling and manual relationship management\nin the client. Relationships are core to the SQL database world and we sometimes want to project those relationships \ninto the mobile client, allowing the backend to preserve any relationships that have been configured while still \nusing the standard offline client capabilities.  If you have existing SQL relationships, you can use a combination\nof AutoMattper and the  MappedEntityDomainManager .    The  MappedEntityDomainManager  is an abstract  IDomainManager  implementation targetting SQL as the backend store where\nthere is not a 1:1 mapping between the data object (DTO) exposed through the TableController and the domain model managed \nby Entity Framework.  If there is a 1:1 mapping, use  EntityDomainManager .  The  MappedEntityDomainManager  uses  AutoMapper  to map between the DTO and the domain model.  It assumes that AutoMapper has already been initialized with \nappropriate mappings that map from DTO to domain model and from the domain model to the DTO.  Let's take a small example.  If I am producing an enterprise mobile app that field engineers can use - the ones\nthat, for example, visit your house to install cable.  I can define an Entity Framework model map as follows:  [Table(\"Customers\")]\npublic class Customer\n{\n    public Customer()\n    {\n        this.Jobs = new HashSet<Job>();\n    }\n\n    [StringLength(50)]\n    public string Id { get; set; }\n\n    [StringLength(50)]\n    public string FullName { get; set; }\n\n    [StringLength(250)]\n    public string Address { get; set; \n\n    public decimal? Latitude { get; set; }\n\n    public decimal? Longitude { get; set; }\n\n    public ICollection<Job> Jobs { get; set; }\n}\n\n[Table(\"Equipment\")]\npublic class Equipment : ITableData\n{\n    public Equipment()\n    {\n        this.Jobs = new HashSet<Job>();\n    }\n\n    [StringLength(50)]\n    public string Name { get; set; }\n\n    [StringLength(28)]\n    public string Asset { get; set; }\n\n    [StringLength(250)]\n    public string Description { get; set; }\n\n    #region ITableData\n    public DateTimeOffset? CreatedAt { get; set; }\n    public bool Deleted { get; set; }\n\n    [DatabaseGenerated(DatabaseGeneratedOption.Computed)]\n    public DateTimeOffset? UpdatedAt { get; set; }\n\n    [Timestamp]\n    public byte[] Version { get; set; }\n    #endregion\n\n    public ICollection<Job> Jobs { get; set; }\n}\n\n[Table(\"Jobs\")]\npublic class Job : ITableData\n{\n    public Job()\n    {\n        this.Equipments = new HashSet<Equipment>();\n    }\n\n    [StringLength(50)]\n    public string CustomerId { get; set; }\n\n    [StringLength(50)]\n    public string AgentId { get; set; }\n\n    public DateTimeOffset? StartTime { get; set; }\n\n    public DateTimeOffset? EndTime { get; set; }\n\n    [StringLength(50)]\n    public string Status { get; set; }\n\n    [StringLength(250)]\n    public string Description { get; set; }\n\n    #region ITableData\n    public DateTimeOffset? CreatedAt { get; set; }\n    public bool Deleted { get; set; }\n\n    [DatabaseGenerated(DatabaseGeneratedOption.Computed)]\n    public DateTimeOffset? UpdatedAt { get; set; }\n\n    [Timestamp]\n    public byte[] Version { get; set; }\n    #endregion\n\n    public ICollection<Equipment> Equipments { get; set; }\n}  This is the representation of the tables within the database.  They don't have to map to what the client\nrequires.  We can wire up the relationships in the normal  Entity Framework way , within the  DbContext :  public partial class ExistingDbContext : DbContext\n{\n    public FieldDbContext() : base(\"name=MS_TableConnectionString\")\n    {            \n    }\n\n    public virtual DbSet<Customer> Customers { get; set; }\n    public virtual DbSet<Equipment> Equipments { get; set; }\n    public virtual DbSet<Job> Jobs { get; set; } \n\n    protected override void OnModelCreating(DbModelBuilder modelBuilder)\n    {            \n        modelBuilder.HasDefaultSchema(\"dbo\");\n        modelBuilder.Conventions.Add(\n            new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n            \"ServiceTableColumn\", (property, attributes) => attributes.Single().ColumnType.ToString()));\n\n        modelBuilder.Entity<Customer>().Property(e => e.Address).IsUnicode(false);\n        modelBuilder.Entity<Customer>().Property(e => e.FullName).IsUnicode(false);\n        modelBuilder.Entity<Customer>().Property(e => e.Id).IsUnicode(false);\n        modelBuilder.Entity<Customer>().Property(e => e.Latitude).HasPrecision(9, 6);\n        modelBuilder.Entity<Customer>().Property(e => e.Longitude).HasPrecision(9, 6);\n\n        modelBuilder.Entity<Equipment>().Property(e => e.Asset).IsUnicode(false);\n        modelBuilder.Entity<Equipment>().Property(e => e.Description).IsUnicode(false);\n        modelBuilder.Entity<Equipment>().Property(e => e.Name).IsUnicode(false);\n        modelBuilder.Entity<Equipment>().Property(e => e.Id).IsUnicode(false);\n\n        modelBuilder.Entity<Job>().Property(e => e.CustomerId).IsUnicode(false);\n        modelBuilder.Entity<Job>().Property(e => e.AgentId).IsUnicode(false);\n        modelBuilder.Entity<Job>().Property(e => e.Id).IsUnicode(false);\n        modelBuilder.Entity<Job>().Property(e => e.Status).IsUnicode(false);\n        modelBuilder.Entity<Job>().Property(e => e.Description).IsUnicode(false);\n\n        modelBuilder.Entity<Equipment>()\n            .HasMany(e => e.Jobs)\n            .WithMany(e => e.Equipments)\n            .Map(m => m.ToTable(\"EquipmentIds\").MapLeftKey(\"EquipmentId\").MapRightKey(\"JobId\"));\n    }\n}  We can see the relationship (a Many:Many relationship) at the end of the  modelBuilder  within\nthe DbContext.  The 1:Many and 1:1 relationships are handled within the models themselves, per the\nnormal Entity Framework methods. This is pure Entity Framework thus far - we have defined the\nstructure of the database.  To translate this into a mobile client, we need to define Data Transfer Objects.  These don't\nhave to be the same shape as the models that Entity Framework is using.  For example:  public class CustomerDTO\n{\n    public string FullName { get; set; }\n    public string Address { get; set; \n    public decimal? Latitude { get; set; }\n    public decimal? Longitude { get; set; }\n}\n\npublic class EquipmentDTO\n{\n    public string Name { get; set; }\n    public string Asset { get; set; }\n    public string Description { get; set; }\n}\n\npublic class JobDTO : EntityData\n{\n    public string AgentId { get; set; }\n    public DateTimeOffset? StartTime { get; set; }\n    public DateTimeOffset? EndTime { get; set; }\n    public string Status { get; set; }\n    public string Description { get; set; }  \n\n    public virtual CustomerDTO Customer { get; set; }\n    public virtual List<EquipmentDTO> Equipments { get; set; }\n}  Note that the DTOs are similar, but definitely not the same.  They don't have the same relationships between\nthe records, for example.   MappedEntityDomainManager  requires that AutoMapper is already configured and\ninitialized, so that's the next step.  Set up an AutoMapper configuration in the  App_Start  directory:  using AutoMapper;\nusing FieldEngineer.Service.DataObjects;\nusing FieldEngineer.Service.Models;\n\nnamespace FieldEngineer.Service\n{\n    public class AutomapperConfiguration\n    {\n        public static void CreateMapping(IConfiguration cfg)\n        {\n            // Apply some name changes from the entity to the DTO\n            cfg.CreateMap<Job, JobDTO>()                \n                .ForMember(jobDTO => jobDTO.Equipments, map => map.MapFrom(job => job.Equipments));\n\n            // For incoming requests, ignore the relationships\n            cfg.CreateMap<JobDTO, Job>()                                            \n                .ForMember(job => job.Customer, map => map.Ignore())\n                .ForMember(job => job.Equipments, map => map.Ignore());\n\n            cfg.CreateMap<Customer, CustomerDTO>();            \n            cfg.CreateMap<Equipment, EquipmentDTO>();\n        }\n    }\n}  You will also need to initialize the AutoMapper - this can be done where you also configure the Azure Mobile Apps:  using System;\nusing System.Web.Http;\nusing AutoMapper;\nusing Microsoft.WindowsAzure.Mobile.Service;\n\nnamespace FieldEngineer.Service\n{\n    public static class WebApiConfig\n    {\n        public static void Register()\n        {\n            // Use this class to set configuration options for your mobile service\n            ConfigOptions options = new ConfigOptions();\n\n            // Use this class to set WebAPI configuration options\n            HttpConfiguration config = ServiceConfig.Initialize(new ConfigBuilder(options));\n\n            // To display errors in the browser during development, uncomment the following\n            // line. Comment it out again when you deploy your service for production use.\n            config.IncludeErrorDetailPolicy = IncludeErrorDetailPolicy.Always;\n\n            // This is the line that initializes AutoMapper\n            Mapper.Initialize(cfg => { AutomapperConfiguration.CreateMapping(cfg); });                                \n        }\n    }\n}  Finally, we can create a controller that allows the receipt and update of jobs:  namespace FieldEngineer.Service.Controllers\n{\n    [Authorize]  \n    public class JobController : TableController<JobDTO>\n    {      \n        private FieldDbContext context;        \n\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            this.context = new FieldDbContext();\n\n            this.DomainManager = new DefaultMappedEntityDomainManager<JobDTO,Job>(this.context, Request, Services);            \n        }\n\n        [ExpandProperty(\"Customer\")]\n        [ExpandProperty(\"Equipments\")]\n        public async Task<IQueryable<JobDTO>> GetAllJobs()\n        {                        \n            var jobs = this.context.Jobs\n                .Include(\"Customer\")\n                .Include(\"Equipments\")\n                .Project().To<JobDTO>();            \n            return jobs;\n        }\n\n        [ExpandProperty(\"Customer\")]\n        [ExpandProperty(\"Equipments\")]\n        public SingleResult<JobDTO> GetJob(string id)\n        {\n            return this.Lookup(id);\n        }\n\n        public async Task<JobDTO> PatchJob(string id, Delta<JobDTO> patch)\n        {\n            return await this.UpdateAsync(id, patch);                   \n        }        \n    }\n}  We are using  [ExpandProperty]  to expand the Customer and Equipment data so that it is transferred with the Job object.\nThe  MappedEntityDomainManager  is an abstract type, so we have to create a concrete implementation.  Fortunately, most\nof the work is done for us.  There are already concrete versions of most of the methods we require (like insert, delete\nand lookup). The  MappedEntityDomainManager  needs help to deal with replacements nor optimistic concurrency - features \nwe want.  We can use the  DefaultMappedEntityDomainManager to handle this for us:  namespace FieldEngineerLite.Service.Helpers\n{\n    public class DefaultMappedEntityDomainManager<TData, TModel>\n            : MappedEntityDomainManager<TData, TModel>\n        where TData : class, ITableData\n        where TModel : class, ITableData\n    {\n        public DefaultMappedEntityDomainManager(DbContext context, HttpRequestMessage request, ApiServices services)\n            : base(context, request, services)\n        {            \n        }\n\n        public override Task<bool> DeleteAsync(string id)\n        {\n            return this.DeleteItemAsync(id);\n        }\n\n        public override Task<TData> UpdateAsync(string id, Delta<TData> patch)\n        {\n            return this.UpdateEntityAsync(patch, id);\n        }\n\n        public override SingleResult<TData> Lookup(string id)\n        {\n            return this.LookupEntity(model => model.Id == id);\n        }\n\n        protected override void SetOriginalVersion(TModel model, byte[] version)\n        {            \n            this.Context.Entry(model).OriginalValues[\"Version\"] = version;\n        }\n    }\n}  The primary thing that the  DefaultMappedEntityDomainManager  does that the original doesn't is in the  SetOriginalVersion \nmethod.  This causes the model to be updated with a new version, allowing for conflict detection in the domain manager.  If we move now to the models on the mobile client, we see some fairly standard models:  public class Customer\n{\n    public string Id { get; set; }\n    public string FullName { get; set; }\n    public string Address { get; set; \n    public decimal? Latitude { get; set; }\n    public decimal? Longitude { get; set; }\n}\n\npublic class Equipment\n{\n    public string Id { get; set; }\n    public string Name { get; set; }\n    public string Asset { get; set; }\n    public string Description { get; set; }\n}\n\npublic class Job\n{\n    public const string CompleteStatus = \"Completed\";\n    public const string InProgressStatus = \"On Site\";\n    public const string PendingStatus = \"Not Started\";\n\n    public string Id { get; set; }\n    public string AgentId { get; set; }\n    public DateTimeOffset? StartTime { get; set; }\n    public DateTimeOffSet? EndTime { get; set; }\n    public string Status { get; set; }\n    public string Description { get; set; }\n\n    public Customer Customer { get; set; }\n    public List<Equipment> Equipments { get; set; }\n\n    [Version]\n    public string Version { get; set; }\n}  In this case, we only need to sync the Job table, so we can define it in the  InitializeAsync()  method on the client:  public async Task InitializeAsync()\n{\n        var store = new MobileServiceSQLiteStore(\"localdata.db\");\n        store.DefineTable<Job>();\n        await MobileService.SyncContext.InitializeAsync(store);\n}  You can use  GetSyncTable<Job>()  to get a reference to the table and deal with it as you normally would.  I'd expect in this\ncase that the Customer and Equipment would be handled elsewhere - maybe a separate web application that customer service\nagents use, for example.  So, what are the caveats?  The first is that the Job, Customer and Equipment data all comes down as one record.  This has a \nside effect of ensuring that the Customer and Equipment data is read-only.  You can only update the information in the Job\ntable.  This is also a very time consuming process to set up properly.  Automapper is known as a fairly picky piece of \nsoftware to integrate, so extra time must be allotted to make it work correctly.  In the end, I prefer handling tables individually and handling relationship management on the mobile client manually.  This\ncauses more code on the mobile client but makes the server much simpler by avoiding most of the complexity of relationships.",
            "title": "Existing Table Relationships with the MappedEntityDomainManager"
        },
        {
            "location": "/chapter3/domainmgr/#1-there-are-no-relationhips",
            "text": "You have to work at relationships and relationships between entities are severely restricted in Entity Framework.  However, they are\npossible.  Not so with Azure Table Storage.  The NoSQL store has no concept of a relationship of any description.  This is not a major\ncaveat since your mobile client similarly has no notion of relationships.  Just treat every table as distinct.",
            "title": "1. There are no relationhips"
        },
        {
            "location": "/chapter3/domainmgr/#2-limited-support-for-odata-query-options",
            "text": "Only  $filter ,  $top  and  $select  are  supported by the OData interface .  Since the Azure Table Storage Domain Manager passes the \nincoming OData query to the Storage driver intact, this limitation is passed on to the OData interface for Azure Mobile Apps.  Specifically, \nthis means paging is handled differently.  With the  EntityDomainManager , paging was accomplished by using  $skip  and  $top  to get more\nrecords until zero records were returned.  With the  StorageDomainManager , a  Link  header is returned when there are more records.   The  Link  header contains the URI that you need to retrieve to get the next page of the results.  This has implications for how you \nreceive more than 50 records.",
            "title": "2. Limited support for OData query options"
        },
        {
            "location": "/chapter3/domainmgr/#3-offline-sync-only-supports-flat-objects",
            "text": "One of the common reasons for using NoSQL stores is that you can store pretty much any document you wish.  You just have to have a JSON\nrepresentation of the object cross the wire.  If you have complex objects stored in Azure Table Storage, they won't be able to be stored\nin the offline cache.  The offline cache is based on SQLite and inherits the limitations of that resource.  In particular, this means no\ncomplex types.  Using a NoSQL store seems like a great idea.  However, the limitations of the platform make Azure Table Storage a poor choice for this\nparticular function.  The Azure Table Storage is ill-suited to the demands of a mobile client backend.  One of the great uses of the Azure Table Storage Domain Manager is to see how you can write your own domain manager.  The  code  for\nthe domain manager (and the ITableData interface) is relatively simple since it passes through the OData query to Azure Storage.  This\nallows you to see what is truly involved in writing a domain manager.",
            "title": "3. Offline sync only supports \"flat\" objects"
        },
        {
            "location": "/chapter4/options/",
            "text": "Server Side Code\n\u00b6\n\n\nAt some point during your mobile client development, you will need to do something a little outside simple\ndata access.  We have already seen an example of this in custom authentication.  It may be that you want to\nkick off a workflow, re-size an image using server-side resources, push a notification to another user, or\ndo a complex transaction on the database.\n\n\nWhatever the reason, that time si when you want to use server side code.  The aim is simple enough.  On a\ntrigger, execute some code and do something with the result.  The trigger can be as simple as a HTTP request\nfrom your client, but could also be in response to a timer, or because something in your environment\nhappened.  The result can be sent back to the user, placed in storage, or updated in the database.  There\nreally are no rules when it comes to server side code.\n\n\nThere are, however, options for running server side code.\n\n\nClient Processing with WebAPIs and Custom APIs\n\u00b6\n\n\nThe first of the set is the venerable \nASP.NET WebAPI\n.  Firstly, configure the ASP.NET application to allow\nattribute-based routing.  This is done in your \nStartup.MobileApp.cs\n file with this line:\n\n\n    config.MapHttpAttributeRoutes();\n\n\n\n\nAny WebAPI that you provide must be preceded by a \n[Route]\n attribute.  We saw an example of this in the\n\nCustom Authentication\n section.  In custom authentication, we were setting up an endpoint that allows\nus to validate a login request.  The attribute looked like this:\n\n\nnamespace Backend.Controllers\n{\n    [Route(\".auth/login/custom\")]\n    public class CustomAuthController : ApiController\n    {\n        [HttpPost]\n        public async Task<IHttpActionResult> Post([FromBody] UserInfo body)\n        {\n            ...\n        }\n    }\n}\n\n\n\n\nThe ASP.NET WebAPI comes with a bunch of capabilities:\n\n\n\n\nYou can use your regular ASP.NET WebAPI programming techniques.\n\n\nYou can use Entity Framework for adjusting the database.\n\n\nYou can use the \n[Authorize]\n attribute for controlling access.\n\n\n\n\nWith ASP.NET WebAPI, you are responsible for absolutely everything.  This option is great for providing\nan endpoint to your mobile client that doesn't need anything special.\n\n\nAs flexible as the ASP.NET WebAPI is, most of the time you just want to do something and get the result\nreturned.  The Custom API feature of the Azure Mobile Apps SDK is a great option because it does a lot\nof the scaffolding for you.  With a Custom API:\n\n\n\n\nYour API appears under '/api' - no exceptions.\n\n\nThe server enforces the ZUMO-API-VERSION.\n\n\nThe server emits a X-ZUMO-SERVER-VERSION header in the response.\n\n\n\n\nYou can be sure, for example, that a random web crawler is not going to call your Custom API - the web crawler\nis not going to provide the \nZUMO-API-VERSION\n header, so your code would never be touched.  The Azure\nMobile Apps Client SDK also includes a routine that assumes a Custom API.  For example, let's say you\ncreate a \nValuesController\n, then you can call this from your mobile client with the following code:\n\n\nvar result = client.InvokeApiAsync<ResultType>('Values');\n\n\n\n\nUsing \nInvokeApiAsync\n is a good alternative because it provides the authentication automatically for you\nand uses any \nDelegatingHandler\n classes you have configured.\n\n\n\n\nTip\n\n\nYou can still use \nInvokeApiAsync()\n with an ASP.NET WebAPI.\n\n\n\n\nBackground Processing with WebJobs & Azure Functions\n\u00b6\n\n\nThe ASP.NET WebAPI and the Custom API provide HTTP endpoints for your mobile clients to interact with.  \nWebJobs\n\nand \nAzure Functions\n, by comparison, are primed for background tasks.  Things that WebJobs and Azure Functions\nare good at:\n\n\n\n\nImage processing or other CPU-intensive work.\n\n\nQueue processing.\n\n\nRSS aggregation.\n\n\nFile and database management.\n\n\n\n\nWebJobs\n run in the context of your site.  They use the same set of virtual machines that your website uses and\nthey share resources with your site.  That means that running memory or CPU intensive jobs can affect your\nmobile backend.\n\n\nAzure Functions\n run in a separate project and run in \"dynamic compute\".  They don't run on your virtual machines.\nRather, they pick up compute power from wherever it is available.  The scaling and lifecycle of the Function\nis handled for you by the platform.  The downside is that you have to configure it as a separate project and\nyou pay for the executions separately.\n\n\nBest Practices\n\u00b6\n\n\nFor each thing we have defined, we have two choices.  There are reasons to use each and every one of these\noptions.  So, which do you choose.  Here are my choices:\n\n\n\n\nUse a \nCustom API\n for basic web endpoints.\n\n\nUse a \nWebAPI\n for custom authentication and anything where you care about the shape of the API.\n\n\nUse \nWebJobs\n for clean-up tasks running on a schedule.\n\n\nUse \nFunctions\n for triggered batch processing, like image or queue processing.\n\n\n\n\nMost mobile applications will be able to work with the following:\n\n\n\n\nA single \nWebJob\n for cleaning up the database deleted records.\n\n\nA \nCustom API\n for doing transaction work or triggering a batch process.\n\n\nAn \nAzure Function\n for doing the batch processing.",
            "title": "Options"
        },
        {
            "location": "/chapter4/options/#server-side-code",
            "text": "At some point during your mobile client development, you will need to do something a little outside simple\ndata access.  We have already seen an example of this in custom authentication.  It may be that you want to\nkick off a workflow, re-size an image using server-side resources, push a notification to another user, or\ndo a complex transaction on the database.  Whatever the reason, that time si when you want to use server side code.  The aim is simple enough.  On a\ntrigger, execute some code and do something with the result.  The trigger can be as simple as a HTTP request\nfrom your client, but could also be in response to a timer, or because something in your environment\nhappened.  The result can be sent back to the user, placed in storage, or updated in the database.  There\nreally are no rules when it comes to server side code.  There are, however, options for running server side code.",
            "title": "Server Side Code"
        },
        {
            "location": "/chapter4/options/#client-processing-with-webapis-and-custom-apis",
            "text": "The first of the set is the venerable  ASP.NET WebAPI .  Firstly, configure the ASP.NET application to allow\nattribute-based routing.  This is done in your  Startup.MobileApp.cs  file with this line:      config.MapHttpAttributeRoutes();  Any WebAPI that you provide must be preceded by a  [Route]  attribute.  We saw an example of this in the Custom Authentication  section.  In custom authentication, we were setting up an endpoint that allows\nus to validate a login request.  The attribute looked like this:  namespace Backend.Controllers\n{\n    [Route(\".auth/login/custom\")]\n    public class CustomAuthController : ApiController\n    {\n        [HttpPost]\n        public async Task<IHttpActionResult> Post([FromBody] UserInfo body)\n        {\n            ...\n        }\n    }\n}  The ASP.NET WebAPI comes with a bunch of capabilities:   You can use your regular ASP.NET WebAPI programming techniques.  You can use Entity Framework for adjusting the database.  You can use the  [Authorize]  attribute for controlling access.   With ASP.NET WebAPI, you are responsible for absolutely everything.  This option is great for providing\nan endpoint to your mobile client that doesn't need anything special.  As flexible as the ASP.NET WebAPI is, most of the time you just want to do something and get the result\nreturned.  The Custom API feature of the Azure Mobile Apps SDK is a great option because it does a lot\nof the scaffolding for you.  With a Custom API:   Your API appears under '/api' - no exceptions.  The server enforces the ZUMO-API-VERSION.  The server emits a X-ZUMO-SERVER-VERSION header in the response.   You can be sure, for example, that a random web crawler is not going to call your Custom API - the web crawler\nis not going to provide the  ZUMO-API-VERSION  header, so your code would never be touched.  The Azure\nMobile Apps Client SDK also includes a routine that assumes a Custom API.  For example, let's say you\ncreate a  ValuesController , then you can call this from your mobile client with the following code:  var result = client.InvokeApiAsync<ResultType>('Values');  Using  InvokeApiAsync  is a good alternative because it provides the authentication automatically for you\nand uses any  DelegatingHandler  classes you have configured.   Tip  You can still use  InvokeApiAsync()  with an ASP.NET WebAPI.",
            "title": "Client Processing with WebAPIs and Custom APIs"
        },
        {
            "location": "/chapter4/options/#background-processing-with-webjobs-azure-functions",
            "text": "The ASP.NET WebAPI and the Custom API provide HTTP endpoints for your mobile clients to interact with.   WebJobs \nand  Azure Functions , by comparison, are primed for background tasks.  Things that WebJobs and Azure Functions\nare good at:   Image processing or other CPU-intensive work.  Queue processing.  RSS aggregation.  File and database management.   WebJobs  run in the context of your site.  They use the same set of virtual machines that your website uses and\nthey share resources with your site.  That means that running memory or CPU intensive jobs can affect your\nmobile backend.  Azure Functions  run in a separate project and run in \"dynamic compute\".  They don't run on your virtual machines.\nRather, they pick up compute power from wherever it is available.  The scaling and lifecycle of the Function\nis handled for you by the platform.  The downside is that you have to configure it as a separate project and\nyou pay for the executions separately.",
            "title": "Background Processing with WebJobs &amp; Azure Functions"
        },
        {
            "location": "/chapter4/options/#best-practices",
            "text": "For each thing we have defined, we have two choices.  There are reasons to use each and every one of these\noptions.  So, which do you choose.  Here are my choices:   Use a  Custom API  for basic web endpoints.  Use a  WebAPI  for custom authentication and anything where you care about the shape of the API.  Use  WebJobs  for clean-up tasks running on a schedule.  Use  Functions  for triggered batch processing, like image or queue processing.   Most mobile applications will be able to work with the following:   A single  WebJob  for cleaning up the database deleted records.  A  Custom API  for doing transaction work or triggering a batch process.  An  Azure Function  for doing the batch processing.",
            "title": "Best Practices"
        },
        {
            "location": "/chapter4/custom/",
            "text": "Custom HTTP Endpoints\n\u00b6\n\n\nAzure Mobile Apps makes it really easy to develop basic APIs that can be used in mobile clients.  Most\ncustom APIs can be simply invoked.  Azure Mobile Apps takes care of most of the scaffolding for you. The\nserver SDK will:\n\n\n\n\nEnsure the \nZUMO-API-VERSION\n is present and valid.\n\n\nHandle serialization and deserialization of JSON.\n\n\nEnsure the API is given an appropriate URL.\n\n\n\n\nAll the custom APIs will appear under the \n/api\n endpoint.  For example, if you created a controller\ncalled \nFooController\n, it would be invoked by sending messages to \n/api/Foo\n.  This is case-insensitive,\nso you could also reference this API as \n/api/foo\n.\n\n\nConfiguring Custom APIs\n\u00b6\n\n\nBefore anything happens, you must add the \nMapApiControllers()\n method to the \nMobileAppConfiguration()\n\ncall.  This is done in the \nConfigureMobileApp()\n method in \nApp_Start\\Startup.MobileApp.cs\n file:\n\n\n    new MobileAppConfiguration()\n        .AddTablesWithEntityFramework()     /* /tables endpoints */\n        .MapApiControllers()                /* /api endpoints */\n        .ApplyTo(config);\n\n\n\n\nThe \nMapApiControllers()\n extension method does the actual work of looking for custom APIs and mapping them\nonto the \n/api\n endpoint.\n\n\nCreating a Basic Custom API\n\u00b6\n\n\nYou might remember that the original Azure Mobile Apps project within Visual Studio comes with a sample\ncustom API called the \nValuesController\n.  This controller did not do anything useful.  Let's re-create\nit from scratch.\n\n\n\n\nRight-click the \nControllers\n node in your backend project and use \nAdd\n -> \nController...\n.\n\n\n\n\n\n\n\n\nSelect the \nAzure Mobile Apps Custom Controller\n, then click \nAdd\n.\n\n\nEnter the name for the controller, for example, \nValuesController\n.  Click \nAdd\n.\n\n\n\n\nThe new controller will be scaffolded for you.  When you are done, it looks like this:\n\n\nusing System.Web.Http;\nusing Microsoft.Azure.Mobile.Server.Config;\n\nnamespace Backend.Controllers\n{\n    [MobileAppController]\n    public class ValuesController : ApiController\n    {\n        // GET api/Default\n        public string Get()\n        {\n            return \"Hello from custom controller!\";\n        }\n    }\n}\n\n\n\n\nIf you have not done anything that requires a backend, then you can press F5 to run the backend and use\nPostman to interact with your new custom API:\n\n\n\n\nWe still have to submit the \nZUMO-API-VERSION\n header for this to work.  Whatever my method returns will\nbe returned as JSON.  This one is not exactly exciting.  One of the things I do quite often is provide\na configuration endpoint called \n/api/config\n which returns a JSON object that I can use to configure the\nmobile client.\n\n\nusing System.Web.Http;\nusing Microsoft.Azure.Mobile.Server.Config;\nusing System.Collections.Generic;\nusing System;\n\nnamespace Backend.Controllers\n{\n    [MobileAppController]\n    public class ConfigController : ApiController\n    {\n        private ConfigViewModel configuration;\n\n        public ConfigController()\n        {\n            Dictionary<string, ProviderInformation> providers = new Dictionary<string, ProviderInformation>();\n\n            AddToProviders(providers, \"aad\", \"MOBILE_AAD_CLIENT_ID\");\n            AddToProviders(providers, \"facebook\", \"MOBILE_FB_CLIENT_ID\");\n            AddToProviders(providers, \"google\", \"MOBILE_GOOGLE_CLIENT_ID\");\n            AddToProviders(providers, \"microsoftaccount\", \"MOBILE_MSA_CLIENT_ID\");\n            AddToProviders(providers, \"twitter\", \"MOBILE_TWITTER_CLIENT_ID\");\n\n            configuration = new ConfigViewModel\n            {\n                AuthProviders = providers\n            };\n        }\n\n        private void AddToProviders(Dictionary<string, ProviderInformation> providers, string provider, string envVar)\n        {\n            string envVal = Environment.GetEnvironmentVariable(envVar);\n            if (envVal != null && envVal?.Length > 0)\n            {\n                providers.Add(provider, new ProviderInformation { ClientId = envVal });\n            }\n\n        }\n\n        [HttpGet]\n        public ConfigViewModel Get()\n        {\n            return configuration;\n        }\n    }\n\n    public class ProviderInformation\n    {\n        public string ClientId { get; set; }\n    }\n\n    public class ConfigViewModel\n    {\n        public Dictionary<string, ProviderInformation> AuthProviders { get; set; }\n    }\n}\n\n\n\n\nThe constructor produces a \nConfigViewModel\n for me.  This describes the configuration object I want to send.  In\nthis case, I want to send the client ID for each authentication provider.  If the authentication provider is not\nconfigured, then the client ID is not sent.  I use the application settings to determine what is configured. The\nprimary idea behind this is to integrate all the client flows within my mobile client.  When the user wishes to\nlog in, they are presented with a menu of options and can pick which social provider they wish to use.  The\nclient-flow authentication libraries may use different client IDs than the ones that are configured into the authentication\nservice.  For example, AAD uses two client IDs - one for server-flow and one for client-flow.  As a result, this\ncontroller uses \nApplication Settings\n (which appear as environment variables to the backend) to set the\nclient IDs.  The result of calling this API from Postman looks like this:\n\n\n\n\n\n\nWarn\n\n\nOnly expose information that you would normally and reasonably embed in a mobile client.  Never transmit\nsecrets this way.  It is insecure and can put your entire authentication system at risk of hijack.\n\n\n\n\nYou can read this information using the Azure Mobile Apps Client SDK once you have a client reference, using\nthe same model classes:\n\n\nvar configuration = await client.InvokeAsync<ConfigViewModel>(\"config\", HttpMethod.Get, null);\n\n\n\n\nYou must specify a class that deserializes the JSON that is produced by your API.  If you use the same classes,\nthat is practically guaranteed.  The other methods in call are the HTTP Method (GET, POST, PATCH, DELETE, etc.)\nand the query parameters.\n\n\nHandling Parameters to a Custom API\n\u00b6\n\n\nThe \n/api/config\n endpoint didn't require any information that is extra.  Sometimes, we need to provide\nextra information so that the right thing can be produced.  For example, consider the case of uploading\nor downloading a file to Azure Storage.  We may want to provide some extra information - the filename of\nthe file we want to upload and the permissions for the file.  Uploading and downloading files is discussed\nmore fully \nlater\n in the book and offers a fuller example of this concept.\n\n\nTo illustrate the concept clearly, let's create an API that adds two numbers together.  We would call\nthis API through HTTP like this: \nGET /api/addition?first=1&second=2\n.  The first number gets added to\nthe second number and we will return the result.  If the first or the second number doesn't exist, we\nwant to produce a 400 Bad Request response rather than crashing the server.  Here is the code:\n\n\nusing System.Web.Http;\nusing Microsoft.Azure.Mobile.Server.Config;\nusing System.Net;\n\nnamespace Backend.Controllers\n{\n    [MobileAppController]\n    public class AdditionController : ApiController\n    {\n        // GET api/Addition\n        public ResultViewModel Get(int? first, int? second)\n        {\n            if (first == null || second == null)\n            {\n                throw new HttpResponseException(HttpStatusCode.BadRequest);\n            }\n            ResultViewModel results = new ResultViewModel\n            {\n                First = first.GetValueOrDefault(),\n                Second = second.GetValueOrDefault()\n            };\n            results.Result = results.First + results.Second;\n            return results;\n        }\n    }\n\n    public class ResultViewModel\n    {\n        public int First { get; set; }\n        public int Second { get; set; }\n        public int Result { get; set; }\n    }\n}\n\n\n\n\nIf you try this out, you will notice something rather odd.  Try doing the following URL: \n/api/addition?first=1&second=2\n.\nYou will note it works as expected.  However, if you try doing the following URL: \n/api/addition?first=1\n, then you\nwill note that you get a \n404 Not Found\n.  This makes the API easy to write because you don't have to worry about\nyour code receiving bad input (most of the time).  However, you may not get the API surface that you want.  In this\ncase, I want to return a \n400 Bad Request\n instead of the normal 404 response.  I have to do a lot more work to\nsupport this case:\n\n\n    public class AdditionController : ApiController\n    {\n        // GET api/Addition\n        public ResultViewModel Get()\n        {\n            int? first = GetParameter(Request, \"first\"),\n                 second = GetParameter(Request, \"second\");\n\n            ResultViewModel results = new ResultViewModel\n            {\n                First = first.GetValueOrDefault(),\n                Second = second.GetValueOrDefault()\n            };\n            results.Result = results.First + results.Second;\n            return results;\n        }\n\n        private int? GetParameter(HttpRequestMessage request, string name)\n        {\n            var queryParams = request.GetQueryNameValuePairs().Where(kv => kv.Key == name).ToList();\n            if (queryParams.Count == 0)\n            {\n                throw new HttpResponseException(HttpStatusCode.BadRequest);\n            }\n\n            int rv;\n            if (!Int32.TryParse(queryParams[0].Value, out rv))\n            {\n                throw new HttpResponseException(HttpStatusCode.BadRequest);\n            }\n            return rv;\n        }\n    }\n\n\n\n\nWhen our Get() routine does not take parameters, no particular pattern is required.  We can use the \nRequest\n\nobject to access the parameters we send.  In this case, the \nGetParameter()\n routine checks to see if there\nis a named parameter and converts it to an integer.  If the named parameter is not there or it is not numeric,\nthen a Bad Request response is sent.\n\n\nHandling POST Requests\n\u00b6\n\n\nGET and DELETE requests take parameters on the URI.  These cam ne dealt with via the automatic conversion to\nmethod parameters or they can be handled via LINQ queries on the request object, as we observed in the prior\nsection.  POST requests, by contrast, allow you to submit a JSON body for processing.  This is useful when we\nwant to submit multiple JSON objects for processing.  For example, one of the common requirements we have is\nfor transactions.",
            "title": "Custom API"
        },
        {
            "location": "/chapter4/custom/#custom-http-endpoints",
            "text": "Azure Mobile Apps makes it really easy to develop basic APIs that can be used in mobile clients.  Most\ncustom APIs can be simply invoked.  Azure Mobile Apps takes care of most of the scaffolding for you. The\nserver SDK will:   Ensure the  ZUMO-API-VERSION  is present and valid.  Handle serialization and deserialization of JSON.  Ensure the API is given an appropriate URL.   All the custom APIs will appear under the  /api  endpoint.  For example, if you created a controller\ncalled  FooController , it would be invoked by sending messages to  /api/Foo .  This is case-insensitive,\nso you could also reference this API as  /api/foo .",
            "title": "Custom HTTP Endpoints"
        },
        {
            "location": "/chapter4/custom/#configuring-custom-apis",
            "text": "Before anything happens, you must add the  MapApiControllers()  method to the  MobileAppConfiguration() \ncall.  This is done in the  ConfigureMobileApp()  method in  App_Start\\Startup.MobileApp.cs  file:      new MobileAppConfiguration()\n        .AddTablesWithEntityFramework()     /* /tables endpoints */\n        .MapApiControllers()                /* /api endpoints */\n        .ApplyTo(config);  The  MapApiControllers()  extension method does the actual work of looking for custom APIs and mapping them\nonto the  /api  endpoint.",
            "title": "Configuring Custom APIs"
        },
        {
            "location": "/chapter4/custom/#creating-a-basic-custom-api",
            "text": "You might remember that the original Azure Mobile Apps project within Visual Studio comes with a sample\ncustom API called the  ValuesController .  This controller did not do anything useful.  Let's re-create\nit from scratch.   Right-click the  Controllers  node in your backend project and use  Add  ->  Controller... .     Select the  Azure Mobile Apps Custom Controller , then click  Add .  Enter the name for the controller, for example,  ValuesController .  Click  Add .   The new controller will be scaffolded for you.  When you are done, it looks like this:  using System.Web.Http;\nusing Microsoft.Azure.Mobile.Server.Config;\n\nnamespace Backend.Controllers\n{\n    [MobileAppController]\n    public class ValuesController : ApiController\n    {\n        // GET api/Default\n        public string Get()\n        {\n            return \"Hello from custom controller!\";\n        }\n    }\n}  If you have not done anything that requires a backend, then you can press F5 to run the backend and use\nPostman to interact with your new custom API:   We still have to submit the  ZUMO-API-VERSION  header for this to work.  Whatever my method returns will\nbe returned as JSON.  This one is not exactly exciting.  One of the things I do quite often is provide\na configuration endpoint called  /api/config  which returns a JSON object that I can use to configure the\nmobile client.  using System.Web.Http;\nusing Microsoft.Azure.Mobile.Server.Config;\nusing System.Collections.Generic;\nusing System;\n\nnamespace Backend.Controllers\n{\n    [MobileAppController]\n    public class ConfigController : ApiController\n    {\n        private ConfigViewModel configuration;\n\n        public ConfigController()\n        {\n            Dictionary<string, ProviderInformation> providers = new Dictionary<string, ProviderInformation>();\n\n            AddToProviders(providers, \"aad\", \"MOBILE_AAD_CLIENT_ID\");\n            AddToProviders(providers, \"facebook\", \"MOBILE_FB_CLIENT_ID\");\n            AddToProviders(providers, \"google\", \"MOBILE_GOOGLE_CLIENT_ID\");\n            AddToProviders(providers, \"microsoftaccount\", \"MOBILE_MSA_CLIENT_ID\");\n            AddToProviders(providers, \"twitter\", \"MOBILE_TWITTER_CLIENT_ID\");\n\n            configuration = new ConfigViewModel\n            {\n                AuthProviders = providers\n            };\n        }\n\n        private void AddToProviders(Dictionary<string, ProviderInformation> providers, string provider, string envVar)\n        {\n            string envVal = Environment.GetEnvironmentVariable(envVar);\n            if (envVal != null && envVal?.Length > 0)\n            {\n                providers.Add(provider, new ProviderInformation { ClientId = envVal });\n            }\n\n        }\n\n        [HttpGet]\n        public ConfigViewModel Get()\n        {\n            return configuration;\n        }\n    }\n\n    public class ProviderInformation\n    {\n        public string ClientId { get; set; }\n    }\n\n    public class ConfigViewModel\n    {\n        public Dictionary<string, ProviderInformation> AuthProviders { get; set; }\n    }\n}  The constructor produces a  ConfigViewModel  for me.  This describes the configuration object I want to send.  In\nthis case, I want to send the client ID for each authentication provider.  If the authentication provider is not\nconfigured, then the client ID is not sent.  I use the application settings to determine what is configured. The\nprimary idea behind this is to integrate all the client flows within my mobile client.  When the user wishes to\nlog in, they are presented with a menu of options and can pick which social provider they wish to use.  The\nclient-flow authentication libraries may use different client IDs than the ones that are configured into the authentication\nservice.  For example, AAD uses two client IDs - one for server-flow and one for client-flow.  As a result, this\ncontroller uses  Application Settings  (which appear as environment variables to the backend) to set the\nclient IDs.  The result of calling this API from Postman looks like this:    Warn  Only expose information that you would normally and reasonably embed in a mobile client.  Never transmit\nsecrets this way.  It is insecure and can put your entire authentication system at risk of hijack.   You can read this information using the Azure Mobile Apps Client SDK once you have a client reference, using\nthe same model classes:  var configuration = await client.InvokeAsync<ConfigViewModel>(\"config\", HttpMethod.Get, null);  You must specify a class that deserializes the JSON that is produced by your API.  If you use the same classes,\nthat is practically guaranteed.  The other methods in call are the HTTP Method (GET, POST, PATCH, DELETE, etc.)\nand the query parameters.",
            "title": "Creating a Basic Custom API"
        },
        {
            "location": "/chapter4/custom/#handling-parameters-to-a-custom-api",
            "text": "The  /api/config  endpoint didn't require any information that is extra.  Sometimes, we need to provide\nextra information so that the right thing can be produced.  For example, consider the case of uploading\nor downloading a file to Azure Storage.  We may want to provide some extra information - the filename of\nthe file we want to upload and the permissions for the file.  Uploading and downloading files is discussed\nmore fully  later  in the book and offers a fuller example of this concept.  To illustrate the concept clearly, let's create an API that adds two numbers together.  We would call\nthis API through HTTP like this:  GET /api/addition?first=1&second=2 .  The first number gets added to\nthe second number and we will return the result.  If the first or the second number doesn't exist, we\nwant to produce a 400 Bad Request response rather than crashing the server.  Here is the code:  using System.Web.Http;\nusing Microsoft.Azure.Mobile.Server.Config;\nusing System.Net;\n\nnamespace Backend.Controllers\n{\n    [MobileAppController]\n    public class AdditionController : ApiController\n    {\n        // GET api/Addition\n        public ResultViewModel Get(int? first, int? second)\n        {\n            if (first == null || second == null)\n            {\n                throw new HttpResponseException(HttpStatusCode.BadRequest);\n            }\n            ResultViewModel results = new ResultViewModel\n            {\n                First = first.GetValueOrDefault(),\n                Second = second.GetValueOrDefault()\n            };\n            results.Result = results.First + results.Second;\n            return results;\n        }\n    }\n\n    public class ResultViewModel\n    {\n        public int First { get; set; }\n        public int Second { get; set; }\n        public int Result { get; set; }\n    }\n}  If you try this out, you will notice something rather odd.  Try doing the following URL:  /api/addition?first=1&second=2 .\nYou will note it works as expected.  However, if you try doing the following URL:  /api/addition?first=1 , then you\nwill note that you get a  404 Not Found .  This makes the API easy to write because you don't have to worry about\nyour code receiving bad input (most of the time).  However, you may not get the API surface that you want.  In this\ncase, I want to return a  400 Bad Request  instead of the normal 404 response.  I have to do a lot more work to\nsupport this case:      public class AdditionController : ApiController\n    {\n        // GET api/Addition\n        public ResultViewModel Get()\n        {\n            int? first = GetParameter(Request, \"first\"),\n                 second = GetParameter(Request, \"second\");\n\n            ResultViewModel results = new ResultViewModel\n            {\n                First = first.GetValueOrDefault(),\n                Second = second.GetValueOrDefault()\n            };\n            results.Result = results.First + results.Second;\n            return results;\n        }\n\n        private int? GetParameter(HttpRequestMessage request, string name)\n        {\n            var queryParams = request.GetQueryNameValuePairs().Where(kv => kv.Key == name).ToList();\n            if (queryParams.Count == 0)\n            {\n                throw new HttpResponseException(HttpStatusCode.BadRequest);\n            }\n\n            int rv;\n            if (!Int32.TryParse(queryParams[0].Value, out rv))\n            {\n                throw new HttpResponseException(HttpStatusCode.BadRequest);\n            }\n            return rv;\n        }\n    }  When our Get() routine does not take parameters, no particular pattern is required.  We can use the  Request \nobject to access the parameters we send.  In this case, the  GetParameter()  routine checks to see if there\nis a named parameter and converts it to an integer.  If the named parameter is not there or it is not numeric,\nthen a Bad Request response is sent.",
            "title": "Handling Parameters to a Custom API"
        },
        {
            "location": "/chapter4/custom/#handling-post-requests",
            "text": "GET and DELETE requests take parameters on the URI.  These cam ne dealt with via the automatic conversion to\nmethod parameters or they can be handled via LINQ queries on the request object, as we observed in the prior\nsection.  POST requests, by contrast, allow you to submit a JSON body for processing.  This is useful when we\nwant to submit multiple JSON objects for processing.  For example, one of the common requirements we have is\nfor transactions.",
            "title": "Handling POST Requests"
        },
        {
            "location": "/chapter4/webjobs/",
            "text": "WebJobs\n\u00b6",
            "title": "WebJobs"
        },
        {
            "location": "/chapter4/webjobs/#webjobs",
            "text": "",
            "title": "WebJobs"
        },
        {
            "location": "/chapter4/functions/",
            "text": "Azure Functions\n\u00b6",
            "title": "Functions"
        },
        {
            "location": "/chapter4/functions/#azure-functions",
            "text": "",
            "title": "Azure Functions"
        },
        {
            "location": "/chapter5/concepts/",
            "text": "Push Notifications\n\u00b6\n\n\nPush Notification Concepts\n\u00b6\n\n\nHow Push Notifications Works\n\u00b6",
            "title": "Concepts"
        },
        {
            "location": "/chapter5/concepts/#push-notifications",
            "text": "",
            "title": "Push Notifications"
        },
        {
            "location": "/chapter5/concepts/#push-notification-concepts",
            "text": "",
            "title": "Push Notification Concepts"
        },
        {
            "location": "/chapter5/concepts/#how-push-notifications-works",
            "text": "",
            "title": "How Push Notifications Works"
        },
        {
            "location": "/chapter5/nh/",
            "text": "Notification Hubs\n\u00b6\n\n\nWhy you need Notification Hubs\n\u00b6\n\n\nFeatures of Notification Hubs\n\u00b6\n\n\nConfiguring Notification Hubs\n\u00b6\n\n\nConfiguring the Registration Endpoint\n\u00b6",
            "title": "Notification Hubs"
        },
        {
            "location": "/chapter5/nh/#notification-hubs",
            "text": "",
            "title": "Notification Hubs"
        },
        {
            "location": "/chapter5/nh/#why-you-need-notification-hubs",
            "text": "",
            "title": "Why you need Notification Hubs"
        },
        {
            "location": "/chapter5/nh/#features-of-notification-hubs",
            "text": "",
            "title": "Features of Notification Hubs"
        },
        {
            "location": "/chapter5/nh/#configuring-notification-hubs",
            "text": "",
            "title": "Configuring Notification Hubs"
        },
        {
            "location": "/chapter5/nh/#configuring-the-registration-endpoint",
            "text": "",
            "title": "Configuring the Registration Endpoint"
        },
        {
            "location": "/chapter5/android/",
            "text": "Push Notifications for Android\n\u00b6\n\n\nRegistering with FCM\n\u00b6\n\n\nRegistering with Azure Mobile Apps\n\u00b6\n\n\nReceiving a Notifications\n\u00b6",
            "title": "Android Push"
        },
        {
            "location": "/chapter5/android/#push-notifications-for-android",
            "text": "",
            "title": "Push Notifications for Android"
        },
        {
            "location": "/chapter5/android/#registering-with-fcm",
            "text": "",
            "title": "Registering with FCM"
        },
        {
            "location": "/chapter5/android/#registering-with-azure-mobile-apps",
            "text": "",
            "title": "Registering with Azure Mobile Apps"
        },
        {
            "location": "/chapter5/android/#receiving-a-notifications",
            "text": "",
            "title": "Receiving a Notifications"
        },
        {
            "location": "/chapter5/ios/",
            "text": "Push Notifications for iOS\n\u00b6\n\n\nRegistering with APNS\n\u00b6\n\n\nRegistering with Azure Mobile Apps\n\u00b6\n\n\nReceiving a Notifications\n\u00b6",
            "title": "iOS Push"
        },
        {
            "location": "/chapter5/ios/#push-notifications-for-ios",
            "text": "",
            "title": "Push Notifications for iOS"
        },
        {
            "location": "/chapter5/ios/#registering-with-apns",
            "text": "",
            "title": "Registering with APNS"
        },
        {
            "location": "/chapter5/ios/#registering-with-azure-mobile-apps",
            "text": "",
            "title": "Registering with Azure Mobile Apps"
        },
        {
            "location": "/chapter5/ios/#receiving-a-notifications",
            "text": "",
            "title": "Receiving a Notifications"
        },
        {
            "location": "/chapter5/windows/",
            "text": "Push Notifications for iOS\n\u00b6\n\n\nRegistering with WNS\n\u00b6\n\n\nRegistering with Azure Mobile Apps\n\u00b6\n\n\nReceiving a Notifications\n\u00b6",
            "title": "Windows Push"
        },
        {
            "location": "/chapter5/windows/#push-notifications-for-ios",
            "text": "",
            "title": "Push Notifications for iOS"
        },
        {
            "location": "/chapter5/windows/#registering-with-wns",
            "text": "",
            "title": "Registering with WNS"
        },
        {
            "location": "/chapter5/windows/#registering-with-azure-mobile-apps",
            "text": "",
            "title": "Registering with Azure Mobile Apps"
        },
        {
            "location": "/chapter5/windows/#receiving-a-notifications",
            "text": "",
            "title": "Receiving a Notifications"
        },
        {
            "location": "/chapter5/testing/",
            "text": "Testing\n\u00b6\n\n\nSending a Test Push\n\u00b6\n\n\nPushing to Android Emulators\n\u00b6\n\n\nPushing to iOS Simulators\n\u00b6\n\n\nPushing to Windows Emulators\n\u00b6",
            "title": "Testing Push"
        },
        {
            "location": "/chapter5/testing/#testing",
            "text": "",
            "title": "Testing"
        },
        {
            "location": "/chapter5/testing/#sending-a-test-push",
            "text": "",
            "title": "Sending a Test Push"
        },
        {
            "location": "/chapter5/testing/#pushing-to-android-emulators",
            "text": "",
            "title": "Pushing to Android Emulators"
        },
        {
            "location": "/chapter5/testing/#pushing-to-ios-simulators",
            "text": "",
            "title": "Pushing to iOS Simulators"
        },
        {
            "location": "/chapter5/testing/#pushing-to-windows-emulators",
            "text": "",
            "title": "Pushing to Windows Emulators"
        },
        {
            "location": "/chapter5/recipes/",
            "text": "Recipes\n\u00b6\n\n\nPush to Sync\n\u00b6\n\n\nPush to a Tag\n\u00b6\n\n\nCross-Platform Templates\n\u00b6",
            "title": "Push Recipes"
        },
        {
            "location": "/chapter5/recipes/#recipes",
            "text": "",
            "title": "Recipes"
        },
        {
            "location": "/chapter5/recipes/#push-to-sync",
            "text": "",
            "title": "Push to Sync"
        },
        {
            "location": "/chapter5/recipes/#push-to-a-tag",
            "text": "",
            "title": "Push to a Tag"
        },
        {
            "location": "/chapter5/recipes/#cross-platform-templates",
            "text": "",
            "title": "Cross-Platform Templates"
        },
        {
            "location": "/chapter6/concepts/",
            "text": "Azure Storage Concepts\n\u00b6\n\n\nWhen dealing with cloud concepts, there are multiple operating levels one can think about.  At the bottom layer\nis \nInfrastructure as a Service\n.  Most people think of this as the Virtual Machine layer, but it also incorporates\nbasic networking and storage concepts.  As you move to higher level services, you gain a lot of efficiencies by\nadding software components, you lose a lot of the potential management headaches, but you also lose flexibility\nin what you can do to the platform.  At the top of the stack is \nSoftware as a Service\n.  You may be running\na helpdesk, for example, but you are completely isolated from what operating system is being run, what web services\nare being run, APIs that can be accessed and language that is used.\n\n\nAzure Mobile Apps is an opinionated combination of a client and server SDK running on top of a standard ASP.NET\nbased web service and is normally thought of as being a \nPlatform as a Service\n.  You get to choose what database\nto use, what tables to expose, and what programming language to use.  You don't get to determine when the operating\nsystem is patched or what patches are applied.  It's a middle of the road between SaaS and IaaS.\n\n\nThat isn't to say we can't dip down sometimes to deal with lower level cloud services, nor to access higher level\nSaaS APIs.  One of those times is when dealing with files.  Storage is conceptually easy - you have an amount of\ndisk and you can store files on it.  However, the management of that storage is complicated.  Placing that storage\nat the service of a scalable web application is similarly complicated.  What we intend to do is develop a set of\nskills that make developing storage based mobile applications easy.\n\n\nBlobs, Table, Queues and files\n\u00b6\n\n\nAt the top of my list of \"storage made complicated\" is the cloud storage concepts.  In the old days, we stored files\non a file system and we didn't really have to worry about differing types of storage, redundancy and capabilities.\nCloud storage tends to come in multiple flavors:\n\n\n\n\n\n\nThe base storage type is \nBlob Storage\n.  Put simply, you have containers (roughly analogous to directories) and\nblobs (roughly analogous to files).  It's the cheapest form of storage and is used for many things, including the underlying\nstorage for virtual machine disks.  Blob storage has many advantages.  From a mobile perspective, developers will\nappreciate the upload/download restart capabilities within the SDK.\n\n\n\n\n\n\nWe've already introduced \nTable Storage\n in \nthe last chapter\n.  It is more analogous to a NoSQL store for storing\nkey / attribute values.  It has a schemaless design, so you can store basic JSON objects.  However, it has limited\nquery capabilities, as we discussed in the last chapter.  That makes it unsuited to large scale query-driven applications.\n\n\n\n\n\n\nYou may think you want \nFiles Storage\n.  This provides an SMB interface to the storage layer.  You would use Files\nStorage if you want to browse files from your PC or Mac as you can mount the file system directly from Azure Storage.\n\n\n\n\n\n\nFinally, \nQueue Storage\n provides cloud messaging between application components.  We'll get onto Azure Functions\nlater on, during our look at Custom API.  Queue Storage will definitely be coming into play then.  Think of Queue\nStorage as the glue that ties work flow components together.\n\n\n\n\n\n\nThe real question is when should you use File Storage and when should you use Blob Storage.  For more applications,\nBlob Storage is going to save you money over File Storage, so it's pretty much always the better choice.  You should\nonly be thinking of File Storage if you have other components of your system that need to access the data you upload\nthat can only access that data via an SMB interface.\n\n\nIf you need to explore the data that you upload or download, you can use the \nAzure Storage Explorer\n as a standalone\napplication or you can use the Cloud Explorer in \nVisual Studio\n.\n\n\nCreating and Linking a Storage Account\n\u00b6\n\n\nBefore we can use storage, we need to set up a storage account and connect it to our environment.  This involves:\n\n\n\n\nCreate a Resource Group\n\n\nCreate an Azure App Service\n\n\nSet up authentication on the Azure App Service\n\n\nCreate a Storage Account\n\n\nLink the Storage Account to the Azure App Service.\n\n\n\n\nWe've already covered the first three items in previous chapters.  We've also created a storage account and linked it\nto the mobile backend during our look at the \nStorage Domain Manager\n.  To create a Storage Account:\n\n\n\n\nLog on to the [Azure portal].\n\n\nClick the big \n+ NEW\n button in the top left corner.\n\n\nClick \nData + Storage\n, then \nStorage account\n.\n\n\nFill in the form:\n\n\nThe name can only contain letters and numbers and must be unique.  A GUID without the dashes is a good choice.\n\n\nThe \nDeployment model\n should be set to \nResource manager\n.\n\n\nThe \nAccount kind\n should be set to \nGeneral purpose\n.\n\n\nThe \nPerformance\n should be set to \nStandard\n for this example.\n\n\nThe \nReplication\n should be set to \nLocally-redundant storage (LRS)\n.\n\n\nSet the \nResource group\n to your existing resource group.\n\n\nSet the \nLocation\n to the same location as your App Service.\n\n\n\n\n\n\nClick \nCreate\n.\n\n\n\n\nJust like SQL Azure, Azure Storage has some great scalability and redundancy features if your backend takes advantage of them.\nFor example, you have the option of \nPremium Storage\n - this provides all-SSD storage that has a large IOPS performance\nnumber.  You can also decide how redundant you want the storage.  Azure always keeps 3 copies of your data.  You can choose\nto increase the number of copies and decide whether the additional copies will be in the same datacenter, another datacenter\nin the same region or another region.  We have selected the slowest performance and least redundant options here to keep the\ncost down on your service.\n\n\n\n\nWarn\n\n\nThere is no \"free\" option for Azure Storage.  You pay by the kilobyte depending on the performance and redundancy selected.\n\n\n\n\nOnce the Azure Storage account is deployed, you can link the storage account to your App Service:\n\n\n\n\nOpen your App Service in the [Azure portal].\n\n\nClick  \nData Connections\n under the \nMOBILE\n section in the settings menu.\n\n\nClick \n+ ADD\n\n\nIn the \nAdd data connection\n blade:\n\n\nSet the Type to \nStorage\n.\n\n\nClick the \nStorage\n link.\n\n\nIn the \nStorage Account\n selector, click the storage account you just created.\n\n\nClick the \nConnection string\n.\n\n\nIn the \nConnection string\n selector, make a note of the \nName\n field.\n\n\nClick \nOK\n.\n\n\nClick \nOK\n to close the \nAdd data connection\n blade.\n\n\n\n\n\n\n\n\nClick on the \nApplication Settings\n menu option, then scroll down to the \nConnection Strings\n section.  Note that the portal\nhas created the connection string as an App Setting for you with the right value:\n\n\nDefaultEndpointsProtocol=https;AccountName=thebook;AccountKey=<key1>\n\n\n\n\nBy default, the connection string is called \nMS_AzureStorageAccountConnectionString\n and we will use that throughout our\nexamples.\n\n\nThe key is the access key for the storage.  When a storage account is created, two keys are also created.  The keys are used for\nsecure access to the storage area.  You should never distribute the storage keys nor check them into source control.  If you feel\nthey have been compromised, you should regenerate them.  There are two keys for this purpose.  The process of regeneration is:\n\n\n\n\nRegenerate KEY2\n\n\nPlace the regenerated KEY2 in the connection string and restart your App Service.\n\n\nRegenerate key1\n\n\nPlace the regenerated KEY1 in the connection string and restart your App Service.\n\n\n\n\nIn this way, your App Service will always be using KEY1 except during regeneration.  You can avoid the restart of your App Service\nby providing a management interface that sets the Account Key for the App Service.\n\n\n\n\nTip\n\n\nFor local development, there is the \nAzure Storage Emulator\n.  The connection string when using the Azure Storage\nEmulator is \nUseDevelopmentStorage=true\n.\n\n\n\n\nIt's normal to add the storage connection string to the \nWeb.config\n file with the following:\n\n\n<connectionStrings>\n    <add name=\"MS_AzureStorageAccountConnectionString\" connectionString=\"UseDevelopmentStorage=true\" />\n</connectionStrings>\n\n\n\n\nThis will be overwritten by the connection string in the App Service Application Settings.  Effectively, you will be using the\nAzure Storage Emulator during local development and Azure Storage when you deploy to Azure App Service.\n\n\nThe Shared Access Signature (SAS)\n\u00b6\n\n\nThe storage account key is kind of like the root or Administrator password.  You should always protect it, never send it to a\nthird party and regenerate it on a regular basis.  You avoid storing the storage account key in source code by linking the\nstorage account to the App Service.  The key is stored in the connection string instead.  You should never ship an account\nkey to your mobile account.\n\n\nThe Azure Storage SDK already has many of the features that you want in handling file upload and download.  Azure Storage is\noptimized for streaming, for example.  You can upload or download blobs in blocks, allowing you to restart the transfer and\nprovide feedback to the user on progress, for example.   You will inevitably be drawn to having your mobile client interact\nwith Azure Storage directly rather than having an intermediary web service for this reason.\n\n\nIf you want to interact with Azure Storage directly and you shouldn't give out the account key, how do you deal with the\nsecurity of the service?  The answer is with a Shared Access Signature, or SAS.  The \nService SAS\n delegates access\nto just a single resource in one of the storage services (Blob, Table, Queue or File service).\n\n\n\n\nInfo\n\n\nThere is also an \nAccount SAS\n which delegates access to resources in more than one service.  You generally don't\nwant this in application development.\n\n\n\n\nA service SAS is a URI that is used when accessing the resource.  It consists of the URI to the resource followed by a\nSAS token.  The SAS token is an cryptographically signed opaque token that the storage service decodes.  Minimally, it\nprovides an expiry time and the permissions being granted to the SAS.\n\n\n\n\nWarn\n\n\nA SAS token \nALWAYS\n expires.  There is no way to produce a permanent SAS token.  If you think you need one,\nthink again.  In mobile development, you \nNEVER\n want a non-expiring token.\n\n\n\n\nAccessing Azure Storage is always done with a specific \nversion of the REST API\n and that follows through to the SDK.  You\nshould always request a SAS token for the appropriate API you are going to be using.   We'll cover the various\nmethods of obtaining a SAS later in the chapter.\n\n\nFile Sync with Azure Mobile Apps\n\u00b6\n\n\nIt's actually fairly rare that you will want to upload and download random files. Generally, your application will need\nto associate your files with a database record.  Take, for example, the common patterns for image management.  Your\nusers will want to organize the images into albums and also store metadata about the images.  They will want to\nsearch for images based on the metadata.  The same can be said for many other applications.  Inevitably, you will\nwant to associate your files with database records.\n\n\nOur database records are available offline via the Azure Mobile Apps offline sync capability.  It is only natural,\ntherefore, that we will want to have our pictures available offline as well.  Fortunately, the mobile clients all\nhave the capability of organizing files on the device, and Azure Mobile Apps has the capability of synchronizing\nfiles between Azure Storage and the device.  No extra data is stored with the database record.  However, it's\nimportant that the data within Azure Storage is organized properly.\n\n\nIn this chapter, we will again be working with Azure Mobile Apps and our typical Task List application.  We will add\nthe capability to upload and download files both at an application level and a per-record basis with offline sync.\nBefore you continue:\n\n\n\n\nCreate a new resource group\n\n\nCreate an App Service with a SQL Azure database\n\n\nConfigure the App Service with some sort of authentication\n\n\nCreate a Storage Account\n\n\nLink the Storage Account to the App Service\n\n\nDeploy the code from the Backend project for the [Chapter4 solution].\n\n\nEnsure that the Tasklist application runs for your platform.\n\n\n\n\nWe will use this as a starting point for our investigations.  You can download the starter project from the books\n\nGitHub repository\n.",
            "title": "Concepts"
        },
        {
            "location": "/chapter6/concepts/#azure-storage-concepts",
            "text": "When dealing with cloud concepts, there are multiple operating levels one can think about.  At the bottom layer\nis  Infrastructure as a Service .  Most people think of this as the Virtual Machine layer, but it also incorporates\nbasic networking and storage concepts.  As you move to higher level services, you gain a lot of efficiencies by\nadding software components, you lose a lot of the potential management headaches, but you also lose flexibility\nin what you can do to the platform.  At the top of the stack is  Software as a Service .  You may be running\na helpdesk, for example, but you are completely isolated from what operating system is being run, what web services\nare being run, APIs that can be accessed and language that is used.  Azure Mobile Apps is an opinionated combination of a client and server SDK running on top of a standard ASP.NET\nbased web service and is normally thought of as being a  Platform as a Service .  You get to choose what database\nto use, what tables to expose, and what programming language to use.  You don't get to determine when the operating\nsystem is patched or what patches are applied.  It's a middle of the road between SaaS and IaaS.  That isn't to say we can't dip down sometimes to deal with lower level cloud services, nor to access higher level\nSaaS APIs.  One of those times is when dealing with files.  Storage is conceptually easy - you have an amount of\ndisk and you can store files on it.  However, the management of that storage is complicated.  Placing that storage\nat the service of a scalable web application is similarly complicated.  What we intend to do is develop a set of\nskills that make developing storage based mobile applications easy.",
            "title": "Azure Storage Concepts"
        },
        {
            "location": "/chapter6/concepts/#blobs-table-queues-and-files",
            "text": "At the top of my list of \"storage made complicated\" is the cloud storage concepts.  In the old days, we stored files\non a file system and we didn't really have to worry about differing types of storage, redundancy and capabilities.\nCloud storage tends to come in multiple flavors:    The base storage type is  Blob Storage .  Put simply, you have containers (roughly analogous to directories) and\nblobs (roughly analogous to files).  It's the cheapest form of storage and is used for many things, including the underlying\nstorage for virtual machine disks.  Blob storage has many advantages.  From a mobile perspective, developers will\nappreciate the upload/download restart capabilities within the SDK.    We've already introduced  Table Storage  in  the last chapter .  It is more analogous to a NoSQL store for storing\nkey / attribute values.  It has a schemaless design, so you can store basic JSON objects.  However, it has limited\nquery capabilities, as we discussed in the last chapter.  That makes it unsuited to large scale query-driven applications.    You may think you want  Files Storage .  This provides an SMB interface to the storage layer.  You would use Files\nStorage if you want to browse files from your PC or Mac as you can mount the file system directly from Azure Storage.    Finally,  Queue Storage  provides cloud messaging between application components.  We'll get onto Azure Functions\nlater on, during our look at Custom API.  Queue Storage will definitely be coming into play then.  Think of Queue\nStorage as the glue that ties work flow components together.    The real question is when should you use File Storage and when should you use Blob Storage.  For more applications,\nBlob Storage is going to save you money over File Storage, so it's pretty much always the better choice.  You should\nonly be thinking of File Storage if you have other components of your system that need to access the data you upload\nthat can only access that data via an SMB interface.  If you need to explore the data that you upload or download, you can use the  Azure Storage Explorer  as a standalone\napplication or you can use the Cloud Explorer in  Visual Studio .",
            "title": "Blobs, Table, Queues and files"
        },
        {
            "location": "/chapter6/concepts/#the-shared-access-signature-sas",
            "text": "The storage account key is kind of like the root or Administrator password.  You should always protect it, never send it to a\nthird party and regenerate it on a regular basis.  You avoid storing the storage account key in source code by linking the\nstorage account to the App Service.  The key is stored in the connection string instead.  You should never ship an account\nkey to your mobile account.  The Azure Storage SDK already has many of the features that you want in handling file upload and download.  Azure Storage is\noptimized for streaming, for example.  You can upload or download blobs in blocks, allowing you to restart the transfer and\nprovide feedback to the user on progress, for example.   You will inevitably be drawn to having your mobile client interact\nwith Azure Storage directly rather than having an intermediary web service for this reason.  If you want to interact with Azure Storage directly and you shouldn't give out the account key, how do you deal with the\nsecurity of the service?  The answer is with a Shared Access Signature, or SAS.  The  Service SAS  delegates access\nto just a single resource in one of the storage services (Blob, Table, Queue or File service).   Info  There is also an  Account SAS  which delegates access to resources in more than one service.  You generally don't\nwant this in application development.   A service SAS is a URI that is used when accessing the resource.  It consists of the URI to the resource followed by a\nSAS token.  The SAS token is an cryptographically signed opaque token that the storage service decodes.  Minimally, it\nprovides an expiry time and the permissions being granted to the SAS.   Warn  A SAS token  ALWAYS  expires.  There is no way to produce a permanent SAS token.  If you think you need one,\nthink again.  In mobile development, you  NEVER  want a non-expiring token.   Accessing Azure Storage is always done with a specific  version of the REST API  and that follows through to the SDK.  You\nshould always request a SAS token for the appropriate API you are going to be using.   We'll cover the various\nmethods of obtaining a SAS later in the chapter.",
            "title": "The Shared Access Signature (SAS)"
        },
        {
            "location": "/chapter6/concepts/#file-sync-with-azure-mobile-apps",
            "text": "It's actually fairly rare that you will want to upload and download random files. Generally, your application will need\nto associate your files with a database record.  Take, for example, the common patterns for image management.  Your\nusers will want to organize the images into albums and also store metadata about the images.  They will want to\nsearch for images based on the metadata.  The same can be said for many other applications.  Inevitably, you will\nwant to associate your files with database records.  Our database records are available offline via the Azure Mobile Apps offline sync capability.  It is only natural,\ntherefore, that we will want to have our pictures available offline as well.  Fortunately, the mobile clients all\nhave the capability of organizing files on the device, and Azure Mobile Apps has the capability of synchronizing\nfiles between Azure Storage and the device.  No extra data is stored with the database record.  However, it's\nimportant that the data within Azure Storage is organized properly.  In this chapter, we will again be working with Azure Mobile Apps and our typical Task List application.  We will add\nthe capability to upload and download files both at an application level and a per-record basis with offline sync.\nBefore you continue:   Create a new resource group  Create an App Service with a SQL Azure database  Configure the App Service with some sort of authentication  Create a Storage Account  Link the Storage Account to the App Service  Deploy the code from the Backend project for the [Chapter4 solution].  Ensure that the Tasklist application runs for your platform.   We will use this as a starting point for our investigations.  You can download the starter project from the books GitHub repository .",
            "title": "File Sync with Azure Mobile Apps"
        },
        {
            "location": "/chapter6/files/",
            "text": "Dealing with Files\n\u00b6\n\n\nThe most normal tasks for dealing with files are the upload and download of files to blob storage.  There is\na natural and consistent process to this which makes this recipe very repeatable.  First, deal with the things\nyou need before you start:\n\n\n\n\nCreate an Azure Storage Account and link it to your Azure App Service.\n\n\nDecide how you want your files organized.\n\n\nCreate a WebAPI to generate a SAS token for your upload or download.\n\n\n\n\nI've already discussed \nhow to create and link an Azure Storage Account\n.  Blob storage is organized in a\ntypical directory structure.  Each directory is called a container, and each file is a blob.  In the examples\nfor this section, I am going to store each uploaded file in a container based on the authenticated user.  My\nWebAPI will create the appropriate container and then return an appropriate SAS token.\n\n\nWe haven't discussed custom code yet.  We will go much deeper than we do right now.  Custom APIs allow us to\nwrite custom code and execute it within the context of the mobile backend.  It has access to many of the same\nfacilities as the rest of the mobile backend - things like app settings, connection strings, and the Entity\nFramework structure.  To enable custom APIs, you need to alter the \nApp_Start\\Startup.MobileApp.cs\n file so\nthat the custom APIs are attached to HTTP routes properly:\n\n\n    HttpConfiguration config = new HttpConfiguration();\n\n    new MobileAppConfiguration()\n        .AddTablesWithEntityFramework()\n        .MapApiControllers()\n        .ApplyTo(config);\n\n\n\n\nThe Custom API is a standard ASP.NET controller with the \n[MobileAppController]\n attribute attached to the\nclass.  The \n[MobileAppController]\n signals to Azure Mobile Apps that the controller needs to be registered\nunder the \n/api\n endpoint.  It also handles API version checking (or at least checks that the \nZUMO-API-VERSION\n\nheader is set to 2.0.0) and appropriately handles authorization if the \n[Authorize]\n attribute is present. The\nmapping under the \n/api\n endpoint only happens if the \n.MapApiControllers()\n extension method is called during\nconfiguration.\n\n\n\n\nInfo\n\n\nEnsure you install the latest version of the \nWindowsAzure.Storage\n Nuget package using the NuGet package\nManager before continuing.\n\n\n\n\nWhen we linked the Azure Storage account, we added a connection string called \nMS_AzureStorageAccountConnectionString\n.\nThis is included in the environment as \nCUSTOMCONNSTR_MS_AzureStorageAccountConnectionString\n.  We can add a new\nCustom API controller in Visual Studio by right-clicking on the \nControllers\n node, then selecting \nAdd\n ->\n\nController...\n and selecting the \nAzure Mobile APps Custom Controller\n option.  We can set up our custom API\nas follows:\n\n\nnamespace Backend.Controllers\n{\n    [Authorize]\n    [MobileappController]\n    public class GetStorageTokenController : ApiController\n    {\n        private const string connString = \"CUSTOMCONNSTR_MS_AzureStorageAccountConnectionString\";\n\n        public GetStorageTokenController()\n        {\n            ConnectionString = Environment.GetEnvironmentVariable(connString);\n            StorageAccount = CloudStorageAccount.Parse(ConnectionString);\n            BlobClient = StorageAccount.CreateCloudBlobClient();\n        }\n\n        public string ConnectionString { get; }\n\n        public CloudStorageAccount StorageAccount { get; }\n\n        public CloudBlobClient BlobClient { get; }\n    }\n}\n\n\n\n\nThe \nConnectionString\n property is the pointer to where the Azure Storage account is located and how to\naccess it.  the \nStorageAccount\n is a reference to that Azure Storage account.  Finally, the \nBlobClient\n\nis an object used for accessing blob storage.  We can access any WebAPI methods in this class by using\nthe endpoint \n/api/GetStorageToken\n within our mobile client or using Postman.\n\n\nAzure Storage doesn't have a true heirarchial container system.  It does have containers and directories\nto organize things though, so we are going to use that:\n\n\n    private const string containerName = \"userdata\";\n\n    [HttpGet]\n    public async Task<StorageTokenViewModel> GetAsync()\n    {\n        // The userId is the SID without the sid: prefix\n        var claimsPrincipal = User as ClaimsPrincipal;\n        var userId = claimsPrincipal\n            .FindFirst(ClaimTypes.NameIdentifier)\n            .Value.Substring(4);\n\n        // Errors creating the storage container result in a 500 Internal Server Error\n        var container = BlobClient.GetContainerReference(containerName);\n        await container.CreateIfNotExistsAsync();\n\n        // Get the user directory within the container\n        var directory = container.GetDirectoryReference(userId);\n        var blobName = Guid.NewGuid().ToString(\"N\");\n        var blob = directory.GetBlockBlobReference(blobName);\n\n        // Create a policy for accessing the defined blob\n        var blobPolicy = new SharedAccessBlobPolicy\n        {\n            SharedAccessStartTime = DateTime.UtcNow.AddMinutes(-5),\n            SharedAccessExpiryTime = DateTime.UtcNow.AddMinutes(60),\n            Permissions = SharedAccessBlobPermissions.Read\n                        | SharedAccessBlobPermissions.Write\n                        | SharedAccessBlobPermissions.Create\n        };\n\n        return new StorageTokenViewModel\n        {\n            Name = blobName,\n            Uri = blob.Uri,\n            SasToken = blob.GetSharedAccessSignature(blobPolicy)\n        };\n    }\n\n\n\n\nThe main piece of work in this API is generating the policy that is then signed and returned to\nthe user as the SAS Token.  The mobile device has permission to read, write and create the blob\nthat we have defined for the next 60 minutes.  I've provided a policy that starts in the past in\ncase there is a little amount of clock-skew between the mobile device and the backend.\n\n\n\n\nWarn\n\n\nContainer names must be a valid DNS name.  The most notable requirement here is between 3\nand 64 lower-case letters.  Container names are case-sensitive.  Check \nthe documentation\n\nfor full details on naming requirements.\n\n\n\n\nThe \nStorageTokenViewModel\n is used for serialization purposes:\n\n\npublic class StorageTokenViewModel\n{\n    public string Name { get; set; }\n    public Uri Uri { get; set; }\n    public string SasToken { get; set; }\n}\n\n\n\n\nWe can test this API using Postman.  First, generate an authentication token.  Then use Postman to\ndo a GET of the \n/api/GetStorageToken\n endpoint:\n\n\n\n\nThere are two pieces of information we need here.  Firstly, the \nuri\n property provides the URI that we are going to\nuse to upload the file.  Secondly, the \nsasToken\n is appended to the \nuri\n when uploading to provide a link to the\npolicy.  Note that the token start and expiry time are encoded and readable in the sasToken.\n\n\nIn real world applications, this is likely not the right method.  We might want to organize the files based on information\nthat the mobile client provides us, for example.  We may also want to upload to a specific upload area and then download\nfrom another location, allowing processing of the files in between.  You may also want to append the uploaded file extension\nto the file before uploading.  There is no \"one size fits all\" token policy.  You must decide on the conditions under which\nyou will allow upload and download capabilities and then provide the appropriate logic to generate the SAS token.\n\n\nUploading a File to Blob Storage\n\u00b6\n\n\nOnce we have the logic to generate a SAS token, we can turn our attention to the mobile clients.  We need to do three\nthings for uploading a file to the service:\n\n\n\n\nGet a reference to the file (as a Stream object).\n\n\nGenerate a SAS token using the custom API.\n\n\nUse the Azure Storage SDK to upload directly to the Azure Storage Account.\n\n\n\n\nYou should not upload to a custom API in your mobile backend.  This needlessly ties up your mobile backend, causing your\nmobile backend to be less efficient at scaling.  Your mobile backend will not have all the facilities that the\nAzure Storage endpoint has provided either.  Azure Storage provides upload and download restarts and progress bar\ncapabilities.\n\n\nObtaining a reference to the file that you wish to upload is normally a per-platform API.  Obtaining a reference to a photo or video\ninvolves interacting with platform-specific APIs to provide access to camera and built-in photo storage capabilities on the\nphone. To support such a per-platform capability, we need to add an interface for the API to the \nAbstractions\\IPlatform.cs\n file:\n\n\nTask<Stream> GetUploadFileAsync();\n\n\n\n\nThis API will interact with whatever photo sharing API is available on the device, open the requested file and return a standard\n\nStream\n object.  Loading a media file is made much simpler using the cross-platform [Xamarin Media] plugin.  This plugin allows\nthe user to take photos or video, or pick  the media file from a gallery.  It's available on NuGet, so add the \nXam.Plugin.Media\n\nplugin to each of the platform-specific projects.\n\n\n\n\nTip\n\n\nI still like separating out code that deals with the hardware of a mobile device into the platform-specific code.  You don't\nneed to do such separation on this project.  I find that I inevitably have one thing or another that requires a platform-specific\ntweak, so starting with a platform-specific API is better.\n\n\n\n\nThe Xamarin Media plugin is used like this:\n\n\nawait CrossMedia.Current.Initialize();\n\nvar file = await CrossMedia.Current.PickPhotoAsync();\nvar stream = file.GetStream();\n\n\n\n\nThere are methods within the plugin to determine if a camera is available.  Different platforms require different permissions:\n\n\nAndroid\n\u00b6\n\n\nAndroid requires the  \nWRITE\\_EXTERNAL\\_STORAGE\n, \nREAD\\_EXTERNAL\\_STORAGE\n and \nCAMERA\n permissions. If the mobile device is\nrunning Android M or later, the plugin will automatically prompt the user for runtime permissions.  You can set these permissions\nwithin Visual Studio:\n\n\n\n\nDouble-click the \nProperties\n node within the Android project.\n\n\nSelect \nAndroid Manifest\n.\n\n\nIn the \nRequired permissions\n list, check the box next to the required permissions by double-clicking the permission.\n\n\nSave the Properties (you may have to right-click on the TaskList.Droid tab and click on \nSave Selected Items\n).\n\n\n\n\niOS\n\u00b6\n\n\nApple iOS requires the \nNSCameraUsageDescription\n and \nNSPhotoLibraryUsageDescription\n keys.  The string provided will be\ndisplayed to the user when they are prompted to provide permission.  You can set these keys within Visual Studio:\n\n\n\n\nRight-click on the \nInfo.plist\n file and select \nOpen with...\n\n\nChoose the \nXML (Text) Editor\n then click \nOK\n.\n\n\nWithin the \n<dict>\n node, add the following lines:\n\n\n\n\n<key>NSCameraUsageDescription</key>\n<string>This app needs access to the camera to take photos.</string>\n<key>NSPhotoLibraryUsageDescription</key>\n<string>This app needs access to photos.</string>\n\n\n\n\n\n\nSave and close the file.\n\n\n\n\nYou can choose whatever string you want to display to the user.  For more information on iOS 10 privacy permissions, review\nthe \nXamarin Blog\n.\n\n\nUniversal Windows\n\u00b6\n\n\nUniversal Windows may require the \nPictures Library\n capability:\n\n\n\n\nIn the \nTaskList.UWP (Universal Windows)\n project, open \nPackage.appxmanifest\n.\n\n\nSelect the \nCapabilities\n tab.\n\n\nCheck the box next to \nPictures Library\n.\n\n\nSave the manifest.\n\n\n\n\nImplementing the File Reader\n\u00b6\n\n\nThe same code can be used in all three platform-specific projects, in the \n*Platform.cs\n file:\n\n\n    /// <summary>\n    /// Picks a photo for uploading\n    /// </summary>\n    /// <returns>A Stream for the photo</returns>\n    public async Task<Stream> GetUploadFileAsync()\n    {\n        var mediaPlugin = CrossMedia.Current;\n        var mainPage = Xamarin.Forms.Application.Current.MainPage;\n\n        await mediaPlugin.Initialize();\n\n        if (mediaPlugin.IsPickPhotoSupported)\n        {\n            var mediaFile = await mediaPlugin.PickPhotoAsync();\n            return mediaFile.GetStream();\n        }\n        else\n        {\n            await mainPage.DisplayAlert(\"Media Service Unavailable\", \"Cannot pick photo\", \"OK\");\n            return null;\n        }\n    }\n\n\n\n\nUploading a File\n\u00b6\n\n\nWe can now put the individual pieces together to actually do an upload.  In this example, we are going to use the photo picker to\npick a photo and then upload it, displaying a progress bar as it happens.  We start with the XAML code in \nPages\\TaskList.xaml\n.  We\nneed a button in the toolbar to initiate the file upload:\n\n\n    <ContentPage.ToolbarItems>\n        <ToolbarItem Name=\"Refresh\"\n                     Command=\"{Binding RefreshCommand}\"\n                     Icon=\"refresh.png\"\n                     Order=\"Primary\"\n                     Priority=\"0\" />\n        <ToolbarItem Name=\"Add Task\"\n                     Command=\"{Binding AddNewItemCommand}\"\n                     Icon=\"add.png\"\n                     Order=\"Primary\"\n                     Priority=\"0\" />\n        <ToolbarItem Name=\"Add File\"\n                     Command=\"{Binding AddNewFileCommand}\"\n                     Icon=\"addfile.png\"\n                     Order=\"Primary\"\n                     Priority=\"0\" />\n    </ContentPage.ToolbarItems>\n\n\n\n\nObtain a suitable \"Add File\" icon from the Internet and resize the image appropriately for the task.  You will need five images total:\n\n\n\n\nTaskList.Droid\\Resources\\drawable\\addfile.png should be 128x128 pixels\n\n\nTaskList.iOS\\Resources\\addfile.png should be 25x25 pixels\n\n\nTaskList.iOS\\Resources\\addfile@2x.png should be 50x50 pixels\n\n\nTaskList.iOS\\Resources\\addfile@3x.png should be 75x75 pixels\n\n\nTaskList.UWP\\addfile.png should be 128x128 pixels\n\n\n\n\nAll images should have a transparent background.\n\n\nThe storage token is retrieved from the backend via the cloud service.  Add the following to \nAbstractions\\ICloudService.cs\n:\n\n\n    // Custom APIs\n    Task<StorageTokenViewModel> GetSasTokenAsync();\n\n\n\n\nThis has a concrete implementation in \nServices\\AzureCloudService.cs\n:\n\n\n    public async Task<StorageTokenViewModel> GetSasTokenAsync()\n    {\n        var parameters = new Dictionary<string, string>();\n        var storageToken = await Client.InvokeApiAsync<StorageTokenViewModel>(\"GetStorageToken\", HttpMethod.Get, parameters);\n        return storageToken;\n    }\n\n\n\n\nThe \nStorageTokenViewModel\n is identical to the class in the \nGetStorageTokenController.cs\n controller in the Backend.  I've placed the class\ndefinition in the \nModels\n namespace for the client.  We could share this model between the backend and front end, but the case of sharing\nmodels is so rare I tend not to share the code.\n\n\nIn the \nTaskListViewModel.cs\n, we can define a command that is called when the Add File button is clicked:\n\n\n    /// <summary>\n    /// Reference to the Platform Provider\n    /// </summary>\n    public IPlatform PlatformProvider => DependencyService.Get<IPlatform>();\n\n    /// <summary>\n    /// Bindable property for the AddNewFile Command\n    /// </summary>\n    public ICommand AddNewFileCommand { get; }\n\n    /// <summary>\n    /// User clicked on the Add New File button\n    /// </summary>\n    private async Task AddNewFileAsync()\n    {\n        if (IsBusy)\n        {\n            return;\n        }\n        IsBusy = true;\n\n        try\n        {\n            // Get a stream for the file\n            var mediaStream = await PlatformProvider.GetUploadFileAsync();\n            if (mediaStream == null)\n            {\n                IsBusy = false;\n                return;\n            }\n\n            // Get the SAS token from the backend\n            var storageToken = await CloudService.GetSasTokenAsync();\n\n            // Use the SAS token to upload the file\n            var storageUri = new Uri($\"{storageToken.Uri}{storageToken.SasToken}\");\n            var blobStorage = new CloudBlockBlob(storageUri);\n            await blobStorage.UploadFromStreamAsync(mediaStream);\n        }\n        catch (Exception ex)\n        {\n            await Application.Current.MainPage.DisplayAlert(\"Error Uploading File\", ex.Message, \"OK\");\n        }\n        finally\n        {\n            IsBusy = false;\n        }\n    }\n\n\n\n\n\n\nWarn\n\n\nAzure Storage SDK support for PCL projects is only available in -preview editions.  When installing the SDK, ensure you check the\n\"Include prerelease\" box in the NuGet package manager.  The latest version with PCL (.NETPortable) support is v7.0.2-preview.\n\n\n\n\nYou can look at the uploaded files in the Azure portal:\n\n\n\n\nLog in to the \nAzure portal\n.\n\n\nClick \nAll resources\n, then your storage account.\n\n\nUnder \nSERVICES\n, click \nBlobs\n.\n\n\nClick your storage container (in this example, that's called \nuserdata\n)\n\n\n\n\n\n\nYou will see a folder for each user account.  The folder is named for the SID of the account - not the username.  It's a good idea to\nstore the user SID with other data about the user in a table within your database.   This allows you to associate a real user with their\nSID since a user will never know what their SID is.\n\n\nImplementing a Progress bar\n\u00b6\n\n\nIt's common to want to see the progress of the upload while it is happening.  For that, we need a progress bar.  First, let's add a hidden\nprogress bar to our \nTaskList.xaml\n page:\n\n\n    <ActivityIndicator HorizontalOptions=\"FillAndExpand\"\n                        IsRunning=\"{Binding IsBusy}\"\n                        IsVisible=\"{Binding IsBusy}\"\n                        VerticalOptions=\"Start\" />\n    <ProgressBar x:Name=\"fileUploadProgress\"\n                    HeightRequest=\"3\"\n                    HorizontalOptions=\"FillAndExpand\"\n                    IsVisible=\"{Binding IsUploadingFile}\"\n                    Progress=\"{Binding FileProgress}\" />\n\n\n\n\nThis comes with two new bindable properties.  \nIsUploadingFile\n is a \nbool\n and \nFileProgress\n is a \nDouble\n.  \nFileProgress\n takes a value between\n0 and 1 to indicate how far along the progress bar should be.  This code should be in the \nTaskListViewModel.cs\n file:\n\n\n    private bool isUploadingFile;\n    public bool IsUploadingFile\n    {\n        get { return isUploadingFile; }\n        set { SetProperty(ref isUploadingFile, value, \"IsUploadingFile\"); }\n    }\n\n    private Double fileProgress = 0.0;\n    public Double FileProgress\n    {\n        get { return fileProgress;  }\n        set { SetProperty(ref fileProgress, value, \"FileProgress\"); }\n    }\n\n\n\n\nFinally, we have to change the upload so that it happens a chunk at a time.  In the \nAddNewFileAsync()\n method, we can replace the upload code with this:\n\n\n    /// <summary>\n    /// User clicked on the Add New File button\n    /// </summary>\n    private async Task AddNewFileAsync()\n    {\n        if (IsBusy)\n        {\n            return;\n        }\n        IsBusy = true;\n\n        try\n        {\n            // Get a stream for the file\n            var mediaStream = await PlatformProvider.GetUploadFileAsync();\n            if (mediaStream == null)\n            {\n                IsBusy = false;\n                return;\n            }\n\n            // Get the SAS token from the backend\n            var storageToken = await CloudService.GetSasTokenAsync();\n\n            // Use the SAS token to get a reference to the blob storage\n            var storageUri = new Uri($\"{storageToken.Uri}{storageToken.SasToken}\");\n            var blobStorage = new CloudBlockBlob(storageUri);\n\n            // Get the length of the stream\n            var mediaLength = mediaStream.Length;\n\n            // Initialize the blocks\n            int bytesInBlock = 1024;                // The number of bytes in a single block\n            var buffer = new byte[bytesInBlock];    // The buffer to hold the data during transfer\n            int totalBytesRead = 0;                 // The number of bytes read from the stream.\n            int bytesRead = 0;                      // The number of bytes read per block.\n            int blocksWritten = 0;                  // The # Blocks Written\n\n            IsUploadingFile = true;\n            FileProgress = 0.00;\n\n            // Loop through until we have processed the whole file\n            do\n            {\n                // Read a block from the media stream\n                bytesRead = mediaStream.Read(buffer, 0, bytesInBlock);\n\n                if (bytesRead > 0)\n                {\n                    // Move the buffer into a memory stream\n                    using (var memoryStream = new MemoryStream(buffer, 0, bytesRead))\n                    {\n                        string blockId = GetBlockId(blocksWritten);\n                        await blobStorage.PutBlockAsync(blockId, memoryStream, null);\n                    }\n\n                    // Update the internal counters\n                    totalBytesRead += bytesRead;\n                    blocksWritten++;\n\n                    // Update the progress bar\n                    FileProgress = totalBytesRead / mediaLength;\n                }\n\n            } while (bytesRead > 0);\n        }\n        catch (Exception ex)\n        {\n            await Application.Current.MainPage.DisplayAlert(\"Error Uploading File\", ex.Message, \"OK\");\n        }\n        finally\n        {\n            IsBusy = false;\n            IsUploadingFile = false;\n            FileProgress = 0.0;\n        }\n    }\n\n    /// <summary>\n    /// Convert the Block ID to the string we need\n    /// </summary>\n    /// <param name=\"block\"></param>\n    /// <returns></returns>\n    private string GetBlockId(int block)\n    {\n        char[] tempID = new char[6];\n        string iStr = block.ToString();\n\n        for (int j = tempID.Length - 1; j > (tempID.Length - iStr.Length - 1); j--)\n        {\n            tempID[j] = iStr[tempID.Length - j - 1];\n        }\n        byte[] blockIDBeforeEncoding = Encoding.UTF8.GetBytes(tempID);\n        return Convert.ToBase64String(blockIDBeforeEncoding);\n    }\n\n\n\n\nThe main work is done in the inner loop.  We split the media stream into 1024 byte blocks.  Each block is copied into a temporary buffer\nthen transferred to cloud storage.  After each block is delivered, the \nFileProgress\n counter is updated which updates the progress bar.\n\n\nOne of the secrets for doing block-based streaming uploads is the \nGetBlockId()\n method.  This properly formats the block ID (based on\na rather convoluted method that ends up being Base-64 encoded).  If you do not get this right, you will instead get a rather cryptic\nmessage about the query parameter for the HTTP request being wrong.\n\n\nDownload a File from Blob Storage\n\u00b6\n\n\nYou can similarly download a file from blob storage.  To do the basic form:\n\n\n    // Get the SAS token from the backend\n    var storageToken = await CloudService.GetSasTokenAsync(filename);\n\n    // Use the SAS token to get a reference to the blob storage\n    var storageUri = new Uri($\"{storageToken.Uri}{storageToken.SasToken}\");\n    var blobStorage = new CloudBlockBlob(storageUri);\n\n    // Get a stream for the blob file\n    var mediaStream = await blobStorage.OpenReadAsync();\n    // Do something with the mediaStream - like move it to storage\n    await PlatformProvider.StoreFileAsync(mediaStream);\n    // At the end, close the stream properly\n    mediaStream.Dispose();\n\n\n\n\nSimilarly, you can also produce a progress bar:\n\n\n    // Get the SAS token from the backend\n    var storageToken = await CloudService.GetSasTokenAsync(filename);\n\n    // Use the SAS token to get a reference to the blob storage\n    var storageUri = new Uri($\"{storageToken.Uri}{storageToken.SasToken}\");\n    var blobStorage = new CloudBlockBlob(storageUri);\n    var mediaStream = await blobStorage.OpenReadAsync();\n\n    var mediaLength = mediaStream.Length;\n    byte[] buffer = new byte[1024];\n    var bytesRead = 0, totalBytesRead = 0;\n\n    // Do what you need to for opening your output file\n    do {\n        bytesRead = mediaStream.ReadAsync(buffer, 0, 1024);\n        if (bytesRead > 0) {\n            // Do something with the buffer\n\n            totalBytesRead += bytesRead;\n            FileProgress = totalBytesRead / mediaLength;\n        }\n    } while (bytesRead > 0);\n\n    // Potentially close your output file as well\n    mediaStream.Dispose();\n\n\n\n\nWhen downloading, you will need to update the \nGetStorageTokenController\n method to provide access to files.  One possibility is to\nprovide read/write access to the entire container, allowing the mobile device to get a directory listing for browsing.",
            "title": "Dealing with Files"
        },
        {
            "location": "/chapter6/files/#dealing-with-files",
            "text": "The most normal tasks for dealing with files are the upload and download of files to blob storage.  There is\na natural and consistent process to this which makes this recipe very repeatable.  First, deal with the things\nyou need before you start:   Create an Azure Storage Account and link it to your Azure App Service.  Decide how you want your files organized.  Create a WebAPI to generate a SAS token for your upload or download.   I've already discussed  how to create and link an Azure Storage Account .  Blob storage is organized in a\ntypical directory structure.  Each directory is called a container, and each file is a blob.  In the examples\nfor this section, I am going to store each uploaded file in a container based on the authenticated user.  My\nWebAPI will create the appropriate container and then return an appropriate SAS token.  We haven't discussed custom code yet.  We will go much deeper than we do right now.  Custom APIs allow us to\nwrite custom code and execute it within the context of the mobile backend.  It has access to many of the same\nfacilities as the rest of the mobile backend - things like app settings, connection strings, and the Entity\nFramework structure.  To enable custom APIs, you need to alter the  App_Start\\Startup.MobileApp.cs  file so\nthat the custom APIs are attached to HTTP routes properly:      HttpConfiguration config = new HttpConfiguration();\n\n    new MobileAppConfiguration()\n        .AddTablesWithEntityFramework()\n        .MapApiControllers()\n        .ApplyTo(config);  The Custom API is a standard ASP.NET controller with the  [MobileAppController]  attribute attached to the\nclass.  The  [MobileAppController]  signals to Azure Mobile Apps that the controller needs to be registered\nunder the  /api  endpoint.  It also handles API version checking (or at least checks that the  ZUMO-API-VERSION \nheader is set to 2.0.0) and appropriately handles authorization if the  [Authorize]  attribute is present. The\nmapping under the  /api  endpoint only happens if the  .MapApiControllers()  extension method is called during\nconfiguration.   Info  Ensure you install the latest version of the  WindowsAzure.Storage  Nuget package using the NuGet package\nManager before continuing.   When we linked the Azure Storage account, we added a connection string called  MS_AzureStorageAccountConnectionString .\nThis is included in the environment as  CUSTOMCONNSTR_MS_AzureStorageAccountConnectionString .  We can add a new\nCustom API controller in Visual Studio by right-clicking on the  Controllers  node, then selecting  Add  -> Controller...  and selecting the  Azure Mobile APps Custom Controller  option.  We can set up our custom API\nas follows:  namespace Backend.Controllers\n{\n    [Authorize]\n    [MobileappController]\n    public class GetStorageTokenController : ApiController\n    {\n        private const string connString = \"CUSTOMCONNSTR_MS_AzureStorageAccountConnectionString\";\n\n        public GetStorageTokenController()\n        {\n            ConnectionString = Environment.GetEnvironmentVariable(connString);\n            StorageAccount = CloudStorageAccount.Parse(ConnectionString);\n            BlobClient = StorageAccount.CreateCloudBlobClient();\n        }\n\n        public string ConnectionString { get; }\n\n        public CloudStorageAccount StorageAccount { get; }\n\n        public CloudBlobClient BlobClient { get; }\n    }\n}  The  ConnectionString  property is the pointer to where the Azure Storage account is located and how to\naccess it.  the  StorageAccount  is a reference to that Azure Storage account.  Finally, the  BlobClient \nis an object used for accessing blob storage.  We can access any WebAPI methods in this class by using\nthe endpoint  /api/GetStorageToken  within our mobile client or using Postman.  Azure Storage doesn't have a true heirarchial container system.  It does have containers and directories\nto organize things though, so we are going to use that:      private const string containerName = \"userdata\";\n\n    [HttpGet]\n    public async Task<StorageTokenViewModel> GetAsync()\n    {\n        // The userId is the SID without the sid: prefix\n        var claimsPrincipal = User as ClaimsPrincipal;\n        var userId = claimsPrincipal\n            .FindFirst(ClaimTypes.NameIdentifier)\n            .Value.Substring(4);\n\n        // Errors creating the storage container result in a 500 Internal Server Error\n        var container = BlobClient.GetContainerReference(containerName);\n        await container.CreateIfNotExistsAsync();\n\n        // Get the user directory within the container\n        var directory = container.GetDirectoryReference(userId);\n        var blobName = Guid.NewGuid().ToString(\"N\");\n        var blob = directory.GetBlockBlobReference(blobName);\n\n        // Create a policy for accessing the defined blob\n        var blobPolicy = new SharedAccessBlobPolicy\n        {\n            SharedAccessStartTime = DateTime.UtcNow.AddMinutes(-5),\n            SharedAccessExpiryTime = DateTime.UtcNow.AddMinutes(60),\n            Permissions = SharedAccessBlobPermissions.Read\n                        | SharedAccessBlobPermissions.Write\n                        | SharedAccessBlobPermissions.Create\n        };\n\n        return new StorageTokenViewModel\n        {\n            Name = blobName,\n            Uri = blob.Uri,\n            SasToken = blob.GetSharedAccessSignature(blobPolicy)\n        };\n    }  The main piece of work in this API is generating the policy that is then signed and returned to\nthe user as the SAS Token.  The mobile device has permission to read, write and create the blob\nthat we have defined for the next 60 minutes.  I've provided a policy that starts in the past in\ncase there is a little amount of clock-skew between the mobile device and the backend.   Warn  Container names must be a valid DNS name.  The most notable requirement here is between 3\nand 64 lower-case letters.  Container names are case-sensitive.  Check  the documentation \nfor full details on naming requirements.   The  StorageTokenViewModel  is used for serialization purposes:  public class StorageTokenViewModel\n{\n    public string Name { get; set; }\n    public Uri Uri { get; set; }\n    public string SasToken { get; set; }\n}  We can test this API using Postman.  First, generate an authentication token.  Then use Postman to\ndo a GET of the  /api/GetStorageToken  endpoint:   There are two pieces of information we need here.  Firstly, the  uri  property provides the URI that we are going to\nuse to upload the file.  Secondly, the  sasToken  is appended to the  uri  when uploading to provide a link to the\npolicy.  Note that the token start and expiry time are encoded and readable in the sasToken.  In real world applications, this is likely not the right method.  We might want to organize the files based on information\nthat the mobile client provides us, for example.  We may also want to upload to a specific upload area and then download\nfrom another location, allowing processing of the files in between.  You may also want to append the uploaded file extension\nto the file before uploading.  There is no \"one size fits all\" token policy.  You must decide on the conditions under which\nyou will allow upload and download capabilities and then provide the appropriate logic to generate the SAS token.",
            "title": "Dealing with Files"
        },
        {
            "location": "/chapter6/files/#uploading-a-file-to-blob-storage",
            "text": "Once we have the logic to generate a SAS token, we can turn our attention to the mobile clients.  We need to do three\nthings for uploading a file to the service:   Get a reference to the file (as a Stream object).  Generate a SAS token using the custom API.  Use the Azure Storage SDK to upload directly to the Azure Storage Account.   You should not upload to a custom API in your mobile backend.  This needlessly ties up your mobile backend, causing your\nmobile backend to be less efficient at scaling.  Your mobile backend will not have all the facilities that the\nAzure Storage endpoint has provided either.  Azure Storage provides upload and download restarts and progress bar\ncapabilities.  Obtaining a reference to the file that you wish to upload is normally a per-platform API.  Obtaining a reference to a photo or video\ninvolves interacting with platform-specific APIs to provide access to camera and built-in photo storage capabilities on the\nphone. To support such a per-platform capability, we need to add an interface for the API to the  Abstractions\\IPlatform.cs  file:  Task<Stream> GetUploadFileAsync();  This API will interact with whatever photo sharing API is available on the device, open the requested file and return a standard Stream  object.  Loading a media file is made much simpler using the cross-platform [Xamarin Media] plugin.  This plugin allows\nthe user to take photos or video, or pick  the media file from a gallery.  It's available on NuGet, so add the  Xam.Plugin.Media \nplugin to each of the platform-specific projects.   Tip  I still like separating out code that deals with the hardware of a mobile device into the platform-specific code.  You don't\nneed to do such separation on this project.  I find that I inevitably have one thing or another that requires a platform-specific\ntweak, so starting with a platform-specific API is better.   The Xamarin Media plugin is used like this:  await CrossMedia.Current.Initialize();\n\nvar file = await CrossMedia.Current.PickPhotoAsync();\nvar stream = file.GetStream();  There are methods within the plugin to determine if a camera is available.  Different platforms require different permissions:",
            "title": "Uploading a File to Blob Storage"
        },
        {
            "location": "/chapter6/files/#android",
            "text": "Android requires the   WRITE\\_EXTERNAL\\_STORAGE ,  READ\\_EXTERNAL\\_STORAGE  and  CAMERA  permissions. If the mobile device is\nrunning Android M or later, the plugin will automatically prompt the user for runtime permissions.  You can set these permissions\nwithin Visual Studio:   Double-click the  Properties  node within the Android project.  Select  Android Manifest .  In the  Required permissions  list, check the box next to the required permissions by double-clicking the permission.  Save the Properties (you may have to right-click on the TaskList.Droid tab and click on  Save Selected Items ).",
            "title": "Android"
        },
        {
            "location": "/chapter6/files/#ios",
            "text": "Apple iOS requires the  NSCameraUsageDescription  and  NSPhotoLibraryUsageDescription  keys.  The string provided will be\ndisplayed to the user when they are prompted to provide permission.  You can set these keys within Visual Studio:   Right-click on the  Info.plist  file and select  Open with...  Choose the  XML (Text) Editor  then click  OK .  Within the  <dict>  node, add the following lines:   <key>NSCameraUsageDescription</key>\n<string>This app needs access to the camera to take photos.</string>\n<key>NSPhotoLibraryUsageDescription</key>\n<string>This app needs access to photos.</string>   Save and close the file.   You can choose whatever string you want to display to the user.  For more information on iOS 10 privacy permissions, review\nthe  Xamarin Blog .",
            "title": "iOS"
        },
        {
            "location": "/chapter6/files/#universal-windows",
            "text": "Universal Windows may require the  Pictures Library  capability:   In the  TaskList.UWP (Universal Windows)  project, open  Package.appxmanifest .  Select the  Capabilities  tab.  Check the box next to  Pictures Library .  Save the manifest.",
            "title": "Universal Windows"
        },
        {
            "location": "/chapter6/files/#implementing-the-file-reader",
            "text": "The same code can be used in all three platform-specific projects, in the  *Platform.cs  file:      /// <summary>\n    /// Picks a photo for uploading\n    /// </summary>\n    /// <returns>A Stream for the photo</returns>\n    public async Task<Stream> GetUploadFileAsync()\n    {\n        var mediaPlugin = CrossMedia.Current;\n        var mainPage = Xamarin.Forms.Application.Current.MainPage;\n\n        await mediaPlugin.Initialize();\n\n        if (mediaPlugin.IsPickPhotoSupported)\n        {\n            var mediaFile = await mediaPlugin.PickPhotoAsync();\n            return mediaFile.GetStream();\n        }\n        else\n        {\n            await mainPage.DisplayAlert(\"Media Service Unavailable\", \"Cannot pick photo\", \"OK\");\n            return null;\n        }\n    }",
            "title": "Implementing the File Reader"
        },
        {
            "location": "/chapter6/files/#uploading-a-file",
            "text": "We can now put the individual pieces together to actually do an upload.  In this example, we are going to use the photo picker to\npick a photo and then upload it, displaying a progress bar as it happens.  We start with the XAML code in  Pages\\TaskList.xaml .  We\nneed a button in the toolbar to initiate the file upload:      <ContentPage.ToolbarItems>\n        <ToolbarItem Name=\"Refresh\"\n                     Command=\"{Binding RefreshCommand}\"\n                     Icon=\"refresh.png\"\n                     Order=\"Primary\"\n                     Priority=\"0\" />\n        <ToolbarItem Name=\"Add Task\"\n                     Command=\"{Binding AddNewItemCommand}\"\n                     Icon=\"add.png\"\n                     Order=\"Primary\"\n                     Priority=\"0\" />\n        <ToolbarItem Name=\"Add File\"\n                     Command=\"{Binding AddNewFileCommand}\"\n                     Icon=\"addfile.png\"\n                     Order=\"Primary\"\n                     Priority=\"0\" />\n    </ContentPage.ToolbarItems>  Obtain a suitable \"Add File\" icon from the Internet and resize the image appropriately for the task.  You will need five images total:   TaskList.Droid\\Resources\\drawable\\addfile.png should be 128x128 pixels  TaskList.iOS\\Resources\\addfile.png should be 25x25 pixels  TaskList.iOS\\Resources\\addfile@2x.png should be 50x50 pixels  TaskList.iOS\\Resources\\addfile@3x.png should be 75x75 pixels  TaskList.UWP\\addfile.png should be 128x128 pixels   All images should have a transparent background.  The storage token is retrieved from the backend via the cloud service.  Add the following to  Abstractions\\ICloudService.cs :      // Custom APIs\n    Task<StorageTokenViewModel> GetSasTokenAsync();  This has a concrete implementation in  Services\\AzureCloudService.cs :      public async Task<StorageTokenViewModel> GetSasTokenAsync()\n    {\n        var parameters = new Dictionary<string, string>();\n        var storageToken = await Client.InvokeApiAsync<StorageTokenViewModel>(\"GetStorageToken\", HttpMethod.Get, parameters);\n        return storageToken;\n    }  The  StorageTokenViewModel  is identical to the class in the  GetStorageTokenController.cs  controller in the Backend.  I've placed the class\ndefinition in the  Models  namespace for the client.  We could share this model between the backend and front end, but the case of sharing\nmodels is so rare I tend not to share the code.  In the  TaskListViewModel.cs , we can define a command that is called when the Add File button is clicked:      /// <summary>\n    /// Reference to the Platform Provider\n    /// </summary>\n    public IPlatform PlatformProvider => DependencyService.Get<IPlatform>();\n\n    /// <summary>\n    /// Bindable property for the AddNewFile Command\n    /// </summary>\n    public ICommand AddNewFileCommand { get; }\n\n    /// <summary>\n    /// User clicked on the Add New File button\n    /// </summary>\n    private async Task AddNewFileAsync()\n    {\n        if (IsBusy)\n        {\n            return;\n        }\n        IsBusy = true;\n\n        try\n        {\n            // Get a stream for the file\n            var mediaStream = await PlatformProvider.GetUploadFileAsync();\n            if (mediaStream == null)\n            {\n                IsBusy = false;\n                return;\n            }\n\n            // Get the SAS token from the backend\n            var storageToken = await CloudService.GetSasTokenAsync();\n\n            // Use the SAS token to upload the file\n            var storageUri = new Uri($\"{storageToken.Uri}{storageToken.SasToken}\");\n            var blobStorage = new CloudBlockBlob(storageUri);\n            await blobStorage.UploadFromStreamAsync(mediaStream);\n        }\n        catch (Exception ex)\n        {\n            await Application.Current.MainPage.DisplayAlert(\"Error Uploading File\", ex.Message, \"OK\");\n        }\n        finally\n        {\n            IsBusy = false;\n        }\n    }   Warn  Azure Storage SDK support for PCL projects is only available in -preview editions.  When installing the SDK, ensure you check the\n\"Include prerelease\" box in the NuGet package manager.  The latest version with PCL (.NETPortable) support is v7.0.2-preview.   You can look at the uploaded files in the Azure portal:   Log in to the  Azure portal .  Click  All resources , then your storage account.  Under  SERVICES , click  Blobs .  Click your storage container (in this example, that's called  userdata )    You will see a folder for each user account.  The folder is named for the SID of the account - not the username.  It's a good idea to\nstore the user SID with other data about the user in a table within your database.   This allows you to associate a real user with their\nSID since a user will never know what their SID is.",
            "title": "Uploading a File"
        },
        {
            "location": "/chapter6/files/#implementing-a-progress-bar",
            "text": "It's common to want to see the progress of the upload while it is happening.  For that, we need a progress bar.  First, let's add a hidden\nprogress bar to our  TaskList.xaml  page:      <ActivityIndicator HorizontalOptions=\"FillAndExpand\"\n                        IsRunning=\"{Binding IsBusy}\"\n                        IsVisible=\"{Binding IsBusy}\"\n                        VerticalOptions=\"Start\" />\n    <ProgressBar x:Name=\"fileUploadProgress\"\n                    HeightRequest=\"3\"\n                    HorizontalOptions=\"FillAndExpand\"\n                    IsVisible=\"{Binding IsUploadingFile}\"\n                    Progress=\"{Binding FileProgress}\" />  This comes with two new bindable properties.   IsUploadingFile  is a  bool  and  FileProgress  is a  Double .   FileProgress  takes a value between\n0 and 1 to indicate how far along the progress bar should be.  This code should be in the  TaskListViewModel.cs  file:      private bool isUploadingFile;\n    public bool IsUploadingFile\n    {\n        get { return isUploadingFile; }\n        set { SetProperty(ref isUploadingFile, value, \"IsUploadingFile\"); }\n    }\n\n    private Double fileProgress = 0.0;\n    public Double FileProgress\n    {\n        get { return fileProgress;  }\n        set { SetProperty(ref fileProgress, value, \"FileProgress\"); }\n    }  Finally, we have to change the upload so that it happens a chunk at a time.  In the  AddNewFileAsync()  method, we can replace the upload code with this:      /// <summary>\n    /// User clicked on the Add New File button\n    /// </summary>\n    private async Task AddNewFileAsync()\n    {\n        if (IsBusy)\n        {\n            return;\n        }\n        IsBusy = true;\n\n        try\n        {\n            // Get a stream for the file\n            var mediaStream = await PlatformProvider.GetUploadFileAsync();\n            if (mediaStream == null)\n            {\n                IsBusy = false;\n                return;\n            }\n\n            // Get the SAS token from the backend\n            var storageToken = await CloudService.GetSasTokenAsync();\n\n            // Use the SAS token to get a reference to the blob storage\n            var storageUri = new Uri($\"{storageToken.Uri}{storageToken.SasToken}\");\n            var blobStorage = new CloudBlockBlob(storageUri);\n\n            // Get the length of the stream\n            var mediaLength = mediaStream.Length;\n\n            // Initialize the blocks\n            int bytesInBlock = 1024;                // The number of bytes in a single block\n            var buffer = new byte[bytesInBlock];    // The buffer to hold the data during transfer\n            int totalBytesRead = 0;                 // The number of bytes read from the stream.\n            int bytesRead = 0;                      // The number of bytes read per block.\n            int blocksWritten = 0;                  // The # Blocks Written\n\n            IsUploadingFile = true;\n            FileProgress = 0.00;\n\n            // Loop through until we have processed the whole file\n            do\n            {\n                // Read a block from the media stream\n                bytesRead = mediaStream.Read(buffer, 0, bytesInBlock);\n\n                if (bytesRead > 0)\n                {\n                    // Move the buffer into a memory stream\n                    using (var memoryStream = new MemoryStream(buffer, 0, bytesRead))\n                    {\n                        string blockId = GetBlockId(blocksWritten);\n                        await blobStorage.PutBlockAsync(blockId, memoryStream, null);\n                    }\n\n                    // Update the internal counters\n                    totalBytesRead += bytesRead;\n                    blocksWritten++;\n\n                    // Update the progress bar\n                    FileProgress = totalBytesRead / mediaLength;\n                }\n\n            } while (bytesRead > 0);\n        }\n        catch (Exception ex)\n        {\n            await Application.Current.MainPage.DisplayAlert(\"Error Uploading File\", ex.Message, \"OK\");\n        }\n        finally\n        {\n            IsBusy = false;\n            IsUploadingFile = false;\n            FileProgress = 0.0;\n        }\n    }\n\n    /// <summary>\n    /// Convert the Block ID to the string we need\n    /// </summary>\n    /// <param name=\"block\"></param>\n    /// <returns></returns>\n    private string GetBlockId(int block)\n    {\n        char[] tempID = new char[6];\n        string iStr = block.ToString();\n\n        for (int j = tempID.Length - 1; j > (tempID.Length - iStr.Length - 1); j--)\n        {\n            tempID[j] = iStr[tempID.Length - j - 1];\n        }\n        byte[] blockIDBeforeEncoding = Encoding.UTF8.GetBytes(tempID);\n        return Convert.ToBase64String(blockIDBeforeEncoding);\n    }  The main work is done in the inner loop.  We split the media stream into 1024 byte blocks.  Each block is copied into a temporary buffer\nthen transferred to cloud storage.  After each block is delivered, the  FileProgress  counter is updated which updates the progress bar.  One of the secrets for doing block-based streaming uploads is the  GetBlockId()  method.  This properly formats the block ID (based on\na rather convoluted method that ends up being Base-64 encoded).  If you do not get this right, you will instead get a rather cryptic\nmessage about the query parameter for the HTTP request being wrong.",
            "title": "Implementing a Progress bar"
        },
        {
            "location": "/chapter6/files/#download-a-file-from-blob-storage",
            "text": "You can similarly download a file from blob storage.  To do the basic form:      // Get the SAS token from the backend\n    var storageToken = await CloudService.GetSasTokenAsync(filename);\n\n    // Use the SAS token to get a reference to the blob storage\n    var storageUri = new Uri($\"{storageToken.Uri}{storageToken.SasToken}\");\n    var blobStorage = new CloudBlockBlob(storageUri);\n\n    // Get a stream for the blob file\n    var mediaStream = await blobStorage.OpenReadAsync();\n    // Do something with the mediaStream - like move it to storage\n    await PlatformProvider.StoreFileAsync(mediaStream);\n    // At the end, close the stream properly\n    mediaStream.Dispose();  Similarly, you can also produce a progress bar:      // Get the SAS token from the backend\n    var storageToken = await CloudService.GetSasTokenAsync(filename);\n\n    // Use the SAS token to get a reference to the blob storage\n    var storageUri = new Uri($\"{storageToken.Uri}{storageToken.SasToken}\");\n    var blobStorage = new CloudBlockBlob(storageUri);\n    var mediaStream = await blobStorage.OpenReadAsync();\n\n    var mediaLength = mediaStream.Length;\n    byte[] buffer = new byte[1024];\n    var bytesRead = 0, totalBytesRead = 0;\n\n    // Do what you need to for opening your output file\n    do {\n        bytesRead = mediaStream.ReadAsync(buffer, 0, 1024);\n        if (bytesRead > 0) {\n            // Do something with the buffer\n\n            totalBytesRead += bytesRead;\n            FileProgress = totalBytesRead / mediaLength;\n        }\n    } while (bytesRead > 0);\n\n    // Potentially close your output file as well\n    mediaStream.Dispose();  When downloading, you will need to update the  GetStorageTokenController  method to provide access to files.  One possibility is to\nprovide read/write access to the entire container, allowing the mobile device to get a directory listing for browsing.",
            "title": "Download a File from Blob Storage"
        },
        {
            "location": "/chapter6/filesync/",
            "text": "File Sync with Azure Mobile Apps\n\u00b6",
            "title": "File Synchronization"
        },
        {
            "location": "/chapter6/filesync/#file-sync-with-azure-mobile-apps",
            "text": "",
            "title": "File Sync with Azure Mobile Apps"
        },
        {
            "location": "/chapter7/mvc/",
            "text": "MVC Web Applications\n\u00b6\n\n\nSharing the Database\n\u00b6\n\n\nSharing Authentication\n\u00b6",
            "title": "MVC Applications"
        },
        {
            "location": "/chapter7/mvc/#mvc-web-applications",
            "text": "",
            "title": "MVC Web Applications"
        },
        {
            "location": "/chapter7/mvc/#sharing-the-database",
            "text": "",
            "title": "Sharing the Database"
        },
        {
            "location": "/chapter7/mvc/#sharing-authentication",
            "text": "",
            "title": "Sharing Authentication"
        },
        {
            "location": "/chapter7/spa/",
            "text": "Single Page Web Applications\n\u00b6\n\n\nUsing Mobile Endpoints\n\u00b6\n\n\nAuthentication\n\u00b6\n\n\nWeb Push\n\u00b6",
            "title": "SPA Applications"
        },
        {
            "location": "/chapter7/spa/#single-page-web-applications",
            "text": "",
            "title": "Single Page Web Applications"
        },
        {
            "location": "/chapter7/spa/#using-mobile-endpoints",
            "text": "",
            "title": "Using Mobile Endpoints"
        },
        {
            "location": "/chapter7/spa/#authentication",
            "text": "",
            "title": "Authentication"
        },
        {
            "location": "/chapter7/spa/#web-push",
            "text": "",
            "title": "Web Push"
        },
        {
            "location": "/chapter8/search/",
            "text": "Integrating Mobile Search\n\u00b6\n\n\nDiscovering Search capabilities\n\u00b6\n\n\nConfiguring Azure Search\n\u00b6\n\n\nUsing Azure Search\n\u00b6",
            "title": "Azure Search"
        },
        {
            "location": "/chapter8/search/#integrating-mobile-search",
            "text": "",
            "title": "Integrating Mobile Search"
        },
        {
            "location": "/chapter8/search/#discovering-search-capabilities",
            "text": "",
            "title": "Discovering Search capabilities"
        },
        {
            "location": "/chapter8/search/#configuring-azure-search",
            "text": "",
            "title": "Configuring Azure Search"
        },
        {
            "location": "/chapter8/search/#using-azure-search",
            "text": "",
            "title": "Using Azure Search"
        },
        {
            "location": "/chapter8/media/",
            "text": "Using Media Services\n\u00b6\n\n\nWhat can Media Services do?\n\u00b6\n\n\nUploading Videos from Mobile\n\u00b6\n\n\nAutomatically Processing Videos\n\u00b6\n\n\nStreaming Videos to Mobile\n\u00b6\n\n\nCase Study: Video Learning App\n\u00b6",
            "title": "Media Services"
        },
        {
            "location": "/chapter8/media/#using-media-services",
            "text": "",
            "title": "Using Media Services"
        },
        {
            "location": "/chapter8/media/#what-can-media-services-do",
            "text": "",
            "title": "What can Media Services do?"
        },
        {
            "location": "/chapter8/media/#uploading-videos-from-mobile",
            "text": "",
            "title": "Uploading Videos from Mobile"
        },
        {
            "location": "/chapter8/media/#automatically-processing-videos",
            "text": "",
            "title": "Automatically Processing Videos"
        },
        {
            "location": "/chapter8/media/#streaming-videos-to-mobile",
            "text": "",
            "title": "Streaming Videos to Mobile"
        },
        {
            "location": "/chapter8/media/#case-study-video-learning-app",
            "text": "",
            "title": "Case Study: Video Learning App"
        },
        {
            "location": "/chapter8/realtime/",
            "text": "Real Time Notifications\n\u00b6",
            "title": "Real-time Notifications"
        },
        {
            "location": "/chapter8/realtime/#real-time-notifications",
            "text": "",
            "title": "Real Time Notifications"
        },
        {
            "location": "/chapter9/developing/",
            "text": "The Development Environment\n\u00b6\n\n\nWorking with Azure mobile Apps Locally\n\u00b6\n\n\nHandling Authentication\n\u00b6\n\n\nHandling Push Notifications\n\u00b6\n\n\nDebugging your Cloud Mobile Backend\n\u00b6\n\n\nDiagnostic Logging\n\u00b6\n\n\nUsing the Visual Studio Debugger\n\u00b6",
            "title": "The Development Environment"
        },
        {
            "location": "/chapter9/developing/#the-development-environment",
            "text": "",
            "title": "The Development Environment"
        },
        {
            "location": "/chapter9/developing/#working-with-azure-mobile-apps-locally",
            "text": "",
            "title": "Working with Azure mobile Apps Locally"
        },
        {
            "location": "/chapter9/developing/#handling-authentication",
            "text": "",
            "title": "Handling Authentication"
        },
        {
            "location": "/chapter9/developing/#handling-push-notifications",
            "text": "",
            "title": "Handling Push Notifications"
        },
        {
            "location": "/chapter9/developing/#debugging-your-cloud-mobile-backend",
            "text": "",
            "title": "Debugging your Cloud Mobile Backend"
        },
        {
            "location": "/chapter9/developing/#diagnostic-logging",
            "text": "",
            "title": "Diagnostic Logging"
        },
        {
            "location": "/chapter9/developing/#using-the-visual-studio-debugger",
            "text": "",
            "title": "Using the Visual Studio Debugger"
        },
        {
            "location": "/chapter9/testing/",
            "text": "Testing your Mobile Application\n\u00b6\n\n\nTesting your Mobile Client\n\u00b6\n\n\nIntroduction to Mobile Client Testing\n\u00b6\n\n\nIntroduction to Xamarin Test Cloud\n\u00b6\n\n\nUsing Mock Data Services\n\u00b6\n\n\nUnit Testing\n\u00b6\n\n\nTesting your Mobile Backend\n\u00b6\n\n\nIntroduction to Mobile Backend Testing\n\u00b6\n\n\nUnit Testing\n\u00b6\n\n\nLoad Testing\n\u00b6\n\n\nEnd to End Testing\n\u00b6",
            "title": "Testing your Application"
        },
        {
            "location": "/chapter9/testing/#testing-your-mobile-application",
            "text": "",
            "title": "Testing your Mobile Application"
        },
        {
            "location": "/chapter9/testing/#testing-your-mobile-client",
            "text": "",
            "title": "Testing your Mobile Client"
        },
        {
            "location": "/chapter9/testing/#introduction-to-mobile-client-testing",
            "text": "",
            "title": "Introduction to Mobile Client Testing"
        },
        {
            "location": "/chapter9/testing/#introduction-to-xamarin-test-cloud",
            "text": "",
            "title": "Introduction to Xamarin Test Cloud"
        },
        {
            "location": "/chapter9/testing/#using-mock-data-services",
            "text": "",
            "title": "Using Mock Data Services"
        },
        {
            "location": "/chapter9/testing/#unit-testing",
            "text": "",
            "title": "Unit Testing"
        },
        {
            "location": "/chapter9/testing/#testing-your-mobile-backend",
            "text": "",
            "title": "Testing your Mobile Backend"
        },
        {
            "location": "/chapter9/testing/#introduction-to-mobile-backend-testing",
            "text": "",
            "title": "Introduction to Mobile Backend Testing"
        },
        {
            "location": "/chapter9/testing/#unit-testing_1",
            "text": "",
            "title": "Unit Testing"
        },
        {
            "location": "/chapter9/testing/#load-testing",
            "text": "",
            "title": "Load Testing"
        },
        {
            "location": "/chapter9/testing/#end-to-end-testing",
            "text": "",
            "title": "End to End Testing"
        },
        {
            "location": "/chapter10/arm/",
            "text": "Repeatable Deployments\n\u00b6\n\n\nOptions for Deployment\n\u00b6\n\n\nCreating an ARM Template\n\u00b6\n\n\nDeploying an ARM Template on Windows\n\u00b6\n\n\nDeploying an ARM Template on MacOS\n\u00b6",
            "title": "Repeatable Deployments"
        },
        {
            "location": "/chapter10/arm/#repeatable-deployments",
            "text": "",
            "title": "Repeatable Deployments"
        },
        {
            "location": "/chapter10/arm/#options-for-deployment",
            "text": "",
            "title": "Options for Deployment"
        },
        {
            "location": "/chapter10/arm/#creating-an-arm-template",
            "text": "",
            "title": "Creating an ARM Template"
        },
        {
            "location": "/chapter10/arm/#deploying-an-arm-template-on-windows",
            "text": "",
            "title": "Deploying an ARM Template on Windows"
        },
        {
            "location": "/chapter10/arm/#deploying-an-arm-template-on-macos",
            "text": "",
            "title": "Deploying an ARM Template on MacOS"
        },
        {
            "location": "/chapter10/appsvc/",
            "text": "Safe Deployments\n\u00b6\n\n\nUsing Slots\n\u00b6\n\n\nScaling your Site\n\u00b6",
            "title": "Safe Deployments"
        },
        {
            "location": "/chapter10/appsvc/#safe-deployments",
            "text": "",
            "title": "Safe Deployments"
        },
        {
            "location": "/chapter10/appsvc/#using-slots",
            "text": "",
            "title": "Using Slots"
        },
        {
            "location": "/chapter10/appsvc/#scaling-your-site",
            "text": "",
            "title": "Scaling your Site"
        },
        {
            "location": "/chapter10/monitoring/",
            "text": "Monitoring\n\u00b6\n\n\nMonitoring your Backend\n\u00b6\n\n\nMonitoring your Mobile Clients\n\u00b6\n\n\nBest Practices\n\u00b6",
            "title": "Monitoring"
        },
        {
            "location": "/chapter10/monitoring/#monitoring",
            "text": "",
            "title": "Monitoring"
        },
        {
            "location": "/chapter10/monitoring/#monitoring-your-backend",
            "text": "",
            "title": "Monitoring your Backend"
        },
        {
            "location": "/chapter10/monitoring/#monitoring-your-mobile-clients",
            "text": "",
            "title": "Monitoring your Mobile Clients"
        },
        {
            "location": "/chapter10/monitoring/#best-practices",
            "text": "",
            "title": "Best Practices"
        },
        {
            "location": "/chapter10/troubleshooting/",
            "text": "Troubleshooting\n\u00b6\n\n\nTroubleshooting the Mobile Backend\n\u00b6\n\n\nTroubleshooting the Mobile Client\n\u00b6\n\n\nBest Practices\n\u00b6",
            "title": "Troubleshooting"
        },
        {
            "location": "/chapter10/troubleshooting/#troubleshooting",
            "text": "",
            "title": "Troubleshooting"
        },
        {
            "location": "/chapter10/troubleshooting/#troubleshooting-the-mobile-backend",
            "text": "",
            "title": "Troubleshooting the Mobile Backend"
        },
        {
            "location": "/chapter10/troubleshooting/#troubleshooting-the-mobile-client",
            "text": "",
            "title": "Troubleshooting the Mobile Client"
        },
        {
            "location": "/chapter10/troubleshooting/#best-practices",
            "text": "",
            "title": "Best Practices"
        },
        {
            "location": "/xamarin_tips/",
            "text": "Xamarin Forms Tips\n\u00b6\n\n\nOver the many months I have spent coding Xamarin Forms, a number of people\nfrom the community and the Xamarin team have given me little tips to improve\nmy Xamarin Forms code.  I hope you find them as useful as I did.\n\n\nImprove your ListView performance\n\u00b6\n\n\nIt should be no surprise that performance matters.  Little things like smooth\nscrolling and fast load times are a must.  A lot of improvement can be gained\nby the techniques we have shown in this book since most of the perceived delays\nare caused by the back end loading times.\n\n\nEventually, a lot of apps generate a list.  The normal way for implementing\nthis is with a \nListView\n that has an \nObservableCollection\n  You load your\ndata into the ObservableCollection and then update that whenever the data\nchanges.  That, in turn, updates the ListView.\n\n\nThere are two problems that are inherent here.  The first is in the ObservableCollection\nand the second is in the ListView.  Let's tackle the ObservableCollection first.\n\n\nThe problem with the ObservableCollection is that it's very hard to update.\nWhat normally ends up happening is code like this:\n\n\n// Earlier in the code\nvar listContents = new ObservableCollection<Model>();\n\n// When updating the code\nvar items = await table.ReadAllItemsAsync();\nlistContents.Clear();\nfor (var item in items) {\n    listContents.Add(item);\n}\n\n\n\n\nThe point of the ObservableCollection is that it emits an event whenever the\nlist changes.  In the case where the table has thousands of entries, thousands\nof events will cause thousands of redraws, causing a major slow down in your\ncode that you probably won't know until you have a large enough data set to\nnote the problem.\n\n\nFortunately, one of the top Xamarin Evangelists, \nJames Montemagno\n, has\ncreated a set of helper classes that assist with this sort of problem.  The\nsolution to this problem is to use the \nObservableRangeCollection\n, like\nthis:\n\n\n// Earlier in the code\nvar listContents = new ObservableRangeCollection<Model>();\n\n// When updating the code\nvar items = await table.ReadAllItemsAsync();\nlistContents.ReplaceRange(items);\n\n\n\n\nWith this code, Xamarin Forms gets notified once instead of thousands of times.\nThere are actually several versions of this same behavior in the NuGet repository.\n\n\nAs to the second problem.  A \nListView\n with thousands of items will not be\nshowing all the items at once.  A ListView will update all the items that have\nbeen updated, irrespective of whether they are visible or not.  The answer is\nto use a caching strategy.  There are two potential caching strategies.  with\n\nRetainElement\n, the ListView will generate a cell for each item in the list.\nThis is the default, but it's really only good for certain situations (most\nnotably when the cell has a large number of bindings).  For almost all situations,\nthe \nRecycleElement\n caching strategy should be used.  In this caching strategy,\nthe ListView will minimize the memory foot print and execution speed by only\nupdating cells when they are in the viewable area.  This is good pretty much\nall the time, but explicitly when the cell has a small number of bindings or\nwhen each cell in the list has the same template.  All data about the cell must\ncome from the binding context when using the \nRecycleElement\n caching strategy.\n\n\nYou can set the caching strategy right in the XAML:\n\n\n<ListView CachingStrategy=\"RecycleElement\" ...>\n\n\n\n\nAlternatively, if you are creating a ListView in code, you can specify the\ncaching strategy in the constructor:\n\n\nvar listView = new ListView(ListViewCachingStrategy.RecycleElement);\n\n\n\n\nThere are more techniques for improving ListView performance in the\n\nXamarin documentation\n\n\nBuild a Floating Action Button\n\u00b6\n\n\nOne of the things that I wanted to do to my apps was to give them a little more in the\nway of normal UI design.  My original design (which I introduced back in [Chapter ][ch1])\nhad teal buttons at the bottom of the page.  These buttons scrolled off the page when\nthere were more items on the page than could reasonably be fit on the page.  To fix this,\nI wanted to create a button that was always relative to the viewport.\n\n\nThere are two steps to this.  Firstly, you need to convert the layout to a \nRelativeLayout\n.\nFor instance, my new \nListView.xaml\n file:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage x:Class=\"TaskList.Pages.TaskList\"\n             xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <RelativeLayout>\n            <StackLayout RelativeLayout.HeightConstraint=\"{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=1}\"\n                         RelativeLayout.WidthConstraint=\"{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=1}\">\n\n\n\n\nThe original \nStackLayout\n layout renderer is placed inside the newly added \nRelativeLayout\n.\nThe height and width constraints tell the StackLayout to consume the whole screen.\n\n\nAt the bottom of the page, I can add my button:\n\n\n            </StackLayout>\n\n            <!--  The Floating Button  -->\n            <Button BackgroundColor=\"Teal\"\n                    Command=\"{Binding AddNewItemCommand}\"\n                    RelativeLayout.XConstraint=\"{ConstraintExpression Type=RelativeToParent,\n                                                                      Property=Width,\n                                                                      Factor=1,\n                                                                      Constant=-60}\"\n                    RelativeLayout.YConstraint=\"{ConstraintExpression Type=RelativeToParent,\n                                                                      Property=Height,\n                                                                      Factor=1,\n                                                                      Constant=-60}\"\n                    Text=\"+\"\n                    TextColor=\"White\" />\n        </RelativeLayout>\n    </ContentPage.Content>\n</ContentPage>\n\n\n\n\nThe \nStackLayout\n is the end of the StackLayout I introduced in the previous listing.  Now\nI can add a button (or any other View type control, including a custom control that I may\nhave downloaded from NuGet or the Xamarin Plugins site) as well.  The button will float\nabove the other content since it is added later.  The constraints in this case provide\nthe location of the button.\n\n\nThere is more work to do.  For instance, you cannot click on the thing behind the button -\nthe button always receives the click, which will (in this case) initiate the addition of\na new item.  A custom control will allow you to provide iconography for the button, handle\nsituations where you want to scroll behind and provide for the circular styling of the button\nwhich seems to be in-vogue right now.\n\n\nIf you want to place commands that are not normally used, you may want to consider the ToolbarItem\narea of the ContentPage.  Here is a snippet:\n\n\n    <ContentPage.ToolbarItems>\n        <ToolbarItem Name=\"Refresh\"\n                     Command=\"{Binding RefreshCommand}\"\n                     Icon=\"refresh.png\"\n                     Order=\"Primary\"\n                     Priority=\"0\" />\n    </ContentPage.ToolbarItems>\n\n\n\n\nOn Universal Windows (where this is actually important due to a lack of \"pull-to-refresh\" logic), you\nwill see the familiar triple-dot on the app bar - clicking on the triple dot gives you access to\nthe refresh command.\n\n\nWork with a Picker in a ViewModel\n\u00b6\n\n\nThere are some controls that do not work well with a \nBindingContext\n.  One of these is the \nPicker\n.\nIt has a number of Items that indicate the elements in the drop-down.   However, the Items are not\nbindable, which means that they cannot be accessed via a ViewModel.\n\n\nLet's say you wish to use the drop-down Picker from a view model and use an async command to update\nthe elements in the Picker.  In the XAML file, give your picker a name:\n\n\n<Picker x:Name=\"myPicker\" />\n\n\n\n\nThis makes \nmyPicker\n a private variable in the generated class.  You can use this in the XAML \ncode-behind file to pass the picker to your view-model by overriding the \nOnBindingContextChanged\n\nmethod:\n\n\nprotected override void OnBindingContextChanged()\n{\n    base.OnBindingContextChanged();\n\n    MyViewModel vm = BindingContext as MyViewModel;\n    if (vm != null)\n    {\n        vm.MyPicker = myPicker;\n        vm.RefreshPickerCommand.Execute(null);\n    }\n}\n\n\n\n\nIn your view-model, you can create a standard async command:\n\n\nasync Task RefreshPickerAsync()\n{\n    if (MyPicker.Items.Count == 0)\n    {\n        /* This section gets the list of items in the picker */\n        var table = await CloudService.GetTableAsync<Tag>();\n        var tags = await tagTable.ReadAllItemsAsync();\n\n        /* This section updates MyPicker with the items */\n        foreach (var item in tags)\n        {\n            MyPicker.Items.Add(item.TagName);\n            // You may want to do a test for something in your item\n            // here and set SelectedIndex to the index if it matches\n        }\n    }\n}\n\n\n\n\nThe \nRefreshPickerAsync()\n command gets executed when the binding context is updated, which means the\nXAML has been executed and bound (thus the myPicker variable is set to the picker).  \n\n\nAnother way to accomplish this would be to encapsulate a picker in a custom control that does have a\nbindable Items element.  This has been discussed on the \nXamarin Forums\n.\n\n\nInstall NuGet Packages in Multiple Projects\n\u00b6\n\n\nOne of the common requirements we have in Xamarin Forms is to install NuGet packages\nin all the Xamarin Forms projects.  To do this, right-click on the solution and select\n\nManage NuGet Packages for Solution...\n.  When you install a package here, you can\nselect which projects it should be applied to, allowing you to install a package once\nacross all the dependent projects.\n\n\nAuto-Deploy Universal Windows Apps\n\u00b6\n\n\nOne of the more annoying things is that you have to \nDeploy\n the Universal Windows app.\nThis gets in the way of the build process.  I like to build then run.  Having the extra\nDeploy step in there might not seem like much until you find yourself deploying several\ntimes an hour.\n\n\nFortunately, there is a simple fix for this.  Set up the \nConfiguration Manager\n to\nautomatically deploy the right libraries on every successful build.  To do this:\n\n\n\n\nIn Visual Studio, select \nBuild\n -> \nConfiguration Manager...\n\n\nCheck the boxes you can under \nDeploy\n\n\n\n\n\n\n\n\nClick on \nClose\n\n\n\n\nThis setting is saved within the solution, so you only need to do it once per project.",
            "title": "Xamarin Forms Tips"
        },
        {
            "location": "/xamarin_tips/#xamarin-forms-tips",
            "text": "Over the many months I have spent coding Xamarin Forms, a number of people\nfrom the community and the Xamarin team have given me little tips to improve\nmy Xamarin Forms code.  I hope you find them as useful as I did.",
            "title": "Xamarin Forms Tips"
        },
        {
            "location": "/xamarin_tips/#improve-your-listview-performance",
            "text": "It should be no surprise that performance matters.  Little things like smooth\nscrolling and fast load times are a must.  A lot of improvement can be gained\nby the techniques we have shown in this book since most of the perceived delays\nare caused by the back end loading times.  Eventually, a lot of apps generate a list.  The normal way for implementing\nthis is with a  ListView  that has an  ObservableCollection   You load your\ndata into the ObservableCollection and then update that whenever the data\nchanges.  That, in turn, updates the ListView.  There are two problems that are inherent here.  The first is in the ObservableCollection\nand the second is in the ListView.  Let's tackle the ObservableCollection first.  The problem with the ObservableCollection is that it's very hard to update.\nWhat normally ends up happening is code like this:  // Earlier in the code\nvar listContents = new ObservableCollection<Model>();\n\n// When updating the code\nvar items = await table.ReadAllItemsAsync();\nlistContents.Clear();\nfor (var item in items) {\n    listContents.Add(item);\n}  The point of the ObservableCollection is that it emits an event whenever the\nlist changes.  In the case where the table has thousands of entries, thousands\nof events will cause thousands of redraws, causing a major slow down in your\ncode that you probably won't know until you have a large enough data set to\nnote the problem.  Fortunately, one of the top Xamarin Evangelists,  James Montemagno , has\ncreated a set of helper classes that assist with this sort of problem.  The\nsolution to this problem is to use the  ObservableRangeCollection , like\nthis:  // Earlier in the code\nvar listContents = new ObservableRangeCollection<Model>();\n\n// When updating the code\nvar items = await table.ReadAllItemsAsync();\nlistContents.ReplaceRange(items);  With this code, Xamarin Forms gets notified once instead of thousands of times.\nThere are actually several versions of this same behavior in the NuGet repository.  As to the second problem.  A  ListView  with thousands of items will not be\nshowing all the items at once.  A ListView will update all the items that have\nbeen updated, irrespective of whether they are visible or not.  The answer is\nto use a caching strategy.  There are two potential caching strategies.  with RetainElement , the ListView will generate a cell for each item in the list.\nThis is the default, but it's really only good for certain situations (most\nnotably when the cell has a large number of bindings).  For almost all situations,\nthe  RecycleElement  caching strategy should be used.  In this caching strategy,\nthe ListView will minimize the memory foot print and execution speed by only\nupdating cells when they are in the viewable area.  This is good pretty much\nall the time, but explicitly when the cell has a small number of bindings or\nwhen each cell in the list has the same template.  All data about the cell must\ncome from the binding context when using the  RecycleElement  caching strategy.  You can set the caching strategy right in the XAML:  <ListView CachingStrategy=\"RecycleElement\" ...>  Alternatively, if you are creating a ListView in code, you can specify the\ncaching strategy in the constructor:  var listView = new ListView(ListViewCachingStrategy.RecycleElement);  There are more techniques for improving ListView performance in the Xamarin documentation",
            "title": "Improve your ListView performance"
        },
        {
            "location": "/xamarin_tips/#build-a-floating-action-button",
            "text": "One of the things that I wanted to do to my apps was to give them a little more in the\nway of normal UI design.  My original design (which I introduced back in [Chapter ][ch1])\nhad teal buttons at the bottom of the page.  These buttons scrolled off the page when\nthere were more items on the page than could reasonably be fit on the page.  To fix this,\nI wanted to create a button that was always relative to the viewport.  There are two steps to this.  Firstly, you need to convert the layout to a  RelativeLayout .\nFor instance, my new  ListView.xaml  file:  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage x:Class=\"TaskList.Pages.TaskList\"\n             xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <RelativeLayout>\n            <StackLayout RelativeLayout.HeightConstraint=\"{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=1}\"\n                         RelativeLayout.WidthConstraint=\"{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=1}\">  The original  StackLayout  layout renderer is placed inside the newly added  RelativeLayout .\nThe height and width constraints tell the StackLayout to consume the whole screen.  At the bottom of the page, I can add my button:              </StackLayout>\n\n            <!--  The Floating Button  -->\n            <Button BackgroundColor=\"Teal\"\n                    Command=\"{Binding AddNewItemCommand}\"\n                    RelativeLayout.XConstraint=\"{ConstraintExpression Type=RelativeToParent,\n                                                                      Property=Width,\n                                                                      Factor=1,\n                                                                      Constant=-60}\"\n                    RelativeLayout.YConstraint=\"{ConstraintExpression Type=RelativeToParent,\n                                                                      Property=Height,\n                                                                      Factor=1,\n                                                                      Constant=-60}\"\n                    Text=\"+\"\n                    TextColor=\"White\" />\n        </RelativeLayout>\n    </ContentPage.Content>\n</ContentPage>  The  StackLayout  is the end of the StackLayout I introduced in the previous listing.  Now\nI can add a button (or any other View type control, including a custom control that I may\nhave downloaded from NuGet or the Xamarin Plugins site) as well.  The button will float\nabove the other content since it is added later.  The constraints in this case provide\nthe location of the button.  There is more work to do.  For instance, you cannot click on the thing behind the button -\nthe button always receives the click, which will (in this case) initiate the addition of\na new item.  A custom control will allow you to provide iconography for the button, handle\nsituations where you want to scroll behind and provide for the circular styling of the button\nwhich seems to be in-vogue right now.  If you want to place commands that are not normally used, you may want to consider the ToolbarItem\narea of the ContentPage.  Here is a snippet:      <ContentPage.ToolbarItems>\n        <ToolbarItem Name=\"Refresh\"\n                     Command=\"{Binding RefreshCommand}\"\n                     Icon=\"refresh.png\"\n                     Order=\"Primary\"\n                     Priority=\"0\" />\n    </ContentPage.ToolbarItems>  On Universal Windows (where this is actually important due to a lack of \"pull-to-refresh\" logic), you\nwill see the familiar triple-dot on the app bar - clicking on the triple dot gives you access to\nthe refresh command.",
            "title": "Build a Floating Action Button"
        },
        {
            "location": "/xamarin_tips/#work-with-a-picker-in-a-viewmodel",
            "text": "There are some controls that do not work well with a  BindingContext .  One of these is the  Picker .\nIt has a number of Items that indicate the elements in the drop-down.   However, the Items are not\nbindable, which means that they cannot be accessed via a ViewModel.  Let's say you wish to use the drop-down Picker from a view model and use an async command to update\nthe elements in the Picker.  In the XAML file, give your picker a name:  <Picker x:Name=\"myPicker\" />  This makes  myPicker  a private variable in the generated class.  You can use this in the XAML \ncode-behind file to pass the picker to your view-model by overriding the  OnBindingContextChanged \nmethod:  protected override void OnBindingContextChanged()\n{\n    base.OnBindingContextChanged();\n\n    MyViewModel vm = BindingContext as MyViewModel;\n    if (vm != null)\n    {\n        vm.MyPicker = myPicker;\n        vm.RefreshPickerCommand.Execute(null);\n    }\n}  In your view-model, you can create a standard async command:  async Task RefreshPickerAsync()\n{\n    if (MyPicker.Items.Count == 0)\n    {\n        /* This section gets the list of items in the picker */\n        var table = await CloudService.GetTableAsync<Tag>();\n        var tags = await tagTable.ReadAllItemsAsync();\n\n        /* This section updates MyPicker with the items */\n        foreach (var item in tags)\n        {\n            MyPicker.Items.Add(item.TagName);\n            // You may want to do a test for something in your item\n            // here and set SelectedIndex to the index if it matches\n        }\n    }\n}  The  RefreshPickerAsync()  command gets executed when the binding context is updated, which means the\nXAML has been executed and bound (thus the myPicker variable is set to the picker).    Another way to accomplish this would be to encapsulate a picker in a custom control that does have a\nbindable Items element.  This has been discussed on the  Xamarin Forums .",
            "title": "Work with a Picker in a ViewModel"
        },
        {
            "location": "/xamarin_tips/#install-nuget-packages-in-multiple-projects",
            "text": "One of the common requirements we have in Xamarin Forms is to install NuGet packages\nin all the Xamarin Forms projects.  To do this, right-click on the solution and select Manage NuGet Packages for Solution... .  When you install a package here, you can\nselect which projects it should be applied to, allowing you to install a package once\nacross all the dependent projects.",
            "title": "Install NuGet Packages in Multiple Projects"
        },
        {
            "location": "/xamarin_tips/#auto-deploy-universal-windows-apps",
            "text": "One of the more annoying things is that you have to  Deploy  the Universal Windows app.\nThis gets in the way of the build process.  I like to build then run.  Having the extra\nDeploy step in there might not seem like much until you find yourself deploying several\ntimes an hour.  Fortunately, there is a simple fix for this.  Set up the  Configuration Manager  to\nautomatically deploy the right libraries on every successful build.  To do this:   In Visual Studio, select  Build  ->  Configuration Manager...  Check the boxes you can under  Deploy     Click on  Close   This setting is saved within the solution, so you only need to do it once per project.",
            "title": "Auto-Deploy Universal Windows Apps"
        },
        {
            "location": "/android_appendix/",
            "text": "Android Developer Notes\n\u00b6\n\n\nThis chapter contains random notes that I discovered while developing mobile apps\nwith Xamarin Forms on the Android platform.  I hope they are useful to you.\n\n\nHandling Callbacks with an Android SDK\n\u00b6\n\n\nDissecting the Google Plus Login Process\n\u00b6\n\n\nMissing libaot-mscorlib.dll.so\n\u00b6\n\n\nWhen running an application is debug mode, I sometimes saw the following deployment issue:\n\n\nD/Mono    ( 1366): AOT module 'mscorlib.dll.so' not found: dlopen failed: library \"/data/app-lib/TaskList.Droid-2/libaot-mscorlib.dll.so\" not found\n\n\n\n\nTo fix this:\n\n\n\n\nRight-click on the \nDroid\n project and select \nProperties\n.\n\n\nSelect the \nAndroid Options\n tab.\n\n\nUncheck the \nUse Fast Deployment\n option.\n\n\nSave the properties sheet.\n\n\nRedeploy the application.\n\n\n\n\nFixing Errors with the Visual Studio Emulator for Android\n\u00b6\n\n\nOne of the issues I found while running on the Visual Studio Emulator for Android involved debugging.  The Android app \nstarts, then immediately closes and debugging stops.  In the output window, you see \nCould not connect to the debugger\n.\nTo fix this:\n\n\n\n\nClose the Android Emulator window.\n\n\nOpen the \nHyper-V Manager\n.\n\n\nRight-click the emulator you are trying to use and select \nSettings...\n.\n\n\nExpand the \nProcessor\n node and select \nCompatibility\n.\n\n\nCheck the \nMigrate to a physical computer with a different processor version\n box.\n\n\nClick on \nOK\n.\n\n\n\n\nIt's a good idea to do this on all the emulators.  When you start the emulator, this error should be gone.",
            "title": "Android Developer Notes"
        },
        {
            "location": "/android_appendix/#android-developer-notes",
            "text": "This chapter contains random notes that I discovered while developing mobile apps\nwith Xamarin Forms on the Android platform.  I hope they are useful to you.",
            "title": "Android Developer Notes"
        },
        {
            "location": "/android_appendix/#handling-callbacks-with-an-android-sdk",
            "text": "",
            "title": "Handling Callbacks with an Android SDK"
        },
        {
            "location": "/android_appendix/#dissecting-the-google-plus-login-process",
            "text": "",
            "title": "Dissecting the Google Plus Login Process"
        },
        {
            "location": "/android_appendix/#missing-libaot-mscorlibdllso",
            "text": "When running an application is debug mode, I sometimes saw the following deployment issue:  D/Mono    ( 1366): AOT module 'mscorlib.dll.so' not found: dlopen failed: library \"/data/app-lib/TaskList.Droid-2/libaot-mscorlib.dll.so\" not found  To fix this:   Right-click on the  Droid  project and select  Properties .  Select the  Android Options  tab.  Uncheck the  Use Fast Deployment  option.  Save the properties sheet.  Redeploy the application.",
            "title": "Missing libaot-mscorlib.dll.so"
        },
        {
            "location": "/android_appendix/#fixing-errors-with-the-visual-studio-emulator-for-android",
            "text": "One of the issues I found while running on the Visual Studio Emulator for Android involved debugging.  The Android app \nstarts, then immediately closes and debugging stops.  In the output window, you see  Could not connect to the debugger .\nTo fix this:   Close the Android Emulator window.  Open the  Hyper-V Manager .  Right-click the emulator you are trying to use and select  Settings... .  Expand the  Processor  node and select  Compatibility .  Check the  Migrate to a physical computer with a different processor version  box.  Click on  OK .   It's a good idea to do this on all the emulators.  When you start the emulator, this error should be gone.",
            "title": "Fixing Errors with the Visual Studio Emulator for Android"
        },
        {
            "location": "/references/",
            "text": "References\n\u00b6\n\n\nFurther Reading\n\u00b6\n\n\nAPI References\n\u00b6\n\n\nSamples\n\u00b6\n\n\nHow to get Help\n\u00b6",
            "title": "References"
        },
        {
            "location": "/references/#references",
            "text": "",
            "title": "References"
        },
        {
            "location": "/references/#further-reading",
            "text": "",
            "title": "Further Reading"
        },
        {
            "location": "/references/#api-references",
            "text": "",
            "title": "API References"
        },
        {
            "location": "/references/#samples",
            "text": "",
            "title": "Samples"
        },
        {
            "location": "/references/#how-to-get-help",
            "text": "",
            "title": "How to get Help"
        },
        {
            "location": "/credits/",
            "text": "Credits\n\u00b6\n\n\nI got a lot of assistance during the writing of this book.  The following people assisted (in no\nparticular order):\n\n\n\n\nChris Gillum\n\n\nChris Risner\n\n\nDonna Malayeri\n\n\nFabio Cavalcante\n\n\nJames Montemagno\n\n\nMike James\n\n\nPierce Boggan\n\n\nSteve Lee",
            "title": "Credits"
        },
        {
            "location": "/credits/#credits",
            "text": "I got a lot of assistance during the writing of this book.  The following people assisted (in no\nparticular order):   Chris Gillum  Chris Risner  Donna Malayeri  Fabio Cavalcante  James Montemagno  Mike James  Pierce Boggan  Steve Lee",
            "title": "Credits"
        }
    ]
}