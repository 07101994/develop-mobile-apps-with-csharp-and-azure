{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nWelcome to my first book.  It's free, it's open source, and it's comprehensive.\nThose attributes also describe two of my favorite technologies, and I'm basing\nmy first book on them.  The first is \nXamarin Forms\n , a technology that\nallows you to develop cross-platform mobile applications using C# and the .NET\nframework.  The second is \nAzure Mobile Apps\n, a technology that allows\nyou to connect your mobile app to  resources that are important in cloud\nconnected mobile applications such as table data, authentication, and push\nnotifications.\n\n\nThis book does not tell you everything there is to know about either topic.  It\nfocuses on the topics necessary to get your mobile apps connected to the cloud.\n\n\nWhat are Cloud Connected Mobile Apps?\n\n\nI guess I should define some of the terminology that I am going to use.  When I\nrefer to a \nmobile application\n or \nmobile app\n, I mean every piece of\nsoftware that is related to the application you want to use.  This includes, for\nexample, the \nmobile client\n. This is the piece of code you run on your iPhone\nor Android phone.  It also includes the \nmobile backend\n which is the service\nthat you run in the cloud to provide important services to your mobile client.\n\n\nA \ncloud connected mobile application\n is a mobile client that connects to a\nmobile backend for shared services.  Quite a few of the apps on your phone are\ncloud connected already.  For example, Instagram uses the cloud for photo\nstorage, and Facebook uses the cloud to store the news feeds of you and your\nfriends.\n\n\nWhy Cross-Platform Native Development is important?\n\n\nIt should come as no surprise that Apple and Google have pretty much won the\nmobile OS wars.  Over 90% of the smart phones being sold today run either iOS\nor Android.  However, these are two very different mobile operating systems,\nwith different programming models.  iOS is based on either \nSwift\n or\nObjective-C.  Android is based on \nJava\n.  If you want to develop for the\n80% case (and you should), then you need to know both Swift and Java.  That's\na tall order even for the most dedicated mobile developer.  \n\n\nHowever, there are alternatives out there.  Most notable, you can write your\nmobile application with one code-base and just write exceptions for when the\nplatforms diverge.  You have to pick a single language and a tool set that\nsupports cross-platform development to do this.  Not all cross-platform tool\nsets are created equal, however.  Some do not compile your code to native\nbinaries, which means that you do not get access to all the functionality of\nthe mobile platforms you are targeting.\n\n\nXamarin, recently acquired by Microsoft, allows you to target all major\nplatforms - iOS, Android and Windows - to gain greater than 95% coverage of\nthe mobile smart phone market.  It does this by leveraging the .NET framework\nand compiling your code to a native binary for each platform.\n\n\nXamarin.Forms is a cross-platform framework, based on XAML and .NET, that\nallows you to use common UI pages to develop your apps.  \n\n\nWhy Azure Mobile Apps?\n\n\nWhen you think about the major apps in the marketplace for each mobile\nplatform, the thing that they have in common is that they have some sort\nof cloud infrastructure driving them.  It might be as simple as storing\nyour task list, or as complex as your Facebook news feed.  It could be a\ngaming leader board, or the social sharing of your photos.  Whatever it\nis, cloud connectivity is a must.\n\n\nNot all clouds are created equal.  There are some common features that you\nshould think about including irrespective of the application.  I like to use\nAzure Mobile Apps for these features because they are all included and you\ncan get started with most of the features for zero cost.  Even the features\nthat cannot be obtained without spending a little money are relatively cheap.\n\n\n\n\nAzure Mobile Apps is a feature of Azure App Service.  Azure App Service is a collection of services that commonly are used together to develop modern Internet Apps.  This includes web hosting, API hosting and Mobile SDKs.\n\n\n\n\nFeatures of Cloud Connected Mobile Apps\n\n\nA cloud connected mobile application will use one or more services in the\nfollowing areas:\n\n\n\n\nAuthentication\n\n\nStorage of structured data (like a task list)\n\n\nStorage of unstructured data (like photographs)\n\n\nPush notifications\n\n\nInvocation of Custom Code\n\n\n\n\nI am going to cover each of these in great detail.  In addition, I will also\ncover some common issues and solutions that developers run into while developing\ncloud connected mobile applications such as testing and going to production.  \n\n\nAside from the actual features of mobile apps, there are other things to\nconsider while developing your mobile application.  Here is my list, in no\nparticular order:\n\n\n\n\nContinuous Deployment\n\n\nSlots or Staging Sites\n\n\nAutomatic Scalability\n\n\nDatabase Backups\n\n\nCombined Web\n\n\n\n\nThe point here is that my intent is to write a production quality application.\nI need to be able to deploy my site with confidence without resorting to jumping\nthrough hoops.  I want to run multiple versions of the backend so that I can run\na staging site for testing purposes.  I want to be able to roll back my\nproduction site to a previous version at a moments notice.  I want to be able to\nhandle the load when my app is successful, and I want things to be backed up\n(since bad things inevitably happen when I am least prepared).\n\n\nAll of these features are available in Azure App Service, and the Mobile Apps\nSDK that I will use throughout the book is supported only on Azure App Service.\n\n\nWho is This Book For?\n\n\nThis book is for intermediate to experienced C# developers who have already\nbuilt a mobile app with Xamarin and want to take their mobile apps to the next\nlevel by utilizing cloud services.\n\n\nThis book is not for the beginner.  Explicitly, I already expect you to know how\nto develop mobile applications with C# and Xamarin technologies.  If you are\nunfamiliar with the C# language, you can get started with a free course on the\nInternet.  The basics of the language can be learned at \nwww.learncs.org\n.\n\nOnce you have the language basics under your belt, you can move on to building\nmobile applications with Xamarin. You can learn more about developing cross-platform\nmobile development with Xamarin at the \nXamarin\n website.  Although you do\nnot need to understand ASP.NET to get value out of this book, be aware that the\nmobile back ends that I will be covering are written in C# and ASP.NET.  A good\nunderstanding of ASP.NET will assist you.\n\n\nThings You Should Know!\n\n\nBefore you get started with development, spend some time learning the tools of\nthe trade.  The command prompt on the Mac is \nbash\n and the command prompt\non the PC is \nPowerShell\n.  You should be proficient in the shell on the\nplatforms that you use.\n\n\nAdditionally, you should become familiar with the source code control system\nthat you will use.  For most, this means becoming familiar with\n\ngit\n.  Don't even think of developing without using source control.\n\n\nWhat You Will Need\n\n\nThe list of hardware and software for mobile development is longer than your\ntypical development projects.  It is still, thankfully, relatively short and\neasy to acquire.\n\n\nHardware\n\n\nYou will want a computer on which to develop code.  If you develop iOS\napplications, then you \nMUST\n have a Mac running the latest version of Mac\nOSX.  If you develop Universal Windows applications, then you \nMUST\n have a\nPC running Windows 10.  Android applications can be developed on either platform.\n\n\nMy own experience has taught me that the tooling for developing mobile backends\nin C# and ASP.NET (our primary languages during the course of this book) are\nbetter on a PC running Windows 10.  Thus, my hardware choice is a rather beefy\n\nWindows 10 PC\n for my main development system.  In addition, I have a\n\nMac Mini\n underneath my desk that I use to build the iOS portions of the\napplications.\n\n\nSoftware\n\n\nAll of the following software are freely available.  You should install each\npackage and update it (if appropriate) so that it is fully patched.\n\n\nOn your Mac\n\n\n\n\nXCode\n (available on the Mac App Store)\n\n\nXamarin Studio\n\n\nAndroid Studio and Tools\n (if you intend to build Android apps on the Mac)\n\n\n\n\nYou must run XCode at least once after installation so that you can accept the\nlicense agreement.\n\n\nOn your Windows PC\n\n\n\n\nAndroid Studio and Tools\n\n\nVisual Studio Community\n\n\nAzure SDK\n\n\n\n\nWhen installing Visual Studio, you will want to install the components for\nWeb applications and Cross-platform Mobile development.  If you have already\ninstalled Visual Studio and did not install these components, run the installer\nagain to add the components.\n\n\n\n\nDevelopment Tools are big, multi-gigabyte installers.  If you are on a slow or\nrestricted link, you may want to download the installers onto a thumb drive for\nlocal installation.\n\n\n\n\nCloud Services\n\n\nYou will need an Azure account to complete most of the tutorials in this book.\nIn fact, you won't be able to get very far without one. If you have an MSDN\naccount, you already have access to free Azure resources.  You just need to log\ninto your \nMSDN account\n and activate your Azure benefit.  Students may be\nable to get access to \nDreamspark\n from school resources, but this is not\nsuitable for developing mobile applications.  This is because storage costs\nmoney.  If you don't have MSDN, then there is a \nfree trial\n available.\n\nOnce the trial period ends, you can move to a Pay-As-You-Go account and continue\nto use free services without incurring a charge. I'll point out when you are\ngoing to incur charges on your Azure account, but I will be using free resources\nmost of the time.\n\n\nAside from Azure resources, you will want some place to store your code.  This\ndoesn't have to be in the cloud.  If you want to use the cloud, you can use\nGitHub or Visual Studio Team Services.  Both are free to use.  GitHub provides\npublic repositories for free.  Visual Studio Team Services provides private\nrespositories for free.  Visual Studio Team Services also includes other\nservices that I will talk about during the course of the book, some of which may\nincur cost.  I will be publishing all my samples and tutorial code on GitHub so\nthat you can easily download it.  You don't have to use one of these resources,\nbut I won't be covering other service usage.\n\n\nYou will need a \nDeveloper Account\n for the appropriate app store if you\nintend to distribute your mobile clients or if you intend to use specific cloud\nservices.  Apple is specific - if you intend to use push notifications or\ndistribute iOS apps, then you need an \nApple Developer Account\n,\n\nGoogle Developer Account\n and/or \nWindows Store Developer Account\n.\nThe terms of the accounts are changed constantly, so review the current terms\nwhen you sign up.  My recommendation is to defer signing up for these programs\nuntil you need something they offer.\n\n\nNow, let's get developing!", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "Welcome to my first book.  It's free, it's open source, and it's comprehensive.\nThose attributes also describe two of my favorite technologies, and I'm basing\nmy first book on them.  The first is  Xamarin Forms  , a technology that\nallows you to develop cross-platform mobile applications using C# and the .NET\nframework.  The second is  Azure Mobile Apps , a technology that allows\nyou to connect your mobile app to  resources that are important in cloud\nconnected mobile applications such as table data, authentication, and push\nnotifications.  This book does not tell you everything there is to know about either topic.  It\nfocuses on the topics necessary to get your mobile apps connected to the cloud.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#what-are-cloud-connected-mobile-apps", 
            "text": "I guess I should define some of the terminology that I am going to use.  When I\nrefer to a  mobile application  or  mobile app , I mean every piece of\nsoftware that is related to the application you want to use.  This includes, for\nexample, the  mobile client . This is the piece of code you run on your iPhone\nor Android phone.  It also includes the  mobile backend  which is the service\nthat you run in the cloud to provide important services to your mobile client.  A  cloud connected mobile application  is a mobile client that connects to a\nmobile backend for shared services.  Quite a few of the apps on your phone are\ncloud connected already.  For example, Instagram uses the cloud for photo\nstorage, and Facebook uses the cloud to store the news feeds of you and your\nfriends.", 
            "title": "What are Cloud Connected Mobile Apps?"
        }, 
        {
            "location": "/#why-cross-platform-native-development-is-important", 
            "text": "It should come as no surprise that Apple and Google have pretty much won the\nmobile OS wars.  Over 90% of the smart phones being sold today run either iOS\nor Android.  However, these are two very different mobile operating systems,\nwith different programming models.  iOS is based on either  Swift  or\nObjective-C.  Android is based on  Java .  If you want to develop for the\n80% case (and you should), then you need to know both Swift and Java.  That's\na tall order even for the most dedicated mobile developer.    However, there are alternatives out there.  Most notable, you can write your\nmobile application with one code-base and just write exceptions for when the\nplatforms diverge.  You have to pick a single language and a tool set that\nsupports cross-platform development to do this.  Not all cross-platform tool\nsets are created equal, however.  Some do not compile your code to native\nbinaries, which means that you do not get access to all the functionality of\nthe mobile platforms you are targeting.  Xamarin, recently acquired by Microsoft, allows you to target all major\nplatforms - iOS, Android and Windows - to gain greater than 95% coverage of\nthe mobile smart phone market.  It does this by leveraging the .NET framework\nand compiling your code to a native binary for each platform.  Xamarin.Forms is a cross-platform framework, based on XAML and .NET, that\nallows you to use common UI pages to develop your apps.", 
            "title": "Why Cross-Platform Native Development is important?"
        }, 
        {
            "location": "/#why-azure-mobile-apps", 
            "text": "When you think about the major apps in the marketplace for each mobile\nplatform, the thing that they have in common is that they have some sort\nof cloud infrastructure driving them.  It might be as simple as storing\nyour task list, or as complex as your Facebook news feed.  It could be a\ngaming leader board, or the social sharing of your photos.  Whatever it\nis, cloud connectivity is a must.  Not all clouds are created equal.  There are some common features that you\nshould think about including irrespective of the application.  I like to use\nAzure Mobile Apps for these features because they are all included and you\ncan get started with most of the features for zero cost.  Even the features\nthat cannot be obtained without spending a little money are relatively cheap.   Azure Mobile Apps is a feature of Azure App Service.  Azure App Service is a collection of services that commonly are used together to develop modern Internet Apps.  This includes web hosting, API hosting and Mobile SDKs.", 
            "title": "Why Azure Mobile Apps?"
        }, 
        {
            "location": "/#features-of-cloud-connected-mobile-apps", 
            "text": "A cloud connected mobile application will use one or more services in the\nfollowing areas:   Authentication  Storage of structured data (like a task list)  Storage of unstructured data (like photographs)  Push notifications  Invocation of Custom Code   I am going to cover each of these in great detail.  In addition, I will also\ncover some common issues and solutions that developers run into while developing\ncloud connected mobile applications such as testing and going to production.    Aside from the actual features of mobile apps, there are other things to\nconsider while developing your mobile application.  Here is my list, in no\nparticular order:   Continuous Deployment  Slots or Staging Sites  Automatic Scalability  Database Backups  Combined Web   The point here is that my intent is to write a production quality application.\nI need to be able to deploy my site with confidence without resorting to jumping\nthrough hoops.  I want to run multiple versions of the backend so that I can run\na staging site for testing purposes.  I want to be able to roll back my\nproduction site to a previous version at a moments notice.  I want to be able to\nhandle the load when my app is successful, and I want things to be backed up\n(since bad things inevitably happen when I am least prepared).  All of these features are available in Azure App Service, and the Mobile Apps\nSDK that I will use throughout the book is supported only on Azure App Service.", 
            "title": "Features of Cloud Connected Mobile Apps"
        }, 
        {
            "location": "/#who-is-this-book-for", 
            "text": "This book is for intermediate to experienced C# developers who have already\nbuilt a mobile app with Xamarin and want to take their mobile apps to the next\nlevel by utilizing cloud services.  This book is not for the beginner.  Explicitly, I already expect you to know how\nto develop mobile applications with C# and Xamarin technologies.  If you are\nunfamiliar with the C# language, you can get started with a free course on the\nInternet.  The basics of the language can be learned at  www.learncs.org . \nOnce you have the language basics under your belt, you can move on to building\nmobile applications with Xamarin. You can learn more about developing cross-platform\nmobile development with Xamarin at the  Xamarin  website.  Although you do\nnot need to understand ASP.NET to get value out of this book, be aware that the\nmobile back ends that I will be covering are written in C# and ASP.NET.  A good\nunderstanding of ASP.NET will assist you.", 
            "title": "Who is This Book For?"
        }, 
        {
            "location": "/#things-you-should-know", 
            "text": "Before you get started with development, spend some time learning the tools of\nthe trade.  The command prompt on the Mac is  bash  and the command prompt\non the PC is  PowerShell .  You should be proficient in the shell on the\nplatforms that you use.  Additionally, you should become familiar with the source code control system\nthat you will use.  For most, this means becoming familiar with git .  Don't even think of developing without using source control.", 
            "title": "Things You Should Know!"
        }, 
        {
            "location": "/#what-you-will-need", 
            "text": "The list of hardware and software for mobile development is longer than your\ntypical development projects.  It is still, thankfully, relatively short and\neasy to acquire.", 
            "title": "What You Will Need"
        }, 
        {
            "location": "/#hardware", 
            "text": "You will want a computer on which to develop code.  If you develop iOS\napplications, then you  MUST  have a Mac running the latest version of Mac\nOSX.  If you develop Universal Windows applications, then you  MUST  have a\nPC running Windows 10.  Android applications can be developed on either platform.  My own experience has taught me that the tooling for developing mobile backends\nin C# and ASP.NET (our primary languages during the course of this book) are\nbetter on a PC running Windows 10.  Thus, my hardware choice is a rather beefy Windows 10 PC  for my main development system.  In addition, I have a Mac Mini  underneath my desk that I use to build the iOS portions of the\napplications.", 
            "title": "Hardware"
        }, 
        {
            "location": "/#software", 
            "text": "All of the following software are freely available.  You should install each\npackage and update it (if appropriate) so that it is fully patched.", 
            "title": "Software"
        }, 
        {
            "location": "/#on-your-mac", 
            "text": "XCode  (available on the Mac App Store)  Xamarin Studio  Android Studio and Tools  (if you intend to build Android apps on the Mac)   You must run XCode at least once after installation so that you can accept the\nlicense agreement.", 
            "title": "On your Mac"
        }, 
        {
            "location": "/#on-your-windows-pc", 
            "text": "Android Studio and Tools  Visual Studio Community  Azure SDK   When installing Visual Studio, you will want to install the components for\nWeb applications and Cross-platform Mobile development.  If you have already\ninstalled Visual Studio and did not install these components, run the installer\nagain to add the components.   Development Tools are big, multi-gigabyte installers.  If you are on a slow or\nrestricted link, you may want to download the installers onto a thumb drive for\nlocal installation.", 
            "title": "On your Windows PC"
        }, 
        {
            "location": "/#cloud-services", 
            "text": "You will need an Azure account to complete most of the tutorials in this book.\nIn fact, you won't be able to get very far without one. If you have an MSDN\naccount, you already have access to free Azure resources.  You just need to log\ninto your  MSDN account  and activate your Azure benefit.  Students may be\nable to get access to  Dreamspark  from school resources, but this is not\nsuitable for developing mobile applications.  This is because storage costs\nmoney.  If you don't have MSDN, then there is a  free trial  available. \nOnce the trial period ends, you can move to a Pay-As-You-Go account and continue\nto use free services without incurring a charge. I'll point out when you are\ngoing to incur charges on your Azure account, but I will be using free resources\nmost of the time.  Aside from Azure resources, you will want some place to store your code.  This\ndoesn't have to be in the cloud.  If you want to use the cloud, you can use\nGitHub or Visual Studio Team Services.  Both are free to use.  GitHub provides\npublic repositories for free.  Visual Studio Team Services provides private\nrespositories for free.  Visual Studio Team Services also includes other\nservices that I will talk about during the course of the book, some of which may\nincur cost.  I will be publishing all my samples and tutorial code on GitHub so\nthat you can easily download it.  You don't have to use one of these resources,\nbut I won't be covering other service usage.  You will need a  Developer Account  for the appropriate app store if you\nintend to distribute your mobile clients or if you intend to use specific cloud\nservices.  Apple is specific - if you intend to use push notifications or\ndistribute iOS apps, then you need an  Apple Developer Account , Google Developer Account  and/or  Windows Store Developer Account .\nThe terms of the accounts are changed constantly, so review the current terms\nwhen you sign up.  My recommendation is to defer signing up for these programs\nuntil you need something they offer.  Now, let's get developing!", 
            "title": "Cloud Services"
        }, 
        {
            "location": "/1_introduction/", 
            "text": "Your First Mobile App\n\n\nThere is a lot of detail to absorb about the possible services that the mobile\nclient can consume and I will go into significant depth on those subjects.\nFirst, wouldn't it be nice to write some code and get something working?\nMicrosoft Azure has a great \nfirst-steps tutorial\n that takes you via the\nquickest possible route from creating a mobile backend to having a functional\nbackend.  I would like to take things a little slower so that we can understand\nwhat is going on while we are doing the process.  We will have practically the\nsame application at the end.  The primary reason for going through this slowly\nis to ensure that all our build and run processes are set up properly.  If this\nis the first mobile app you have ever written, you will see that there are quite\na few things that need to be set up.\n\n\nThe application we are going to build together is a simple task list.  The\nmobile client will have three screens - an entry screen, a task list and a task\ndetails page.  I have mocked these pages up using \nMockingBot\n.\n\n\n\n\nMocking your screens before you start coding is a great habit to get into.\nThere are some great tools available including free tools like \nMockingBot\n.\nDoing mockups before you start coding is a good way to prevent wasted time later\non.\n\n\n\n\n\n\n\n\nWhy include a back button?  If you are using iOS, then you may want to remove\nthe back button as the style guides suggest you don't need one.  Other platforms\nwill need it though, so it's best to start with the least common denominator.\nIt's the same reason I add a refresh button even though it's only valid on\nWindows Phone!\n\n\n\n\nMy ideas for this app include:\n\n\n\n\nTapping on a task title in the task list will bring up the details page.\n\n\nToggling the completed link in the task list will set the completed flag.\n\n\nTapping the spinner will initiate a network refresh.\n\n\n\n\nNow that we have our client screens planned out, we can move onto the thinking\nabout the mobile backend.\n\n\nThe Mobile Backend\n\n\nThe mobile backend is an ASP.NET WebApi that is served from within Azure App\nService: a highly scalable and redundant web hosting facility that supports all\nthe major web languages (like ASP.NET, Node, PHP and Python).  Azure Mobile\nApps is an SDK (which is available in ASP.NET and Node) that runs on top of\nAzure App Service.\n\n\nCreating a Simple Azure Mobile Apps Backend\n\n\nMicrosoft Azure has included a comprehensive starter kit template in the\nAzure SDK.  To get started:\n\n\n\n\nFire up Visual Studio 2015\n\n\nAdd a new project with File -\n New Project...\n\n\n\n\nIn the \nNew Project\n window:\n\n\n\n\nOpen up Templates -\n Visual C# -\n Web and select \nASP.NET Web Application (.NET Framework)\n.\n\n\nEnter \nBackend\n for the Name and \nChapter1\n for the Solution name.\n\n\nPick a suitable directory for the Location field.\n\n\nClick on OK.\n\n\n\n\n\n\n\n\n\n\nIn the \nNew ASP.NET Web Application\n window:\n\n\n\n\nClick on \nAzure Mobile App\n.\n\n\nDo \nNOT\n check \"Host in the cloud\" or any other checkboxes.\n\n\nClick on OK.\n\n\n\n\n\n\n\n\nAt this point, Visual Studio will create your backend project.\n\n\n\n\nIt's very tempting to select \nAzure Mobile Services\n instead - it sounds closer to what you want.  Azure Mobile Services is the \nOLD\n service and is being shut down.  You should not select Azure Mobile Services for any project.\n\n\n\n\nThere are a few files of which you should take note.  The Mobile Apps SDK is\ninitialized within \nApp_Start\\Startup.MobileApp.cs\n (with the call to the\nconfiguration routine happening within \nStartup.cs\n).  The default startup\nroutine is reasonable but it hides what it is doing behind extension methods.\nThis technique is fairly common in ASP.NET programs.  Let's expand the configuration\nroutine to only include what we need:\n\n\npublic static void ConfigureMobileApp(IAppBuilder app)\n{\n    var config = new HttpConfiguration();\n    var mobileConfig = new MobileAppConfiguration();\n\n    mobileConfig\n        .AddTablesWithEntityFramework()\n        .ApplyTo(config);\n\n    Database.SetInitializer(new MobileServiceInitializer());\n\n    app.UseWebApi(config);\n}\n\n\n\n\nThe minimal version of the mobile backend initialization is actually shorter\nthan the original.  It also only includes a data access layer.  Other services\nlike authentication, storage and push notifications are not configured.\n\n\nThere is another method in the \nApp_Start\\Startup.MobileApp.cs\n file for\nseeding data into the database for us.  We can leave that alone for now, but\nremember it is there in case you need to seed data into a new database for\nyour own backend.\n\n\n\n\nWe refer to \"seeding data\" into a database.  This means that we are going to introduce some data into the database so that we aren't operating on an empty database.  The data will be there when we query the database later on.\n\n\n\n\nThe next important file is the \nDbContext\n - located in \nModels\\MobileServiceContext.cs\n.\nAzure Mobile Apps is heavily dependent on \nEntity Framework v6.x\n and the\n\nDbContext\n is a central part of that library.  Fortunately, we don't need\nto do anything to this file right now.\n\n\nFinally, we get to the meat of the backend.  The whole point of this demonstration\nis to project a single database table - the TodoItem table - into the mobile realm\nwith the aid of an opinionated \nOData v3\n feed.  To that end, we need three\nitems:\n\n\n\n\nA \nDbSet\n within the \nDbContext\n\n\nA Data Transfer Object (or DTO)\n\n\nA Table Controller\n\n\n\n\nWhen we create the project, a sample of each one of these for the TodoItem table\nis added for us.  You can see the \nDbSet\n in the \nModels\\MobileServiceContext.cs\n\nfile, for example.  Let's take a look at the DTO and Table Controller for this\nexample table as well.  The DTO for the TodoItem table is located within the\n\nDataObjects\n directory:\n\n\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.DataObjects\n{\n    public class TodoItem : EntityData\n    {\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n    }\n}\n\n\n\n\nNote that the model uses \nEntityData\n as a base class.  The \nEntityData\n class\nadds five additional properties to the class - we'll discuss those in more\ndetails during the \nData Access and Offline Sync\n chapter.\n\n\nFinally, let's look at the table controller for the example TodoItem table.  This\nis located in \nControllers\\TodoItemController.cs\n:\n\n\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController\nTodoItem\n\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager\nTodoItem\n(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable\nTodoItem\n GetAllTodoItems() =\n Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult\nTodoItem\n GetTodoItem(string id) =\n Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task\nTodoItem\n PatchTodoItem(string id, Delta\nTodoItem\n patch) =\n UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task\nIHttpActionResult\n PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\nTables\n, new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) =\n DeleteAsync(id);\n    }\n}\n\n\n\n\nThe \nTableController\n is the central processing for the database access layer.\nIt handles all the OData capabilities for us and exposes these as REST endpoints\nwithin our WebAPI.  This means that the actual code for this controller is tiny - just 12 lines of code.\n\n\n\n\nOData\n is a specification for accessing table data on the Internet.  It provides a mechanism for querying and manipulating data within a table.  Entity Framework is a common data access layer for ASP.NET applications.\n\n\n\n\nWe can build the project at this point.  If Visual Studio hasn't done so already,\nthe missing NuGet packages for Azure Mobile Apps will be downloaded.  There\nshould not be any errors.  If there are, check the typing for any changes you\nmade.\n\n\n\n\nYou can delete or ignore the \nControllers\\ValuesController.cs\n file if you like - it isn't important for this walkthrough.\n\n\n\n\nBuilding an Azure App Service for Mobile Apps\n\n\nThe next step in the process is to build the resources on Azure that will run\nyour mobile backend.  Start by logging into the \nAzure Portal\n, then follow\nthese instructions:\n\n\n\n\nClick on the big \n+ New\n button in the top-left corner.\n\n\nClick on \nWeb + Mobile\n, then \nMobile App\n.\n\n\n\n\nEnter a unique name in the \nApp name\n box.\n\n\n\n\nSince the name doesn't matter and it has to be unique, you can use \na GUID generator\n to generate a unique name.\n\n\n\n\n\n\n\n\nIf you have more than one subscription (for example, you have a trial and\n    an MSDN subscription), then ensure you select the right subscription in\n    the \nSubscription\n drop-down.\n\n\n\n\n\n\nSelect \nCreate new\n under resource group and enter a name for this mobile application.\n\n\n\n\nResource groups are great for grouping all the resources associated with a mobile application together.  During development, it means you can delete all the resources in one operation.  For production, it means you can see how much the service is costing you and how the resources are being used.\n\n\n\n\n\n\n\n\nFinally, select or create a new \nApp Service Plan\n.\n\n\n\n\nThe App Service Plan is the thing that actually bills you - not the web or mobile backend.  You can run a number of web or mobile backends on the same App Service Plan.\n\n\n\n\nI tend to create a new App Service Plan for each mobile application.  This is because the App Service Plan lives inside the Resource Group that you create.  The process for creating an App Service Plan is straight forward.  You have two decisions to make.  The first decision is where is the service going to run.  In a production environment, the correct choice is \"near your customers\".  \"Close to the developers\" is a good choice during development.  Unfortunately, neither\nof those is an option you can actually choose in the portal, so you will have to translate into some sort of geographic location.  With 16 regions to choose from, you have a lot of choice.\n\n\nThe second decision you have to make is what to run the service on; also known as the Pricing tier.   If you click on \nView all\n, you will see you have lots of choices.  F1 Free and D1 Shared, for example, run on shared resources and are CPU limited. You should avoid these as the service will stop responding when you are over the CPU quota.  That leaves Basic, Standard and Premium.  Basic has no automatic scaling and can run up to 3 instances - perfect for development tasks.  Standard and Premium both have automatic scaling, automatic backups, and large amounts of storage; they differ in features: the number of sites or instances you can run on them, for example.  Finally, there is a number after the plan.  This tells you how big the virtual machine is that the plan is running on.  The numbers differ by number of cores and memory.\n\n\nFor our purposes, an F1 Free site is enough to run this small demonstration project.  More complex development projects should use something in the Basic range of pricing plans.  Production apps should be set up in Standard or Premium pricing plans.\n\n\n\n\n\n\nOnce you have created your app service plan and saved it, click on \nCreate\n.\n\n\n\n\n\n\nThe creation of the service can take a couple of minutes.  You can monitor the process of deployment by clicking on the Notifications icon.  This is in the top bar on the right-hand side and looks like a Bell.  Clicking on a specific notification will provide more information about the activity.  Once you have created your app service, the App Service blade will open.\n\n\n\n\nWhat's the difference between a Web App, a Mobile App and an API App?  Not a lot.  The type determines which Quick start projects are available in the Quick start menu under \nAll settings\n.  Since we selected a Mobile app, a set of starter client projects for mobile devices will be presented.\n\n\n\n\nThe next step in the process is to create a SQL Azure instance.  The ASP.NET application that we produced earlier will use this to store the data presented in the table controller.\n\n\n\n\nClick on the \n+ New\n button on the left hand side of the page.\n\n\nSelect \nData + Storage\n and then \nSQL Database\n.\n\n\nEnter a unique database name (I use a GUID again) in the \nDatabase name\n box.\n\n\nSelect \nUse existing\n under the \nResource group\n, then select the resource group you created earlier.\n\n\nSelect \nBlank database\n in the \nSelect source\n box.\n\n\n\n\nClick on \nConfigure required settings\n for the \nServer\n.\n\n\n\n\nClick on \nCreate a new server\n.\n\n\nEnter another globally unique name for the \nServer name\n (I use a GUID yet again).\n\n\nEnter \nappservice\n in the \nServer admin login\n (or use your own name).\n\n\nEnter a password in the \nPassword\n and \nConfirm password\n boxes.\n\n\nSelect the same location as your App Service in the \nLocation\n box.\n\n\nClick on \nSelect\n to create the Server.\n\n\n\n\n\n\n\n\nClick on the \nPricing tier\n.  The \nB Basic\n plan is the cheapest plan available.\n\n\n\n\nClick on \nCreate\n.\n\n\n\n\n\n\nThere are other methods of creating a SQL Azure instance, including using\nthe Data Connections blade within the App Service.\n\n\n\n\nThe SQL Azure instance takes longer to deploy than the App Service in general.\nHowever, it will still be available within 3-5 minutes.\n\n\n\n\nGUIDs are not the best names to use when you need to actually find resources, but using GUIDS prevents conflicts when deploying, so I prefer them as a naming scheme.  You can prefix the GUID (example: chapter1-GUID) to aid in discovery later on.  Generally, the first four digits of a GUID are enough to identify individual resources.\n\n\n\n\nFinally, you will need to link your SQL Azure instance to the App Service instance:\n\n\n\n\nClick on \nResource groups\n in the left hand side menu.\n\n\nClick on the resource group you created.\n\n\nClick on the App Service you created.\n\n\nClick on \nAll settings\n.\n\n\nClick on \nData connections\n in the \nMOBILE\n menu.\n\n\n\n\nClick on \nAdd\n.\n\n\n\n\nClick on the \nConfigure required settings\n under \nSQL Database\n.\n\n\nSelect the database you just created, then click on \nSelect\n.\n\n\nClick on \nConfigure required settings\n under \nConnection string\n.\n\n\nEnter \nappservice\n in the \nUser Name\n box.\n\n\nEnter your chosen password in the \nPassword\n box.\n\n\nwatch for green tick marks to ensure the username and password are correct.\n\n\nClick on \nOK\n\n\nClick on \nOK\n in the \nAdd data connection\n blade.\n\n\n\n\n\n\n\n\nThis produces another deployment step.  It doesn't take very long so you can\nswitch back to your Visual Studio window.\n\n\n\n\nIf you want a completely free mobile backend, search for the \nMobile Apps\nQuickstart\n in the Azure Marketplace.  This template does not require a\ndatabase.  It relies on a Node backend, however, so you won't be developing a C#\nbackend.\n\n\n\n\nDeploying the Azure Mobile Apps Backend\n\n\nDeploying to Azure as a developer can be accomplished while entirely within Visual Studio:\n\n\n\n\nRight-click on the \nBackend\n project, then select \nPublish...\n.\n\n\n\n\nMake sure you see this screen shot:\n\n\n\n\nIf you do not see this image, then it is likely you have an older version\nof the Azure SDK installed.  Make sure the Azure SDK version is v2.9 or\nlater.\n\n\n\n\n\n\nClick on \nMicrosoft Azure App Service\n.\n\n\n\n\nYou may be prompted to enter your Azure credentials here.  Enter the same\n    information that you enter to access the Azure Portal.\n\n\nIn the lower box, expand the resource group that you created and select the\n    app service you created in the portal.\n\n\nClick on \nOK\n.\n\n\nClick on \nPublish\n.\n\n\n\n\nVisual Studio will open a browser.  Add \n/tables/todoitem?ZUMO-API-VERSION=2.0.0\n\nto the end of the URL.  This will show the JSON contents of the table that we\ndefined in the backend.\n\n\n\n\nYou will see the word ZUMO all over the SDK, including in optional HTTP headers and throughout the SDK source code.  ZUMO was the original code name within Microsoft for A\nZU\nre \nMO\nbile.\n\n\n\n\nThe Mobile Client\n\n\nNow that the mobile backend is created and deployed, we can move onto the client\nside of things.  First of all, let's prepare the Visual Studio instance.  If you\nhave installed the Cross-Platform Mobile tools during the installation, most of\nthe work has already been done.  However, you may want to install the \nXamarin\nForms Templates\n using the Tools -\n Extensions and Updates...\n\n\n\n\nThis template pack provides additional templates for Xamarin Forms development\nthat I find useful.  Most notably, there is a specific template for a mobile\ncross-platform project covering the Android, iOS and UWP mobile platforms.\n\n\n\n\nWhen you compile a Xamarin.Forms application for a specific platform, you are\nproducing a true native application for that platform - whether it be iOS, Android\nor Windows.\n\n\n\n\nCreating a Simple Mobile Client with Xamarin\n\n\nNow that we have prepared your Visual Studio instance, we can create the project.\nRight-click on the solution and select \nAdd\n -\n \nNew Project...\n.  This will\nbring up the familiar New Project dialog.  The project you want is under \nVisual C#\n\n-\n \nCross-Platform\n, and is called \nXamarin.Forms (UWP/Android/iOS)\n.  If you\ndid not install the Xamarin Forms Template add-on, then choose the\n\nBlank Xaml App (Xamarin.Forms Portable)\n project.  Give the project a name,\nthen click on \nOK\n.\n\n\n\n\n\n\nIf you did not install the Xamarin Forms Templates, then you can create a \nBlank Xaml App (Xamarin.Forms Portable)\n project instead.\n\n\n\n\nProject creation will take longer than you expect, but there is a lot going on.\nIf you have never created a mobile or UWP project before, you will be prompted\nto turn on Windows 10 Developer Mode:\n\n\n\n\nDeveloper mode in Windows 10 allows you to run unsigned binaries for development\npurposes and to turn on debugging so that you can step through your UWP programs\nwithin Visual Studio.\n\n\nWe will also get asked to choose what version of the Universal Windows platform\nwe want to target:\n\n\n\n\nVersion 10240 was the first version of Windows 10 that was released to the general\npublic, so that's a good minimum version to pick.  In general, the defaults for\nthe Universal Windows Platform choice are good enough.\n\n\nXamarin allows us to build iOS applications directly from Visual Studio. For\nthis to work, we must have access to a Mac. This could be anything from a MacBook\nAir/Pro, to a Mac Mini in a drawer or closet in the office, or maybe even a\n\nMac in the cloud\n.  The Xamarin tools use SSH to connect to the Mac, which\nmust be \nconfigured to build iOS apps from Visual Studio\n.\n\n\n\n\nIf you don't have a Mac and are not interested in building iOS applications, don't give up now!  You can cancel through the Mac specific project setup and continue with building a great Android and Universal Windows app.  You can delete the iOS specific project after it has been created.\n\n\n\n\nWhen prompted about the Xamarin Mac Agent, click on \nOK\n to get the list of\nlocal mac agents:\n\n\n\n\nHighlight your mac (in case there are multiples), then click on \nConnect...\n.\nIf your mac is not listed or you are using a Mac in the cloud, then you can\nalways enter the IP address for your mac.  \n\n\n\n\nFor more troubleshooting tips, visit  https://developer.xamarin.com/guides/ios/getting_started/installation/windows/connecting-to-mac/troubleshooting/\n\n\n\n\nYou will be prompted for your username and password:\n\n\n\n\nJust enter the username and password that you use to log in to your mac and click\non \nLogin\n.\n\n\n\n\nWhat's my username?\n  Apple tries very hard to hide the real username of\nyour account from you.  The easiest way to find your mac username is to open up\nthe Finder.  The name next to your home icon is the name of your account.\n\n\n\n\nIf the connection has successed, you will see a green icon in the Xamarin Visual\nStudio toolbar area. It may take a minute or two to connect and verify that the\nmac can be used.\n\n\nOnce the project is created, you will see that four new projects have been\ncreated: a common library which you named plus one project for each platform\nthat has been chosen.  Since we chose a project with three platforms, we get\nfour projects:\n\n\n\n\nMost of our work will happen in the common library.  However, we can introduce\nplatform-specific code at any point.  The platform-specific code is stored in\nthe platform-specific project.\n\n\nThere is one final item we must do before we leave the set up of the project.\nThere are a number of platform upgrades that inevitably have to happen.  The\nXamarin Platform is updated much more often than the Visual Studio plugin - the\nupdates are released via NuGet: the standard method of distributing libraries\nfor .NET applications.  In addition to the inevitable Xamarin Platform update,\nwe also will want to add the following NuGet packages:\n\n\n\n\nMicrosoft.Azure.Mobile.Client v2.0.0 or later\n\n\nNewtonsoft.Json v6.0.3 or later\n\n\n\n\n\n\nAlthough it is tempting, do not include a v1.x version of the Mobile Client.\nThis is for the earlier Azure Mobile Services.  There are many differences between\nthe wire protocols of the two products.\n\n\n\n\nYou can install the NuGet packages by right-clicking on the project and selecting\n\nManage NuGet Packages...\n.\n\n\n\n\nYou must install the updates and the new NuGet packages on all four projects.\nThis involves repeating the same process for each client project in your\nsolution.\n\n\n\n\nAndroid generally has more updates than the other platforms.  Ensure that you\nupdate the main Xamarin.Forms package and then refresh the update list.  This will\nensure the right list of packages is updated.\n\n\n\n\nBuilding the Common Library\n\n\nThere are two parts that we must concentrate on within the common library.  The\nfirst is the connection to Azure Mobile Apps and the second is in the pages\nthat the user interacts with.  In both cases, there are best practices to observe.\n\n\nBuilding an Azure Mobile Apps Connection\n\n\nWe will rely on interfaces for defining the shape for the class for any service\nthat we interact with.  This is really not important in small projects like this\none.  This technique allows us to mock the backend service, as we shall see\nlater on.  Mocking the backend service is a great technique to rapidly iterate\non the front end mobile client without getting tied into what the backend is doing.\n\n\nLet's start with the cloud service - this is defined in \nAbstractions\\ICloudService.cs\n.\nIt is basically used for initializing the connection and getting a table definition:\n\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        public ICloudTable\nT\n GetTable\nT\n() where T : TableData;\n    }\n}\n\n\n\n\nThere is a dependent implementation here: the \nICloudTable\n generic interface.  This\nrepresents a CRUD interface into our tables and is defined in \nAbstractions\\ICloudTable.cs\n:\n\n\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudTable\nT\n where T : TableData\n    {\n        Task\nT\n CreateItemAsync(T item);\n        Task\nT\n ReadItemAsync(string id);\n        Task\nT\n UpdateItemAsync(T item);\n        Task DeleteItemAsync(T item);\n\n        Task\nICollection\nT\n ReadAllItemsAsync() where T : TableData;\n    }\n}\n\n\n\n\nThe \nICloudTable\nT\n interface defines the normal CRUD operations: Create, Read,\nUpdate and Delete.  However, it does so asynchronously.  We are dealing with network\noperations in general so it is easy for those operations to tie up the UI thread\nfor an appreciable amount of time.  Making them async provides the ability to\nrespond to other events.  I also provide a \nReadAllItemsAsync()\n method that\nreturns a collection of all the items.\n\n\nThere are some fields that every single record within an Azure Mobile Apps table\nprovides.  These fields are required for offline sync capabilities like incremental\nsync and conflict resolution.  The fields are provided by an abstract base class\non the client called \nTableData\n:\n\n\nusing System;\n\nnamespace TaskList.Abstractions\n{\n    public abstract class TableData\n    {\n        public string Id { get; set; }\n        public DateTimeOffset? UpdatedAt { get; set; }\n        public DateTimeOffset? CreatedAt { get; set; }\n        public byte[] Version { get; set; }\n    }\n}\n\n\n\n\nAs we will learn when we deal with table data in Chapter 3, these fields need to\nbe defined with the same name and semantics as on the server.  Our model on\nthe server was sub-classed from \nEntityData\n and the \nEntityData\n class on the\nserver defines these fields.\n\n\nIt's tempting to call the client version of the class the same as the server\nversion.  If we did that, the models on both the client and server would look\nthe same.  However, I find that this confuses the issue.  The models on the\nclient and server are not the same.  They are missing the \nDeleted\n flag and\nthey do not contain any relationship information on the client.  I choose to\ndeliberately call the base class something else on the client to avoid this\nconfusion.\n\n\nWe will be adding to these interfaces in future chapters as we add more\ncapabilities to the application.\n\n\nThe concrete implementations of these classes are similarly easily defined.  The\nAzure Mobile Apps Client SDK does most of the work for us.  Here is the concrete\nimplementation of the \nICloudService\n (in \nServices\\AzureCloudService.cs\n):\n\n\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(\nhttps://my-backend.azurewebsites.net\n);\n        }\n\n        public ICloudTable\nT\n GetTable\nT\n() where T : TableData\n        {\n            return new AzureCloudTable\nT\n(client);\n        }\n    }\n}\n\n\n\n\nThe Azure Mobile Apps Client SDK takes a lot of the pain out of communicating\nwith the mobile backend that we have already published.  Just swap out the\nname of your mobile backend and the rest is silently dealt with.\n\n\n\n\nThe name \nMicrosoft.WindowsAzure.MobileServices\n is a hold-over from the old Azure Mobile Services code-base.  Don't be fooled - clients for Azure Mobile Services are not interchangeable with clients for Azure Mobile Apps.\n\n\n\n\nWe also need a concrete implementation of the \nICloudTable\nT\n interface (in \nServices\\AzureCloudTable.cs\n):\n\n\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudTable\nT\n : ICloudTable\nT\n where T : TableData\n    {\n        MobileServiceClient client;\n        IMobileServiceTable\nT\n table;\n\n        public AzureCloudTable(MobileServiceClient client)\n        {\n            this.client = client;\n            this.table = client.GetTable\nT\n();\n        }\n\n        #region ICloudTable implementation\n        public async Task\nT\n CreateItemAsync(T item)\n        {\n            await table.InsertAsync(item);\n            return item;\n        }\n\n        public async Task\nT\n DeleteItemAsync(T item)\n        {\n            await table.DeleteAsync(item);\n        }\n\n        public async Task\nICollection\nT\n ReadAllItemsAsync()\n        {\n            return await table.ToListAsync();\n        }\n\n        public async Task\nT\n ReadItemAsync(string id)\n        {\n            return await table.LookupAsync(id);\n        }\n\n        public async Task\nT\n UpdateItemAsync(T item)\n        {\n          await table.UpdateAsync(item);\n          return item;\n        }\n        #endregion\n    }\n}\n\n\n\n\nIt's important to note here that the Azure Mobile Apps Client SDK does a lot of\nthe work for us.  In fact, we are just wrapping the basic interface here.  This\nwon't normally be the case, but you can see that the majority of the code for\ndealing with the remote server is done for us.\n\n\n\n\nYou can use a shorthand (called a lambda expression) for methods with only one line.  For instance, the delete method could just as easily have been written as \npublic async Task\nT\n DeleteItemAsync(T item) =\n await table.DeleteAsync(item);\n.  You may see this sort of short hand in samples.\n\n\n\n\nWe also need to create the model that we will use for the data.  This should\nlook very similar to the model on the server - including having the same name\nand fields.  In this case, it's \nModels\\TodoItem.cs\n:\n\n\nusing TaskList.Abstractions\n\nnamespace TaskList.Models\n{\n    public class TodoItem : TableData\n    {\n        public string Text { get; set; }\n        public bool Complete { get; set; }\n    }\n}\n\n\n\n\nWe have a final piece of code to write before we move on to the views, but it's\nan important piece.  The \nICloudService\n must be a singleton in the client.  We\nwill add authentication and offline sync capabilities in future versions of this\ncode.  The singleton becomes critical when using those features.  For right now,\nit's good practice and saves on memory if you only have one copy of the \nICloudService\n\nin your mobile client.  Since there is only one copy of the \nApp.cs\n in any\ngiven app, I can place it there.  Ideally, I'd use some sort of dependency\ninjection system or a singleton manager to deal with this.  Here is the \nApp.cs\n:\n\n\nusing TaskList.Abstractions;\nusing TaskList.Services;\nusing Xamarin.Forms;\n\nnamespace TaskList\n{\n    public class App : Application\n    {\n        public static ICloudService CloudService { get; set; }\n\n        public App()\n        {\n            CloudService = new AzureCloudService();\n            MainPage = new NavigationPage(new Pages.EntryPage());\n        }\n\n        // There are lifecycle methods here...\n    }\n}\n\n\n\n\nWe haven't written \nPages.EntryPage\n yet, but that's coming.  The original \nApp.cs\n\nclass file had several methods for handling lifecycle events like starting, suspending\nor resuming the app.  I did not touch those methods for this example.\n\n\nBuilding the UI for the App\n\n\nEarlier, I showed the mockup for my UI.  It included three pages - an entry\npage, a list page and a detail page.  These pages have three elements - a\nXAML definition file, a (simple) code-behind file and a view model.\n\n\n\n\nThis book is not intending to introduce you to everything that there is to know about Xamarin and UI programming with XAML.  If you wish to have that sort of introduction, then I recommend reading the excellent book by Charles Petzold: \nCreating Mobile Apps with Xamarin.Forms\n.\n\n\n\n\nI tend to use MVVM (or Model-View-ViewModel) for UI development in Xamarin\nbased applications.  It's a nice clean pattern and is well understood and\ndocumented.  In MVVM, there is a 1:1 correlation between the view and the\nview-model, 2-way communication between the view and the view-model and\nproperties within the view-model are bound directly to UI elements.  In\ngeneral (and in all my code), view-models expose an INotifyPropertyChanged\nevent to tell the UI that something within the view-model has been changed.\n\n\nTo do this, we will use a \nBaseViewModel\n class that implements the base functionality\nfor each view.  Aside from the \nINotifyPropertyChanged\n interface, there are\nsome common properties we need for each page.  Each page needs a title, for\nexample, and each page needs an indicator of network activity.  These can be\nplaced in the \nAbstractions\\BaseViewModel.cs\n class:\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\n\nnamespace TaskList.Abstractions\n{\n    public class BaseViewModel : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n        string _propTitle = string.Empty;\n        bool _propIsBusy;\n\n        public string Title\n        {\n            get { return _propTitle; }\n            set { SetProperty(ref _propTitle, value, \nTitle\n); }\n        }\n\n        public bool IsBusy\n        {\n            get { return _propIsBusy; }\n            set { SetProperty(ref _propIsBusy, value, \nIsBusy\n); }\n        }\n\n        protected void SetProperty\nT\n(ref T store, T value, string propName, Action onChanged = null)\n        {\n            if (EqualityComparer\nT\n.Default.Equals(store, value))\n                return;\n            store = value;\n            if (onChanged != null)\n                onChanged();\n            OnPropertyChanged(propName);\n        }\n\n        public void OnPropertyChanged(string propName)\n        {\n            if (PropertyChanged == null)\n                return;\n            PropertyChanged(this, new PropertyChangedEventArgs(propName));\n        }\n    }\n}\n\n\n\n\nThis is a fairly common \nINotifyPropertyChanged\n interface implementation pattern.\nEach property that we want to expose is a standard property, but the \nset\n operation\nis replaced by the \nSetProperty()\n call.  The \nSetProperty()\n call deals with the\nnotification; calling the event emitter if the property has changed value.  We\nonly need two properties on the \nBaseViewModel\n: the title and the network indicator.\n\n\nI tend to write my apps in two stages.  I concentrate on the functionality of the\napp in the first stage.  There is no fancy graphics, custom UI widgets, or anything\nelse to clutter the thinking.   The page is all about the functionality of the\nvarious interactions.  Once I have the functionality working, I work on the styling\nof the page.  We won't be doing any styling work in the demonstration apps that we\nwrite during the course of this book.\n\n\nThe EntryPage has just one thing to do.  It provides a button that enters the app.\nWhen we cover authentication later on, we'll use this to log in to the backend.  If\nyou are looking at the perfect app, this is a great place to put the introductory\nscreen.\n\n\nCreating a XAML file is relatively simple.  First, create a \nPages\n directory to\nhold the pages of our application.  Then right-click on the \nPages\n directory in\nthe solution explorer and choose \nAdd\n -\n \nNew Item...\n.  In the \nAdd New Item\n\ndialog, pick \nVisual C#\n -\n \nCross-Platform\n -\n \nForms Xaml Page\n.  Name the\nnew page \nEntryPage.cs\n.  This will create two files - \nEntryPage.xaml\n and\n\nEntryPage.xaml.cs\n.  Let's center a button on the page and wire it up with\na command.  Here is the \nPages\\EntryPage.xaml\n file:\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n ?\n\n\nContentPage xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n             xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n             x:Class=\nTaskList.Pages.EntryPage\n\n             Title=\n{Binding Title}\n\n    \nContentPage.Content\n\n        \nStackLayout HorizontalOptions=\nCenter\n\n                     Orientation=\nVertical\n\n                     VerticalOptions=\nCenter\n\n            \nButton BackgroundColor=\nTeal\n\n                    BorderRadius=\n10\n\n                    Command=\n{Binding LoginCommand}\n\n                    Text=\nLogin\n\n                    TextColor=\nWhite\n /\n\n        \n/StackLayout\n\n    \n/ContentPage.Content\n\n\n/ContentPage\n\n\n\n\n\nThere are a couple of interesting things to note here.  The \nStackLayout\n element\nis our layout element.  It occupies the entire screen (since it is a direct child\nof the content page) and the options just center whatever the contents are.  The\nonly contents are a button.\n\n\nThere are two bindings.  These are bound from the view-model.  We've already seen\nthe Title property - this is a text field that specifies the title of the page.\nThe other binding is a login command.  When the button is tapped, the login command\nwill be run.  We'll get onto that in the view-model later.\n\n\nThe other part of the XAML is the code-behind file.  Because we are moving all\nof the non-UI code into a view-model, the code-behind file is trivial:\n\n\nusing TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class EntryPage : ContentPage\n    {\n        public EntryPage()\n        {\n            InitializeComponent();\n            BindingContext = new EntryPageViewModel();\n        }\n    }\n}\n\n\n\n\nThis is a recipe that will be repeated over and over again for the code-behind\nwhen you are using a XAML-based project with MVVM.  We initialize the UI, then\nbind all the bindings to a new instantiation of the view model.\n\n\nTalking of which, the view-model needs just to handle the login click.  Note that\nthe location or namespace is \nTaskList.ViewModels\n.  I'm of two minds about location.\nThere tends to be a 1:1 relationship between the XAML file and the View Model, so\nit makes sense that they are stored together.  However, just about all the sample\ncode that I see has the view-models in a separate namespace.  Which one is correct?\nI'll go with copying the samples for now.  Here is the code for \nViewModels\\EntryPageViewModel.cs\n:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class EntryPageViewModel : BaseViewModel\n    {\n        public EntryPageViewModel()\n        {\n            Title = \nTask List\n;\n        }\n\n        Command loginCmd;\n        public Command LoginCommand =\n loginCmd ?? (loginCmd = new Command(async () =\n await ExecuteLoginCommand()));\n\n        async Task ExecuteLoginCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\n[Login] Error = {ex.Message}\n);\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}\n\n\n\n\nThis is a fairly simple view-model but there are some patterns here that are\nworth explaining.  Firstly, note the way we create the \nLoginCommand\n property.\nThis is the property that is bound to the \nCommand\n parameter in the \nButton\n\nof our view.  This recipe is the method of invoking a UI action asynchronously.\nIt isn't important now, but we will want this technique repeatedly as our UI\nactions kick off network activity.\n\n\nThe second is the pattern for the \nExecuteLoginCommand\n method.  Firstly, I\nensure nothing else is happening by checking the IsBusy flag.   If nothing\nis happening, I set the IsBusy flag.  Then I do what I need to do in a try/catch\nblock.  If an exception is thrown, I deal with it.  Most of the time this\ninvolves displaying an error condition.  There are several cross-platform dialog\npackages to choose from or you can roll your own.  That is not covered here.  We\njust write a debug log statement so we can see the result in the debug log.  Once\neverything is done, we clear the IsBusy flag.\n\n\nThe only thing we are doing now is swapping out our main page for a new main\npage.  This is where we will attach authentication later on.\n\n\nThe next page is the Task List page, which is in \nPages\\TaskList.xaml\n:\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n ?\n\n\nContentPage xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n             xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n             x:Class=\nTaskList.Pages.TaskList\n\n             Title=\n{Binding Title}\n\n  \nContentPage.Content\n\n    \nStackLayout\n\n      \nListView BackgroundColor=\n#7F7F7F\n\n                CachingStrategy=\nRecycleElement\n\n                IsPullToRefreshEnabled=\nTrue\n\n                IsRefreshing=\n{Binding IsBusy, Mode=OneWay}\n\n                ItemsSource=\n{Binding Items}\n\n                RefreshCommand=\n{Binding RefreshCommand}\n\n                RowHeight=\n50\n\n                SelectedItem=\n{Binding SelectedItem, Mode=TwoWay}\n\n        \nListView.ItemTemplate\n\n          \nDataTemplate\n\n            \nViewCell\n\n              \nStackLayout HorizontalOptions=\nFillAndExpand\n\n                           Orientation=\nHorizontal\n\n                           Padding=\n10\n\n                           VerticalOptions=\nCenterAndExpand\n\n                \nLabel HorizontalOptions=\nFillAndExpand\n\n                       Text=\n{Binding Text}\n\n                       TextColor=\n#272832\n /\n\n                \nSwitch IsToggled=\n{Binding Complete, Mode=OneWay}\n /\n\n              \n/StackLayout\n\n            \n/ViewCell\n\n          \n/DataTemplate\n\n        \n/ListView.ItemTemplate\n\n      \n/ListView\n\n      \nStackLayout HorizontalOptions=\nCenter\n\n                   Orientation=\nHorizontal\n\n        \nButton BackgroundColor=\nTeal\n\n                Command=\n{Binding AddNewItemCommand}\n\n                Text=\nAdd New Item\n\n                TextColor=\nWhite\n /\n\n      \n/StackLayout\n\n    \n/StackLayout\n\n  \n/ContentPage.Content\n\n\n/ContentPage\n\n\n\n\n\nNote that some bindings here are one-way.  This means that the value in the\nview-model drives the value in the UI.  There is nothing within the UI that you\ncan do to alter the state of the underlying property.  Some bindings are two-way.\nDoing something in the UI (for example, toggling the switch) alters the underlying\nproperty.\n\n\nThis view is a little more complex.  It can be split into two parts - the list\nat the top of the page and the button area at the bottom of the page.  The list\narea uses a template to help with the display of each item.\n\n\nNote that the \nListView\n object has a \"pull-to-refresh\" option that I have wired\nup so that when pulled, it calls the RefreshCommand.  It also has an indicator\nthat I have wired up to the IsBusy indicator.  Anyone who is familiar with the\niOS \"pull-to-refresh\" gesture can probably guess what this does.\n\n\nThere is a view-model that goes along with the view (in \nViewModels\\TaskListViewModel.cs\n):\n\n\nusing System;\nusing System.Collections.ObjectModel;\nusing System.Collections.Specialized;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskListViewModel : BaseViewModel\n    {\n        public TaskListViewModel()\n        {\n            Title = \nTask List\n;\n            RefreshList();\n        }\n\n        ObservableCollection\nTodoItem\n items = new ObservableCollection\nTodoItem\n();\n        public ObservableCollection\nTodoItem\n Items\n        {\n            get { return items; }\n            set { SetProperty(ref items, value, \nItems\n); }\n        }\n\n        TodoItem selectedItem;\n        public TodoItem SelectedItem\n        {\n            get { return selectedItem; }\n            set\n            {\n                SetProperty(ref selectedItem, value, \nSelectedItem\n);\n                if (selectedItem != null)\n                {\n                    Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail(selectedItem));\n                    SelectedItem = null;\n                }\n            }\n        }\n\n        Command refreshCmd;\n        public Command RefreshCommand =\n refreshCmd ?? (refreshCmd = new Command(async () =\n await ExecuteRefreshCommand()));\n\n        async Task ExecuteRefreshCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                var table = App.CloudService.GetTable\nTodoItem\n();\n                var list = await table.ReadAllItemsAsync();\n                Items.Clear();\n                foreach (var item in list)\n                    Items.Add(item);\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\n[TaskList] Error loading items: {ex.Message}\n);\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command addNewCmd;\n        public Command AddNewItemCommand =\n addNewCmd ?? (addNewCmd = new Command(async () =\n await ExecuteAddNewItemCommand()));\n\n        async Task ExecuteAddNewItemCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                await Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\n[TaskList] Error in AddNewItem: {ex.Message}\n);\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        async Task RefreshList()\n        {\n            await ExecuteRefreshCommand();\n            MessagingCenter.Subscribe\nTaskDetailViewModel\n(this, \nItemsChanged\n, async (sender) =\n\n            {\n                await ExecuteRefreshCommand();\n            });\n        }\n    }\n}\n\n\n\n\nThis is a combination of the patterns we have seen earlier.  The Add New Item\nand Refresh commands should be fairly normal patterns now.  We navigate to the\ndetail page (more on that later) in the case of selecting an item (which occurs\nwhen the UI sets the \nSelectedItem\n property through a two-way binding) and when\nthe user clicks on the Add New Item button.  When the Refresh button is clicked\n(or when the user opens the view for the first time), the list is refreshed.  It\nis fairly common to use an \nObservableCollection\n or another class that uses the\n\nICollectionChanged\n event handler for the list storage.  Doing so allows the UI\nto react to changes in the items.\n\n\nNote the use of the \nICloudTable\n interface here.  We are using the \nReadAllItemsAsync()\n\nmethod to get a list of items, then we copy the items we received into the \nObservableCollection\n.\n\n\nFinally, there is the TaskDetail page.  This is defined in the \nPages\\TaskDetail.xaml\n\nfile:\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n ?\n\n\nContentPage xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n             xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n             x:Class=\nTaskList.Pages.TaskDetail\n\n             Title=\n{Binding Title}\n\n  \nContentPage.Content\n\n    \nStackLayout Padding=\n10\n Spacing=\n10\n\n      \nLabel Text=\nWhat should I be doing?\n/\n\n      \nEntry Text=\n{Binding Item.Text}\n/\n\n      \nLabel Text=\nCompleted?\n/\n\n      \nSwitch IsToggled=\n{Binding Item.Complete}\n/\n\n      \nStackLayout VerticalOptions=\nCenterAndExpand\n/\n\n      \nStackLayout Orientation=\nVertical\n VerticalOptions=\nEnd\n\n        \nStackLayout HorizontalOptions=\nCenter\n Orientation=\nHorizontal\n\n          \nButton BackgroundColor=\n#A6E55E\n\n                  Command=\n{Binding SaveCommand}\n\n                  Text=\nSave\n TextColor=\nWhite\n/\n\n          \nButton BackgroundColor=\nRed\n\n                  Command=\n{Binding DeleteCommand}\n\n                  Text=\nDelete\n TextColor=\nWhite\n/\n\n        \n/StackLayout\n\n      \n/StackLayout\n\n    \n/StackLayout\n\n  \n/ContentPage.Content\n\n\n/ContentPage\n\n\n\n\n\nThis page is a simple form with just two buttons that need to have commands\nwired up.  However, this page is used for both the \"Add New Item\" gesture\nand the \"Edit Item\" gesture.  As a result of this, we need to handle the\npassing of the item to be edited.  This is done in the \nPages\\TaskDetail.xaml.cs\n\ncode-behind file:\n\n\nusing TaskList.Models;\nusing TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class TaskDetail : ContentPage\n    {\n        public TaskDetail(TodoItem item = null)\n        {\n            InitializeComponent();\n            BindingContext = new TaskDetailViewModel(item);\n        }\n    }\n}\n\n\n\n\nThe item that is passed in from the \nTaskList\n page is used to create a\nspecific view-model for that item.  The view-model is similarly configured\nto use that item:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskDetailViewModel : BaseViewModel\n    {\n        ICloudTable\nTodoItem\n table = App.CloudService.GetTable\nTodoItem\n();\n\n        public TaskDetailViewModel(TodoItem item = null)\n        {\n            if (item != null)\n            {\n                Item = item;\n                Title = item.Text;\n            }\n            else\n            {\n                Item = new TodoItem { Text = \nNew Item\n, Complete = false };\n                Title = \nNew Item\n;\n            }\n        }\n\n        public TodoItem Item { get; set; }\n\n        Command cmdSave;\n        public Command SaveCommand =\n cmdSave ?? (cmdSave = new Command(async () =\n await ExecuteSaveCommand()));\n\n        async Task ExecuteSaveCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id == null)\n                {\n                    await table.CreateItemAsync(Item);\n                }\n                else\n                {\n                    await table.UpdateItemAsync(Item);\n                }\n                MessagingCenter.Send\nTaskDetailViewModel\n(this, \nItemsChanged\n);\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\n[TaskDetail] Save error: {ex.Message}\n);\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command cmdDelete;\n        public Command DeleteCommand =\n cmdDelete ?? (cmdDelete = new Command(async () =\n await ExecuteDeleteCommand()));\n\n        async Task ExecuteDeleteCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id != null)\n                {\n                    await table.DeleteItemAsync(Item);\n                }\n                MessagingCenter.Send\nTaskDetailViewModel\n(this, \nItemsChanged\n);\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\n[TaskDetail] Save error: {ex.Message}\n);\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}\n\n\n\n\nThe save command uses the \nICloudTable\n interface again - this time doing\neither \nCreateItemAsync()\n or \nUpdateItemAsync()\n to create or update the\nitem.  The delete command, as you would expect, deletes the item with the\n\nDeleteItemAsync()\n method.\n\n\nThe final thing to note from our views is that I am using the \nMessagingCenter\n\nto communicate between the TaskDetail and TaskList views.  If I change the item\nin the \nTaskDetail\n list, then I want to update the list in the \nTaskList\n view.\n\n\nNote that all the code we have added to the solution thus far is in the common\n\nTaskList\n project.  Nothing is required for this simple example in a platform\nspecific project.  That isn't normal, as we shall see.\n\n\nBuilding the Client for Universal Windows\n\n\nI tend to start by building the Universal Windows mobile client.  I'm using\nVisual Studio, after all, and I don't need to use any emulator.  To build the\nclients:\n\n\n\n\nRight-click on the \nTaskList.UWP (Universal Windows)\n project, then select \nSet as StartUp Project\n.\n\n\nRight-click on the \nTaskList.UWP (Universal Windows)\n project again, then select \nBuild\n.\n\n\nOnce the build is complete, Right-click on the \nTaskList.UWP (Universal Windows)\n project again, then select \nDeploy\n.\n\n\nClick on the \nLocal Machine\n button in your command bar to run the application.\n\n\n\n\nHere are the three screen screens we generated on Windows:\n\n\n\n\nThere are some problems with the UWP version.  Most notably, the \"pull-to-refresh\"\ngesture does not exist, so we will need to set up an alternate gesture.  This\ncould be as easy as adding a refresh button right next to the Add New Item\nbutton.  In addition, there is no indication of network activity - this manifests\nas a significant delay between the TaskList page appearing and the data appearing\nin the list.\n\n\nAside from this, I did do some styling work to ensure that the final version\nlooked like my mock-ups (with the exception of the UI form of the switch, which\nis platform dependent).  If you want to see what I did to correct this, check out\nthe final version of \nthe Chapter 1 sample\n on GitHub.\n\n\nIf you need to build the project, ensure you redeploy the project after building.\nIt's a step that is easy to miss and can cause some consternation as you change\nthe code and it doesn't seem to have an effect on the application.\n\n\nBuilding the Client for Android\n\n\nBuilding Android with Visual Studio is as easy as building the Universal Windows\nversion of the mobile client:\n\n\n\n\nRight-click on the \nTaskList.Droid\n project, then select \nSet as StartUp Project\n.\n\n\nRight-click on the \nTaskList.Droid\n project again, then select \nBuild\n.\n\n\n\n\nThe button for running the application has a drop-down that is now significant.\nIt lets you choose the type of device that you will use.  Normally, this runs\neither a 5\" or 7\" KitKat-based Android device.  There is some setup required for\nthe Visual Studio Emulator for Android.  The Visual Studio Emulator for Android\nruns within Hyper-V, so you must install Hyper-V before use.  You get the following\nerror if you don't do this:\n\n\n\n\nTo install Hyper-V:\n\n\n\n\nClose all applications (your system will be rebooted during this process).\n\n\nSearch for \nPrograms and Features\n.\n\n\nClick on \nTurn Windows features on or off\n (in the left-hand menu).\n\n\nExpand the \nHyper-V\n node.\n\n\nCheck all the boxes below the \nHyper-V\n node.  This will include Hyper-V Management Tools and Hyper-V Services.\n\n\nClick on \nOK\n.\n\n\nYour system will install the required pieces and then ask you to restart.  Click on \nRestart now\n when prompted.\n\n\n\n\nOnce you have done this, the next hurdle is to be added to the Hyper-V Administrators\nsecurity group.  It gets done for you (again - the first time you try to run the\napplication after installing Hyper-V).  Once it is done, close Visual Studio (again),\nthe log out and back in again.\n\n\nAs if that wasn't enough, the emulator also needs an Internet connection to\nstart.\n\n\n\n\nYou should be able to just click on \nYes\n or \nOK\n to enable the Internet\nconnection.  My laptop required a reboot before this would work, however.  In\naddition, the process may request elevated privileges.\n\n\n\n\nIf you want to run additional Android profiles before starting, run the \nVisual Studio Emulator for Android\n and download any additional profiles.  For example, if you wish to emulate something similar to a Samsung Galaxy S6, then download the profile for a 5.1\" Marshmallow (6.0.0) XXHDPI Phone.\n\n\n\n\nFinally the Visual Studio Emulator for Android starts when you click on the Run\nbutton.  Fortunately, the setup of the emulator only has to be done once per\nmachine.  The Visual Studio Emulator for Android is also a superior emulator\nto the standard Android Emulator, so this process is well worth going through.\n\n\n\n\nWhen testing the mobile client manually through the Visual Studio Emulator for Android, you are likely to need to rebuild the application.  You do not have to shut down the emulator between runs.  You can leave it running.  The application will be stopped and replaced before starting again.  This can significantly speed up the debug cycle since you are not waiting for the emulator to start each time.\n\n\n\n\nWatch the Output window.  If the debugger won't connect or the application\nwon't start, you may need to restart your computer again to get the network\nworking.\n\n\n\n\nIf your computer doesn't run Hyper-V well (or at all), then the emulator won't run well (or at all) either.  I find laptops to be particularly prone to this problem.  If this happens, you can always run the Google Emulator instead.  Build the application as normal.  You will find the APK file to install in \n...\\TaskList.Droid\\bin\\Debug\n. Fortunately, there are lots of resources that show how to do this.  You can find the answer on \nStack Overflow\n\n\n\n\nIf everything is working, you should see the Visual Studio Emulator for Android\ndisplay your mobile client:\n\n\n\n\n\n\nYou can also build the Android version on a mac with Xamarin Studio.  However, I find that version mismatches between Mono (which is used on the mac) and Visual Studio - particularly in reference to the version of the .NET framework - cause issues when swapping between the two environments.  For best results, stay in one environment.\n\n\n\n\nNote that the task list view is a \"light\" style and the rest of the app is a\n\"dark\" style.  This is because the default styling on an Android device is\ndark.  We are using the default styling on two of the pages and specifying\ncolors on the list page.  Fortunately, Xamarin Forms allows for \nplatform-specific\nstyling\n.  The \nfinal sample\n has platform-specific styling for the\nlist page.\n\n\nBuilding the Client for iOS\n\n\nFinally, we get to the iOS platform.  You will need to ensure your Mac is turned\non and accessible, that it has XCode installed (and you have run XCode once so\nthat you can accept the license agreement), and it has Xamarin Studio installed.\n\n\nWhen you created the projects, you were asked to link Visual Studio to your mac.\nThis linkage is used for building the project.  In essence, the entire project\nis sent to the Mac and the build tools that are supplied with Xamarin Studio\nwill be used to build the project.\n\n\n\n\nRight-click on the \nTaskList.iOS\n project and select \nSet as StartUp Project\n.\n\n\nRight-click on the \nTaskList.iOS\n project and select \nBuild\n.\n\n\n\n\nYou knew it was not going to be that easy, right?  Here are the errors that I\nreceived when building for the first time:\n\n\n\n\nThere are two errors right at the top.  Let's cover the first one.  The error\nabout \nBuild Action 'EmbeddedResource' is not supported\n is an annoying one.\nThe fix is to do the following:\n\n\n\n\nSet the iOS project as the StartUp project.\n\n\nGo through each project, expand the \nReferences\n node and ensure that there are no references with a warning (a little yellow triangle).  If there are - fix those first.  Generally, this is fixed by either using the \nRestore NuGet Packages\n option or removing the reference and then adding it again from NuGet.\n\n\nClose the solution.\n\n\nRe-open the solution.  You don't need to close Visual Studio to do this.\n\n\nRight-click on the iOS project and select \nClean\n.\n\n\nRight-click on the iOS project and select \nRebuild\n.\n\n\n\n\nOnce you have done this sequence, the error should go away.\n\n\nThe error about \nNo valid iOS code signing keys found in keychain\n is because\nwe have not yet signed up for an Apple Developer Account and linked it to our\nMac development environment.\n\n\n\n\nGo to the \nApple Developer Center\n.\n\n\nClick on \nAccount\n in the top navigation bar.\n\n\nIf you haven't got an Apple ID yet, create one first.\n\n\nIf you have go an Apple ID, then log in.\n\n\n\n\nThere are a sequence of sign-up prompts in both cases (first for creating your\nApple ID and secondly for signing up for the Apple Developer program).  Once\nyou have gone through this process, you are registered as an Apple Developer.\n\n\n\n\nIf you want to distribute your apps on the Apple App Store, run on real devices or get access to the beta bits, then you might consider signing up for the Apple Developer Program.  The Apple Developer Program is an additional cost and is not required for developing iOS apps that are only run on the iOS simulator.\n\n\n\n\nOnce you have created your account and enabled it as a developer account, open\nup XCode.  Go to \nPreferences...\n, then \nAccount\n and\nclick on the \n+\n in the bottom-left corner of the window:\n\n\n\n\nSign in with the same account you used to sign up for the developer account.\n\n\n\n\nClick on the \nView Details\n button.  This will bring up the Signing Identities\nlist.  For a free account, it looks like this:\n\n\n\n\nClick on the Create button next to \niOS Development\n.  Once the UI comes back,\nclick on \nDone\n.  For more information on this process, refer to the \nApple Documentation\n.\n\n\nYou can close XCode at this point.  Ensure Xamarin Studio is not running.  Back\nwithin Visual Studio, right-click on the \nTaskList.iOS\n project and select \nRebuild\n.\nThis will (finally!) build the application for you.\n\n\n\n\nGetting an error about \nProvisioning Profiles\n not being available?  This is because you are building for a real device instead of the simulator.  In order to build for a real device, you must have a linked Apple Developer Program.  To get around this, select a Simulator before building.\n\n\n\n\nThe \nRun\n button has received a \nDevice\n label, but there are several simulator options.\nYou should only use \nDevice\n if you have signed up for the Apple Developer Program.  Pick\none of the simulator options like the \niPhone 6 iOS 9.3\n simulator, then click on it\nto run the simulator.  Before long, you should see the following:\n\n\n\n\nAt some point, you will need a platform initialization call on all platforms.  It's best to\nadd it now.  In TaskList.Droid, this should be added in \nMainActivity.cs\n and in TaskList.iOS,\nit's \nAppDelegate.cs\n.  In each of these files, there is a line that initializes the Xamarin\nForms system.\n\n\n// Android Version\nglobal::Xamarin.Forms.Forms.Init(this, bundle);\n// iOS Version\nglobal::Xamarin.Forms.Forms.Init ();\n\n\n\n\nImmediately before this line, you should add the  initializer for Azure Mobile Apps. It's\nimportant that the Azure Mobile Apps subsystem is initialized prior to Xamarin Forms being\ninitialized and any UI code being called.\n\n\nMicrosoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n\n\n\nThis initializer is not required on the UWP project.  Once this is done and you have re-built\nthe project, we can see the fruits of our labor.  You can, of course, run the IPA in the\niOS simulator on the Mac.  However, it's much more satisfying (to me, at least) to be able\nto do everything from within Visual Studio.  For this, you need to install the\n\nXamarin Installer\n.  This is an MSI for your Windows development system and is\nquickly installed.  Once installed, start (or restart) Visual Studio, select \nTools\n -\n\n\nOptions\n.  Search for \nXamarin\n, and select the \niOS Settings\n page.  There is\na new option:\n\n\n\n\nNote the \nRemote Simulator to Windows\n.  This should be checked.  You may need to\nrebuild the TaskList.iOS project after installing the Xamarin Simulator.  The debug\nwindow will tell you if this is the case.  There are also a few \nknown issues\n\nso check the documentation if you run into problems.\n\n\nThe final product screens look like this:\n\n\n\n\nSome Final Thoughts\n\n\nIf you have got through the entire process outlined in this Chapter and built the application\nfor each platform, then congratulations.  There are a lot of places where things can go\nwrong.  You are really integrating the build systems across Visual Studio, Android, Xamarin,\nand XCode.\n\n\nFortunately, once these are set up, it's likely that they will continue working and you\nwon't have to think too much about them again. The Android and iOS build tools and simulators\nwill just work.\n\n\nThe next 7 chapters each take one aspect of the cloud services that can be provided to\nmobile apps and explores it in detail, using an Azure Mobile App as a beginning. You can\njump around at this point, but be aware that we expect you to cover these topics in order.\nIf you do the data chapter before covering authentication, it's likely you will have missed\nimportant functionality in your app to complete the work.", 
            "title": "1. Your First Mobile App"
        }, 
        {
            "location": "/1_introduction/#your-first-mobile-app", 
            "text": "There is a lot of detail to absorb about the possible services that the mobile\nclient can consume and I will go into significant depth on those subjects.\nFirst, wouldn't it be nice to write some code and get something working?\nMicrosoft Azure has a great  first-steps tutorial  that takes you via the\nquickest possible route from creating a mobile backend to having a functional\nbackend.  I would like to take things a little slower so that we can understand\nwhat is going on while we are doing the process.  We will have practically the\nsame application at the end.  The primary reason for going through this slowly\nis to ensure that all our build and run processes are set up properly.  If this\nis the first mobile app you have ever written, you will see that there are quite\na few things that need to be set up.  The application we are going to build together is a simple task list.  The\nmobile client will have three screens - an entry screen, a task list and a task\ndetails page.  I have mocked these pages up using  MockingBot .   Mocking your screens before you start coding is a great habit to get into.\nThere are some great tools available including free tools like  MockingBot .\nDoing mockups before you start coding is a good way to prevent wasted time later\non.     Why include a back button?  If you are using iOS, then you may want to remove\nthe back button as the style guides suggest you don't need one.  Other platforms\nwill need it though, so it's best to start with the least common denominator.\nIt's the same reason I add a refresh button even though it's only valid on\nWindows Phone!   My ideas for this app include:   Tapping on a task title in the task list will bring up the details page.  Toggling the completed link in the task list will set the completed flag.  Tapping the spinner will initiate a network refresh.   Now that we have our client screens planned out, we can move onto the thinking\nabout the mobile backend.", 
            "title": "Your First Mobile App"
        }, 
        {
            "location": "/1_introduction/#the-mobile-backend", 
            "text": "The mobile backend is an ASP.NET WebApi that is served from within Azure App\nService: a highly scalable and redundant web hosting facility that supports all\nthe major web languages (like ASP.NET, Node, PHP and Python).  Azure Mobile\nApps is an SDK (which is available in ASP.NET and Node) that runs on top of\nAzure App Service.", 
            "title": "The Mobile Backend"
        }, 
        {
            "location": "/1_introduction/#creating-a-simple-azure-mobile-apps-backend", 
            "text": "Microsoft Azure has included a comprehensive starter kit template in the\nAzure SDK.  To get started:   Fire up Visual Studio 2015  Add a new project with File -  New Project...   In the  New Project  window:   Open up Templates -  Visual C# -  Web and select  ASP.NET Web Application (.NET Framework) .  Enter  Backend  for the Name and  Chapter1  for the Solution name.  Pick a suitable directory for the Location field.  Click on OK.      In the  New ASP.NET Web Application  window:   Click on  Azure Mobile App .  Do  NOT  check \"Host in the cloud\" or any other checkboxes.  Click on OK.     At this point, Visual Studio will create your backend project.   It's very tempting to select  Azure Mobile Services  instead - it sounds closer to what you want.  Azure Mobile Services is the  OLD  service and is being shut down.  You should not select Azure Mobile Services for any project.   There are a few files of which you should take note.  The Mobile Apps SDK is\ninitialized within  App_Start\\Startup.MobileApp.cs  (with the call to the\nconfiguration routine happening within  Startup.cs ).  The default startup\nroutine is reasonable but it hides what it is doing behind extension methods.\nThis technique is fairly common in ASP.NET programs.  Let's expand the configuration\nroutine to only include what we need:  public static void ConfigureMobileApp(IAppBuilder app)\n{\n    var config = new HttpConfiguration();\n    var mobileConfig = new MobileAppConfiguration();\n\n    mobileConfig\n        .AddTablesWithEntityFramework()\n        .ApplyTo(config);\n\n    Database.SetInitializer(new MobileServiceInitializer());\n\n    app.UseWebApi(config);\n}  The minimal version of the mobile backend initialization is actually shorter\nthan the original.  It also only includes a data access layer.  Other services\nlike authentication, storage and push notifications are not configured.  There is another method in the  App_Start\\Startup.MobileApp.cs  file for\nseeding data into the database for us.  We can leave that alone for now, but\nremember it is there in case you need to seed data into a new database for\nyour own backend.   We refer to \"seeding data\" into a database.  This means that we are going to introduce some data into the database so that we aren't operating on an empty database.  The data will be there when we query the database later on.   The next important file is the  DbContext  - located in  Models\\MobileServiceContext.cs .\nAzure Mobile Apps is heavily dependent on  Entity Framework v6.x  and the DbContext  is a central part of that library.  Fortunately, we don't need\nto do anything to this file right now.  Finally, we get to the meat of the backend.  The whole point of this demonstration\nis to project a single database table - the TodoItem table - into the mobile realm\nwith the aid of an opinionated  OData v3  feed.  To that end, we need three\nitems:   A  DbSet  within the  DbContext  A Data Transfer Object (or DTO)  A Table Controller   When we create the project, a sample of each one of these for the TodoItem table\nis added for us.  You can see the  DbSet  in the  Models\\MobileServiceContext.cs \nfile, for example.  Let's take a look at the DTO and Table Controller for this\nexample table as well.  The DTO for the TodoItem table is located within the DataObjects  directory:  using Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.DataObjects\n{\n    public class TodoItem : EntityData\n    {\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n    }\n}  Note that the model uses  EntityData  as a base class.  The  EntityData  class\nadds five additional properties to the class - we'll discuss those in more\ndetails during the  Data Access and Offline Sync  chapter.  Finally, let's look at the table controller for the example TodoItem table.  This\nis located in  Controllers\\TodoItemController.cs :  using System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController TodoItem \n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager TodoItem (context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable TodoItem  GetAllTodoItems() =  Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult TodoItem  GetTodoItem(string id) =  Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task TodoItem  PatchTodoItem(string id, Delta TodoItem  patch) =  UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task IHttpActionResult  PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute( Tables , new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) =  DeleteAsync(id);\n    }\n}  The  TableController  is the central processing for the database access layer.\nIt handles all the OData capabilities for us and exposes these as REST endpoints\nwithin our WebAPI.  This means that the actual code for this controller is tiny - just 12 lines of code.   OData  is a specification for accessing table data on the Internet.  It provides a mechanism for querying and manipulating data within a table.  Entity Framework is a common data access layer for ASP.NET applications.   We can build the project at this point.  If Visual Studio hasn't done so already,\nthe missing NuGet packages for Azure Mobile Apps will be downloaded.  There\nshould not be any errors.  If there are, check the typing for any changes you\nmade.   You can delete or ignore the  Controllers\\ValuesController.cs  file if you like - it isn't important for this walkthrough.", 
            "title": "Creating a Simple Azure Mobile Apps Backend"
        }, 
        {
            "location": "/1_introduction/#building-an-azure-app-service-for-mobile-apps", 
            "text": "The next step in the process is to build the resources on Azure that will run\nyour mobile backend.  Start by logging into the  Azure Portal , then follow\nthese instructions:   Click on the big  + New  button in the top-left corner.  Click on  Web + Mobile , then  Mobile App .   Enter a unique name in the  App name  box.   Since the name doesn't matter and it has to be unique, you can use  a GUID generator  to generate a unique name.     If you have more than one subscription (for example, you have a trial and\n    an MSDN subscription), then ensure you select the right subscription in\n    the  Subscription  drop-down.    Select  Create new  under resource group and enter a name for this mobile application.   Resource groups are great for grouping all the resources associated with a mobile application together.  During development, it means you can delete all the resources in one operation.  For production, it means you can see how much the service is costing you and how the resources are being used.     Finally, select or create a new  App Service Plan .   The App Service Plan is the thing that actually bills you - not the web or mobile backend.  You can run a number of web or mobile backends on the same App Service Plan.   I tend to create a new App Service Plan for each mobile application.  This is because the App Service Plan lives inside the Resource Group that you create.  The process for creating an App Service Plan is straight forward.  You have two decisions to make.  The first decision is where is the service going to run.  In a production environment, the correct choice is \"near your customers\".  \"Close to the developers\" is a good choice during development.  Unfortunately, neither\nof those is an option you can actually choose in the portal, so you will have to translate into some sort of geographic location.  With 16 regions to choose from, you have a lot of choice.  The second decision you have to make is what to run the service on; also known as the Pricing tier.   If you click on  View all , you will see you have lots of choices.  F1 Free and D1 Shared, for example, run on shared resources and are CPU limited. You should avoid these as the service will stop responding when you are over the CPU quota.  That leaves Basic, Standard and Premium.  Basic has no automatic scaling and can run up to 3 instances - perfect for development tasks.  Standard and Premium both have automatic scaling, automatic backups, and large amounts of storage; they differ in features: the number of sites or instances you can run on them, for example.  Finally, there is a number after the plan.  This tells you how big the virtual machine is that the plan is running on.  The numbers differ by number of cores and memory.  For our purposes, an F1 Free site is enough to run this small demonstration project.  More complex development projects should use something in the Basic range of pricing plans.  Production apps should be set up in Standard or Premium pricing plans.    Once you have created your app service plan and saved it, click on  Create .    The creation of the service can take a couple of minutes.  You can monitor the process of deployment by clicking on the Notifications icon.  This is in the top bar on the right-hand side and looks like a Bell.  Clicking on a specific notification will provide more information about the activity.  Once you have created your app service, the App Service blade will open.   What's the difference between a Web App, a Mobile App and an API App?  Not a lot.  The type determines which Quick start projects are available in the Quick start menu under  All settings .  Since we selected a Mobile app, a set of starter client projects for mobile devices will be presented.   The next step in the process is to create a SQL Azure instance.  The ASP.NET application that we produced earlier will use this to store the data presented in the table controller.   Click on the  + New  button on the left hand side of the page.  Select  Data + Storage  and then  SQL Database .  Enter a unique database name (I use a GUID again) in the  Database name  box.  Select  Use existing  under the  Resource group , then select the resource group you created earlier.  Select  Blank database  in the  Select source  box.   Click on  Configure required settings  for the  Server .   Click on  Create a new server .  Enter another globally unique name for the  Server name  (I use a GUID yet again).  Enter  appservice  in the  Server admin login  (or use your own name).  Enter a password in the  Password  and  Confirm password  boxes.  Select the same location as your App Service in the  Location  box.  Click on  Select  to create the Server.     Click on the  Pricing tier .  The  B Basic  plan is the cheapest plan available.   Click on  Create .    There are other methods of creating a SQL Azure instance, including using\nthe Data Connections blade within the App Service.   The SQL Azure instance takes longer to deploy than the App Service in general.\nHowever, it will still be available within 3-5 minutes.   GUIDs are not the best names to use when you need to actually find resources, but using GUIDS prevents conflicts when deploying, so I prefer them as a naming scheme.  You can prefix the GUID (example: chapter1-GUID) to aid in discovery later on.  Generally, the first four digits of a GUID are enough to identify individual resources.   Finally, you will need to link your SQL Azure instance to the App Service instance:   Click on  Resource groups  in the left hand side menu.  Click on the resource group you created.  Click on the App Service you created.  Click on  All settings .  Click on  Data connections  in the  MOBILE  menu.   Click on  Add .   Click on the  Configure required settings  under  SQL Database .  Select the database you just created, then click on  Select .  Click on  Configure required settings  under  Connection string .  Enter  appservice  in the  User Name  box.  Enter your chosen password in the  Password  box.  watch for green tick marks to ensure the username and password are correct.  Click on  OK  Click on  OK  in the  Add data connection  blade.     This produces another deployment step.  It doesn't take very long so you can\nswitch back to your Visual Studio window.   If you want a completely free mobile backend, search for the  Mobile Apps\nQuickstart  in the Azure Marketplace.  This template does not require a\ndatabase.  It relies on a Node backend, however, so you won't be developing a C#\nbackend.", 
            "title": "Building an Azure App Service for Mobile Apps"
        }, 
        {
            "location": "/1_introduction/#deploying-the-azure-mobile-apps-backend", 
            "text": "Deploying to Azure as a developer can be accomplished while entirely within Visual Studio:   Right-click on the  Backend  project, then select  Publish... .   Make sure you see this screen shot:   If you do not see this image, then it is likely you have an older version\nof the Azure SDK installed.  Make sure the Azure SDK version is v2.9 or\nlater.    Click on  Microsoft Azure App Service .   You may be prompted to enter your Azure credentials here.  Enter the same\n    information that you enter to access the Azure Portal.  In the lower box, expand the resource group that you created and select the\n    app service you created in the portal.  Click on  OK .  Click on  Publish .   Visual Studio will open a browser.  Add  /tables/todoitem?ZUMO-API-VERSION=2.0.0 \nto the end of the URL.  This will show the JSON contents of the table that we\ndefined in the backend.   You will see the word ZUMO all over the SDK, including in optional HTTP headers and throughout the SDK source code.  ZUMO was the original code name within Microsoft for A ZU re  MO bile.", 
            "title": "Deploying the Azure Mobile Apps Backend"
        }, 
        {
            "location": "/1_introduction/#the-mobile-client", 
            "text": "Now that the mobile backend is created and deployed, we can move onto the client\nside of things.  First of all, let's prepare the Visual Studio instance.  If you\nhave installed the Cross-Platform Mobile tools during the installation, most of\nthe work has already been done.  However, you may want to install the  Xamarin\nForms Templates  using the Tools -  Extensions and Updates...   This template pack provides additional templates for Xamarin Forms development\nthat I find useful.  Most notably, there is a specific template for a mobile\ncross-platform project covering the Android, iOS and UWP mobile platforms.   When you compile a Xamarin.Forms application for a specific platform, you are\nproducing a true native application for that platform - whether it be iOS, Android\nor Windows.", 
            "title": "The Mobile Client"
        }, 
        {
            "location": "/1_introduction/#creating-a-simple-mobile-client-with-xamarin", 
            "text": "Now that we have prepared your Visual Studio instance, we can create the project.\nRight-click on the solution and select  Add  -   New Project... .  This will\nbring up the familiar New Project dialog.  The project you want is under  Visual C# \n-   Cross-Platform , and is called  Xamarin.Forms (UWP/Android/iOS) .  If you\ndid not install the Xamarin Forms Template add-on, then choose the Blank Xaml App (Xamarin.Forms Portable)  project.  Give the project a name,\nthen click on  OK .    If you did not install the Xamarin Forms Templates, then you can create a  Blank Xaml App (Xamarin.Forms Portable)  project instead.   Project creation will take longer than you expect, but there is a lot going on.\nIf you have never created a mobile or UWP project before, you will be prompted\nto turn on Windows 10 Developer Mode:   Developer mode in Windows 10 allows you to run unsigned binaries for development\npurposes and to turn on debugging so that you can step through your UWP programs\nwithin Visual Studio.  We will also get asked to choose what version of the Universal Windows platform\nwe want to target:   Version 10240 was the first version of Windows 10 that was released to the general\npublic, so that's a good minimum version to pick.  In general, the defaults for\nthe Universal Windows Platform choice are good enough.  Xamarin allows us to build iOS applications directly from Visual Studio. For\nthis to work, we must have access to a Mac. This could be anything from a MacBook\nAir/Pro, to a Mac Mini in a drawer or closet in the office, or maybe even a Mac in the cloud .  The Xamarin tools use SSH to connect to the Mac, which\nmust be  configured to build iOS apps from Visual Studio .   If you don't have a Mac and are not interested in building iOS applications, don't give up now!  You can cancel through the Mac specific project setup and continue with building a great Android and Universal Windows app.  You can delete the iOS specific project after it has been created.   When prompted about the Xamarin Mac Agent, click on  OK  to get the list of\nlocal mac agents:   Highlight your mac (in case there are multiples), then click on  Connect... .\nIf your mac is not listed or you are using a Mac in the cloud, then you can\nalways enter the IP address for your mac.     For more troubleshooting tips, visit  https://developer.xamarin.com/guides/ios/getting_started/installation/windows/connecting-to-mac/troubleshooting/   You will be prompted for your username and password:   Just enter the username and password that you use to log in to your mac and click\non  Login .   What's my username?   Apple tries very hard to hide the real username of\nyour account from you.  The easiest way to find your mac username is to open up\nthe Finder.  The name next to your home icon is the name of your account.   If the connection has successed, you will see a green icon in the Xamarin Visual\nStudio toolbar area. It may take a minute or two to connect and verify that the\nmac can be used.  Once the project is created, you will see that four new projects have been\ncreated: a common library which you named plus one project for each platform\nthat has been chosen.  Since we chose a project with three platforms, we get\nfour projects:   Most of our work will happen in the common library.  However, we can introduce\nplatform-specific code at any point.  The platform-specific code is stored in\nthe platform-specific project.  There is one final item we must do before we leave the set up of the project.\nThere are a number of platform upgrades that inevitably have to happen.  The\nXamarin Platform is updated much more often than the Visual Studio plugin - the\nupdates are released via NuGet: the standard method of distributing libraries\nfor .NET applications.  In addition to the inevitable Xamarin Platform update,\nwe also will want to add the following NuGet packages:   Microsoft.Azure.Mobile.Client v2.0.0 or later  Newtonsoft.Json v6.0.3 or later    Although it is tempting, do not include a v1.x version of the Mobile Client.\nThis is for the earlier Azure Mobile Services.  There are many differences between\nthe wire protocols of the two products.   You can install the NuGet packages by right-clicking on the project and selecting Manage NuGet Packages... .   You must install the updates and the new NuGet packages on all four projects.\nThis involves repeating the same process for each client project in your\nsolution.   Android generally has more updates than the other platforms.  Ensure that you\nupdate the main Xamarin.Forms package and then refresh the update list.  This will\nensure the right list of packages is updated.", 
            "title": "Creating a Simple Mobile Client with Xamarin"
        }, 
        {
            "location": "/1_introduction/#building-the-common-library", 
            "text": "There are two parts that we must concentrate on within the common library.  The\nfirst is the connection to Azure Mobile Apps and the second is in the pages\nthat the user interacts with.  In both cases, there are best practices to observe.", 
            "title": "Building the Common Library"
        }, 
        {
            "location": "/1_introduction/#building-an-azure-mobile-apps-connection", 
            "text": "We will rely on interfaces for defining the shape for the class for any service\nthat we interact with.  This is really not important in small projects like this\none.  This technique allows us to mock the backend service, as we shall see\nlater on.  Mocking the backend service is a great technique to rapidly iterate\non the front end mobile client without getting tied into what the backend is doing.  Let's start with the cloud service - this is defined in  Abstractions\\ICloudService.cs .\nIt is basically used for initializing the connection and getting a table definition:  namespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        public ICloudTable T  GetTable T () where T : TableData;\n    }\n}  There is a dependent implementation here: the  ICloudTable  generic interface.  This\nrepresents a CRUD interface into our tables and is defined in  Abstractions\\ICloudTable.cs :  using System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudTable T  where T : TableData\n    {\n        Task T  CreateItemAsync(T item);\n        Task T  ReadItemAsync(string id);\n        Task T  UpdateItemAsync(T item);\n        Task DeleteItemAsync(T item);\n\n        Task ICollection T  ReadAllItemsAsync() where T : TableData;\n    }\n}  The  ICloudTable T  interface defines the normal CRUD operations: Create, Read,\nUpdate and Delete.  However, it does so asynchronously.  We are dealing with network\noperations in general so it is easy for those operations to tie up the UI thread\nfor an appreciable amount of time.  Making them async provides the ability to\nrespond to other events.  I also provide a  ReadAllItemsAsync()  method that\nreturns a collection of all the items.  There are some fields that every single record within an Azure Mobile Apps table\nprovides.  These fields are required for offline sync capabilities like incremental\nsync and conflict resolution.  The fields are provided by an abstract base class\non the client called  TableData :  using System;\n\nnamespace TaskList.Abstractions\n{\n    public abstract class TableData\n    {\n        public string Id { get; set; }\n        public DateTimeOffset? UpdatedAt { get; set; }\n        public DateTimeOffset? CreatedAt { get; set; }\n        public byte[] Version { get; set; }\n    }\n}  As we will learn when we deal with table data in Chapter 3, these fields need to\nbe defined with the same name and semantics as on the server.  Our model on\nthe server was sub-classed from  EntityData  and the  EntityData  class on the\nserver defines these fields.  It's tempting to call the client version of the class the same as the server\nversion.  If we did that, the models on both the client and server would look\nthe same.  However, I find that this confuses the issue.  The models on the\nclient and server are not the same.  They are missing the  Deleted  flag and\nthey do not contain any relationship information on the client.  I choose to\ndeliberately call the base class something else on the client to avoid this\nconfusion.  We will be adding to these interfaces in future chapters as we add more\ncapabilities to the application.  The concrete implementations of these classes are similarly easily defined.  The\nAzure Mobile Apps Client SDK does most of the work for us.  Here is the concrete\nimplementation of the  ICloudService  (in  Services\\AzureCloudService.cs ):  using Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient( https://my-backend.azurewebsites.net );\n        }\n\n        public ICloudTable T  GetTable T () where T : TableData\n        {\n            return new AzureCloudTable T (client);\n        }\n    }\n}  The Azure Mobile Apps Client SDK takes a lot of the pain out of communicating\nwith the mobile backend that we have already published.  Just swap out the\nname of your mobile backend and the rest is silently dealt with.   The name  Microsoft.WindowsAzure.MobileServices  is a hold-over from the old Azure Mobile Services code-base.  Don't be fooled - clients for Azure Mobile Services are not interchangeable with clients for Azure Mobile Apps.   We also need a concrete implementation of the  ICloudTable T  interface (in  Services\\AzureCloudTable.cs ):  using System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudTable T  : ICloudTable T  where T : TableData\n    {\n        MobileServiceClient client;\n        IMobileServiceTable T  table;\n\n        public AzureCloudTable(MobileServiceClient client)\n        {\n            this.client = client;\n            this.table = client.GetTable T ();\n        }\n\n        #region ICloudTable implementation\n        public async Task T  CreateItemAsync(T item)\n        {\n            await table.InsertAsync(item);\n            return item;\n        }\n\n        public async Task T  DeleteItemAsync(T item)\n        {\n            await table.DeleteAsync(item);\n        }\n\n        public async Task ICollection T  ReadAllItemsAsync()\n        {\n            return await table.ToListAsync();\n        }\n\n        public async Task T  ReadItemAsync(string id)\n        {\n            return await table.LookupAsync(id);\n        }\n\n        public async Task T  UpdateItemAsync(T item)\n        {\n          await table.UpdateAsync(item);\n          return item;\n        }\n        #endregion\n    }\n}  It's important to note here that the Azure Mobile Apps Client SDK does a lot of\nthe work for us.  In fact, we are just wrapping the basic interface here.  This\nwon't normally be the case, but you can see that the majority of the code for\ndealing with the remote server is done for us.   You can use a shorthand (called a lambda expression) for methods with only one line.  For instance, the delete method could just as easily have been written as  public async Task T  DeleteItemAsync(T item) =  await table.DeleteAsync(item); .  You may see this sort of short hand in samples.   We also need to create the model that we will use for the data.  This should\nlook very similar to the model on the server - including having the same name\nand fields.  In this case, it's  Models\\TodoItem.cs :  using TaskList.Abstractions\n\nnamespace TaskList.Models\n{\n    public class TodoItem : TableData\n    {\n        public string Text { get; set; }\n        public bool Complete { get; set; }\n    }\n}  We have a final piece of code to write before we move on to the views, but it's\nan important piece.  The  ICloudService  must be a singleton in the client.  We\nwill add authentication and offline sync capabilities in future versions of this\ncode.  The singleton becomes critical when using those features.  For right now,\nit's good practice and saves on memory if you only have one copy of the  ICloudService \nin your mobile client.  Since there is only one copy of the  App.cs  in any\ngiven app, I can place it there.  Ideally, I'd use some sort of dependency\ninjection system or a singleton manager to deal with this.  Here is the  App.cs :  using TaskList.Abstractions;\nusing TaskList.Services;\nusing Xamarin.Forms;\n\nnamespace TaskList\n{\n    public class App : Application\n    {\n        public static ICloudService CloudService { get; set; }\n\n        public App()\n        {\n            CloudService = new AzureCloudService();\n            MainPage = new NavigationPage(new Pages.EntryPage());\n        }\n\n        // There are lifecycle methods here...\n    }\n}  We haven't written  Pages.EntryPage  yet, but that's coming.  The original  App.cs \nclass file had several methods for handling lifecycle events like starting, suspending\nor resuming the app.  I did not touch those methods for this example.", 
            "title": "Building an Azure Mobile Apps Connection"
        }, 
        {
            "location": "/1_introduction/#building-the-ui-for-the-app", 
            "text": "Earlier, I showed the mockup for my UI.  It included three pages - an entry\npage, a list page and a detail page.  These pages have three elements - a\nXAML definition file, a (simple) code-behind file and a view model.   This book is not intending to introduce you to everything that there is to know about Xamarin and UI programming with XAML.  If you wish to have that sort of introduction, then I recommend reading the excellent book by Charles Petzold:  Creating Mobile Apps with Xamarin.Forms .   I tend to use MVVM (or Model-View-ViewModel) for UI development in Xamarin\nbased applications.  It's a nice clean pattern and is well understood and\ndocumented.  In MVVM, there is a 1:1 correlation between the view and the\nview-model, 2-way communication between the view and the view-model and\nproperties within the view-model are bound directly to UI elements.  In\ngeneral (and in all my code), view-models expose an INotifyPropertyChanged\nevent to tell the UI that something within the view-model has been changed.  To do this, we will use a  BaseViewModel  class that implements the base functionality\nfor each view.  Aside from the  INotifyPropertyChanged  interface, there are\nsome common properties we need for each page.  Each page needs a title, for\nexample, and each page needs an indicator of network activity.  These can be\nplaced in the  Abstractions\\BaseViewModel.cs  class:  using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\n\nnamespace TaskList.Abstractions\n{\n    public class BaseViewModel : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n        string _propTitle = string.Empty;\n        bool _propIsBusy;\n\n        public string Title\n        {\n            get { return _propTitle; }\n            set { SetProperty(ref _propTitle, value,  Title ); }\n        }\n\n        public bool IsBusy\n        {\n            get { return _propIsBusy; }\n            set { SetProperty(ref _propIsBusy, value,  IsBusy ); }\n        }\n\n        protected void SetProperty T (ref T store, T value, string propName, Action onChanged = null)\n        {\n            if (EqualityComparer T .Default.Equals(store, value))\n                return;\n            store = value;\n            if (onChanged != null)\n                onChanged();\n            OnPropertyChanged(propName);\n        }\n\n        public void OnPropertyChanged(string propName)\n        {\n            if (PropertyChanged == null)\n                return;\n            PropertyChanged(this, new PropertyChangedEventArgs(propName));\n        }\n    }\n}  This is a fairly common  INotifyPropertyChanged  interface implementation pattern.\nEach property that we want to expose is a standard property, but the  set  operation\nis replaced by the  SetProperty()  call.  The  SetProperty()  call deals with the\nnotification; calling the event emitter if the property has changed value.  We\nonly need two properties on the  BaseViewModel : the title and the network indicator.  I tend to write my apps in two stages.  I concentrate on the functionality of the\napp in the first stage.  There is no fancy graphics, custom UI widgets, or anything\nelse to clutter the thinking.   The page is all about the functionality of the\nvarious interactions.  Once I have the functionality working, I work on the styling\nof the page.  We won't be doing any styling work in the demonstration apps that we\nwrite during the course of this book.  The EntryPage has just one thing to do.  It provides a button that enters the app.\nWhen we cover authentication later on, we'll use this to log in to the backend.  If\nyou are looking at the perfect app, this is a great place to put the introductory\nscreen.  Creating a XAML file is relatively simple.  First, create a  Pages  directory to\nhold the pages of our application.  Then right-click on the  Pages  directory in\nthe solution explorer and choose  Add  -   New Item... .  In the  Add New Item \ndialog, pick  Visual C#  -   Cross-Platform  -   Forms Xaml Page .  Name the\nnew page  EntryPage.cs .  This will create two files -  EntryPage.xaml  and EntryPage.xaml.cs .  Let's center a button on the page and wire it up with\na command.  Here is the  Pages\\EntryPage.xaml  file:  ?xml version= 1.0  encoding= utf-8  ?  ContentPage xmlns= http://xamarin.com/schemas/2014/forms \n             xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n             x:Class= TaskList.Pages.EntryPage \n             Title= {Binding Title} \n     ContentPage.Content \n         StackLayout HorizontalOptions= Center \n                     Orientation= Vertical \n                     VerticalOptions= Center \n             Button BackgroundColor= Teal \n                    BorderRadius= 10 \n                    Command= {Binding LoginCommand} \n                    Text= Login \n                    TextColor= White  / \n         /StackLayout \n     /ContentPage.Content  /ContentPage   There are a couple of interesting things to note here.  The  StackLayout  element\nis our layout element.  It occupies the entire screen (since it is a direct child\nof the content page) and the options just center whatever the contents are.  The\nonly contents are a button.  There are two bindings.  These are bound from the view-model.  We've already seen\nthe Title property - this is a text field that specifies the title of the page.\nThe other binding is a login command.  When the button is tapped, the login command\nwill be run.  We'll get onto that in the view-model later.  The other part of the XAML is the code-behind file.  Because we are moving all\nof the non-UI code into a view-model, the code-behind file is trivial:  using TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class EntryPage : ContentPage\n    {\n        public EntryPage()\n        {\n            InitializeComponent();\n            BindingContext = new EntryPageViewModel();\n        }\n    }\n}  This is a recipe that will be repeated over and over again for the code-behind\nwhen you are using a XAML-based project with MVVM.  We initialize the UI, then\nbind all the bindings to a new instantiation of the view model.  Talking of which, the view-model needs just to handle the login click.  Note that\nthe location or namespace is  TaskList.ViewModels .  I'm of two minds about location.\nThere tends to be a 1:1 relationship between the XAML file and the View Model, so\nit makes sense that they are stored together.  However, just about all the sample\ncode that I see has the view-models in a separate namespace.  Which one is correct?\nI'll go with copying the samples for now.  Here is the code for  ViewModels\\EntryPageViewModel.cs :  using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class EntryPageViewModel : BaseViewModel\n    {\n        public EntryPageViewModel()\n        {\n            Title =  Task List ;\n        }\n\n        Command loginCmd;\n        public Command LoginCommand =  loginCmd ?? (loginCmd = new Command(async () =  await ExecuteLoginCommand()));\n\n        async Task ExecuteLoginCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($ [Login] Error = {ex.Message} );\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}  This is a fairly simple view-model but there are some patterns here that are\nworth explaining.  Firstly, note the way we create the  LoginCommand  property.\nThis is the property that is bound to the  Command  parameter in the  Button \nof our view.  This recipe is the method of invoking a UI action asynchronously.\nIt isn't important now, but we will want this technique repeatedly as our UI\nactions kick off network activity.  The second is the pattern for the  ExecuteLoginCommand  method.  Firstly, I\nensure nothing else is happening by checking the IsBusy flag.   If nothing\nis happening, I set the IsBusy flag.  Then I do what I need to do in a try/catch\nblock.  If an exception is thrown, I deal with it.  Most of the time this\ninvolves displaying an error condition.  There are several cross-platform dialog\npackages to choose from or you can roll your own.  That is not covered here.  We\njust write a debug log statement so we can see the result in the debug log.  Once\neverything is done, we clear the IsBusy flag.  The only thing we are doing now is swapping out our main page for a new main\npage.  This is where we will attach authentication later on.  The next page is the Task List page, which is in  Pages\\TaskList.xaml :  ?xml version= 1.0  encoding= utf-8  ?  ContentPage xmlns= http://xamarin.com/schemas/2014/forms \n             xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n             x:Class= TaskList.Pages.TaskList \n             Title= {Binding Title} \n   ContentPage.Content \n     StackLayout \n       ListView BackgroundColor= #7F7F7F \n                CachingStrategy= RecycleElement \n                IsPullToRefreshEnabled= True \n                IsRefreshing= {Binding IsBusy, Mode=OneWay} \n                ItemsSource= {Binding Items} \n                RefreshCommand= {Binding RefreshCommand} \n                RowHeight= 50 \n                SelectedItem= {Binding SelectedItem, Mode=TwoWay} \n         ListView.ItemTemplate \n           DataTemplate \n             ViewCell \n               StackLayout HorizontalOptions= FillAndExpand \n                           Orientation= Horizontal \n                           Padding= 10 \n                           VerticalOptions= CenterAndExpand \n                 Label HorizontalOptions= FillAndExpand \n                       Text= {Binding Text} \n                       TextColor= #272832  / \n                 Switch IsToggled= {Binding Complete, Mode=OneWay}  / \n               /StackLayout \n             /ViewCell \n           /DataTemplate \n         /ListView.ItemTemplate \n       /ListView \n       StackLayout HorizontalOptions= Center \n                   Orientation= Horizontal \n         Button BackgroundColor= Teal \n                Command= {Binding AddNewItemCommand} \n                Text= Add New Item \n                TextColor= White  / \n       /StackLayout \n     /StackLayout \n   /ContentPage.Content  /ContentPage   Note that some bindings here are one-way.  This means that the value in the\nview-model drives the value in the UI.  There is nothing within the UI that you\ncan do to alter the state of the underlying property.  Some bindings are two-way.\nDoing something in the UI (for example, toggling the switch) alters the underlying\nproperty.  This view is a little more complex.  It can be split into two parts - the list\nat the top of the page and the button area at the bottom of the page.  The list\narea uses a template to help with the display of each item.  Note that the  ListView  object has a \"pull-to-refresh\" option that I have wired\nup so that when pulled, it calls the RefreshCommand.  It also has an indicator\nthat I have wired up to the IsBusy indicator.  Anyone who is familiar with the\niOS \"pull-to-refresh\" gesture can probably guess what this does.  There is a view-model that goes along with the view (in  ViewModels\\TaskListViewModel.cs ):  using System;\nusing System.Collections.ObjectModel;\nusing System.Collections.Specialized;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskListViewModel : BaseViewModel\n    {\n        public TaskListViewModel()\n        {\n            Title =  Task List ;\n            RefreshList();\n        }\n\n        ObservableCollection TodoItem  items = new ObservableCollection TodoItem ();\n        public ObservableCollection TodoItem  Items\n        {\n            get { return items; }\n            set { SetProperty(ref items, value,  Items ); }\n        }\n\n        TodoItem selectedItem;\n        public TodoItem SelectedItem\n        {\n            get { return selectedItem; }\n            set\n            {\n                SetProperty(ref selectedItem, value,  SelectedItem );\n                if (selectedItem != null)\n                {\n                    Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail(selectedItem));\n                    SelectedItem = null;\n                }\n            }\n        }\n\n        Command refreshCmd;\n        public Command RefreshCommand =  refreshCmd ?? (refreshCmd = new Command(async () =  await ExecuteRefreshCommand()));\n\n        async Task ExecuteRefreshCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                var table = App.CloudService.GetTable TodoItem ();\n                var list = await table.ReadAllItemsAsync();\n                Items.Clear();\n                foreach (var item in list)\n                    Items.Add(item);\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($ [TaskList] Error loading items: {ex.Message} );\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command addNewCmd;\n        public Command AddNewItemCommand =  addNewCmd ?? (addNewCmd = new Command(async () =  await ExecuteAddNewItemCommand()));\n\n        async Task ExecuteAddNewItemCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                await Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($ [TaskList] Error in AddNewItem: {ex.Message} );\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        async Task RefreshList()\n        {\n            await ExecuteRefreshCommand();\n            MessagingCenter.Subscribe TaskDetailViewModel (this,  ItemsChanged , async (sender) = \n            {\n                await ExecuteRefreshCommand();\n            });\n        }\n    }\n}  This is a combination of the patterns we have seen earlier.  The Add New Item\nand Refresh commands should be fairly normal patterns now.  We navigate to the\ndetail page (more on that later) in the case of selecting an item (which occurs\nwhen the UI sets the  SelectedItem  property through a two-way binding) and when\nthe user clicks on the Add New Item button.  When the Refresh button is clicked\n(or when the user opens the view for the first time), the list is refreshed.  It\nis fairly common to use an  ObservableCollection  or another class that uses the ICollectionChanged  event handler for the list storage.  Doing so allows the UI\nto react to changes in the items.  Note the use of the  ICloudTable  interface here.  We are using the  ReadAllItemsAsync() \nmethod to get a list of items, then we copy the items we received into the  ObservableCollection .  Finally, there is the TaskDetail page.  This is defined in the  Pages\\TaskDetail.xaml \nfile:  ?xml version= 1.0  encoding= utf-8  ?  ContentPage xmlns= http://xamarin.com/schemas/2014/forms \n             xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n             x:Class= TaskList.Pages.TaskDetail \n             Title= {Binding Title} \n   ContentPage.Content \n     StackLayout Padding= 10  Spacing= 10 \n       Label Text= What should I be doing? / \n       Entry Text= {Binding Item.Text} / \n       Label Text= Completed? / \n       Switch IsToggled= {Binding Item.Complete} / \n       StackLayout VerticalOptions= CenterAndExpand / \n       StackLayout Orientation= Vertical  VerticalOptions= End \n         StackLayout HorizontalOptions= Center  Orientation= Horizontal \n           Button BackgroundColor= #A6E55E \n                  Command= {Binding SaveCommand} \n                  Text= Save  TextColor= White / \n           Button BackgroundColor= Red \n                  Command= {Binding DeleteCommand} \n                  Text= Delete  TextColor= White / \n         /StackLayout \n       /StackLayout \n     /StackLayout \n   /ContentPage.Content  /ContentPage   This page is a simple form with just two buttons that need to have commands\nwired up.  However, this page is used for both the \"Add New Item\" gesture\nand the \"Edit Item\" gesture.  As a result of this, we need to handle the\npassing of the item to be edited.  This is done in the  Pages\\TaskDetail.xaml.cs \ncode-behind file:  using TaskList.Models;\nusing TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class TaskDetail : ContentPage\n    {\n        public TaskDetail(TodoItem item = null)\n        {\n            InitializeComponent();\n            BindingContext = new TaskDetailViewModel(item);\n        }\n    }\n}  The item that is passed in from the  TaskList  page is used to create a\nspecific view-model for that item.  The view-model is similarly configured\nto use that item:  using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskDetailViewModel : BaseViewModel\n    {\n        ICloudTable TodoItem  table = App.CloudService.GetTable TodoItem ();\n\n        public TaskDetailViewModel(TodoItem item = null)\n        {\n            if (item != null)\n            {\n                Item = item;\n                Title = item.Text;\n            }\n            else\n            {\n                Item = new TodoItem { Text =  New Item , Complete = false };\n                Title =  New Item ;\n            }\n        }\n\n        public TodoItem Item { get; set; }\n\n        Command cmdSave;\n        public Command SaveCommand =  cmdSave ?? (cmdSave = new Command(async () =  await ExecuteSaveCommand()));\n\n        async Task ExecuteSaveCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id == null)\n                {\n                    await table.CreateItemAsync(Item);\n                }\n                else\n                {\n                    await table.UpdateItemAsync(Item);\n                }\n                MessagingCenter.Send TaskDetailViewModel (this,  ItemsChanged );\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($ [TaskDetail] Save error: {ex.Message} );\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command cmdDelete;\n        public Command DeleteCommand =  cmdDelete ?? (cmdDelete = new Command(async () =  await ExecuteDeleteCommand()));\n\n        async Task ExecuteDeleteCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id != null)\n                {\n                    await table.DeleteItemAsync(Item);\n                }\n                MessagingCenter.Send TaskDetailViewModel (this,  ItemsChanged );\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($ [TaskDetail] Save error: {ex.Message} );\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}  The save command uses the  ICloudTable  interface again - this time doing\neither  CreateItemAsync()  or  UpdateItemAsync()  to create or update the\nitem.  The delete command, as you would expect, deletes the item with the DeleteItemAsync()  method.  The final thing to note from our views is that I am using the  MessagingCenter \nto communicate between the TaskDetail and TaskList views.  If I change the item\nin the  TaskDetail  list, then I want to update the list in the  TaskList  view.  Note that all the code we have added to the solution thus far is in the common TaskList  project.  Nothing is required for this simple example in a platform\nspecific project.  That isn't normal, as we shall see.", 
            "title": "Building the UI for the App"
        }, 
        {
            "location": "/1_introduction/#building-the-client-for-universal-windows", 
            "text": "I tend to start by building the Universal Windows mobile client.  I'm using\nVisual Studio, after all, and I don't need to use any emulator.  To build the\nclients:   Right-click on the  TaskList.UWP (Universal Windows)  project, then select  Set as StartUp Project .  Right-click on the  TaskList.UWP (Universal Windows)  project again, then select  Build .  Once the build is complete, Right-click on the  TaskList.UWP (Universal Windows)  project again, then select  Deploy .  Click on the  Local Machine  button in your command bar to run the application.   Here are the three screen screens we generated on Windows:   There are some problems with the UWP version.  Most notably, the \"pull-to-refresh\"\ngesture does not exist, so we will need to set up an alternate gesture.  This\ncould be as easy as adding a refresh button right next to the Add New Item\nbutton.  In addition, there is no indication of network activity - this manifests\nas a significant delay between the TaskList page appearing and the data appearing\nin the list.  Aside from this, I did do some styling work to ensure that the final version\nlooked like my mock-ups (with the exception of the UI form of the switch, which\nis platform dependent).  If you want to see what I did to correct this, check out\nthe final version of  the Chapter 1 sample  on GitHub.  If you need to build the project, ensure you redeploy the project after building.\nIt's a step that is easy to miss and can cause some consternation as you change\nthe code and it doesn't seem to have an effect on the application.", 
            "title": "Building the Client for Universal Windows"
        }, 
        {
            "location": "/1_introduction/#building-the-client-for-android", 
            "text": "Building Android with Visual Studio is as easy as building the Universal Windows\nversion of the mobile client:   Right-click on the  TaskList.Droid  project, then select  Set as StartUp Project .  Right-click on the  TaskList.Droid  project again, then select  Build .   The button for running the application has a drop-down that is now significant.\nIt lets you choose the type of device that you will use.  Normally, this runs\neither a 5\" or 7\" KitKat-based Android device.  There is some setup required for\nthe Visual Studio Emulator for Android.  The Visual Studio Emulator for Android\nruns within Hyper-V, so you must install Hyper-V before use.  You get the following\nerror if you don't do this:   To install Hyper-V:   Close all applications (your system will be rebooted during this process).  Search for  Programs and Features .  Click on  Turn Windows features on or off  (in the left-hand menu).  Expand the  Hyper-V  node.  Check all the boxes below the  Hyper-V  node.  This will include Hyper-V Management Tools and Hyper-V Services.  Click on  OK .  Your system will install the required pieces and then ask you to restart.  Click on  Restart now  when prompted.   Once you have done this, the next hurdle is to be added to the Hyper-V Administrators\nsecurity group.  It gets done for you (again - the first time you try to run the\napplication after installing Hyper-V).  Once it is done, close Visual Studio (again),\nthe log out and back in again.  As if that wasn't enough, the emulator also needs an Internet connection to\nstart.   You should be able to just click on  Yes  or  OK  to enable the Internet\nconnection.  My laptop required a reboot before this would work, however.  In\naddition, the process may request elevated privileges.   If you want to run additional Android profiles before starting, run the  Visual Studio Emulator for Android  and download any additional profiles.  For example, if you wish to emulate something similar to a Samsung Galaxy S6, then download the profile for a 5.1\" Marshmallow (6.0.0) XXHDPI Phone.   Finally the Visual Studio Emulator for Android starts when you click on the Run\nbutton.  Fortunately, the setup of the emulator only has to be done once per\nmachine.  The Visual Studio Emulator for Android is also a superior emulator\nto the standard Android Emulator, so this process is well worth going through.   When testing the mobile client manually through the Visual Studio Emulator for Android, you are likely to need to rebuild the application.  You do not have to shut down the emulator between runs.  You can leave it running.  The application will be stopped and replaced before starting again.  This can significantly speed up the debug cycle since you are not waiting for the emulator to start each time.   Watch the Output window.  If the debugger won't connect or the application\nwon't start, you may need to restart your computer again to get the network\nworking.   If your computer doesn't run Hyper-V well (or at all), then the emulator won't run well (or at all) either.  I find laptops to be particularly prone to this problem.  If this happens, you can always run the Google Emulator instead.  Build the application as normal.  You will find the APK file to install in  ...\\TaskList.Droid\\bin\\Debug . Fortunately, there are lots of resources that show how to do this.  You can find the answer on  Stack Overflow   If everything is working, you should see the Visual Studio Emulator for Android\ndisplay your mobile client:    You can also build the Android version on a mac with Xamarin Studio.  However, I find that version mismatches between Mono (which is used on the mac) and Visual Studio - particularly in reference to the version of the .NET framework - cause issues when swapping between the two environments.  For best results, stay in one environment.   Note that the task list view is a \"light\" style and the rest of the app is a\n\"dark\" style.  This is because the default styling on an Android device is\ndark.  We are using the default styling on two of the pages and specifying\ncolors on the list page.  Fortunately, Xamarin Forms allows for  platform-specific\nstyling .  The  final sample  has platform-specific styling for the\nlist page.", 
            "title": "Building the Client for Android"
        }, 
        {
            "location": "/1_introduction/#building-the-client-for-ios", 
            "text": "Finally, we get to the iOS platform.  You will need to ensure your Mac is turned\non and accessible, that it has XCode installed (and you have run XCode once so\nthat you can accept the license agreement), and it has Xamarin Studio installed.  When you created the projects, you were asked to link Visual Studio to your mac.\nThis linkage is used for building the project.  In essence, the entire project\nis sent to the Mac and the build tools that are supplied with Xamarin Studio\nwill be used to build the project.   Right-click on the  TaskList.iOS  project and select  Set as StartUp Project .  Right-click on the  TaskList.iOS  project and select  Build .   You knew it was not going to be that easy, right?  Here are the errors that I\nreceived when building for the first time:   There are two errors right at the top.  Let's cover the first one.  The error\nabout  Build Action 'EmbeddedResource' is not supported  is an annoying one.\nThe fix is to do the following:   Set the iOS project as the StartUp project.  Go through each project, expand the  References  node and ensure that there are no references with a warning (a little yellow triangle).  If there are - fix those first.  Generally, this is fixed by either using the  Restore NuGet Packages  option or removing the reference and then adding it again from NuGet.  Close the solution.  Re-open the solution.  You don't need to close Visual Studio to do this.  Right-click on the iOS project and select  Clean .  Right-click on the iOS project and select  Rebuild .   Once you have done this sequence, the error should go away.  The error about  No valid iOS code signing keys found in keychain  is because\nwe have not yet signed up for an Apple Developer Account and linked it to our\nMac development environment.   Go to the  Apple Developer Center .  Click on  Account  in the top navigation bar.  If you haven't got an Apple ID yet, create one first.  If you have go an Apple ID, then log in.   There are a sequence of sign-up prompts in both cases (first for creating your\nApple ID and secondly for signing up for the Apple Developer program).  Once\nyou have gone through this process, you are registered as an Apple Developer.   If you want to distribute your apps on the Apple App Store, run on real devices or get access to the beta bits, then you might consider signing up for the Apple Developer Program.  The Apple Developer Program is an additional cost and is not required for developing iOS apps that are only run on the iOS simulator.   Once you have created your account and enabled it as a developer account, open\nup XCode.  Go to  Preferences... , then  Account  and\nclick on the  +  in the bottom-left corner of the window:   Sign in with the same account you used to sign up for the developer account.   Click on the  View Details  button.  This will bring up the Signing Identities\nlist.  For a free account, it looks like this:   Click on the Create button next to  iOS Development .  Once the UI comes back,\nclick on  Done .  For more information on this process, refer to the  Apple Documentation .  You can close XCode at this point.  Ensure Xamarin Studio is not running.  Back\nwithin Visual Studio, right-click on the  TaskList.iOS  project and select  Rebuild .\nThis will (finally!) build the application for you.   Getting an error about  Provisioning Profiles  not being available?  This is because you are building for a real device instead of the simulator.  In order to build for a real device, you must have a linked Apple Developer Program.  To get around this, select a Simulator before building.   The  Run  button has received a  Device  label, but there are several simulator options.\nYou should only use  Device  if you have signed up for the Apple Developer Program.  Pick\none of the simulator options like the  iPhone 6 iOS 9.3  simulator, then click on it\nto run the simulator.  Before long, you should see the following:   At some point, you will need a platform initialization call on all platforms.  It's best to\nadd it now.  In TaskList.Droid, this should be added in  MainActivity.cs  and in TaskList.iOS,\nit's  AppDelegate.cs .  In each of these files, there is a line that initializes the Xamarin\nForms system.  // Android Version\nglobal::Xamarin.Forms.Forms.Init(this, bundle);\n// iOS Version\nglobal::Xamarin.Forms.Forms.Init ();  Immediately before this line, you should add the  initializer for Azure Mobile Apps. It's\nimportant that the Azure Mobile Apps subsystem is initialized prior to Xamarin Forms being\ninitialized and any UI code being called.  Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();  This initializer is not required on the UWP project.  Once this is done and you have re-built\nthe project, we can see the fruits of our labor.  You can, of course, run the IPA in the\niOS simulator on the Mac.  However, it's much more satisfying (to me, at least) to be able\nto do everything from within Visual Studio.  For this, you need to install the Xamarin Installer .  This is an MSI for your Windows development system and is\nquickly installed.  Once installed, start (or restart) Visual Studio, select  Tools  -  Options .  Search for  Xamarin , and select the  iOS Settings  page.  There is\na new option:   Note the  Remote Simulator to Windows .  This should be checked.  You may need to\nrebuild the TaskList.iOS project after installing the Xamarin Simulator.  The debug\nwindow will tell you if this is the case.  There are also a few  known issues \nso check the documentation if you run into problems.  The final product screens look like this:", 
            "title": "Building the Client for iOS"
        }, 
        {
            "location": "/1_introduction/#some-final-thoughts", 
            "text": "If you have got through the entire process outlined in this Chapter and built the application\nfor each platform, then congratulations.  There are a lot of places where things can go\nwrong.  You are really integrating the build systems across Visual Studio, Android, Xamarin,\nand XCode.  Fortunately, once these are set up, it's likely that they will continue working and you\nwon't have to think too much about them again. The Android and iOS build tools and simulators\nwill just work.  The next 7 chapters each take one aspect of the cloud services that can be provided to\nmobile apps and explores it in detail, using an Azure Mobile App as a beginning. You can\njump around at this point, but be aware that we expect you to cover these topics in order.\nIf you do the data chapter before covering authentication, it's likely you will have missed\nimportant functionality in your app to complete the work.", 
            "title": "Some Final Thoughts"
        }, 
        {
            "location": "/2_authentication/", 
            "text": "Authentication\n\n\nOne of the very first things you will want to do is to provide users with a\nunique experience.  For our example task list application, this could be as\nsimple as providing a task list for the user who is logged in.  In more complex\napplications, this is the gateway to role-based access controls, group rules,\nand sharing with your friends.  In all these cases, properly identifying the\nuser using the phone is the starting point.\n\n\nAuthentication Concepts\n\n\nAuthentication provides a process by which the user that is using the mobile\ndevice can be identified securely.  This is generally done by entering a username\nand password.  However, modern systems can also provide \nmulti-factor authentication\n,\nsend you a text message to a registered device, or \nuse your fingerprint\n as the password.\n\n\nThe OAuth Process\n\n\nIn just about every single mobile application, a process called \nOAuth\n is used\nto properly identify a user to the mobile backend.  OAuth is not an authentication\nmechanism in its own right.  It is used to route the authentication request to the\nright place and to verify that the authentication took place. There are three actors\nin the OAuth protocol:\n\n\n\n\nThe \nClient\n is the application attempting to get access to the resource.\n\n\nThe \nResource\n is the mobile backend that the client is attempting to access.\n\n\nThe \nIdentity Provider\n (or IdP) is the service that is responsible for authenticating the client.\n\n\n\n\nAt the end of the process, a cryptographically signed token is minted.  This\ntoken is added to every single subsequent request to identify the user.\n\n\nServer Side vs. Client Side Authentication\n\n\nThere are two types of authentication flow: Server-Flow and Client-Flow.  They\nare so named because of who controls the flow of the actual authentication.  In\na server-flow authentication, the client asks Azure Mobile Apps to login.  Azure\nMobile Apps then redirects to the configured Identity Provider.  That IdP will\nthen authenticate the user before redirecting back to Azure Mobile Apps.  At\nthis point, Azure Mobile Apps will mint a ZUMO token that shows the user is\nauthenticated and return that token to the client application.  \n\n\n\n\nServer-flow is named because the authentication flow is managed by the server\nthrough a web connection.  It is generally used in two cases:\n\n\n\n\nYou want a simple placeholder for authentication in your mobile app while you are developing other code.\n\n\nYou are developing a web app.\n\n\n\n\nClient-flow authentication uses an IdP provided SDK to integrate a more native\nfeel to the authentication flow.  The actual flow happens on the client,\ncommunicating only with the IdP.  For example, if you use the Facebook SDK for\nauthentication, your app will seamlessly switch over into the Facebook app and\nask you to authorize your client application before switching you back to your\nclient application.  The IdP SDK will return a token to your code.  Your client\napplication will then contact the mobile backend to swap the IdP token for a\nZUMO token.  You will then use the ZUMO token to communicate with the mobile\nbackend.\n\n\nIt is generally recommended that you use the IdP SDK when developing an app\nthat will be released on the app store.  This follows the best practice provided\nby the majority of identity providers and provides the best experience for your\nend users.\n\n\nAuthentication Providers\n\n\nAzure Mobile Apps supports five identity providers natively:\n\n\n\n\nAzure Active Directory\n\n\nFacebook\n\n\nGoogle\n\n\nMicrosoft (MSA)\n\n\nTwitter\n\n\n\n\nIn addition, you can set up client-flow custom authentication that allows\nyou to mint a ZUMO token to your specifications for any provider using a\nclient-flow.  For example, you could use authentication providers like\n\nAzure AD B2C\n, \nLinkedIn\n or \nGitHub\n, a third-party authentication\nprovider like  \nAuth0\n, or you could set up an identity table in your\ndatabase so that you can check  username and password without an identity\nprovider.\n\n\nAdding Authentication to a Mobile Backend\n\n\nAdding authentication to an Azure Mobile Apps backend is made easier because\nAzure Mobile Apps adds authentication using the default ASP.NET identity\nframework.  However, you must add the authentication initialization code to\nyour \nStartup.MobileApp.cs\n file:\n\n\npublic static void ConfigureMobileApp(IAppBuilder app)\n{\n    HttpConfiguration config = new HttpConfiguration();\n\n    new MobileAppConfiguration()\n        .AddTablesWithEntityFramework()\n        .ApplyTo(config);\n\n    // Use Entity Framework Code First to create database tables based on your DbContext\n    Database.SetInitializer(new MobileServiceInitializer());\n\n    MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();\n\n    if (string.IsNullOrEmpty(settings.HostName))\n    {\n        app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions\n        {\n            // This middleware is intended to be used locally for debugging. By default, HostName will\n            // only have a value when running in an App Service application.\n            SigningKey = ConfigurationManager.AppSettings[\nSigningKey\n],\n            ValidAudiences = new[] { ConfigurationManager.AppSettings[\nValidAudience\n] },\n            ValidIssuers = new[] { ConfigurationManager.AppSettings[\nValidIssuer\n] },\n            TokenHandler = config.GetAppServiceTokenHandler()\n        });\n    }\n\n    app.UseWebApi(config);\n}\n\n\n\n\nAuthentication is done at one of two levels.  We can add\nauthentication to an entire table controller by adding the \n[Authorize]\n\nattribute to the table controller.  We can also add authentication on\nindividual operations by adding the \n[Authorize]\n attribute to individual\nmethods within the table controller. For example, here is our table controller\nfrom the first chapter with authentication required for all operations:\n\n\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    [Authorize]\n    public class TodoItemController : TableController\nTodoItem\n\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager\nTodoItem\n(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable\nTodoItem\n GetAllTodoItems() =\n Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult\nTodoItem\n GetTodoItem(string id) =\n Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task\nTodoItem\n PatchTodoItem(string id, Delta\nTodoItem\n patch) =\n UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task\nIHttpActionResult\n PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\nTables\n, new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) =\n DeleteAsync(id);\n    }\n}\n\n\n\n\nWe could also have a version where reading was possible anonymously but\nupdating the database required authentication:\n\n\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController\nTodoItem\n\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager\nTodoItem\n(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable\nTodoItem\n GetAllTodoItems() =\n Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult\nTodoItem\n GetTodoItem(string id) =\n Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        [Authorize]\n        public Task\nTodoItem\n PatchTodoItem(string id, Delta\nTodoItem\n patch) =\n UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        [Authorize]\n        public async Task\nIHttpActionResult\n PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\nTables\n, new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        [Authorize]\n        public Task DeleteTodoItem(string id) =\n DeleteAsync(id);\n    }\n}\n\n\n\n\nAlthough the attribute is called \n[Authorize]\n, this only does authentication.\n\nIt does not actually perform authorization.  Authorization is about ensuring\nthat only certain authorized users can perform actions.  We'll get onto\nauthorization later on.\n\n\nSocial Authentication\n\n\nAzure App Service provides built-in support for Facebook, Google, Microsoft\nand Twitter.  Irrespective of whether you intend to use server-flow or\nclient-flow, you will need to configure the Azure App Service Authentication\nservice.  In general, the method involves:\n\n\n\n\nObtain a Developer Account for the provider.\n\n\nCreate a new application, obtaining a Client ID and Secret.\n\n\nTurn on Azure App Service Authentication.\n\n\nEnter the Client ID and Secret into the specific provider setup.\n\n\nSave the configuration.\n\n\n\n\nBefore you start any of this, create a new Azure Mobile Apps as we described\nin \nChapter 1\n.  If you want a site to deploy for the configuration, the\n\nBackend\n project in the [Chapter2][10] solution is pre-configured for authorization.\nYou just need to deploy it to Azure App Service.\n\n\nFacebook Authentication\n\n\nI'm going to assume you have a Facebook account already.  If you don't, go to\n\nFacebook\n and sign up.  All your friends are likely there already!  Now\nlog in to the \nFacebook Developers\n web site.  Let's create a new Facebook\napplication:\n\n\n\n\nNote\n: Facebook updates the look and feel of their developer site on a regularb\nbasis.  As a result, the screen shots I've provided here may be different.  If\nin doubt, follow the bullet descriptions to find your way.\n\n\n\n\nIf you are not already registered, click on the drop-down in the top-right\ncorner and \nRegister as a Developer\n before continuing.\n\n\n\n\n\n\nClick on the \nMy Apps\n link in the top right corner of the screen.\n\n\nClick on \nCreate a New App\n.\n\n\nFill in the form:\n\n\n\n\n\n\n\n\n\n\nIf required, verify your account according to the instructions.  This usually\ninvolves adding a credit card number or verifying your mobile phone number.  \n\n\n\n\n\n\nClick on the \nGet Started\n button next to \nFacebook Login\n.\n\n\n\n\n\n\n\n\n\n\nEnter your application URL + \n/.auth/login/facebook/callback\n in the \nValid\nOAuth redirect URIs\n.\n\n\n\n\n\n\n\n\nNote that you may not be able to use SSL if you are using the certain plans such\nas the F1 Free App  Service Plan.  Some identity providers only allow SSL redirects.\n\nYou can upgrade the App Service Plan to a B1 Basic in this case.\n\n\n\n\n\n\nClick on \nSave Changes\n.\n\n\nClick on the \nSettings\n -\n \nBasic\n in the left hand side-bar.\n\n\nClick on the \nShow\n button next to the App Secret\n\n\n\n\nNow that you have the \nApp ID\n and \nApp Secret\n, you can continue configuration\nof your app within the \nAzure Portal\n.\n\n\n\n\nOpen up your App Service by clicking on \nAll Resources\n or \nApp Services\n\nfollowed by the name of your app service.\n\n\nIn the \nSettings\n blade, click on \nAuthentication / Authorization\n which\nis under \nFeatures\n.\n\n\nTurn \nApp Service Authentication\n to \nOn\n.\n\n\nIn the \nAction to take when request is not authenticated\n, select \nAllow Request (no action)\n.\n\n\n\n\n\n\nIt's very tempting to choose \nLog in with Facebook\n.  However, you need to avoid this.  Selecting this option will mean that all requests need to be authenticated and you won't get the information on the back end.  Selecting \nAllow Request\n means your app is in charge of what gets authenticated and what does not require authentication.\n\n\n\n\n\n\nClick on \nFacebook\n (which should show \nNot Configured\n).\n\n\nCut and Paste the \nApp ID\n and \nApp Secret\n into the boxes provided.\n\n\nSelect \npublic_profile\n and \nemail\n for Scopes.\n\n\n\n\n\n\nNote that if you request anything but public_profile, user_friends, and email, your app will need further review by Facebook, which will take time.  This process is not worth it for test apps like this one.\n\n\n\n\n\n\nClick on \nOK\n (at the bottom of the blade) to close the Facebook configuration blade.\n\n\nClick on \nSave\n (at the top of the blade) to save your Authentication changes.\n\n\n\n\nYou can test your authentication process by browsing to https://\nyoursite\n.azurewebsites.net/.auth/login/facebook;\nthis is the same endpoint that the Azure Mobile Apps Client SDK calls when it is time\nto integrate authentication into the mobile client.\n\n\n\n\nIf you are not logged in to facebook already, you will be prompted for your\nfacebook credentials first.  Finally, here is your happy page - the page that\nsignifies you have done everything right:\n\n\n\n\nGoogle Authentication\n\n\nEnterprise Authentication\n\n\nWhat is in a JWT\n\n\nImplementing Authentication to a Mobile Client\n\n\nSocial Authentication\n\n\nEnterprise Authentication\n\n\nCustom Authentication\n\n\nAzure Active Directory B2C\n\n\nUsing Third-Party Tokens\n\n\nUsing an Identity Database.\n\n\nAuthorization\n\n\nRefresh Tokens\n\n\nConfiguring Refresh Tokens\n\n\nUsing Refresh Tokens\n\n\nLogging out\n\n\nBest Practices", 
            "title": "2. Authentication"
        }, 
        {
            "location": "/2_authentication/#authentication", 
            "text": "One of the very first things you will want to do is to provide users with a\nunique experience.  For our example task list application, this could be as\nsimple as providing a task list for the user who is logged in.  In more complex\napplications, this is the gateway to role-based access controls, group rules,\nand sharing with your friends.  In all these cases, properly identifying the\nuser using the phone is the starting point.", 
            "title": "Authentication"
        }, 
        {
            "location": "/2_authentication/#authentication-concepts", 
            "text": "Authentication provides a process by which the user that is using the mobile\ndevice can be identified securely.  This is generally done by entering a username\nand password.  However, modern systems can also provide  multi-factor authentication ,\nsend you a text message to a registered device, or  use your fingerprint  as the password.", 
            "title": "Authentication Concepts"
        }, 
        {
            "location": "/2_authentication/#the-oauth-process", 
            "text": "In just about every single mobile application, a process called  OAuth  is used\nto properly identify a user to the mobile backend.  OAuth is not an authentication\nmechanism in its own right.  It is used to route the authentication request to the\nright place and to verify that the authentication took place. There are three actors\nin the OAuth protocol:   The  Client  is the application attempting to get access to the resource.  The  Resource  is the mobile backend that the client is attempting to access.  The  Identity Provider  (or IdP) is the service that is responsible for authenticating the client.   At the end of the process, a cryptographically signed token is minted.  This\ntoken is added to every single subsequent request to identify the user.", 
            "title": "The OAuth Process"
        }, 
        {
            "location": "/2_authentication/#server-side-vs-client-side-authentication", 
            "text": "There are two types of authentication flow: Server-Flow and Client-Flow.  They\nare so named because of who controls the flow of the actual authentication.  In\na server-flow authentication, the client asks Azure Mobile Apps to login.  Azure\nMobile Apps then redirects to the configured Identity Provider.  That IdP will\nthen authenticate the user before redirecting back to Azure Mobile Apps.  At\nthis point, Azure Mobile Apps will mint a ZUMO token that shows the user is\nauthenticated and return that token to the client application.     Server-flow is named because the authentication flow is managed by the server\nthrough a web connection.  It is generally used in two cases:   You want a simple placeholder for authentication in your mobile app while you are developing other code.  You are developing a web app.   Client-flow authentication uses an IdP provided SDK to integrate a more native\nfeel to the authentication flow.  The actual flow happens on the client,\ncommunicating only with the IdP.  For example, if you use the Facebook SDK for\nauthentication, your app will seamlessly switch over into the Facebook app and\nask you to authorize your client application before switching you back to your\nclient application.  The IdP SDK will return a token to your code.  Your client\napplication will then contact the mobile backend to swap the IdP token for a\nZUMO token.  You will then use the ZUMO token to communicate with the mobile\nbackend.  It is generally recommended that you use the IdP SDK when developing an app\nthat will be released on the app store.  This follows the best practice provided\nby the majority of identity providers and provides the best experience for your\nend users.", 
            "title": "Server Side vs. Client Side Authentication"
        }, 
        {
            "location": "/2_authentication/#authentication-providers", 
            "text": "Azure Mobile Apps supports five identity providers natively:   Azure Active Directory  Facebook  Google  Microsoft (MSA)  Twitter   In addition, you can set up client-flow custom authentication that allows\nyou to mint a ZUMO token to your specifications for any provider using a\nclient-flow.  For example, you could use authentication providers like Azure AD B2C ,  LinkedIn  or  GitHub , a third-party authentication\nprovider like   Auth0 , or you could set up an identity table in your\ndatabase so that you can check  username and password without an identity\nprovider.", 
            "title": "Authentication Providers"
        }, 
        {
            "location": "/2_authentication/#adding-authentication-to-a-mobile-backend", 
            "text": "Adding authentication to an Azure Mobile Apps backend is made easier because\nAzure Mobile Apps adds authentication using the default ASP.NET identity\nframework.  However, you must add the authentication initialization code to\nyour  Startup.MobileApp.cs  file:  public static void ConfigureMobileApp(IAppBuilder app)\n{\n    HttpConfiguration config = new HttpConfiguration();\n\n    new MobileAppConfiguration()\n        .AddTablesWithEntityFramework()\n        .ApplyTo(config);\n\n    // Use Entity Framework Code First to create database tables based on your DbContext\n    Database.SetInitializer(new MobileServiceInitializer());\n\n    MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();\n\n    if (string.IsNullOrEmpty(settings.HostName))\n    {\n        app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions\n        {\n            // This middleware is intended to be used locally for debugging. By default, HostName will\n            // only have a value when running in an App Service application.\n            SigningKey = ConfigurationManager.AppSettings[ SigningKey ],\n            ValidAudiences = new[] { ConfigurationManager.AppSettings[ ValidAudience ] },\n            ValidIssuers = new[] { ConfigurationManager.AppSettings[ ValidIssuer ] },\n            TokenHandler = config.GetAppServiceTokenHandler()\n        });\n    }\n\n    app.UseWebApi(config);\n}  Authentication is done at one of two levels.  We can add\nauthentication to an entire table controller by adding the  [Authorize] \nattribute to the table controller.  We can also add authentication on\nindividual operations by adding the  [Authorize]  attribute to individual\nmethods within the table controller. For example, here is our table controller\nfrom the first chapter with authentication required for all operations:  using System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    [Authorize]\n    public class TodoItemController : TableController TodoItem \n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager TodoItem (context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable TodoItem  GetAllTodoItems() =  Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult TodoItem  GetTodoItem(string id) =  Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task TodoItem  PatchTodoItem(string id, Delta TodoItem  patch) =  UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task IHttpActionResult  PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute( Tables , new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) =  DeleteAsync(id);\n    }\n}  We could also have a version where reading was possible anonymously but\nupdating the database required authentication:  using System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController TodoItem \n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager TodoItem (context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable TodoItem  GetAllTodoItems() =  Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult TodoItem  GetTodoItem(string id) =  Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        [Authorize]\n        public Task TodoItem  PatchTodoItem(string id, Delta TodoItem  patch) =  UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        [Authorize]\n        public async Task IHttpActionResult  PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute( Tables , new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        [Authorize]\n        public Task DeleteTodoItem(string id) =  DeleteAsync(id);\n    }\n}  Although the attribute is called  [Authorize] , this only does authentication. \nIt does not actually perform authorization.  Authorization is about ensuring\nthat only certain authorized users can perform actions.  We'll get onto\nauthorization later on.", 
            "title": "Adding Authentication to a Mobile Backend"
        }, 
        {
            "location": "/2_authentication/#social-authentication", 
            "text": "Azure App Service provides built-in support for Facebook, Google, Microsoft\nand Twitter.  Irrespective of whether you intend to use server-flow or\nclient-flow, you will need to configure the Azure App Service Authentication\nservice.  In general, the method involves:   Obtain a Developer Account for the provider.  Create a new application, obtaining a Client ID and Secret.  Turn on Azure App Service Authentication.  Enter the Client ID and Secret into the specific provider setup.  Save the configuration.   Before you start any of this, create a new Azure Mobile Apps as we described\nin  Chapter 1 .  If you want a site to deploy for the configuration, the Backend  project in the [Chapter2][10] solution is pre-configured for authorization.\nYou just need to deploy it to Azure App Service.", 
            "title": "Social Authentication"
        }, 
        {
            "location": "/2_authentication/#facebook-authentication", 
            "text": "I'm going to assume you have a Facebook account already.  If you don't, go to Facebook  and sign up.  All your friends are likely there already!  Now\nlog in to the  Facebook Developers  web site.  Let's create a new Facebook\napplication:   Note : Facebook updates the look and feel of their developer site on a regularb\nbasis.  As a result, the screen shots I've provided here may be different.  If\nin doubt, follow the bullet descriptions to find your way.   If you are not already registered, click on the drop-down in the top-right\ncorner and  Register as a Developer  before continuing.    Click on the  My Apps  link in the top right corner of the screen.  Click on  Create a New App .  Fill in the form:      If required, verify your account according to the instructions.  This usually\ninvolves adding a credit card number or verifying your mobile phone number.      Click on the  Get Started  button next to  Facebook Login .      Enter your application URL +  /.auth/login/facebook/callback  in the  Valid\nOAuth redirect URIs .     Note that you may not be able to use SSL if you are using the certain plans such\nas the F1 Free App  Service Plan.  Some identity providers only allow SSL redirects. \nYou can upgrade the App Service Plan to a B1 Basic in this case.    Click on  Save Changes .  Click on the  Settings  -   Basic  in the left hand side-bar.  Click on the  Show  button next to the App Secret   Now that you have the  App ID  and  App Secret , you can continue configuration\nof your app within the  Azure Portal .   Open up your App Service by clicking on  All Resources  or  App Services \nfollowed by the name of your app service.  In the  Settings  blade, click on  Authentication / Authorization  which\nis under  Features .  Turn  App Service Authentication  to  On .  In the  Action to take when request is not authenticated , select  Allow Request (no action) .    It's very tempting to choose  Log in with Facebook .  However, you need to avoid this.  Selecting this option will mean that all requests need to be authenticated and you won't get the information on the back end.  Selecting  Allow Request  means your app is in charge of what gets authenticated and what does not require authentication.    Click on  Facebook  (which should show  Not Configured ).  Cut and Paste the  App ID  and  App Secret  into the boxes provided.  Select  public_profile  and  email  for Scopes.    Note that if you request anything but public_profile, user_friends, and email, your app will need further review by Facebook, which will take time.  This process is not worth it for test apps like this one.    Click on  OK  (at the bottom of the blade) to close the Facebook configuration blade.  Click on  Save  (at the top of the blade) to save your Authentication changes.   You can test your authentication process by browsing to https:// yoursite .azurewebsites.net/.auth/login/facebook;\nthis is the same endpoint that the Azure Mobile Apps Client SDK calls when it is time\nto integrate authentication into the mobile client.   If you are not logged in to facebook already, you will be prompted for your\nfacebook credentials first.  Finally, here is your happy page - the page that\nsignifies you have done everything right:", 
            "title": "Facebook Authentication"
        }, 
        {
            "location": "/2_authentication/#google-authentication", 
            "text": "", 
            "title": "Google Authentication"
        }, 
        {
            "location": "/2_authentication/#enterprise-authentication", 
            "text": "", 
            "title": "Enterprise Authentication"
        }, 
        {
            "location": "/2_authentication/#what-is-in-a-jwt", 
            "text": "", 
            "title": "What is in a JWT"
        }, 
        {
            "location": "/2_authentication/#implementing-authentication-to-a-mobile-client", 
            "text": "", 
            "title": "Implementing Authentication to a Mobile Client"
        }, 
        {
            "location": "/2_authentication/#social-authentication_1", 
            "text": "", 
            "title": "Social Authentication"
        }, 
        {
            "location": "/2_authentication/#enterprise-authentication_1", 
            "text": "", 
            "title": "Enterprise Authentication"
        }, 
        {
            "location": "/2_authentication/#custom-authentication", 
            "text": "", 
            "title": "Custom Authentication"
        }, 
        {
            "location": "/2_authentication/#azure-active-directory-b2c", 
            "text": "", 
            "title": "Azure Active Directory B2C"
        }, 
        {
            "location": "/2_authentication/#using-third-party-tokens", 
            "text": "", 
            "title": "Using Third-Party Tokens"
        }, 
        {
            "location": "/2_authentication/#using-an-identity-database", 
            "text": "", 
            "title": "Using an Identity Database."
        }, 
        {
            "location": "/2_authentication/#authorization", 
            "text": "", 
            "title": "Authorization"
        }, 
        {
            "location": "/2_authentication/#refresh-tokens", 
            "text": "", 
            "title": "Refresh Tokens"
        }, 
        {
            "location": "/2_authentication/#configuring-refresh-tokens", 
            "text": "", 
            "title": "Configuring Refresh Tokens"
        }, 
        {
            "location": "/2_authentication/#using-refresh-tokens", 
            "text": "", 
            "title": "Using Refresh Tokens"
        }, 
        {
            "location": "/2_authentication/#logging-out", 
            "text": "", 
            "title": "Logging out"
        }, 
        {
            "location": "/2_authentication/#best-practices", 
            "text": "", 
            "title": "Best Practices"
        }, 
        {
            "location": "/3_data/", 
            "text": "Data Access and Offline Sync\n\n\nData Access Concepts\n\n\nData Access Protocol\n\n\nHow Offline Sync Works\n\n\nTesting Data Access\n\n\nAdding a SQL Table Controller\n\n\nUsing an Existing SQL Table\n\n\nUsing Code Behind\n\n\nWhy use Code Behind?\n\n\nImplementing Code Behind\n\n\nCode Behind Recipes\n\n\nWorking with Data in your Client\n\n\nImplementing an Online Table\n\n\nImplementing an Offline Table\n\n\nUsing a Non-SQL Data Source\n\n\nThe ASP.NET Domain Manager\n\n\nImplementing a DocumentDB Domain Manager\n\n\nImplementing an Azure Table Storage Domain Manager", 
            "title": "3. Data Access and Offline Sync"
        }, 
        {
            "location": "/3_data/#data-access-and-offline-sync", 
            "text": "", 
            "title": "Data Access and Offline Sync"
        }, 
        {
            "location": "/3_data/#data-access-concepts", 
            "text": "", 
            "title": "Data Access Concepts"
        }, 
        {
            "location": "/3_data/#data-access-protocol", 
            "text": "", 
            "title": "Data Access Protocol"
        }, 
        {
            "location": "/3_data/#how-offline-sync-works", 
            "text": "", 
            "title": "How Offline Sync Works"
        }, 
        {
            "location": "/3_data/#testing-data-access", 
            "text": "", 
            "title": "Testing Data Access"
        }, 
        {
            "location": "/3_data/#adding-a-sql-table-controller", 
            "text": "", 
            "title": "Adding a SQL Table Controller"
        }, 
        {
            "location": "/3_data/#using-an-existing-sql-table", 
            "text": "", 
            "title": "Using an Existing SQL Table"
        }, 
        {
            "location": "/3_data/#using-code-behind", 
            "text": "", 
            "title": "Using Code Behind"
        }, 
        {
            "location": "/3_data/#why-use-code-behind", 
            "text": "", 
            "title": "Why use Code Behind?"
        }, 
        {
            "location": "/3_data/#implementing-code-behind", 
            "text": "", 
            "title": "Implementing Code Behind"
        }, 
        {
            "location": "/3_data/#code-behind-recipes", 
            "text": "", 
            "title": "Code Behind Recipes"
        }, 
        {
            "location": "/3_data/#working-with-data-in-your-client", 
            "text": "", 
            "title": "Working with Data in your Client"
        }, 
        {
            "location": "/3_data/#implementing-an-online-table", 
            "text": "", 
            "title": "Implementing an Online Table"
        }, 
        {
            "location": "/3_data/#implementing-an-offline-table", 
            "text": "", 
            "title": "Implementing an Offline Table"
        }, 
        {
            "location": "/3_data/#using-a-non-sql-data-source", 
            "text": "", 
            "title": "Using a Non-SQL Data Source"
        }, 
        {
            "location": "/3_data/#the-aspnet-domain-manager", 
            "text": "", 
            "title": "The ASP.NET Domain Manager"
        }, 
        {
            "location": "/3_data/#implementing-a-documentdb-domain-manager", 
            "text": "", 
            "title": "Implementing a DocumentDB Domain Manager"
        }, 
        {
            "location": "/3_data/#implementing-an-azure-table-storage-domain-manager", 
            "text": "", 
            "title": "Implementing an Azure Table Storage Domain Manager"
        }, 
        {
            "location": "/4_authdata/", 
            "text": "Authenticated Data Access\n\n\nAdjusting the querying\n\n\nPotential things you can do\n- Per User Tables (with ID)\n- Per Email Tables\n- See My Friends Data", 
            "title": "4. Authenticated Data Access"
        }, 
        {
            "location": "/4_authdata/#authenticated-data-access", 
            "text": "Adjusting the querying  Potential things you can do\n- Per User Tables (with ID)\n- Per Email Tables\n- See My Friends Data", 
            "title": "Authenticated Data Access"
        }, 
        {
            "location": "/5_files/", 
            "text": "File Management\n\n\nAzure Storage Concepts\n\n\nBlobs, Table, Queues and files\n\n\nThe SAS Tokens\n\n\nFile Sync with Azure Mobile Apps\n\n\nDealing with Files\n\n\nUploading a File to Blob Storage\n\n\nDownload a File from Blob Storage\n\n\nFile Sync with Azure Mobile Apps\n\n\nConfiguring the Mobile Backend\n\n\nDeveloping the Mobile Client", 
            "title": "5. File Management"
        }, 
        {
            "location": "/5_files/#file-management", 
            "text": "", 
            "title": "File Management"
        }, 
        {
            "location": "/5_files/#azure-storage-concepts", 
            "text": "", 
            "title": "Azure Storage Concepts"
        }, 
        {
            "location": "/5_files/#blobs-table-queues-and-files", 
            "text": "", 
            "title": "Blobs, Table, Queues and files"
        }, 
        {
            "location": "/5_files/#the-sas-tokens", 
            "text": "", 
            "title": "The SAS Tokens"
        }, 
        {
            "location": "/5_files/#file-sync-with-azure-mobile-apps", 
            "text": "", 
            "title": "File Sync with Azure Mobile Apps"
        }, 
        {
            "location": "/5_files/#dealing-with-files", 
            "text": "", 
            "title": "Dealing with Files"
        }, 
        {
            "location": "/5_files/#uploading-a-file-to-blob-storage", 
            "text": "", 
            "title": "Uploading a File to Blob Storage"
        }, 
        {
            "location": "/5_files/#download-a-file-from-blob-storage", 
            "text": "", 
            "title": "Download a File from Blob Storage"
        }, 
        {
            "location": "/5_files/#file-sync-with-azure-mobile-apps_1", 
            "text": "", 
            "title": "File Sync with Azure Mobile Apps"
        }, 
        {
            "location": "/5_files/#configuring-the-mobile-backend", 
            "text": "", 
            "title": "Configuring the Mobile Backend"
        }, 
        {
            "location": "/5_files/#developing-the-mobile-client", 
            "text": "", 
            "title": "Developing the Mobile Client"
        }, 
        {
            "location": "/6_push/", 
            "text": "Push Notifications\n\n\nPush Notification Concepts\n\n\nHow Push Notifications Works\n\n\nWorking with Notification Hubs\n\n\nTesting Push Notifications\n\n\nPush Notifications for Android\n\n\nConfiguring the Notification Hub\n\n\nRegistering for Push Notifications\n\n\nHandling Push Notifications\n\n\nPush Notifications for iOS\n\n\nConfiguring the Notification Hub\n\n\nRegistering for Push Notifications\n\n\nHandling Push Notifications\n\n\nPush Notifications for Universal Windows\n\n\nConfiguring the Notification Hub\n\n\nRegistering for Push Notifications\n\n\nHandling Push Notifications\n\n\nPush Notification Recipes\n\n\nCross-Platform Templates\n\n\nPushing to Tags", 
            "title": "6. Push Notifications"
        }, 
        {
            "location": "/6_push/#push-notifications", 
            "text": "", 
            "title": "Push Notifications"
        }, 
        {
            "location": "/6_push/#push-notification-concepts", 
            "text": "", 
            "title": "Push Notification Concepts"
        }, 
        {
            "location": "/6_push/#how-push-notifications-works", 
            "text": "", 
            "title": "How Push Notifications Works"
        }, 
        {
            "location": "/6_push/#working-with-notification-hubs", 
            "text": "", 
            "title": "Working with Notification Hubs"
        }, 
        {
            "location": "/6_push/#testing-push-notifications", 
            "text": "", 
            "title": "Testing Push Notifications"
        }, 
        {
            "location": "/6_push/#push-notifications-for-android", 
            "text": "", 
            "title": "Push Notifications for Android"
        }, 
        {
            "location": "/6_push/#configuring-the-notification-hub", 
            "text": "", 
            "title": "Configuring the Notification Hub"
        }, 
        {
            "location": "/6_push/#registering-for-push-notifications", 
            "text": "", 
            "title": "Registering for Push Notifications"
        }, 
        {
            "location": "/6_push/#handling-push-notifications", 
            "text": "", 
            "title": "Handling Push Notifications"
        }, 
        {
            "location": "/6_push/#push-notifications-for-ios", 
            "text": "", 
            "title": "Push Notifications for iOS"
        }, 
        {
            "location": "/6_push/#configuring-the-notification-hub_1", 
            "text": "", 
            "title": "Configuring the Notification Hub"
        }, 
        {
            "location": "/6_push/#registering-for-push-notifications_1", 
            "text": "", 
            "title": "Registering for Push Notifications"
        }, 
        {
            "location": "/6_push/#handling-push-notifications_1", 
            "text": "", 
            "title": "Handling Push Notifications"
        }, 
        {
            "location": "/6_push/#push-notifications-for-universal-windows", 
            "text": "", 
            "title": "Push Notifications for Universal Windows"
        }, 
        {
            "location": "/6_push/#configuring-the-notification-hub_2", 
            "text": "", 
            "title": "Configuring the Notification Hub"
        }, 
        {
            "location": "/6_push/#registering-for-push-notifications_2", 
            "text": "", 
            "title": "Registering for Push Notifications"
        }, 
        {
            "location": "/6_push/#handling-push-notifications_2", 
            "text": "", 
            "title": "Handling Push Notifications"
        }, 
        {
            "location": "/6_push/#push-notification-recipes", 
            "text": "", 
            "title": "Push Notification Recipes"
        }, 
        {
            "location": "/6_push/#cross-platform-templates", 
            "text": "", 
            "title": "Cross-Platform Templates"
        }, 
        {
            "location": "/6_push/#pushing-to-tags", 
            "text": "", 
            "title": "Pushing to Tags"
        }, 
        {
            "location": "/7_custom/", 
            "text": "Server Side\n\n\nWorking with Server Side\n\n\nCustom APIs\n\n\nFunctions\n\n\nServer Side Recipes", 
            "title": "7. Server Side Code"
        }, 
        {
            "location": "/7_custom/#server-side", 
            "text": "", 
            "title": "Server Side"
        }, 
        {
            "location": "/7_custom/#working-with-server-side", 
            "text": "", 
            "title": "Working with Server Side"
        }, 
        {
            "location": "/7_custom/#custom-apis", 
            "text": "", 
            "title": "Custom APIs"
        }, 
        {
            "location": "/7_custom/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/7_custom/#server-side-recipes", 
            "text": "", 
            "title": "Server Side Recipes"
        }, 
        {
            "location": "/8_media/", 
            "text": "Using Media Services\n\n\nWhat can Media Services do?\n\n\nUploading Videos from Mobile\n\n\nAutomatically Processing Videos\n\n\nStreaming Videos to Mobile\n\n\nCase Study: Video Learning App", 
            "title": "8. Media Services"
        }, 
        {
            "location": "/8_media/#using-media-services", 
            "text": "", 
            "title": "Using Media Services"
        }, 
        {
            "location": "/8_media/#what-can-media-services-do", 
            "text": "", 
            "title": "What can Media Services do?"
        }, 
        {
            "location": "/8_media/#uploading-videos-from-mobile", 
            "text": "", 
            "title": "Uploading Videos from Mobile"
        }, 
        {
            "location": "/8_media/#automatically-processing-videos", 
            "text": "", 
            "title": "Automatically Processing Videos"
        }, 
        {
            "location": "/8_media/#streaming-videos-to-mobile", 
            "text": "", 
            "title": "Streaming Videos to Mobile"
        }, 
        {
            "location": "/8_media/#case-study-video-learning-app", 
            "text": "", 
            "title": "Case Study: Video Learning App"
        }, 
        {
            "location": "/9_search/", 
            "text": "Integrating Mobile Search\n\n\nDiscovering Search capabilities\n\n\nConfiguring Azure Search\n\n\nUsing Azure Search", 
            "title": "9. Leveraging Search"
        }, 
        {
            "location": "/9_search/#integrating-mobile-search", 
            "text": "", 
            "title": "Integrating Mobile Search"
        }, 
        {
            "location": "/9_search/#discovering-search-capabilities", 
            "text": "", 
            "title": "Discovering Search capabilities"
        }, 
        {
            "location": "/9_search/#configuring-azure-search", 
            "text": "", 
            "title": "Configuring Azure Search"
        }, 
        {
            "location": "/9_search/#using-azure-search", 
            "text": "", 
            "title": "Using Azure Search"
        }, 
        {
            "location": "/10_combined/", 
            "text": "Web and Mobile Apps\n\n\nServer Side Development\n\n\nSharing the Database Between Web and Mobile Apps\n\n\nAuthentication for Web and Mobile Apps\n\n\nClient Side Development\n\n\nAccessing Mobile Data from a Single Page Application\n\n\nAuthentication for Single Page Applications\n\n\nRecipes for Single Page Applications\n\n\nAngular 1.x\n\n\nAngular 2.x\n\n\nEmber 1.x\n\n\nReact", 
            "title": "10. Web and Mobile Apps"
        }, 
        {
            "location": "/10_combined/#web-and-mobile-apps", 
            "text": "", 
            "title": "Web and Mobile Apps"
        }, 
        {
            "location": "/10_combined/#server-side-development", 
            "text": "", 
            "title": "Server Side Development"
        }, 
        {
            "location": "/10_combined/#sharing-the-database-between-web-and-mobile-apps", 
            "text": "", 
            "title": "Sharing the Database Between Web and Mobile Apps"
        }, 
        {
            "location": "/10_combined/#authentication-for-web-and-mobile-apps", 
            "text": "", 
            "title": "Authentication for Web and Mobile Apps"
        }, 
        {
            "location": "/10_combined/#client-side-development", 
            "text": "", 
            "title": "Client Side Development"
        }, 
        {
            "location": "/10_combined/#accessing-mobile-data-from-a-single-page-application", 
            "text": "", 
            "title": "Accessing Mobile Data from a Single Page Application"
        }, 
        {
            "location": "/10_combined/#authentication-for-single-page-applications", 
            "text": "", 
            "title": "Authentication for Single Page Applications"
        }, 
        {
            "location": "/10_combined/#recipes-for-single-page-applications", 
            "text": "", 
            "title": "Recipes for Single Page Applications"
        }, 
        {
            "location": "/10_combined/#angular-1x", 
            "text": "", 
            "title": "Angular 1.x"
        }, 
        {
            "location": "/10_combined/#angular-2x", 
            "text": "", 
            "title": "Angular 2.x"
        }, 
        {
            "location": "/10_combined/#ember-1x", 
            "text": "", 
            "title": "Ember 1.x"
        }, 
        {
            "location": "/10_combined/#react", 
            "text": "", 
            "title": "React"
        }, 
        {
            "location": "/11_developing/", 
            "text": "The Development Environment\n\n\nWorking with Azure mobile Apps Locally\n\n\nHandling Authentication\n\n\nHandling Push Notifications\n\n\nDebugging your Cloud Mobile Backend\n\n\nDiagnostic Logging\n\n\nUsing the Visual Studio Debugger", 
            "title": "11. The Development Environment"
        }, 
        {
            "location": "/11_developing/#the-development-environment", 
            "text": "", 
            "title": "The Development Environment"
        }, 
        {
            "location": "/11_developing/#working-with-azure-mobile-apps-locally", 
            "text": "", 
            "title": "Working with Azure mobile Apps Locally"
        }, 
        {
            "location": "/11_developing/#handling-authentication", 
            "text": "", 
            "title": "Handling Authentication"
        }, 
        {
            "location": "/11_developing/#handling-push-notifications", 
            "text": "", 
            "title": "Handling Push Notifications"
        }, 
        {
            "location": "/11_developing/#debugging-your-cloud-mobile-backend", 
            "text": "", 
            "title": "Debugging your Cloud Mobile Backend"
        }, 
        {
            "location": "/11_developing/#diagnostic-logging", 
            "text": "", 
            "title": "Diagnostic Logging"
        }, 
        {
            "location": "/11_developing/#using-the-visual-studio-debugger", 
            "text": "", 
            "title": "Using the Visual Studio Debugger"
        }, 
        {
            "location": "/12_testing/", 
            "text": "Testing your Mobile Application\n\n\nTesting your Mobile Client\n\n\nIntroduction to Mobile Client Testing\n\n\nIntroduction to Xamarin Test Cloud\n\n\nUsing Mock Data Services\n\n\nUnit Testing\n\n\nTesting your Mobile Backend\n\n\nIntroduction to Mobile Backend Testing\n\n\nUnit Testing\n\n\nLoad Testing\n\n\nEnd to End Testing", 
            "title": "12. Testing your Application"
        }, 
        {
            "location": "/12_testing/#testing-your-mobile-application", 
            "text": "", 
            "title": "Testing your Mobile Application"
        }, 
        {
            "location": "/12_testing/#testing-your-mobile-client", 
            "text": "", 
            "title": "Testing your Mobile Client"
        }, 
        {
            "location": "/12_testing/#introduction-to-mobile-client-testing", 
            "text": "", 
            "title": "Introduction to Mobile Client Testing"
        }, 
        {
            "location": "/12_testing/#introduction-to-xamarin-test-cloud", 
            "text": "", 
            "title": "Introduction to Xamarin Test Cloud"
        }, 
        {
            "location": "/12_testing/#using-mock-data-services", 
            "text": "", 
            "title": "Using Mock Data Services"
        }, 
        {
            "location": "/12_testing/#unit-testing", 
            "text": "", 
            "title": "Unit Testing"
        }, 
        {
            "location": "/12_testing/#testing-your-mobile-backend", 
            "text": "", 
            "title": "Testing your Mobile Backend"
        }, 
        {
            "location": "/12_testing/#introduction-to-mobile-backend-testing", 
            "text": "", 
            "title": "Introduction to Mobile Backend Testing"
        }, 
        {
            "location": "/12_testing/#unit-testing_1", 
            "text": "", 
            "title": "Unit Testing"
        }, 
        {
            "location": "/12_testing/#load-testing", 
            "text": "", 
            "title": "Load Testing"
        }, 
        {
            "location": "/12_testing/#end-to-end-testing", 
            "text": "", 
            "title": "End to End Testing"
        }, 
        {
            "location": "/13_troubleshooting/", 
            "text": "Troubleshooting\n\n\nTroubleshooting the Mobile Backend\n\n\nIntroduction to Azure Application Insights\n\n\nTroubleshooting the Mobile Client\n\n\nIntroduction to HockeyApp\n\n\nIntroduction to Xamarin Insights", 
            "title": "13. Troubleshooting"
        }, 
        {
            "location": "/13_troubleshooting/#troubleshooting", 
            "text": "", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/13_troubleshooting/#troubleshooting-the-mobile-backend", 
            "text": "", 
            "title": "Troubleshooting the Mobile Backend"
        }, 
        {
            "location": "/13_troubleshooting/#introduction-to-azure-application-insights", 
            "text": "", 
            "title": "Introduction to Azure Application Insights"
        }, 
        {
            "location": "/13_troubleshooting/#troubleshooting-the-mobile-client", 
            "text": "", 
            "title": "Troubleshooting the Mobile Client"
        }, 
        {
            "location": "/13_troubleshooting/#introduction-to-hockeyapp", 
            "text": "", 
            "title": "Introduction to HockeyApp"
        }, 
        {
            "location": "/13_troubleshooting/#introduction-to-xamarin-insights", 
            "text": "", 
            "title": "Introduction to Xamarin Insights"
        }, 
        {
            "location": "/14_production/", 
            "text": "Going to Production\n\n\nDeploying Beta Editions of your Application\n\n\nUsing Slots for the Mobile Backend\n\n\nUsing HockeyApp for the Mobile Client\n\n\nScaling your Backend\n\n\nMonitoring your Production Application\n\n\nApplication Insights vs. Xamarin Insights\n\n\nConfiguration as Code (DevOps)\n\n\nIntroduction to Azure Resource Manager\n\n\nDeploying your site with Azure Resource Manager", 
            "title": "14. Going to Production"
        }, 
        {
            "location": "/14_production/#going-to-production", 
            "text": "", 
            "title": "Going to Production"
        }, 
        {
            "location": "/14_production/#deploying-beta-editions-of-your-application", 
            "text": "", 
            "title": "Deploying Beta Editions of your Application"
        }, 
        {
            "location": "/14_production/#using-slots-for-the-mobile-backend", 
            "text": "", 
            "title": "Using Slots for the Mobile Backend"
        }, 
        {
            "location": "/14_production/#using-hockeyapp-for-the-mobile-client", 
            "text": "", 
            "title": "Using HockeyApp for the Mobile Client"
        }, 
        {
            "location": "/14_production/#scaling-your-backend", 
            "text": "", 
            "title": "Scaling your Backend"
        }, 
        {
            "location": "/14_production/#monitoring-your-production-application", 
            "text": "", 
            "title": "Monitoring your Production Application"
        }, 
        {
            "location": "/14_production/#application-insights-vs-xamarin-insights", 
            "text": "", 
            "title": "Application Insights vs. Xamarin Insights"
        }, 
        {
            "location": "/14_production/#configuration-as-code-devops", 
            "text": "", 
            "title": "Configuration as Code (DevOps)"
        }, 
        {
            "location": "/14_production/#introduction-to-azure-resource-manager", 
            "text": "", 
            "title": "Introduction to Azure Resource Manager"
        }, 
        {
            "location": "/14_production/#deploying-your-site-with-azure-resource-manager", 
            "text": "", 
            "title": "Deploying your site with Azure Resource Manager"
        }, 
        {
            "location": "/references/", 
            "text": "References\n\n\nFurther Reading\n\n\nAPI References\n\n\nSamples\n\n\nHow to get Help", 
            "title": "References"
        }, 
        {
            "location": "/references/#references", 
            "text": "", 
            "title": "References"
        }, 
        {
            "location": "/references/#further-reading", 
            "text": "", 
            "title": "Further Reading"
        }, 
        {
            "location": "/references/#api-references", 
            "text": "", 
            "title": "API References"
        }, 
        {
            "location": "/references/#samples", 
            "text": "", 
            "title": "Samples"
        }, 
        {
            "location": "/references/#how-to-get-help", 
            "text": "", 
            "title": "How to get Help"
        }
    ]
}