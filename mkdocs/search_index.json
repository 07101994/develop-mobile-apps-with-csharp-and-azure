{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\n\nWelcome to my first book.  It's free, it's open source, and it's comprehensive.\nThose attributes also describe two of my favorite technologies, and I'm basing\nmy first book on them.  The first is \nXamarin Forms\n , a technology that\nallows you to develop cross-platform mobile applications using C# and the .NET\nframework.  The second is \nAzure Mobile Apps\n, a technology that allows\nyou to connect your mobile app to  resources that are important in cloud\nconnected mobile applications such as table data, authentication, and push\nnotifications.\n\n\nThis book does not tell you everything there is to know about either topic.  It\nfocuses on the topics necessary to get your mobile apps connected to the cloud.\n\n\nWhat are Cloud Connected Mobile Apps?\n\n\nI guess I should define some of the terminology that I am going to use.  When I\nrefer to a \nmobile application\n or \nmobile app\n, I mean every piece of\nsoftware that is related to the application you want to use.  This includes, for\nexample, the \nmobile client\n. This is the piece of code you run on your iPhone\nor Android phone.  It also includes the \nmobile backend\n which is the service\nthat you run in the cloud to provide important services to your mobile client.\n\n\nA \ncloud connected mobile application\n is a mobile client that connects to a\nmobile backend for shared services.  Quite a few of the apps on your phone are\ncloud connected already.  For example, Instagram uses the cloud for photo\nstorage, and Facebook uses the cloud to store the news feeds of you and your\nfriends.\n\n\nWhy Cross-Platform Native Development is important?\n\n\nIt should come as no surprise that Apple and Google have pretty much won the\nmobile OS wars.  Over 90% of the smart phones being sold today run either iOS\nor Android.  However, these are two very different mobile operating systems,\nwith different programming models.  iOS is based on either \nSwift\n or\nObjective-C.  Android is based on \nJava\n.  If you want to develop for the\n80% case (and you should), then you need to know both Swift and Java.  That's\na tall order even for the most dedicated mobile developer.\n\n\nHowever, there are alternatives out there.  Most notable, you can write your\nmobile application with one code-base and just write exceptions for when the\nplatforms diverge.  You have to pick a single language and a tool set that\nsupports cross-platform development to do this.  Not all cross-platform tool\nsets are created equal, however.  Some do not compile your code to native\nbinaries, which means that you do not get access to all the functionality of\nthe mobile platforms you are targeting.\n\n\nXamarin, recently acquired by Microsoft, allows you to target all major\nplatforms - iOS, Android and Windows - to gain greater than 95% coverage of\nthe mobile smart phone market.  It does this by leveraging the .NET framework\nand compiling your code to a native binary for each platform.\n\n\nXamarin.Forms is a cross-platform framework, based on XAML and .NET, that\nallows you to use common UI pages to develop your apps.\n\n\nWhy Azure Mobile Apps?\n\n\nWhen you think about the major apps in the marketplace for each mobile\nplatform, the thing that they have in common is that they have some sort\nof cloud infrastructure driving them.  It might be as simple as storing\nyour task list, or as complex as your Facebook news feed.  It could be a\ngaming leader board, or the social sharing of your photos.  Whatever it\nis, cloud connectivity is a must.\n\n\nNot all clouds are created equal.  There are some common features that you\nshould think about including irrespective of the application.  I like to use\nAzure Mobile Apps for these features because they are all included and you\ncan get started with most of the features for zero cost.  Even the features\nthat cannot be obtained without spending a little money are relatively cheap.\n\n\n\n\nAzure Mobile Apps is a feature of Azure App Service.  Azure App Service is\na collection of services that commonly are used together to develop modern\nInternet Apps.  This includes web hosting, API hosting and Mobile SDKs.\n\n\n\n\nFeatures of Cloud Connected Mobile Apps\n\n\nA cloud connected mobile application will use one or more services in the\nfollowing areas:\n\n\n\n\nAuthentication\n\n\nStorage of structured data (like a task list)\n\n\nStorage of unstructured data (like photographs)\n\n\nPush notifications\n\n\nInvocation of Custom Code\n\n\n\n\nI am going to cover each of these in great detail.  In addition, I will also\ncover some common issues and solutions that developers run into while developing\ncloud connected mobile applications such as testing and going to production.\n\n\nAside from the actual features of mobile apps, there are other things to\nconsider while developing your mobile application.  Here is my list, in no\nparticular order:\n\n\n\n\nContinuous Deployment\n\n\nSlots or Staging Sites\n\n\nAutomatic Scalability\n\n\nDatabase Backups\n\n\nCombined Web\n\n\n\n\nThe point here is that my intent is to write a production quality application.\nI need to be able to deploy my site with confidence without resorting to jumping\nthrough hoops.  I want to run multiple versions of the backend so that I can run\na staging site for testing purposes.  I want to be able to roll back my\nproduction site to a previous version at a moments notice.  I want to be able to\nhandle the load when my app is successful, and I want things to be backed up\n(since bad things inevitably happen when I am least prepared).\n\n\nAll of these features are available in Azure App Service, and the Mobile Apps\nSDK that I will use throughout the book is supported only on Azure App Service.\n\n\nWho is This Book For?\n\n\nThis book is for intermediate to experienced C# developers who have already\nbuilt a mobile app with Xamarin and want to take their mobile apps to the next\nlevel by utilizing cloud services.\n\n\nThis book is not for the beginner.  Explicitly, I already expect you to know how\nto develop mobile applications with C# and Xamarin technologies.  If you are\nunfamiliar with the C# language, you can get started with a free course on the\nInternet.  The basics of the language can be learned at \nwww.learncs.org\n.\nOnce you have the language basics under your belt, you can move on to building\nmobile applications with Xamarin. You can learn more about developing cross-platform\nmobile development with Xamarin at the \nXamarin\n website.  Although you do\nnot need to understand ASP.NET to get value out of this book, be aware that the\nmobile back ends that I will be covering are written in C# and ASP.NET.  A good\nunderstanding of ASP.NET will assist you.\n\n\nThings You Should Know!\n\n\nBefore you get started with development, spend some time learning the tools of\nthe trade.  The command prompt on the Mac is \nbash\n and the command prompt\non the PC is \nPowerShell\n.  You should be proficient in the shell on the\nplatforms that you use.\n\n\nAdditionally, you should become familiar with the source code control system\nthat you will use.  For most, this means becoming familiar with\n\ngit\n.  Don't even think of developing without using source control.\n\n\nWhat You Will Need\n\n\nThe list of hardware and software for mobile development is longer than your\ntypical development projects.  It is still, thankfully, relatively short and\neasy to acquire.\n\n\nHardware\n\n\nYou will want a computer on which to develop code.  If you develop iOS\napplications, then you \nMUST\n have a Mac running the latest version of Mac\nOSX.  If you develop Universal Windows applications, then you \nMUST\n have a\nPC running Windows 10.  Android applications can be developed on either platform.\n\n\nMy own experience has taught me that the tooling for developing mobile backends\nin C# and ASP.NET (our primary languages during the course of this book) are\nbetter on a PC running Windows 10.  Thus, my hardware choice is a rather beefy\n\nWindows 10 PC\n for my main development system.  In addition, I have a\n\nMac Mini\n underneath my desk that I use to build the iOS portions of the\napplications.\n\n\nSoftware\n\n\nAll of the following software are freely available.  You should install each\npackage and update it (if appropriate) so that it is fully patched.\n\n\nOn your Mac\n\n\n\n\nXCode\n (available on the Mac App Store)\n\n\nXamarin Studio\n\n\nAndroid Studio and Tools\n (if you intend to build Android apps on the Mac)\n\n\n\n\nYou must run XCode at least once after installation so that you can accept the\nlicense agreement.\n\n\nOn your Windows PC\n\n\n\n\nAndroid Studio and Tools\n\n\nVisual Studio Community\n\n\nAzure SDK\n\n\n\n\nWhen installing Visual Studio, you will want to install the components for\nWeb applications and Cross-platform Mobile development.  If you have already\ninstalled Visual Studio and did not install these components, run the installer\nagain to add the components.\n\n\n\n\nDevelopment Tools are big, multi-gigabyte installers.  If you are on a slow or\nrestricted link, you may want to download the installers onto a thumb drive for\nlocal installation.\n\n\n\n\nCloud Services\n\n\nYou will need an Azure account to complete most of the tutorials in this book.\nIn fact, you won't be able to get very far without one. If you have an MSDN\naccount, you already have access to free Azure resources.  You just need to log\ninto your \nMSDN account\n and activate your Azure benefit.  Students may be\nable to get access to \nDreamspark\n from school resources, but this is not\nsuitable for developing mobile applications.  This is because storage costs\nmoney.  If you don't have MSDN, then there is a \nfree trial\n available.\nOnce the trial period ends, you can move to a Pay-As-You-Go account and continue\nto use free services without incurring a charge. I'll point out when you are\ngoing to incur charges on your Azure account, but I will be using free resources\nmost of the time.\n\n\nAside from Azure resources, you will want some place to store your code.  This\ndoesn't have to be in the cloud.  If you want to use the cloud, you can use\nGitHub or Visual Studio Team Services.  Both are free to use.  GitHub provides\npublic repositories for free.  Visual Studio Team Services provides private\nrespositories for free.  Visual Studio Team Services also includes other\nservices that I will talk about during the course of the book, some of which may\nincur cost.  I will be publishing all my samples and tutorial code on GitHub so\nthat you can easily download it.  You don't have to use one of these resources,\nbut I won't be covering other service usage.\n\n\nYou will need a \nDeveloper Account\n for the appropriate app store if you\nintend to distribute your mobile clients or if you intend to use specific cloud\nservices.  Apple is specific - if you intend to use push notifications or\ndistribute iOS apps, then you need an \nApple Developer Account\n,\n\nGoogle Developer Account\n and/or \nWindows Store Developer Account\n.\nThe terms of the accounts are changed constantly, so review the current terms\nwhen you sign up.  My recommendation is to defer signing up for these programs\nuntil you need something they offer.\n\n\nNow, let's get developing!  Our next section is dependent on where you are developing:\n\n\n\n\nOn a Mac, skip ahead to the \nMac section\n.\n\n\nOn a PC, the \nnext section\n covers Visual Studio.",
            "title": "Getting Started"
        },
        {
            "location": "/#introduction",
            "text": "Welcome to my first book.  It's free, it's open source, and it's comprehensive.\nThose attributes also describe two of my favorite technologies, and I'm basing\nmy first book on them.  The first is  Xamarin Forms  , a technology that\nallows you to develop cross-platform mobile applications using C# and the .NET\nframework.  The second is  Azure Mobile Apps , a technology that allows\nyou to connect your mobile app to  resources that are important in cloud\nconnected mobile applications such as table data, authentication, and push\nnotifications.  This book does not tell you everything there is to know about either topic.  It\nfocuses on the topics necessary to get your mobile apps connected to the cloud.",
            "title": "Introduction"
        },
        {
            "location": "/#what-are-cloud-connected-mobile-apps",
            "text": "I guess I should define some of the terminology that I am going to use.  When I\nrefer to a  mobile application  or  mobile app , I mean every piece of\nsoftware that is related to the application you want to use.  This includes, for\nexample, the  mobile client . This is the piece of code you run on your iPhone\nor Android phone.  It also includes the  mobile backend  which is the service\nthat you run in the cloud to provide important services to your mobile client.  A  cloud connected mobile application  is a mobile client that connects to a\nmobile backend for shared services.  Quite a few of the apps on your phone are\ncloud connected already.  For example, Instagram uses the cloud for photo\nstorage, and Facebook uses the cloud to store the news feeds of you and your\nfriends.",
            "title": "What are Cloud Connected Mobile Apps?"
        },
        {
            "location": "/#why-cross-platform-native-development-is-important",
            "text": "It should come as no surprise that Apple and Google have pretty much won the\nmobile OS wars.  Over 90% of the smart phones being sold today run either iOS\nor Android.  However, these are two very different mobile operating systems,\nwith different programming models.  iOS is based on either  Swift  or\nObjective-C.  Android is based on  Java .  If you want to develop for the\n80% case (and you should), then you need to know both Swift and Java.  That's\na tall order even for the most dedicated mobile developer.  However, there are alternatives out there.  Most notable, you can write your\nmobile application with one code-base and just write exceptions for when the\nplatforms diverge.  You have to pick a single language and a tool set that\nsupports cross-platform development to do this.  Not all cross-platform tool\nsets are created equal, however.  Some do not compile your code to native\nbinaries, which means that you do not get access to all the functionality of\nthe mobile platforms you are targeting.  Xamarin, recently acquired by Microsoft, allows you to target all major\nplatforms - iOS, Android and Windows - to gain greater than 95% coverage of\nthe mobile smart phone market.  It does this by leveraging the .NET framework\nand compiling your code to a native binary for each platform.  Xamarin.Forms is a cross-platform framework, based on XAML and .NET, that\nallows you to use common UI pages to develop your apps.",
            "title": "Why Cross-Platform Native Development is important?"
        },
        {
            "location": "/#why-azure-mobile-apps",
            "text": "When you think about the major apps in the marketplace for each mobile\nplatform, the thing that they have in common is that they have some sort\nof cloud infrastructure driving them.  It might be as simple as storing\nyour task list, or as complex as your Facebook news feed.  It could be a\ngaming leader board, or the social sharing of your photos.  Whatever it\nis, cloud connectivity is a must.  Not all clouds are created equal.  There are some common features that you\nshould think about including irrespective of the application.  I like to use\nAzure Mobile Apps for these features because they are all included and you\ncan get started with most of the features for zero cost.  Even the features\nthat cannot be obtained without spending a little money are relatively cheap.   Azure Mobile Apps is a feature of Azure App Service.  Azure App Service is\na collection of services that commonly are used together to develop modern\nInternet Apps.  This includes web hosting, API hosting and Mobile SDKs.",
            "title": "Why Azure Mobile Apps?"
        },
        {
            "location": "/#features-of-cloud-connected-mobile-apps",
            "text": "A cloud connected mobile application will use one or more services in the\nfollowing areas:   Authentication  Storage of structured data (like a task list)  Storage of unstructured data (like photographs)  Push notifications  Invocation of Custom Code   I am going to cover each of these in great detail.  In addition, I will also\ncover some common issues and solutions that developers run into while developing\ncloud connected mobile applications such as testing and going to production.  Aside from the actual features of mobile apps, there are other things to\nconsider while developing your mobile application.  Here is my list, in no\nparticular order:   Continuous Deployment  Slots or Staging Sites  Automatic Scalability  Database Backups  Combined Web   The point here is that my intent is to write a production quality application.\nI need to be able to deploy my site with confidence without resorting to jumping\nthrough hoops.  I want to run multiple versions of the backend so that I can run\na staging site for testing purposes.  I want to be able to roll back my\nproduction site to a previous version at a moments notice.  I want to be able to\nhandle the load when my app is successful, and I want things to be backed up\n(since bad things inevitably happen when I am least prepared).  All of these features are available in Azure App Service, and the Mobile Apps\nSDK that I will use throughout the book is supported only on Azure App Service.",
            "title": "Features of Cloud Connected Mobile Apps"
        },
        {
            "location": "/#who-is-this-book-for",
            "text": "This book is for intermediate to experienced C# developers who have already\nbuilt a mobile app with Xamarin and want to take their mobile apps to the next\nlevel by utilizing cloud services.  This book is not for the beginner.  Explicitly, I already expect you to know how\nto develop mobile applications with C# and Xamarin technologies.  If you are\nunfamiliar with the C# language, you can get started with a free course on the\nInternet.  The basics of the language can be learned at  www.learncs.org .\nOnce you have the language basics under your belt, you can move on to building\nmobile applications with Xamarin. You can learn more about developing cross-platform\nmobile development with Xamarin at the  Xamarin  website.  Although you do\nnot need to understand ASP.NET to get value out of this book, be aware that the\nmobile back ends that I will be covering are written in C# and ASP.NET.  A good\nunderstanding of ASP.NET will assist you.",
            "title": "Who is This Book For?"
        },
        {
            "location": "/#things-you-should-know",
            "text": "Before you get started with development, spend some time learning the tools of\nthe trade.  The command prompt on the Mac is  bash  and the command prompt\non the PC is  PowerShell .  You should be proficient in the shell on the\nplatforms that you use.  Additionally, you should become familiar with the source code control system\nthat you will use.  For most, this means becoming familiar with git .  Don't even think of developing without using source control.",
            "title": "Things You Should Know!"
        },
        {
            "location": "/#what-you-will-need",
            "text": "The list of hardware and software for mobile development is longer than your\ntypical development projects.  It is still, thankfully, relatively short and\neasy to acquire.",
            "title": "What You Will Need"
        },
        {
            "location": "/#hardware",
            "text": "You will want a computer on which to develop code.  If you develop iOS\napplications, then you  MUST  have a Mac running the latest version of Mac\nOSX.  If you develop Universal Windows applications, then you  MUST  have a\nPC running Windows 10.  Android applications can be developed on either platform.  My own experience has taught me that the tooling for developing mobile backends\nin C# and ASP.NET (our primary languages during the course of this book) are\nbetter on a PC running Windows 10.  Thus, my hardware choice is a rather beefy Windows 10 PC  for my main development system.  In addition, I have a Mac Mini  underneath my desk that I use to build the iOS portions of the\napplications.",
            "title": "Hardware"
        },
        {
            "location": "/#software",
            "text": "All of the following software are freely available.  You should install each\npackage and update it (if appropriate) so that it is fully patched.",
            "title": "Software"
        },
        {
            "location": "/#on-your-mac",
            "text": "XCode  (available on the Mac App Store)  Xamarin Studio  Android Studio and Tools  (if you intend to build Android apps on the Mac)   You must run XCode at least once after installation so that you can accept the\nlicense agreement.",
            "title": "On your Mac"
        },
        {
            "location": "/#on-your-windows-pc",
            "text": "Android Studio and Tools  Visual Studio Community  Azure SDK   When installing Visual Studio, you will want to install the components for\nWeb applications and Cross-platform Mobile development.  If you have already\ninstalled Visual Studio and did not install these components, run the installer\nagain to add the components.   Development Tools are big, multi-gigabyte installers.  If you are on a slow or\nrestricted link, you may want to download the installers onto a thumb drive for\nlocal installation.",
            "title": "On your Windows PC"
        },
        {
            "location": "/#cloud-services",
            "text": "You will need an Azure account to complete most of the tutorials in this book.\nIn fact, you won't be able to get very far without one. If you have an MSDN\naccount, you already have access to free Azure resources.  You just need to log\ninto your  MSDN account  and activate your Azure benefit.  Students may be\nable to get access to  Dreamspark  from school resources, but this is not\nsuitable for developing mobile applications.  This is because storage costs\nmoney.  If you don't have MSDN, then there is a  free trial  available.\nOnce the trial period ends, you can move to a Pay-As-You-Go account and continue\nto use free services without incurring a charge. I'll point out when you are\ngoing to incur charges on your Azure account, but I will be using free resources\nmost of the time.  Aside from Azure resources, you will want some place to store your code.  This\ndoesn't have to be in the cloud.  If you want to use the cloud, you can use\nGitHub or Visual Studio Team Services.  Both are free to use.  GitHub provides\npublic repositories for free.  Visual Studio Team Services provides private\nrespositories for free.  Visual Studio Team Services also includes other\nservices that I will talk about during the course of the book, some of which may\nincur cost.  I will be publishing all my samples and tutorial code on GitHub so\nthat you can easily download it.  You don't have to use one of these resources,\nbut I won't be covering other service usage.  You will need a  Developer Account  for the appropriate app store if you\nintend to distribute your mobile clients or if you intend to use specific cloud\nservices.  Apple is specific - if you intend to use push notifications or\ndistribute iOS apps, then you need an  Apple Developer Account , Google Developer Account  and/or  Windows Store Developer Account .\nThe terms of the accounts are changed constantly, so review the current terms\nwhen you sign up.  My recommendation is to defer signing up for these programs\nuntil you need something they offer.  Now, let's get developing!  Our next section is dependent on where you are developing:   On a Mac, skip ahead to the  Mac section .  On a PC, the  next section  covers Visual Studio.",
            "title": "Cloud Services"
        },
        {
            "location": "/chapter1/firstapp_pc/",
            "text": "Your First Mobile App\n\n\nThere is a lot of detail to absorb about the possible services that the mobile\nclient can consume and I will go into significant depth on those subjects.\nFirst, wouldn't it be nice to write some code and get something working?\nMicrosoft Azure has a great \nfirst-steps tutorial\n that takes you via the\nquickest possible route from creating a mobile backend to having a functional\nbackend.  I would like to take things a little slower so that we can understand\nwhat is going on while we are doing the process.  We will have practically the\nsame application at the end.  The primary reason for going through this slowly\nis to ensure that all our build and run processes are set up properly.  If this\nis the first mobile app you have ever written, you will see that there are quite\na few things that need to be set up.  This chapter covers the set up required\nfor a Windows PC.  If you wish to develop your applications on a Mac, then skip\nto the \nnext section\n.\n\n\nThe application we are going to build together is a simple task list.  The\nmobile client will have three screens - an entry screen, a task list and a task\ndetails page.  I have mocked these pages up using \nMockingBot\n.\n\n\n\n\nMocking your screens before you start coding is a great habit to get into.\nThere are some great tools available including free tools like \nMockingBot\n.\nDoing mockups before you start coding is a good way to prevent wasted time later\non.\n\n\n\n\n\n\n\n\nWhy include a back button?  If you are using iOS, then you may want to remove\nthe back button as the style guides suggest you don't need one.  Other platforms\nwill need it though, so it's best to start with the least common denominator.\nIt's the same reason I add a refresh button even though it's only valid on\nWindows Phone!\n\n\n\n\nMy ideas for this app include:\n\n\n\n\nTapping on a task title in the task list will bring up the details page.\n\n\nToggling the completed link in the task list will set the completed flag.\n\n\nTapping the spinner will initiate a network refresh.\n\n\n\n\nNow that we have our client screens planned out, we can move onto the thinking\nabout the mobile backend.\n\n\nThe Mobile Backend\n\n\nThe mobile backend is an ASP.NET WebApi that is served from within Azure App\nService: a highly scalable and redundant web hosting facility that supports all\nthe major web languages (like ASP.NET, Node, PHP and Python).  Azure Mobile\nApps is an SDK (which is available in ASP.NET and Node) that runs on top of\nAzure App Service.\n\n\nCreating a Simple Azure Mobile Apps Backend\n\n\nMicrosoft Azure has included a comprehensive starter kit template in the\nAzure SDK.  To get started:\n\n\n\n\nFire up Visual Studio 2015\n\n\nAdd a new project with File -> New Project...\n\n\n\n\nIn the \nNew Project\n window:\n\n\n\n\nOpen up Templates -> Visual C# -> Web and select \nASP.NET Web Application (.NET Framework)\n.\n\n\nEnter \nBackend\n for the Name and \nChapter1\n for the Solution name.\n\n\nPick a suitable directory for the Location field.\n\n\nClick on OK.\n\n\n\n\n\n\n\n\n\n\nIn the \nNew ASP.NET Web Application\n window:\n\n\n\n\nClick on \nAzure Mobile App\n.\n\n\nDo \nNOT\n check \"Host in the cloud\" or any other checkboxes.\n\n\nClick on OK.\n\n\n\n\n\n\n\n\nAt this point, Visual Studio will create your backend project.\n\n\n\n\nIt's very tempting to select \nAzure Mobile Services\n instead - it sounds\ncloser to what you want.  Azure Mobile Services is the \nOLD\n service and is\nbeing shut down.  You should not select Azure Mobile Services for any project.\n\n\n\n\nThere are a few files of which you should take note.  The Mobile Apps SDK is\ninitialized within \nApp_Start\\Startup.MobileApp.cs\n (with the call to the\nconfiguration routine happening within \nStartup.cs\n).  The default startup\nroutine is reasonable but it hides what it is doing behind extension methods.\nThis technique is fairly common in ASP.NET programs.  Let's expand the\nconfiguration routine to only include what we need:\n\n\npublic static void ConfigureMobileApp(IAppBuilder app)\n{\n    var config = new HttpConfiguration();\n    var mobileConfig = new MobileAppConfiguration();\n\n    mobileConfig\n        .AddTablesWithEntityFramework()\n        .ApplyTo(config);\n\n    Database.SetInitializer(new MobileServiceInitializer());\n\n    app.UseWebApi(config);\n}\n\n\n\n\nThe minimal version of the mobile backend initialization is actually shorter\nthan the original.  It also only includes a data access layer.  Other services\nlike authentication, storage and push notifications are not configured.\n\n\nThere is another method in the \nApp_Start\\Startup.MobileApp.cs\n file for\nseeding data into the database for us.  We can leave that alone for now, but\nremember it is there in case you need to seed data into a new database for\nyour own backend.\n\n\n\n\nWe refer to \"seeding data\" into a database.  This means that we are going to introduce some data into the database so that we aren't operating on an empty database.  The data will be there when we query the database later on.\n\n\n\n\nThe next important file is the \nDbContext\n - located in\n\nModels\\MobileServiceContext.cs\n. Azure Mobile Apps is heavily dependent on\n\nEntity Framework v6.x\n and the \nDbContext\n is a central part of that\nlibrary.  Fortunately, we don't need to do anything to this file right now.\n\n\nFinally, we get to the meat of the backend.  The whole point of this\ndemonstration is to project a single database table - the TodoItem table - into\nthe mobile realm with the aid of an opinionated \nOData v3\n feed.  To that\nend, we need three items:\n\n\n\n\nA \nDbSet<>\n within the \nDbContext\n\n\nA Data Transfer Object (or DTO)\n\n\nA Table Controller\n\n\n\n\nWhen we create the project, a sample of each one of these for the TodoItem table\nis added for us.  You can see the \nDbSet<>\n in the \nModels\\MobileServiceContext.cs\n\nfile, for example.  Let's take a look at the DTO and Table Controller for this\nexample table as well.  The DTO for the TodoItem table is located within the\n\nDataObjects\n directory:\n\n\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.DataObjects\n{\n    public class TodoItem : EntityData\n    {\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n    }\n}\n\n\n\n\nNote that the model uses \nEntityData\n as a base class.  The \nEntityData\n class\nadds five additional properties to the class - we'll discuss those in more\ndetails during the \nData Access and Offline Sync\n chapter.\n\n\nFinally, let's look at the table controller for the example TodoItem table.  This\nis located in \nControllers\\TodoItemController.cs\n:\n\n\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}\n\n\n\n\nThe \nTableController\n is the central processing for the database access layer.\nIt handles all the OData capabilities for us and exposes these as REST endpoints\nwithin our WebAPI.  This means that the actual code for this controller is tiny - just 12 lines of code.\n\n\n\n\nOData\n is a specification for accessing table data on the Internet.  It provides a mechanism for querying and manipulating data within a table.  Entity Framework is a common data access layer for ASP.NET applications.\n\n\n\n\nWe can build the project at this point.  If Visual Studio hasn't done so already,\nthe missing NuGet packages for Azure Mobile Apps will be downloaded.  There\nshould not be any errors.  If there are, check the typing for any changes you\nmade.\n\n\n\n\nYou can delete or ignore the \nControllers\\ValuesController.cs\n file if you like - it isn't important for this walkthrough.\n\n\n\n\nBuilding an Azure App Service for Mobile Apps\n\n\nThe next step in the process is to build the resources on Azure that will\nrun your mobile backend.  Start by logging into the \nAzure Portal\n, then\nfollow these instructions:\n\n\n\n\nClick on the big \n+ New\n button in the top-left corner.\n\n\nClick on \nWeb + Mobile\n, then \nMobile App\n.\n\n\n\n\nEnter a unique name in the \nApp name\n box.\n\n\n\n\nSince the name doesn't matter and it has to be unique, you can use \na\nGUID generator\n to generate a unique name. GUIDs are not the best\nnames to use when you need to actually find resources, but using GUIDS\nprevents conflicts when deploying, so I prefer them as a naming scheme.\nYou can prefix the GUID  (example: chapter1-GUID) to aid in discovery\nlater on.  Generally, the first four digits of a GUID are enough to\nidentify individual resources.\n\n\n\n\n\n\n\n\nIf you have more than one subscription (for example, you have a trial\n   and an MSDN subscription), then ensure you select the right subscription\n   in the \nSubscription\n drop-down.\n\n\n\n\n\n\nSelect \nCreate new\n under resource group and enter a name for this\n   mobile application.\n\n\n\n\nResource groups are great for grouping all the resources associated with a mobile application together.  During development, it means you can delete all the resources in one operation.  For production, it means you can see how much the service is costing you and how the resources are being used.\n\n\n\n\n\n\n\n\nFinally, select or create a new \nApp Service Plan\n.\n\n\n\n\nThe App Service Plan is the thing that actually bills you - not the web or mobile backend.  You can run a number of web or mobile backends on the same App Service Plan.\n\n\n\n\nI tend to create a new App Service Plan for each mobile application.  This\nis because the App Service Plan lives inside the Resource Group that you\ncreate.  The process for creating an App Service Plan is straight forward.\nYou have two decisions to make.  The first decision is where is the service\ngoing to run.  In a production environment, the correct choice is \"near your\ncustomers\".  \"Close to the developers\" is a good choice during development.\nUnfortunately, neither of those is an option you can actually choose in the\nportal, so you will have to translate into some sort of geographic location.\nWith 16 regions to choose from, you have a lot of choice.\n\n\nThe second decision you have to make is what to run the service on; also\nknown as the Pricing tier.   If you click on \nView all\n, you will see you\nhave lots of choices.  F1 Free and D1 Shared, for example, run on shared\nresources and are CPU limited. You should avoid these as the service will\nstop responding when you are over the CPU quota.  That leaves Basic,\nStandard and Premium.  Basic has no automatic scaling and can run up to 3\ninstances - perfect for development tasks.  Standard and Premium both have\nautomatic scaling, automatic backups, and large amounts of storage; they\ndiffer in features: the number of sites or instances you can run on them,\nfor example.  Finally, there is a number after the plan.  This tells you how\nbig the virtual machine is that the plan is running on.  The numbers differ\nby number of cores and memory.\n\n\nFor our purposes, an F1 Free site is enough to run this small demonstration\nproject.  More complex development projects should use something in the\nBasic range of pricing plans.  Production apps should be set up in Standard\nor Premium pricing plans.\n\n\n\n\n\n\nOnce you have created your app service plan and saved it, click on \nCreate\n.\n\n\n\n\n\n\nThe creation of the service can take a couple of minutes.  You can monitor the\nprocess of deployment by clicking on the Notifications icon.  This is in the top\nbar on the right-hand side and looks like a Bell.  Clicking on a specific\nnotification will provide more information about the activity.  Once you have\ncreated your app service, the App Service blade will open.\n\n\n\n\nWhat's the difference between a Web App, a Mobile App and an API App?  Not a\nlot.  The type determines which Quick start projects are available in the Quick\nstart menu under \nAll settings\n.  Since we selected a Mobile app, a set of\nstarter client projects for mobile devices will be presented.\n\n\n\n\nWe will also want a place to store our data.  This role is taken on by a\nSQL Azure instance.  We could link an existing database if we had one\ndefined.  However, we can also create a test database.\n\n\n\n\nCreating a Test Database through the App Service Data Connections (as\nI describe here) allows you to create a free database.  This option is\nnot normally available through other SQL database creation flows.\n\n\n\n\n\n\nClick on \nResource groups\n in the left hand side menu.\n\n\nClick on the resource group you created.\n\n\nClick on the App Service your created.\n\n\n\n\nClick on \nAll settings\n.\n\n\n\n\nIf you pinned your App Service to the dashboard, you can click on the\npinned App Service instead.  It will bring you to the same place.\n\n\n\n\n\n\n\n\nClick on \nData connections\n in the \nMOBILE\n menu.\n\n\n\n\n\n\nClick on \nAdd\n.\n\n\n\n\nIn the \nType\n box, select \nSQL Database\n.\n\n\nClick on the unconfigured \nSQL Database\n link:\n\n\n\n\n\n\n\n\nIn the \nDatabase\n blade, select \nCreate a new database\n.\n\n\nEnter a name for the database (like \nchapter1-db\n).\n\n\nSelect a Pricing Tier (look for \nF Free\n at the bottom).\n\n\nClick on the unconfigured \nServer\n.\n\n\n\n\n\n\n\n\nEnter a unique name for the server (a GUID is a good idea here).\n\n\nEnter a username and password for the server.\n\n\nClick on \nOK\n to close the \nNew Server\n blade.\n\n\nClick on \nOK\n to close the \nNew Database\n blade.\n\n\nClick on \nOK\n to close the \nAdd Data Connection\n blade.\n\n\n\n\n\n\n\n\nThis produces another deployment step that creates a SQL Server and a SQL\ndatabase with your settings.  Once complete, the connection\n\nMS_TableConnectionString\n will be listed in Data Connections blade.\n\n\n\n\n\n\nIf you want a completely free mobile backend, search for the \nMobile\nApps Quickstart\n in the Azure Marketplace.  This template does not\nrequire a database.  It relies on a Node backend, however, so you won't\nbe developing a C# backend.\n\n\n\n\nDeploying the Azure Mobile Apps Backend\n\n\nDeploying to Azure as a developer can be accomplished while entirely within\nVisual Studio:\n\n\n\n\nRight-click on the \nBackend\n project, then select \nPublish...\n.\n\n\n\n\nMake sure you see this screen shot:\n\n\n\n\nIf you do not see this image, then it is likely you have an older version\nof the Azure SDK installed.  Make sure the Azure SDK version is v2.9 or\nlater.\n\n\n\n\n\n\nClick on \nMicrosoft Azure App Service\n.\n\n\n\n\nYou may be prompted to enter your Azure credentials here.  Enter the same\n    information that you enter to access the Azure Portal.\n\n\nIn the lower box, expand the resource group that you created and select the\n    app service you created in the portal.\n\n\nClick on \nOK\n.\n\n\nClick on \nPublish\n.\n\n\n\n\nVisual Studio will open a browser.  Add \n/tables/todoitem?ZUMO-API-VERSION=2.0.0\n\nto the end of the URL.  This will show the JSON contents of the table that we\ndefined in the backend.\n\n\n\n\nYou will see the word ZUMO all over the SDK, including in optional HTTP headers\nand throughout the SDK source code.  ZUMO was the original code name within Microsoft\nfor A\nZU\nre \nMO\nbile.\n\n\n\n\nThe Mobile Client\n\n\nNow that the mobile backend is created and deployed, we can move onto the client\nside of things.  First of all, let's prepare the Visual Studio instance.  If you\nhave installed the Cross-Platform Mobile tools during the installation, most of\nthe work has already been done.  However, you may want to install the \nXamarin\nForms Templates\n using the Tools -> Extensions and Updates...\n\n\n\n\nThis template pack provides additional templates for Xamarin Forms development\nthat I find useful.  Most notably, there is a specific template for a mobile\ncross-platform project covering the Android, iOS and UWP mobile platforms.\n\n\n\n\nWhen you compile a Xamarin.Forms application for a specific platform, you are\nproducing a true native application for that platform - whether it be iOS,\nAndroid or Windows.\n\n\n\n\nCreating a Simple Mobile Client with Xamarin\n\n\nNow that we have prepared your Visual Studio instance, we can create the\nproject. Right-click on the solution and select \nAdd\n -> \nNew Project...\n.\nThis will bring up the familiar New Project dialog.  The project you want is\nunder \nVisual C#\n -> \nCross-Platform\n, and is called \nXamarin.Forms\n(UWP/Android/iOS)\n.  If you did not install the Xamarin Forms Template add-on,\nthen choose the \nBlank Xaml App (Xamarin.Forms Portable)\n project.  Give the\nproject a name, then click on \nOK\n.\n\n\n\n\n\n\nIf you did not install the Xamarin Forms Templates, then you can create a\n\nBlank Xaml App (Xamarin.Forms Portable)\n project instead.\n\n\n\n\nProject creation will take longer than you expect, but there is a lot going on.\nIf you have never created a mobile or UWP project before, you will be prompted\nto turn on Windows 10 Developer Mode:\n\n\n\n\nDeveloper mode in Windows 10 allows you to run unsigned binaries for development\npurposes and to turn on debugging so that you can step through your UWP programs\nwithin Visual Studio.\n\n\nWe will also get asked to choose what version of the Universal Windows platform\nwe want to target:\n\n\n\n\nVersion 10240 was the first version of Windows 10 that was released to the general\npublic, so that's a good minimum version to pick.  In general, the defaults for\nthe Universal Windows Platform choice are good enough.\n\n\nXamarin allows us to build iOS applications directly from Visual Studio. For\nthis to work, we must have access to a Mac. This could be anything from a\nMacBook Air/Pro, to a Mac Mini in a drawer or closet in the office, or maybe\neven a \nMac in the cloud\n.  The Xamarin tools use SSH to connect to the Mac,\nwhich must be \nconfigured to build iOS apps from Visual Studio\n.\n\n\n\n\nIf you don't have a Mac and are not interested in building iOS applications,\ndon't give up now!  You can cancel through the Mac specific project setup and\ncontinue with building a great Android and Universal Windows app.  You can\ndelete the iOS specific project after it has been created.\n\n\n\n\nWhen prompted about the Xamarin Mac Agent, click on \nOK\n to get the list of\nlocal mac agents:\n\n\n\n\nHighlight your mac (in case there are multiples), then click on \nConnect...\n.\nIf your mac is not listed or you are using a Mac in the cloud, then you can\nalways enter the IP address for your mac.\n\n\n\n\nFor more troubleshooting tips, visit  https://developer.xamarin.com/guides/ios/getting_started/installation/windows/connecting-to-mac/troubleshooting/\n\n\n\n\nYou will be prompted for your username and password:\n\n\n\n\nJust enter the username and password that you use to log in to your mac and click\non \nLogin\n.\n\n\n\n\nWhat's my username?\n  Apple tries very hard to hide the real username of\nyour account from you.  The easiest way to find your mac username is to open up\nthe Finder.  The name next to your home icon is the name of your account.\n\n\n\n\nIf the connection has successed, you will see a green icon in the Xamarin Visual\nStudio toolbar area. It may take a minute or two to connect and verify that the\nmac can be used.\n\n\nOnce the project is created, you will see that four new projects have been\ncreated: a common library which you named plus one project for each platform\nthat has been chosen.  Since we chose a project with three platforms, we get\nfour projects:\n\n\n\n\nMost of our work will happen in the common library.  However, we can introduce\nplatform-specific code at any point.  The platform-specific code is stored in\nthe platform-specific project.\n\n\nThere is one final item we must do before we leave the set up of the project.\nThere are a number of platform upgrades that inevitably have to happen.  The\nXamarin Platform is updated much more often than the Visual Studio plugin - the\nupdates are released via NuGet: the standard method of distributing libraries\nfor .NET applications.  In addition to the inevitable Xamarin Platform update,\nwe also will want to add the following NuGet packages:\n\n\n\n\nMicrosoft.Azure.Mobile.Client v2.0.0 or later\n\n\nNewtonsoft.Json v6.0.3 or later\n\n\n\n\n\n\nAlthough it is tempting, do not include a v1.x version of the Mobile Client.\nThis is for the earlier Azure Mobile Services.  There are many differences between\nthe wire protocols of the two products.\n\n\n\n\nYou can install the NuGet packages by right-clicking on the project and selecting\n\nManage NuGet Packages...\n.\n\n\n\n\nYou must install the updates and the new NuGet packages on all four projects.\nThis involves repeating the same process for each client project in your\nsolution.\n\n\n\n\nAndroid generally has more updates than the other platforms.  Ensure that you\nupdate the main Xamarin.Forms package and then refresh the update list.  This will\nensure the right list of packages is updated.\n\n\n\n\nBuilding the Common Library\n\n\nThere are two parts that we must concentrate on within the common library.  The\nfirst is the connection to Azure Mobile Apps and the second is in the pages\nthat the user interacts with.  In both cases, there are best practices to observe.\n\n\nBuilding an Azure Mobile Apps Connection\n\n\nWe will rely on interfaces for defining the shape for the class for any service\nthat we interact with.  This is really not important in small projects like this\none.  This technique allows us to mock the backend service, as we shall see\nlater on.  Mocking the backend service is a great technique to rapidly iterate\non the front end mobile client without getting tied into what the backend is doing.\n\n\nLet's start with the cloud service - this is defined in\n\nAbstractions\\ICloudService.cs\n.  It is basically used for initializing\nthe connection and getting a table definition:\n\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        public ICloudTable<T> GetTable<T>() where T : TableData;\n    }\n}\n\n\n\n\nThere is a dependent implementation here: the \nICloudTable\n generic interface.  This\nrepresents a CRUD interface into our tables and is defined in \nAbstractions\\ICloudTable.cs\n:\n\n\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudTable<T> where T : TableData\n    {\n        Task<T> CreateItemAsync(T item);\n        Task<T> ReadItemAsync(string id);\n        Task<T> UpdateItemAsync(T item);\n        Task DeleteItemAsync(T item);\n\n        Task<ICollection<T>> ReadAllItemsAsync() where T : TableData;\n    }\n}\n\n\n\n\nThe \nICloudTable<T>\n interface defines the normal CRUD operations: Create, Read,\nUpdate and Delete.  However, it does so asynchronously.  We are dealing with network\noperations in general so it is easy for those operations to tie up the UI thread\nfor an appreciable amount of time.  Making them async provides the ability to\nrespond to other events.  I also provide a \nReadAllItemsAsync()\n method that\nreturns a collection of all the items.\n\n\nThere are some fields that every single record within an Azure Mobile Apps table\nprovides.  These fields are required for offline sync capabilities like incremental\nsync and conflict resolution.  The fields are provided by an abstract base class\non the client called \nTableData\n:\n\n\nusing System;\n\nnamespace TaskList.Abstractions\n{\n    public abstract class TableData\n    {\n        public string Id { get; set; }\n        public DateTimeOffset? UpdatedAt { get; set; }\n        public DateTimeOffset? CreatedAt { get; set; }\n        public byte[] Version { get; set; }\n    }\n}\n\n\n\n\nAs we will learn when we deal with \ntable data\n, these fields need to\nbe defined with the same name and semantics as on the server.  Our model on\nthe server was sub-classed from \nEntityData\n and the \nEntityData\n class on the\nserver defines these fields.\n\n\nIt's tempting to call the client version of the class the same as the server\nversion.  If we did that, the models on both the client and server would look\nthe same.  However, I find that this confuses the issue.  The models on the\nclient and server are not the same.  They are missing the \nDeleted\n flag and\nthey do not contain any relationship information on the client.  I choose to\ndeliberately call the base class something else on the client to avoid this\nconfusion.\n\n\nWe will be adding to these interfaces in future chapters as we add more\ncapabilities to the application.\n\n\nThe concrete implementations of these classes are similarly easily defined.  The\nAzure Mobile Apps Client SDK does most of the work for us.  Here is the concrete\nimplementation of the \nICloudService\n (in \nServices\\AzureCloudService.cs\n):\n\n\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(\"https://my-backend.azurewebsites.net\");\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData\n        {\n            return new AzureCloudTable<T>(client);\n        }\n    }\n}\n\n\n\n\nThe Azure Mobile Apps Client SDK takes a lot of the pain out of communicating\nwith the mobile backend that we have already published.  Just swap out the\nname of your mobile backend and the rest is silently dealt with.\n\n\n\n\nThe name \nMicrosoft.WindowsAzure.MobileServices\n is a hold-over from the old Azure\nMobile Services code-base.  Don't be fooled - clients for Azure Mobile Services are\nnot interchangeable with clients for Azure Mobile Apps.\n\n\n\n\nWe also need a concrete implementation of the \nICloudTable<T>\n interface (in \nServices\\AzureCloudTable.cs\n):\n\n\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudTable<T> : ICloudTable<T> where T : TableData\n    {\n        MobileServiceClient client;\n        IMobileServiceTable<T> table;\n\n        public AzureCloudTable(MobileServiceClient client)\n        {\n            this.client = client;\n            this.table = client.GetTable<T>();\n        }\n\n        #region ICloudTable implementation\n        public async Task<T> CreateItemAsync(T item)\n        {\n            await table.InsertAsync(item);\n            return item;\n        }\n\n        public async Task<T> DeleteItemAsync(T item)\n        {\n            await table.DeleteAsync(item);\n        }\n\n        public async Task<ICollection<T>> ReadAllItemsAsync()\n        {\n            return await table.ToListAsync();\n        }\n\n        public async Task<T> ReadItemAsync(string id)\n        {\n            return await table.LookupAsync(id);\n        }\n\n        public async Task<T> UpdateItemAsync(T item)\n        {\n          await table.UpdateAsync(item);\n          return item;\n        }\n        #endregion\n    }\n}\n\n\n\n\nIt's important to note here that the Azure Mobile Apps Client SDK does a lot of\nthe work for us.  In fact, we are just wrapping the basic interface here.  This\nwon't normally be the case, but you can see that the majority of the code for\ndealing with the remote server is done for us.\n\n\n\n\nYou can use a shorthand (called a lambda expression) for methods with only one line.\nFor instance, the delete method could just as easily have been written as \npublic async Task<T> DeleteItemAsync(T item) => await table.DeleteAsync(item);\n.\nYou may see this sort of short hand in samples.\n\n\n\n\nWe also need to create the model that we will use for the data.  This should\nlook very similar to the model on the server - including having the same name\nand fields.  In this case, it's \nModels\\TodoItem.cs\n:\n\n\nusing TaskList.Abstractions\n\nnamespace TaskList.Models\n{\n    public class TodoItem : TableData\n    {\n        public string Text { get; set; }\n        public bool Complete { get; set; }\n    }\n}\n\n\n\n\nWe have a final piece of code to write before we move on to the views, but it's\nan important piece.  The \nICloudService\n must be a singleton in the client.  We\nwill add authentication and offline sync capabilities in future versions of this\ncode.  The singleton becomes critical when using those features.  For right now,\nit's good practice and saves on memory if you only have one copy of the \nICloudService\n\nin your mobile client.  Since there is only one copy of the \nApp.cs\n in any\ngiven app, I can place it there.  Ideally, I'd use some sort of dependency\ninjection system or a singleton manager to deal with this.  Here is the \nApp.cs\n:\n\n\nusing TaskList.Abstractions;\nusing TaskList.Services;\nusing Xamarin.Forms;\n\nnamespace TaskList\n{\n    public class App : Application\n    {\n        public static ICloudService CloudService { get; set; }\n\n        public App()\n        {\n            CloudService = new AzureCloudService();\n            MainPage = new NavigationPage(new Pages.EntryPage());\n        }\n\n        // There are lifecycle methods here...\n    }\n}\n\n\n\n\nWe haven't written \nPages.EntryPage\n yet, but that's coming.  The original \nApp.cs\n\nclass file had several methods for handling lifecycle events like starting, suspending\nor resuming the app.  I did not touch those methods for this example.\n\n\nBuilding the UI for the App\n\n\nEarlier, I showed the mockup for my UI.  It included three pages - an entry\npage, a list page and a detail page.  These pages have three elements - a\nXAML definition file, a (simple) code-behind file and a view model.\n\n\n\n\nThis book is not intending to introduce you to everything that there is to know\nabout Xamarin and UI programming with XAML.  If you wish to have that sort of introduction,\nthen I recommend reading the excellent book by Charles Petzold: \nCreating Mobile Apps with Xamarin.Forms\n.\n\n\n\n\nI tend to use MVVM (or Model-View-ViewModel) for UI development in Xamarin\nbased applications.  It's a nice clean pattern and is well understood and\ndocumented.  In MVVM, there is a 1:1 correlation between the view and the\nview-model, 2-way communication between the view and the view-model and\nproperties within the view-model are bound directly to UI elements.  In\ngeneral (and in all my code), view-models expose an INotifyPropertyChanged\nevent to tell the UI that something within the view-model has been changed.\n\n\nTo do this, we will use a \nBaseViewModel\n class that implements the base functionality\nfor each view.  Aside from the \nINotifyPropertyChanged\n interface, there are\nsome common properties we need for each page.  Each page needs a title, for\nexample, and each page needs an indicator of network activity.  These can be\nplaced in the \nAbstractions\\BaseViewModel.cs\n class:\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\n\nnamespace TaskList.Abstractions\n{\n    public class BaseViewModel : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n        string _propTitle = string.Empty;\n        bool _propIsBusy;\n\n        public string Title\n        {\n            get { return _propTitle; }\n            set { SetProperty(ref _propTitle, value, \"Title\"); }\n        }\n\n        public bool IsBusy\n        {\n            get { return _propIsBusy; }\n            set { SetProperty(ref _propIsBusy, value, \"IsBusy\"); }\n        }\n\n        protected void SetProperty<T>(ref T store, T value, string propName, Action onChanged = null)\n        {\n            if (EqualityComparer<T>.Default.Equals(store, value))\n                return;\n            store = value;\n            if (onChanged != null)\n                onChanged();\n            OnPropertyChanged(propName);\n        }\n\n        public void OnPropertyChanged(string propName)\n        {\n            if (PropertyChanged == null)\n                return;\n            PropertyChanged(this, new PropertyChangedEventArgs(propName));\n        }\n    }\n}\n\n\n\n\nThis is a fairly common \nINotifyPropertyChanged\n interface implementation pattern.\nEach property that we want to expose is a standard property, but the \nset\n operation\nis replaced by the \nSetProperty()\n call.  The \nSetProperty()\n call deals with the\nnotification; calling the event emitter if the property has changed value.  We\nonly need two properties on the \nBaseViewModel\n: the title and the network indicator.\n\n\nI tend to write my apps in two stages.  I concentrate on the functionality of the\napp in the first stage.  There is no fancy graphics, custom UI widgets, or anything\nelse to clutter the thinking.   The page is all about the functionality of the\nvarious interactions.  Once I have the functionality working, I work on the styling\nof the page.  We won't be doing any styling work in the demonstration apps that we\nwrite during the course of this book.\n\n\nThe EntryPage has just one thing to do.  It provides a button that enters the app.\nWhen we cover authentication later on, we'll use this to log in to the backend.  If\nyou are looking at the perfect app, this is a great place to put the introductory\nscreen.\n\n\nCreating a XAML file is relatively simple.  First, create a \nPages\n directory to\nhold the pages of our application.  Then right-click on the \nPages\n directory in\nthe solution explorer and choose \nAdd\n -> \nNew Item...\n.  In the \nAdd New Item\n\ndialog, pick \nVisual C#\n -> \nCross-Platform\n -> \nForms Xaml Page\n.  Name the\nnew page \nEntryPage.cs\n.  This will create two files - \nEntryPage.xaml\n and\n\nEntryPage.xaml.cs\n.  Let's center a button on the page and wire it up with\na command.  Here is the \nPages\\EntryPage.xaml\n file:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.EntryPage\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <StackLayout HorizontalOptions=\"Center\"\n                     Orientation=\"Vertical\"\n                     VerticalOptions=\"Center\">\n            <Button BackgroundColor=\"Teal\"\n                    BorderRadius=\"10\"\n                    Command=\"{Binding LoginCommand}\"\n                    Text=\"Login\"\n                    TextColor=\"White\" />\n        </StackLayout>\n    </ContentPage.Content>\n</ContentPage>\n\n\n\n\nThere are a couple of interesting things to note here.  The \nStackLayout\n element\nis our layout element.  It occupies the entire screen (since it is a direct child\nof the content page) and the options just center whatever the contents are.  The\nonly contents are a button.\n\n\nThere are two bindings.  These are bound from the view-model.  We've already seen\nthe Title property - this is a text field that specifies the title of the page.\nThe other binding is a login command.  When the button is tapped, the login command\nwill be run.  We'll get onto that in the view-model later.\n\n\nThe other part of the XAML is the code-behind file.  Because we are moving all\nof the non-UI code into a view-model, the code-behind file is trivial:\n\n\nusing TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class EntryPage : ContentPage\n    {\n        public EntryPage()\n        {\n            InitializeComponent();\n            BindingContext = new EntryPageViewModel();\n        }\n    }\n}\n\n\n\n\nThis is a recipe that will be repeated over and over again for the code-behind\nwhen you are using a XAML-based project with MVVM.  We initialize the UI, then\nbind all the bindings to a new instantiation of the view model.\n\n\nTalking of which, the view-model needs just to handle the login click.  Note that\nthe location or namespace is \nTaskList.ViewModels\n.  I'm of two minds about location.\nThere tends to be a 1:1 relationship between the XAML file and the View Model, so\nit makes sense that they are stored together.  However, just about all the sample\ncode that I see has the view-models in a separate namespace.  Which one is correct?\nI'll go with copying the samples for now.  Here is the code for \nViewModels\\EntryPageViewModel.cs\n:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class EntryPageViewModel : BaseViewModel\n    {\n        public EntryPageViewModel()\n        {\n            Title = \"Task List\";\n        }\n\n        Command loginCmd;\n        public Command LoginCommand => loginCmd ?? (loginCmd = new Command(async () => await ExecuteLoginCommand()));\n\n        async Task ExecuteLoginCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[Login] Error = {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}\n\n\n\n\nThis is a fairly simple view-model but there are some patterns here that are\nworth explaining.  Firstly, note the way we create the \nLoginCommand\n property.\nThis is the property that is bound to the \nCommand\n parameter in the \nButton\n\nof our view.  This recipe is the method of invoking a UI action asynchronously.\nIt isn't important now, but we will want this technique repeatedly as our UI\nactions kick off network activity.\n\n\nThe second is the pattern for the \nExecuteLoginCommand\n method.  Firstly, I\nensure nothing else is happening by checking the IsBusy flag.   If nothing\nis happening, I set the IsBusy flag.  Then I do what I need to do in a try/catch\nblock.  If an exception is thrown, I deal with it.  Most of the time this\ninvolves displaying an error condition.  There are several cross-platform dialog\npackages to choose from or you can roll your own.  That is not covered here.  We\njust write a debug log statement so we can see the result in the debug log.  Once\neverything is done, we clear the IsBusy flag.\n\n\nThe only thing we are doing now is swapping out our main page for a new main\npage.  This is where we will attach authentication later on.\n\n\nThe next page is the Task List page, which is in \nPages\\TaskList.xaml\n:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.TaskList\"\n             Title=\"{Binding Title}\">\n  <ContentPage.Content>\n    <StackLayout>\n      <ListView BackgroundColor=\"#7F7F7F\"\n                CachingStrategy=\"RecycleElement\"\n                IsPullToRefreshEnabled=\"True\"\n                IsRefreshing=\"{Binding IsBusy, Mode=OneWay}\"\n                ItemsSource=\"{Binding Items}\"\n                RefreshCommand=\"{Binding RefreshCommand}\"\n                RowHeight=\"50\"\n                SelectedItem=\"{Binding SelectedItem, Mode=TwoWay}\">\n        <ListView.ItemTemplate>\n          <DataTemplate>\n            <ViewCell>\n              <StackLayout HorizontalOptions=\"FillAndExpand\"\n                           Orientation=\"Horizontal\"\n                           Padding=\"10\"\n                           VerticalOptions=\"CenterAndExpand\">\n                <Label HorizontalOptions=\"FillAndExpand\"\n                       Text=\"{Binding Text}\"\n                       TextColor=\"#272832\" />\n                <Switch IsToggled=\"{Binding Complete, Mode=OneWay}\" />\n              </StackLayout>\n            </ViewCell>\n          </DataTemplate>\n        </ListView.ItemTemplate>\n      </ListView>\n      <StackLayout HorizontalOptions=\"Center\"\n                   Orientation=\"Horizontal\">\n        <Button BackgroundColor=\"Teal\"\n                Command=\"{Binding AddNewItemCommand}\"\n                Text=\"Add New Item\"\n                TextColor=\"White\" />\n      </StackLayout>\n    </StackLayout>\n  </ContentPage.Content>\n</ContentPage>\n\n\n\n\nNote that some bindings here are one-way.  This means that the value in the\nview-model drives the value in the UI.  There is nothing within the UI that you\ncan do to alter the state of the underlying property.  Some bindings are two-way.\nDoing something in the UI (for example, toggling the switch) alters the underlying\nproperty.\n\n\nThis view is a little more complex.  It can be split into two parts - the list\nat the top of the page and the button area at the bottom of the page.  The list\narea uses a template to help with the display of each item.\n\n\nNote that the \nListView\n object has a \"pull-to-refresh\" option that I have wired\nup so that when pulled, it calls the RefreshCommand.  It also has an indicator\nthat I have wired up to the IsBusy indicator.  Anyone who is familiar with the\niOS \"pull-to-refresh\" gesture can probably guess what this does.\n\n\nThere is a view-model that goes along with the view (in \nViewModels\\TaskListViewModel.cs\n):\n\n\nusing System;\nusing System.Collections.ObjectModel;\nusing System.Collections.Specialized;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskListViewModel : BaseViewModel\n    {\n        public TaskListViewModel()\n        {\n            Title = \"Task List\";\n            RefreshList();\n        }\n\n        ObservableCollection<TodoItem> items = new ObservableCollection<TodoItem>();\n        public ObservableCollection<TodoItem> Items\n        {\n            get { return items; }\n            set { SetProperty(ref items, value, \"Items\"); }\n        }\n\n        TodoItem selectedItem;\n        public TodoItem SelectedItem\n        {\n            get { return selectedItem; }\n            set\n            {\n                SetProperty(ref selectedItem, value, \"SelectedItem\");\n                if (selectedItem != null)\n                {\n                    Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail(selectedItem));\n                    SelectedItem = null;\n                }\n            }\n        }\n\n        Command refreshCmd;\n        public Command RefreshCommand => refreshCmd ?? (refreshCmd = new Command(async () => await ExecuteRefreshCommand()));\n\n        async Task ExecuteRefreshCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                var table = App.CloudService.GetTable<TodoItem>();\n                var list = await table.ReadAllItemsAsync();\n                Items.Clear();\n                foreach (var item in list)\n                    Items.Add(item);\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskList] Error loading items: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command addNewCmd;\n        public Command AddNewItemCommand => addNewCmd ?? (addNewCmd = new Command(async () => await ExecuteAddNewItemCommand()));\n\n        async Task ExecuteAddNewItemCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                await Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskList] Error in AddNewItem: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        async Task RefreshList()\n        {\n            await ExecuteRefreshCommand();\n            MessagingCenter.Subscribe<TaskDetailViewModel>(this, \"ItemsChanged\", async (sender) =>\n            {\n                await ExecuteRefreshCommand();\n            });\n        }\n    }\n}\n\n\n\n\nThis is a combination of the patterns we have seen earlier.  The Add New Item\nand Refresh commands should be fairly normal patterns now.  We navigate to the\ndetail page (more on that later) in the case of selecting an item (which occurs\nwhen the UI sets the \nSelectedItem\n property through a two-way binding) and when\nthe user clicks on the Add New Item button.  When the Refresh button is clicked\n(or when the user opens the view for the first time), the list is refreshed.  It\nis fairly common to use an \nObservableCollection\n or another class that uses the\n\nICollectionChanged\n event handler for the list storage.  Doing so allows the UI\nto react to changes in the items.\n\n\nNote the use of the \nICloudTable\n interface here.  We are using the \nReadAllItemsAsync()\n\nmethod to get a list of items, then we copy the items we received into the \nObservableCollection\n.\n\n\nFinally, there is the TaskDetail page.  This is defined in the \nPages\\TaskDetail.xaml\n\nfile:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.TaskDetail\"\n             Title=\"{Binding Title}\">\n  <ContentPage.Content>\n    <StackLayout Padding=\"10\" Spacing=\"10\">\n      <Label Text=\"What should I be doing?\"/>\n      <Entry Text=\"{Binding Item.Text}\"/>\n      <Label Text=\"Completed?\"/>\n      <Switch IsToggled=\"{Binding Item.Complete}\"/>\n      <StackLayout VerticalOptions=\"CenterAndExpand\"/>\n      <StackLayout Orientation=\"Vertical\" VerticalOptions=\"End\">\n        <StackLayout HorizontalOptions=\"Center\" Orientation=\"Horizontal\">\n          <Button BackgroundColor=\"#A6E55E\"\n                  Command=\"{Binding SaveCommand}\"\n                  Text=\"Save\" TextColor=\"White\"/>\n          <Button BackgroundColor=\"Red\"\n                  Command=\"{Binding DeleteCommand}\"\n                  Text=\"Delete\" TextColor=\"White\"/>\n        </StackLayout>\n      </StackLayout>\n    </StackLayout>\n  </ContentPage.Content>\n</ContentPage>\n\n\n\n\nThis page is a simple form with just two buttons that need to have commands\nwired up.  However, this page is used for both the \"Add New Item\" gesture\nand the \"Edit Item\" gesture.  As a result of this, we need to handle the\npassing of the item to be edited.  This is done in the \nPages\\TaskDetail.xaml.cs\n\ncode-behind file:\n\n\nusing TaskList.Models;\nusing TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class TaskDetail : ContentPage\n    {\n        public TaskDetail(TodoItem item = null)\n        {\n            InitializeComponent();\n            BindingContext = new TaskDetailViewModel(item);\n        }\n    }\n}\n\n\n\n\nThe item that is passed in from the \nTaskList\n page is used to create a\nspecific view-model for that item.  The view-model is similarly configured\nto use that item:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskDetailViewModel : BaseViewModel\n    {\n        ICloudTable<TodoItem> table = App.CloudService.GetTable<TodoItem>();\n\n        public TaskDetailViewModel(TodoItem item = null)\n        {\n            if (item != null)\n            {\n                Item = item;\n                Title = item.Text;\n            }\n            else\n            {\n                Item = new TodoItem { Text = \"New Item\", Complete = false };\n                Title = \"New Item\";\n            }\n        }\n\n        public TodoItem Item { get; set; }\n\n        Command cmdSave;\n        public Command SaveCommand => cmdSave ?? (cmdSave = new Command(async () => await ExecuteSaveCommand()));\n\n        async Task ExecuteSaveCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id == null)\n                {\n                    await table.CreateItemAsync(Item);\n                }\n                else\n                {\n                    await table.UpdateItemAsync(Item);\n                }\n                MessagingCenter.Send<TaskDetailViewModel>(this, \"ItemsChanged\");\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskDetail] Save error: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command cmdDelete;\n        public Command DeleteCommand => cmdDelete ?? (cmdDelete = new Command(async () => await ExecuteDeleteCommand()));\n\n        async Task ExecuteDeleteCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id != null)\n                {\n                    await table.DeleteItemAsync(Item);\n                }\n                MessagingCenter.Send<TaskDetailViewModel>(this, \"ItemsChanged\");\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskDetail] Save error: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}\n\n\n\n\nThe save command uses the \nICloudTable\n interface again - this time doing\neither \nCreateItemAsync()\n or \nUpdateItemAsync()\n to create or update the\nitem.  The delete command, as you would expect, deletes the item with the\n\nDeleteItemAsync()\n method.\n\n\nThe final thing to note from our views is that I am using the \nMessagingCenter\n\nto communicate between the TaskDetail and TaskList views.  If I change the item\nin the \nTaskDetail\n list, then I want to update the list in the \nTaskList\n view.\n\n\nNote that all the code we have added to the solution thus far is in the common\n\nTaskList\n project.  Nothing is required for this simple example in a platform\nspecific project.  That isn't normal, as we shall see.\n\n\nBuilding the Client for Universal Windows\n\n\nI tend to start by building the Universal Windows mobile client.  I'm using\nVisual Studio, after all, and I don't need to use any emulator.  To build the\nclients:\n\n\n\n\nRight-click on the \nTaskList.UWP (Universal Windows)\n project, then select \nSet as StartUp Project\n.\n\n\nRight-click on the \nTaskList.UWP (Universal Windows)\n project again, then select \nBuild\n.\n\n\nOnce the build is complete, Right-click on the \nTaskList.UWP (Universal Windows)\n project again, then select \nDeploy\n.\n\n\nClick on the \nLocal Machine\n button in your command bar to run the application.\n\n\n\n\nHere are the three screen screens we generated on Windows:\n\n\n\n\nThere are some problems with the UWP version.  Most notably, the \"pull-to-refresh\"\ngesture does not exist, so we will need to set up an alternate gesture.  This\ncould be as easy as adding a refresh button right next to the Add New Item\nbutton.  In addition, there is no indication of network activity - this manifests\nas a significant delay between the TaskList page appearing and the data appearing\nin the list.\n\n\nAside from this, I did do some styling work to ensure that the final version\nlooked like my mock-ups (with the exception of the UI form of the switch, which\nis platform dependent).  If you want to see what I did to correct this, check out\nthe final version of \nthe Chapter 1 sample\n on GitHub.\n\n\nIf you need to build the project, ensure you redeploy the project after building.\nIt's a step that is easy to miss and can cause some consternation as you change\nthe code and it doesn't seem to have an effect on the application.\n\n\nBuilding the Client for Android\n\n\nBuilding Android with Visual Studio is as easy as building the Universal Windows\nversion of the mobile client:\n\n\n\n\nRight-click on the \nTaskList.Droid\n project, then select \nSet as StartUp Project\n.\n\n\nRight-click on the \nTaskList.Droid\n project again, then select \nBuild\n.\n\n\n\n\nThe button for running the application has a drop-down that is now significant.\nIt lets you choose the type of device that you will use.  Normally, this runs\neither a 5\" or 7\" KitKat-based Android device.  There is some setup required for\nthe Visual Studio Emulator for Android.  The Visual Studio Emulator for Android\nruns within Hyper-V, so you must install Hyper-V before use.  You get the following\nerror if you don't do this:\n\n\n\n\nTo install Hyper-V:\n\n\n\n\nClose all applications (your system will be rebooted during this process).\n\n\nSearch for \nPrograms and Features\n.\n\n\nClick on \nTurn Windows features on or off\n (in the left-hand menu).\n\n\nExpand the \nHyper-V\n node.\n\n\nCheck all the boxes below the \nHyper-V\n node.  This will include Hyper-V Management Tools and Hyper-V Services.\n\n\nClick on \nOK\n.\n\n\nYour system will install the required pieces and then ask you to restart.  Click on \nRestart now\n when prompted.\n\n\n\n\nOnce you have done this, the next hurdle is to be added to the Hyper-V Administrators\nsecurity group.  It gets done for you (again - the first time you try to run the\napplication after installing Hyper-V).  Once it is done, close Visual Studio (again),\nthe log out and back in again.\n\n\nAs if that wasn't enough, the emulator also needs an Internet connection to\nstart.\n\n\n\n\nYou should be able to just click on \nYes\n or \nOK\n to enable the Internet\nconnection.  My laptop required a reboot before this would work, however.  In\naddition, the process may request elevated privileges.\n\n\n\n\nIf you want to run additional Android profiles before starting, run the \nVisual Studio Emulator for Android\n and download any additional profiles.  For example, if you wish to emulate something similar to a Samsung Galaxy S6, then download the profile for a 5.1\" Marshmallow (6.0.0) XXHDPI Phone.\n\n\n\n\nFinally the Visual Studio Emulator for Android starts when you click on the Run\nbutton.  Fortunately, the setup of the emulator only has to be done once per\nmachine.  The Visual Studio Emulator for Android is also a superior emulator\nto the standard Android Emulator, so this process is well worth going through.\n\n\n\n\nWhen testing the mobile client manually through the Visual Studio Emulator for Android, you are likely to need to rebuild the application.  You do not have to shut down the emulator between runs.  You can leave it running.  The application will be stopped and replaced before starting again.  This can significantly speed up the debug cycle since you are not waiting for the emulator to start each time.\n\n\n\n\nWatch the Output window.  If the debugger won't connect or the application\nwon't start, you may need to restart your computer again to get the network\nworking.\n\n\n\n\nIf your computer doesn't run Hyper-V well (or at all), then the emulator won't run well (or at all) either.  I find laptops to be particularly prone to this problem.  If this happens, you can always run the Google Emulator instead.  Build the application as normal.  You will find the APK file to install in \n...\\TaskList.Droid\\bin\\Debug\n. Fortunately, there are lots of resources that show how to do this.  You can find the answer on \nStack Overflow\n\n\n\n\nIf everything is working, you should see the Visual Studio Emulator for Android\ndisplay your mobile client:\n\n\n\n\n\n\nYou can also build the Android version on a mac with Xamarin Studio.  However, I find that version mismatches between Mono (which is used on the mac) and Visual Studio - particularly in reference to the version of the .NET framework - cause issues when swapping between the two environments.  For best results, stay in one environment.\n\n\n\n\nNote that the task list view is a \"light\" style and the rest of the app is a\n\"dark\" style.  This is because the default styling on an Android device is\ndark.  We are using the default styling on two of the pages and specifying\ncolors on the list page.  Fortunately, Xamarin Forms allows for \nplatform-specific\nstyling\n.  The \nfinal sample\n has platform-specific styling for the\nlist page.\n\n\nBuilding the Client for iOS\n\n\nFinally, we get to the iOS platform.  You will need to ensure your Mac is turned\non and accessible, that it has XCode installed (and you have run XCode once so\nthat you can accept the license agreement), and it has Xamarin Studio installed.\n\n\nWhen you created the projects, you were asked to link Visual Studio to your mac.\nThis linkage is used for building the project.  In essence, the entire project\nis sent to the Mac and the build tools that are supplied with Xamarin Studio\nwill be used to build the project.\n\n\n\n\nRight-click on the \nTaskList.iOS\n project and select \nSet as StartUp Project\n.\n\n\nRight-click on the \nTaskList.iOS\n project and select \nBuild\n.\n\n\n\n\nYou knew it was not going to be that easy, right?  Here are the errors that I\nreceived when building for the first time:\n\n\n\n\nThere are two errors right at the top.  Let's cover the first one.  The error\nabout \nBuild Action 'EmbeddedResource' is not supported\n is an annoying one.\nThe fix is to do the following:\n\n\n\n\nSet the iOS project as the StartUp project.\n\n\nGo through each project, expand the \nReferences\n node and ensure that there are no references with a warning (a little yellow triangle).  If there are - fix those first.  Generally, this is fixed by either using the \nRestore NuGet Packages\n option or removing the reference and then adding it again from NuGet.\n\n\nClose the solution.\n\n\nRe-open the solution.  You don't need to close Visual Studio to do this.\n\n\nRight-click on the iOS project and select \nClean\n.\n\n\nRight-click on the iOS project and select \nRebuild\n.\n\n\n\n\nOnce you have done this sequence, the error should go away.\n\n\nThe error about \nNo valid iOS code signing keys found in keychain\n is because\nwe have not yet signed up for an Apple Developer Account and linked it to our\nMac development environment.\n\n\n\n\nGo to the \nApple Developer Center\n.\n\n\nClick on \nAccount\n in the top navigation bar.\n\n\nIf you haven't got an Apple ID yet, create one first.\n\n\nIf you have go an Apple ID, then log in.\n\n\n\n\nThere are a sequence of sign-up prompts in both cases (first for creating your\nApple ID and secondly for signing up for the Apple Developer program).  Once\nyou have gone through this process, you are registered as an Apple Developer.\n\n\n\n\nIf you want to distribute your apps on the Apple App Store, run on real devices or get access to the beta bits, then you might consider signing up for the Apple Developer Program.  The Apple Developer Program is an additional cost and is not required for developing iOS apps that are only run on the iOS simulator.\n\n\n\n\nOnce you have created your account and enabled it as a developer account, open\nup XCode.  Go to \nPreferences...\n, then \nAccount\n and\nclick on the \n+\n in the bottom-left corner of the window:\n\n\n\n\nSign in with the same account you used to sign up for the developer account.\n\n\n\n\nClick on the \nView Details\n button.  This will bring up the Signing Identities\nlist.  For a free account, it looks like this:\n\n\n\n\nClick on the Create button next to \niOS Development\n.  Once the UI comes back,\nclick on \nDone\n.  For more information on this process, refer to the \nApple Documentation\n.\n\n\nYou can close XCode at this point.  Ensure Xamarin Studio is not running.  Back\nwithin Visual Studio, right-click on the \nTaskList.iOS\n project and select \nRebuild\n.\nThis will (finally!) build the application for you.\n\n\n\n\nGetting an error about \nProvisioning Profiles\n not being available?  This is because you are building for a real device instead of the simulator.  In order to build for a real device, you must have a linked Apple Developer Program.  To get around this, select a Simulator before building.\n\n\n\n\nThe \nRun\n button has received a \nDevice\n label, but there are several simulator options.\nYou should only use \nDevice\n if you have signed up for the Apple Developer Program.  Pick\none of the simulator options like the \niPhone 6 iOS 9.3\n simulator, then click on it\nto run the simulator.  Before long, you should see the following:\n\n\n\n\nAt some point, you will need a platform initialization call on all platforms.  It's best to\nadd it now.  In TaskList.Droid, this should be added in \nMainActivity.cs\n and in TaskList.iOS,\nit's \nAppDelegate.cs\n.  In each of these files, there is a line that initializes the Xamarin\nForms system.\n\n\n// Android Version\nglobal::Xamarin.Forms.Forms.Init(this, bundle);\n// iOS Version\nglobal::Xamarin.Forms.Forms.Init ();\n\n\n\n\nImmediately before this line, you should add the  initializer for Azure Mobile Apps. It's\nimportant that the Azure Mobile Apps subsystem is initialized prior to Xamarin Forms being\ninitialized and any UI code being called.\n\n\nMicrosoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n\n\n\nThis initializer is not required on the UWP project.  Once this is done and you have re-built\nthe project, we can see the fruits of our labor.  You can, of course, run the IPA in the\niOS simulator on the Mac.  However, it's much more satisfying (to me, at least) to be able\nto do everything from within Visual Studio.  For this, you need to install the\n\nXamarin Installer\n.  This is an MSI for your Windows development system and is\nquickly installed.  Once installed, start (or restart) Visual Studio, select \nTools\n ->\n\nOptions\n.  Search for \nXamarin\n, and select the \niOS Settings\n page.  There is\na new option:\n\n\n\n\nNote the \nRemote Simulator to Windows\n.  This should be checked.  You may need to\nrebuild the TaskList.iOS project after installing the Xamarin Simulator.  The debug\nwindow will tell you if this is the case.  There are also a few \nknown issues\n\nso check the documentation if you run into problems.\n\n\nThe final product screens look like this:\n\n\n\n\nSome Final Thoughts\n\n\nIf you have got through the entire process outlined in this Chapter and built the application\nfor each platform, then congratulations.  There are a lot of places where things can go\nwrong.  You are really integrating the build systems across Visual Studio, Android, Xamarin,\nand XCode.\n\n\nFortunately, once these are set up, it's likely that they will continue working and you\nwon't have to think too much about them again. The Android and iOS build tools and simulators\nwill just work.\n\n\nIf you would rather develop code on your mac, the next chapter is for you - it gets into\nthe nitty gritty of developing the exact same app, but using Xamarin Studio instead.\n\n\nThe following 7 chapters each take one aspect of the cloud services that can be provided to\nmobile apps and explores it in detail, using an Azure Mobile App as a beginning. You can\njump around at this point, but be aware that we expect you to cover these topics in order.\nIf you do the data chapter before covering authentication, it's likely you will have missed\nimportant functionality in your app to complete the work.",
            "title": "Your First App - PC Edition"
        },
        {
            "location": "/chapter1/firstapp_pc/#your-first-mobile-app",
            "text": "There is a lot of detail to absorb about the possible services that the mobile\nclient can consume and I will go into significant depth on those subjects.\nFirst, wouldn't it be nice to write some code and get something working?\nMicrosoft Azure has a great  first-steps tutorial  that takes you via the\nquickest possible route from creating a mobile backend to having a functional\nbackend.  I would like to take things a little slower so that we can understand\nwhat is going on while we are doing the process.  We will have practically the\nsame application at the end.  The primary reason for going through this slowly\nis to ensure that all our build and run processes are set up properly.  If this\nis the first mobile app you have ever written, you will see that there are quite\na few things that need to be set up.  This chapter covers the set up required\nfor a Windows PC.  If you wish to develop your applications on a Mac, then skip\nto the  next section .  The application we are going to build together is a simple task list.  The\nmobile client will have three screens - an entry screen, a task list and a task\ndetails page.  I have mocked these pages up using  MockingBot .   Mocking your screens before you start coding is a great habit to get into.\nThere are some great tools available including free tools like  MockingBot .\nDoing mockups before you start coding is a good way to prevent wasted time later\non.     Why include a back button?  If you are using iOS, then you may want to remove\nthe back button as the style guides suggest you don't need one.  Other platforms\nwill need it though, so it's best to start with the least common denominator.\nIt's the same reason I add a refresh button even though it's only valid on\nWindows Phone!   My ideas for this app include:   Tapping on a task title in the task list will bring up the details page.  Toggling the completed link in the task list will set the completed flag.  Tapping the spinner will initiate a network refresh.   Now that we have our client screens planned out, we can move onto the thinking\nabout the mobile backend.",
            "title": "Your First Mobile App"
        },
        {
            "location": "/chapter1/firstapp_pc/#the-mobile-backend",
            "text": "The mobile backend is an ASP.NET WebApi that is served from within Azure App\nService: a highly scalable and redundant web hosting facility that supports all\nthe major web languages (like ASP.NET, Node, PHP and Python).  Azure Mobile\nApps is an SDK (which is available in ASP.NET and Node) that runs on top of\nAzure App Service.",
            "title": "The Mobile Backend"
        },
        {
            "location": "/chapter1/firstapp_pc/#creating-a-simple-azure-mobile-apps-backend",
            "text": "Microsoft Azure has included a comprehensive starter kit template in the\nAzure SDK.  To get started:   Fire up Visual Studio 2015  Add a new project with File -> New Project...   In the  New Project  window:   Open up Templates -> Visual C# -> Web and select  ASP.NET Web Application (.NET Framework) .  Enter  Backend  for the Name and  Chapter1  for the Solution name.  Pick a suitable directory for the Location field.  Click on OK.      In the  New ASP.NET Web Application  window:   Click on  Azure Mobile App .  Do  NOT  check \"Host in the cloud\" or any other checkboxes.  Click on OK.     At this point, Visual Studio will create your backend project.   It's very tempting to select  Azure Mobile Services  instead - it sounds\ncloser to what you want.  Azure Mobile Services is the  OLD  service and is\nbeing shut down.  You should not select Azure Mobile Services for any project.   There are a few files of which you should take note.  The Mobile Apps SDK is\ninitialized within  App_Start\\Startup.MobileApp.cs  (with the call to the\nconfiguration routine happening within  Startup.cs ).  The default startup\nroutine is reasonable but it hides what it is doing behind extension methods.\nThis technique is fairly common in ASP.NET programs.  Let's expand the\nconfiguration routine to only include what we need:  public static void ConfigureMobileApp(IAppBuilder app)\n{\n    var config = new HttpConfiguration();\n    var mobileConfig = new MobileAppConfiguration();\n\n    mobileConfig\n        .AddTablesWithEntityFramework()\n        .ApplyTo(config);\n\n    Database.SetInitializer(new MobileServiceInitializer());\n\n    app.UseWebApi(config);\n}  The minimal version of the mobile backend initialization is actually shorter\nthan the original.  It also only includes a data access layer.  Other services\nlike authentication, storage and push notifications are not configured.  There is another method in the  App_Start\\Startup.MobileApp.cs  file for\nseeding data into the database for us.  We can leave that alone for now, but\nremember it is there in case you need to seed data into a new database for\nyour own backend.   We refer to \"seeding data\" into a database.  This means that we are going to introduce some data into the database so that we aren't operating on an empty database.  The data will be there when we query the database later on.   The next important file is the  DbContext  - located in Models\\MobileServiceContext.cs . Azure Mobile Apps is heavily dependent on Entity Framework v6.x  and the  DbContext  is a central part of that\nlibrary.  Fortunately, we don't need to do anything to this file right now.  Finally, we get to the meat of the backend.  The whole point of this\ndemonstration is to project a single database table - the TodoItem table - into\nthe mobile realm with the aid of an opinionated  OData v3  feed.  To that\nend, we need three items:   A  DbSet<>  within the  DbContext  A Data Transfer Object (or DTO)  A Table Controller   When we create the project, a sample of each one of these for the TodoItem table\nis added for us.  You can see the  DbSet<>  in the  Models\\MobileServiceContext.cs \nfile, for example.  Let's take a look at the DTO and Table Controller for this\nexample table as well.  The DTO for the TodoItem table is located within the DataObjects  directory:  using Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.DataObjects\n{\n    public class TodoItem : EntityData\n    {\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n    }\n}  Note that the model uses  EntityData  as a base class.  The  EntityData  class\nadds five additional properties to the class - we'll discuss those in more\ndetails during the  Data Access and Offline Sync  chapter.  Finally, let's look at the table controller for the example TodoItem table.  This\nis located in  Controllers\\TodoItemController.cs :  using System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}  The  TableController  is the central processing for the database access layer.\nIt handles all the OData capabilities for us and exposes these as REST endpoints\nwithin our WebAPI.  This means that the actual code for this controller is tiny - just 12 lines of code.   OData  is a specification for accessing table data on the Internet.  It provides a mechanism for querying and manipulating data within a table.  Entity Framework is a common data access layer for ASP.NET applications.   We can build the project at this point.  If Visual Studio hasn't done so already,\nthe missing NuGet packages for Azure Mobile Apps will be downloaded.  There\nshould not be any errors.  If there are, check the typing for any changes you\nmade.   You can delete or ignore the  Controllers\\ValuesController.cs  file if you like - it isn't important for this walkthrough.",
            "title": "Creating a Simple Azure Mobile Apps Backend"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-an-azure-app-service-for-mobile-apps",
            "text": "The next step in the process is to build the resources on Azure that will\nrun your mobile backend.  Start by logging into the  Azure Portal , then\nfollow these instructions:   Click on the big  + New  button in the top-left corner.  Click on  Web + Mobile , then  Mobile App .   Enter a unique name in the  App name  box.   Since the name doesn't matter and it has to be unique, you can use  a\nGUID generator  to generate a unique name. GUIDs are not the best\nnames to use when you need to actually find resources, but using GUIDS\nprevents conflicts when deploying, so I prefer them as a naming scheme.\nYou can prefix the GUID  (example: chapter1-GUID) to aid in discovery\nlater on.  Generally, the first four digits of a GUID are enough to\nidentify individual resources.     If you have more than one subscription (for example, you have a trial\n   and an MSDN subscription), then ensure you select the right subscription\n   in the  Subscription  drop-down.    Select  Create new  under resource group and enter a name for this\n   mobile application.   Resource groups are great for grouping all the resources associated with a mobile application together.  During development, it means you can delete all the resources in one operation.  For production, it means you can see how much the service is costing you and how the resources are being used.     Finally, select or create a new  App Service Plan .   The App Service Plan is the thing that actually bills you - not the web or mobile backend.  You can run a number of web or mobile backends on the same App Service Plan.   I tend to create a new App Service Plan for each mobile application.  This\nis because the App Service Plan lives inside the Resource Group that you\ncreate.  The process for creating an App Service Plan is straight forward.\nYou have two decisions to make.  The first decision is where is the service\ngoing to run.  In a production environment, the correct choice is \"near your\ncustomers\".  \"Close to the developers\" is a good choice during development.\nUnfortunately, neither of those is an option you can actually choose in the\nportal, so you will have to translate into some sort of geographic location.\nWith 16 regions to choose from, you have a lot of choice.  The second decision you have to make is what to run the service on; also\nknown as the Pricing tier.   If you click on  View all , you will see you\nhave lots of choices.  F1 Free and D1 Shared, for example, run on shared\nresources and are CPU limited. You should avoid these as the service will\nstop responding when you are over the CPU quota.  That leaves Basic,\nStandard and Premium.  Basic has no automatic scaling and can run up to 3\ninstances - perfect for development tasks.  Standard and Premium both have\nautomatic scaling, automatic backups, and large amounts of storage; they\ndiffer in features: the number of sites or instances you can run on them,\nfor example.  Finally, there is a number after the plan.  This tells you how\nbig the virtual machine is that the plan is running on.  The numbers differ\nby number of cores and memory.  For our purposes, an F1 Free site is enough to run this small demonstration\nproject.  More complex development projects should use something in the\nBasic range of pricing plans.  Production apps should be set up in Standard\nor Premium pricing plans.    Once you have created your app service plan and saved it, click on  Create .    The creation of the service can take a couple of minutes.  You can monitor the\nprocess of deployment by clicking on the Notifications icon.  This is in the top\nbar on the right-hand side and looks like a Bell.  Clicking on a specific\nnotification will provide more information about the activity.  Once you have\ncreated your app service, the App Service blade will open.   What's the difference between a Web App, a Mobile App and an API App?  Not a\nlot.  The type determines which Quick start projects are available in the Quick\nstart menu under  All settings .  Since we selected a Mobile app, a set of\nstarter client projects for mobile devices will be presented.   We will also want a place to store our data.  This role is taken on by a\nSQL Azure instance.  We could link an existing database if we had one\ndefined.  However, we can also create a test database.   Creating a Test Database through the App Service Data Connections (as\nI describe here) allows you to create a free database.  This option is\nnot normally available through other SQL database creation flows.    Click on  Resource groups  in the left hand side menu.  Click on the resource group you created.  Click on the App Service your created.   Click on  All settings .   If you pinned your App Service to the dashboard, you can click on the\npinned App Service instead.  It will bring you to the same place.     Click on  Data connections  in the  MOBILE  menu.    Click on  Add .   In the  Type  box, select  SQL Database .  Click on the unconfigured  SQL Database  link:     In the  Database  blade, select  Create a new database .  Enter a name for the database (like  chapter1-db ).  Select a Pricing Tier (look for  F Free  at the bottom).  Click on the unconfigured  Server .     Enter a unique name for the server (a GUID is a good idea here).  Enter a username and password for the server.  Click on  OK  to close the  New Server  blade.  Click on  OK  to close the  New Database  blade.  Click on  OK  to close the  Add Data Connection  blade.     This produces another deployment step that creates a SQL Server and a SQL\ndatabase with your settings.  Once complete, the connection MS_TableConnectionString  will be listed in Data Connections blade.    If you want a completely free mobile backend, search for the  Mobile\nApps Quickstart  in the Azure Marketplace.  This template does not\nrequire a database.  It relies on a Node backend, however, so you won't\nbe developing a C# backend.",
            "title": "Building an Azure App Service for Mobile Apps"
        },
        {
            "location": "/chapter1/firstapp_pc/#deploying-the-azure-mobile-apps-backend",
            "text": "Deploying to Azure as a developer can be accomplished while entirely within\nVisual Studio:   Right-click on the  Backend  project, then select  Publish... .   Make sure you see this screen shot:   If you do not see this image, then it is likely you have an older version\nof the Azure SDK installed.  Make sure the Azure SDK version is v2.9 or\nlater.    Click on  Microsoft Azure App Service .   You may be prompted to enter your Azure credentials here.  Enter the same\n    information that you enter to access the Azure Portal.  In the lower box, expand the resource group that you created and select the\n    app service you created in the portal.  Click on  OK .  Click on  Publish .   Visual Studio will open a browser.  Add  /tables/todoitem?ZUMO-API-VERSION=2.0.0 \nto the end of the URL.  This will show the JSON contents of the table that we\ndefined in the backend.   You will see the word ZUMO all over the SDK, including in optional HTTP headers\nand throughout the SDK source code.  ZUMO was the original code name within Microsoft\nfor A ZU re  MO bile.",
            "title": "Deploying the Azure Mobile Apps Backend"
        },
        {
            "location": "/chapter1/firstapp_pc/#the-mobile-client",
            "text": "Now that the mobile backend is created and deployed, we can move onto the client\nside of things.  First of all, let's prepare the Visual Studio instance.  If you\nhave installed the Cross-Platform Mobile tools during the installation, most of\nthe work has already been done.  However, you may want to install the  Xamarin\nForms Templates  using the Tools -> Extensions and Updates...   This template pack provides additional templates for Xamarin Forms development\nthat I find useful.  Most notably, there is a specific template for a mobile\ncross-platform project covering the Android, iOS and UWP mobile platforms.   When you compile a Xamarin.Forms application for a specific platform, you are\nproducing a true native application for that platform - whether it be iOS,\nAndroid or Windows.",
            "title": "The Mobile Client"
        },
        {
            "location": "/chapter1/firstapp_pc/#creating-a-simple-mobile-client-with-xamarin",
            "text": "Now that we have prepared your Visual Studio instance, we can create the\nproject. Right-click on the solution and select  Add  ->  New Project... .\nThis will bring up the familiar New Project dialog.  The project you want is\nunder  Visual C#  ->  Cross-Platform , and is called  Xamarin.Forms\n(UWP/Android/iOS) .  If you did not install the Xamarin Forms Template add-on,\nthen choose the  Blank Xaml App (Xamarin.Forms Portable)  project.  Give the\nproject a name, then click on  OK .    If you did not install the Xamarin Forms Templates, then you can create a Blank Xaml App (Xamarin.Forms Portable)  project instead.   Project creation will take longer than you expect, but there is a lot going on.\nIf you have never created a mobile or UWP project before, you will be prompted\nto turn on Windows 10 Developer Mode:   Developer mode in Windows 10 allows you to run unsigned binaries for development\npurposes and to turn on debugging so that you can step through your UWP programs\nwithin Visual Studio.  We will also get asked to choose what version of the Universal Windows platform\nwe want to target:   Version 10240 was the first version of Windows 10 that was released to the general\npublic, so that's a good minimum version to pick.  In general, the defaults for\nthe Universal Windows Platform choice are good enough.  Xamarin allows us to build iOS applications directly from Visual Studio. For\nthis to work, we must have access to a Mac. This could be anything from a\nMacBook Air/Pro, to a Mac Mini in a drawer or closet in the office, or maybe\neven a  Mac in the cloud .  The Xamarin tools use SSH to connect to the Mac,\nwhich must be  configured to build iOS apps from Visual Studio .   If you don't have a Mac and are not interested in building iOS applications,\ndon't give up now!  You can cancel through the Mac specific project setup and\ncontinue with building a great Android and Universal Windows app.  You can\ndelete the iOS specific project after it has been created.   When prompted about the Xamarin Mac Agent, click on  OK  to get the list of\nlocal mac agents:   Highlight your mac (in case there are multiples), then click on  Connect... .\nIf your mac is not listed or you are using a Mac in the cloud, then you can\nalways enter the IP address for your mac.   For more troubleshooting tips, visit  https://developer.xamarin.com/guides/ios/getting_started/installation/windows/connecting-to-mac/troubleshooting/   You will be prompted for your username and password:   Just enter the username and password that you use to log in to your mac and click\non  Login .   What's my username?   Apple tries very hard to hide the real username of\nyour account from you.  The easiest way to find your mac username is to open up\nthe Finder.  The name next to your home icon is the name of your account.   If the connection has successed, you will see a green icon in the Xamarin Visual\nStudio toolbar area. It may take a minute or two to connect and verify that the\nmac can be used.  Once the project is created, you will see that four new projects have been\ncreated: a common library which you named plus one project for each platform\nthat has been chosen.  Since we chose a project with three platforms, we get\nfour projects:   Most of our work will happen in the common library.  However, we can introduce\nplatform-specific code at any point.  The platform-specific code is stored in\nthe platform-specific project.  There is one final item we must do before we leave the set up of the project.\nThere are a number of platform upgrades that inevitably have to happen.  The\nXamarin Platform is updated much more often than the Visual Studio plugin - the\nupdates are released via NuGet: the standard method of distributing libraries\nfor .NET applications.  In addition to the inevitable Xamarin Platform update,\nwe also will want to add the following NuGet packages:   Microsoft.Azure.Mobile.Client v2.0.0 or later  Newtonsoft.Json v6.0.3 or later    Although it is tempting, do not include a v1.x version of the Mobile Client.\nThis is for the earlier Azure Mobile Services.  There are many differences between\nthe wire protocols of the two products.   You can install the NuGet packages by right-clicking on the project and selecting Manage NuGet Packages... .   You must install the updates and the new NuGet packages on all four projects.\nThis involves repeating the same process for each client project in your\nsolution.   Android generally has more updates than the other platforms.  Ensure that you\nupdate the main Xamarin.Forms package and then refresh the update list.  This will\nensure the right list of packages is updated.",
            "title": "Creating a Simple Mobile Client with Xamarin"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-the-common-library",
            "text": "There are two parts that we must concentrate on within the common library.  The\nfirst is the connection to Azure Mobile Apps and the second is in the pages\nthat the user interacts with.  In both cases, there are best practices to observe.",
            "title": "Building the Common Library"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-an-azure-mobile-apps-connection",
            "text": "We will rely on interfaces for defining the shape for the class for any service\nthat we interact with.  This is really not important in small projects like this\none.  This technique allows us to mock the backend service, as we shall see\nlater on.  Mocking the backend service is a great technique to rapidly iterate\non the front end mobile client without getting tied into what the backend is doing.  Let's start with the cloud service - this is defined in Abstractions\\ICloudService.cs .  It is basically used for initializing\nthe connection and getting a table definition:  namespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        public ICloudTable<T> GetTable<T>() where T : TableData;\n    }\n}  There is a dependent implementation here: the  ICloudTable  generic interface.  This\nrepresents a CRUD interface into our tables and is defined in  Abstractions\\ICloudTable.cs :  using System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudTable<T> where T : TableData\n    {\n        Task<T> CreateItemAsync(T item);\n        Task<T> ReadItemAsync(string id);\n        Task<T> UpdateItemAsync(T item);\n        Task DeleteItemAsync(T item);\n\n        Task<ICollection<T>> ReadAllItemsAsync() where T : TableData;\n    }\n}  The  ICloudTable<T>  interface defines the normal CRUD operations: Create, Read,\nUpdate and Delete.  However, it does so asynchronously.  We are dealing with network\noperations in general so it is easy for those operations to tie up the UI thread\nfor an appreciable amount of time.  Making them async provides the ability to\nrespond to other events.  I also provide a  ReadAllItemsAsync()  method that\nreturns a collection of all the items.  There are some fields that every single record within an Azure Mobile Apps table\nprovides.  These fields are required for offline sync capabilities like incremental\nsync and conflict resolution.  The fields are provided by an abstract base class\non the client called  TableData :  using System;\n\nnamespace TaskList.Abstractions\n{\n    public abstract class TableData\n    {\n        public string Id { get; set; }\n        public DateTimeOffset? UpdatedAt { get; set; }\n        public DateTimeOffset? CreatedAt { get; set; }\n        public byte[] Version { get; set; }\n    }\n}  As we will learn when we deal with  table data , these fields need to\nbe defined with the same name and semantics as on the server.  Our model on\nthe server was sub-classed from  EntityData  and the  EntityData  class on the\nserver defines these fields.  It's tempting to call the client version of the class the same as the server\nversion.  If we did that, the models on both the client and server would look\nthe same.  However, I find that this confuses the issue.  The models on the\nclient and server are not the same.  They are missing the  Deleted  flag and\nthey do not contain any relationship information on the client.  I choose to\ndeliberately call the base class something else on the client to avoid this\nconfusion.  We will be adding to these interfaces in future chapters as we add more\ncapabilities to the application.  The concrete implementations of these classes are similarly easily defined.  The\nAzure Mobile Apps Client SDK does most of the work for us.  Here is the concrete\nimplementation of the  ICloudService  (in  Services\\AzureCloudService.cs ):  using Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(\"https://my-backend.azurewebsites.net\");\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData\n        {\n            return new AzureCloudTable<T>(client);\n        }\n    }\n}  The Azure Mobile Apps Client SDK takes a lot of the pain out of communicating\nwith the mobile backend that we have already published.  Just swap out the\nname of your mobile backend and the rest is silently dealt with.   The name  Microsoft.WindowsAzure.MobileServices  is a hold-over from the old Azure\nMobile Services code-base.  Don't be fooled - clients for Azure Mobile Services are\nnot interchangeable with clients for Azure Mobile Apps.   We also need a concrete implementation of the  ICloudTable<T>  interface (in  Services\\AzureCloudTable.cs ):  using System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudTable<T> : ICloudTable<T> where T : TableData\n    {\n        MobileServiceClient client;\n        IMobileServiceTable<T> table;\n\n        public AzureCloudTable(MobileServiceClient client)\n        {\n            this.client = client;\n            this.table = client.GetTable<T>();\n        }\n\n        #region ICloudTable implementation\n        public async Task<T> CreateItemAsync(T item)\n        {\n            await table.InsertAsync(item);\n            return item;\n        }\n\n        public async Task<T> DeleteItemAsync(T item)\n        {\n            await table.DeleteAsync(item);\n        }\n\n        public async Task<ICollection<T>> ReadAllItemsAsync()\n        {\n            return await table.ToListAsync();\n        }\n\n        public async Task<T> ReadItemAsync(string id)\n        {\n            return await table.LookupAsync(id);\n        }\n\n        public async Task<T> UpdateItemAsync(T item)\n        {\n          await table.UpdateAsync(item);\n          return item;\n        }\n        #endregion\n    }\n}  It's important to note here that the Azure Mobile Apps Client SDK does a lot of\nthe work for us.  In fact, we are just wrapping the basic interface here.  This\nwon't normally be the case, but you can see that the majority of the code for\ndealing with the remote server is done for us.   You can use a shorthand (called a lambda expression) for methods with only one line.\nFor instance, the delete method could just as easily have been written as  public async Task<T> DeleteItemAsync(T item) => await table.DeleteAsync(item); .\nYou may see this sort of short hand in samples.   We also need to create the model that we will use for the data.  This should\nlook very similar to the model on the server - including having the same name\nand fields.  In this case, it's  Models\\TodoItem.cs :  using TaskList.Abstractions\n\nnamespace TaskList.Models\n{\n    public class TodoItem : TableData\n    {\n        public string Text { get; set; }\n        public bool Complete { get; set; }\n    }\n}  We have a final piece of code to write before we move on to the views, but it's\nan important piece.  The  ICloudService  must be a singleton in the client.  We\nwill add authentication and offline sync capabilities in future versions of this\ncode.  The singleton becomes critical when using those features.  For right now,\nit's good practice and saves on memory if you only have one copy of the  ICloudService \nin your mobile client.  Since there is only one copy of the  App.cs  in any\ngiven app, I can place it there.  Ideally, I'd use some sort of dependency\ninjection system or a singleton manager to deal with this.  Here is the  App.cs :  using TaskList.Abstractions;\nusing TaskList.Services;\nusing Xamarin.Forms;\n\nnamespace TaskList\n{\n    public class App : Application\n    {\n        public static ICloudService CloudService { get; set; }\n\n        public App()\n        {\n            CloudService = new AzureCloudService();\n            MainPage = new NavigationPage(new Pages.EntryPage());\n        }\n\n        // There are lifecycle methods here...\n    }\n}  We haven't written  Pages.EntryPage  yet, but that's coming.  The original  App.cs \nclass file had several methods for handling lifecycle events like starting, suspending\nor resuming the app.  I did not touch those methods for this example.",
            "title": "Building an Azure Mobile Apps Connection"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-the-ui-for-the-app",
            "text": "Earlier, I showed the mockup for my UI.  It included three pages - an entry\npage, a list page and a detail page.  These pages have three elements - a\nXAML definition file, a (simple) code-behind file and a view model.   This book is not intending to introduce you to everything that there is to know\nabout Xamarin and UI programming with XAML.  If you wish to have that sort of introduction,\nthen I recommend reading the excellent book by Charles Petzold:  Creating Mobile Apps with Xamarin.Forms .   I tend to use MVVM (or Model-View-ViewModel) for UI development in Xamarin\nbased applications.  It's a nice clean pattern and is well understood and\ndocumented.  In MVVM, there is a 1:1 correlation between the view and the\nview-model, 2-way communication between the view and the view-model and\nproperties within the view-model are bound directly to UI elements.  In\ngeneral (and in all my code), view-models expose an INotifyPropertyChanged\nevent to tell the UI that something within the view-model has been changed.  To do this, we will use a  BaseViewModel  class that implements the base functionality\nfor each view.  Aside from the  INotifyPropertyChanged  interface, there are\nsome common properties we need for each page.  Each page needs a title, for\nexample, and each page needs an indicator of network activity.  These can be\nplaced in the  Abstractions\\BaseViewModel.cs  class:  using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\n\nnamespace TaskList.Abstractions\n{\n    public class BaseViewModel : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n        string _propTitle = string.Empty;\n        bool _propIsBusy;\n\n        public string Title\n        {\n            get { return _propTitle; }\n            set { SetProperty(ref _propTitle, value, \"Title\"); }\n        }\n\n        public bool IsBusy\n        {\n            get { return _propIsBusy; }\n            set { SetProperty(ref _propIsBusy, value, \"IsBusy\"); }\n        }\n\n        protected void SetProperty<T>(ref T store, T value, string propName, Action onChanged = null)\n        {\n            if (EqualityComparer<T>.Default.Equals(store, value))\n                return;\n            store = value;\n            if (onChanged != null)\n                onChanged();\n            OnPropertyChanged(propName);\n        }\n\n        public void OnPropertyChanged(string propName)\n        {\n            if (PropertyChanged == null)\n                return;\n            PropertyChanged(this, new PropertyChangedEventArgs(propName));\n        }\n    }\n}  This is a fairly common  INotifyPropertyChanged  interface implementation pattern.\nEach property that we want to expose is a standard property, but the  set  operation\nis replaced by the  SetProperty()  call.  The  SetProperty()  call deals with the\nnotification; calling the event emitter if the property has changed value.  We\nonly need two properties on the  BaseViewModel : the title and the network indicator.  I tend to write my apps in two stages.  I concentrate on the functionality of the\napp in the first stage.  There is no fancy graphics, custom UI widgets, or anything\nelse to clutter the thinking.   The page is all about the functionality of the\nvarious interactions.  Once I have the functionality working, I work on the styling\nof the page.  We won't be doing any styling work in the demonstration apps that we\nwrite during the course of this book.  The EntryPage has just one thing to do.  It provides a button that enters the app.\nWhen we cover authentication later on, we'll use this to log in to the backend.  If\nyou are looking at the perfect app, this is a great place to put the introductory\nscreen.  Creating a XAML file is relatively simple.  First, create a  Pages  directory to\nhold the pages of our application.  Then right-click on the  Pages  directory in\nthe solution explorer and choose  Add  ->  New Item... .  In the  Add New Item \ndialog, pick  Visual C#  ->  Cross-Platform  ->  Forms Xaml Page .  Name the\nnew page  EntryPage.cs .  This will create two files -  EntryPage.xaml  and EntryPage.xaml.cs .  Let's center a button on the page and wire it up with\na command.  Here is the  Pages\\EntryPage.xaml  file:  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.EntryPage\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <StackLayout HorizontalOptions=\"Center\"\n                     Orientation=\"Vertical\"\n                     VerticalOptions=\"Center\">\n            <Button BackgroundColor=\"Teal\"\n                    BorderRadius=\"10\"\n                    Command=\"{Binding LoginCommand}\"\n                    Text=\"Login\"\n                    TextColor=\"White\" />\n        </StackLayout>\n    </ContentPage.Content>\n</ContentPage>  There are a couple of interesting things to note here.  The  StackLayout  element\nis our layout element.  It occupies the entire screen (since it is a direct child\nof the content page) and the options just center whatever the contents are.  The\nonly contents are a button.  There are two bindings.  These are bound from the view-model.  We've already seen\nthe Title property - this is a text field that specifies the title of the page.\nThe other binding is a login command.  When the button is tapped, the login command\nwill be run.  We'll get onto that in the view-model later.  The other part of the XAML is the code-behind file.  Because we are moving all\nof the non-UI code into a view-model, the code-behind file is trivial:  using TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class EntryPage : ContentPage\n    {\n        public EntryPage()\n        {\n            InitializeComponent();\n            BindingContext = new EntryPageViewModel();\n        }\n    }\n}  This is a recipe that will be repeated over and over again for the code-behind\nwhen you are using a XAML-based project with MVVM.  We initialize the UI, then\nbind all the bindings to a new instantiation of the view model.  Talking of which, the view-model needs just to handle the login click.  Note that\nthe location or namespace is  TaskList.ViewModels .  I'm of two minds about location.\nThere tends to be a 1:1 relationship between the XAML file and the View Model, so\nit makes sense that they are stored together.  However, just about all the sample\ncode that I see has the view-models in a separate namespace.  Which one is correct?\nI'll go with copying the samples for now.  Here is the code for  ViewModels\\EntryPageViewModel.cs :  using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class EntryPageViewModel : BaseViewModel\n    {\n        public EntryPageViewModel()\n        {\n            Title = \"Task List\";\n        }\n\n        Command loginCmd;\n        public Command LoginCommand => loginCmd ?? (loginCmd = new Command(async () => await ExecuteLoginCommand()));\n\n        async Task ExecuteLoginCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[Login] Error = {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}  This is a fairly simple view-model but there are some patterns here that are\nworth explaining.  Firstly, note the way we create the  LoginCommand  property.\nThis is the property that is bound to the  Command  parameter in the  Button \nof our view.  This recipe is the method of invoking a UI action asynchronously.\nIt isn't important now, but we will want this technique repeatedly as our UI\nactions kick off network activity.  The second is the pattern for the  ExecuteLoginCommand  method.  Firstly, I\nensure nothing else is happening by checking the IsBusy flag.   If nothing\nis happening, I set the IsBusy flag.  Then I do what I need to do in a try/catch\nblock.  If an exception is thrown, I deal with it.  Most of the time this\ninvolves displaying an error condition.  There are several cross-platform dialog\npackages to choose from or you can roll your own.  That is not covered here.  We\njust write a debug log statement so we can see the result in the debug log.  Once\neverything is done, we clear the IsBusy flag.  The only thing we are doing now is swapping out our main page for a new main\npage.  This is where we will attach authentication later on.  The next page is the Task List page, which is in  Pages\\TaskList.xaml :  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.TaskList\"\n             Title=\"{Binding Title}\">\n  <ContentPage.Content>\n    <StackLayout>\n      <ListView BackgroundColor=\"#7F7F7F\"\n                CachingStrategy=\"RecycleElement\"\n                IsPullToRefreshEnabled=\"True\"\n                IsRefreshing=\"{Binding IsBusy, Mode=OneWay}\"\n                ItemsSource=\"{Binding Items}\"\n                RefreshCommand=\"{Binding RefreshCommand}\"\n                RowHeight=\"50\"\n                SelectedItem=\"{Binding SelectedItem, Mode=TwoWay}\">\n        <ListView.ItemTemplate>\n          <DataTemplate>\n            <ViewCell>\n              <StackLayout HorizontalOptions=\"FillAndExpand\"\n                           Orientation=\"Horizontal\"\n                           Padding=\"10\"\n                           VerticalOptions=\"CenterAndExpand\">\n                <Label HorizontalOptions=\"FillAndExpand\"\n                       Text=\"{Binding Text}\"\n                       TextColor=\"#272832\" />\n                <Switch IsToggled=\"{Binding Complete, Mode=OneWay}\" />\n              </StackLayout>\n            </ViewCell>\n          </DataTemplate>\n        </ListView.ItemTemplate>\n      </ListView>\n      <StackLayout HorizontalOptions=\"Center\"\n                   Orientation=\"Horizontal\">\n        <Button BackgroundColor=\"Teal\"\n                Command=\"{Binding AddNewItemCommand}\"\n                Text=\"Add New Item\"\n                TextColor=\"White\" />\n      </StackLayout>\n    </StackLayout>\n  </ContentPage.Content>\n</ContentPage>  Note that some bindings here are one-way.  This means that the value in the\nview-model drives the value in the UI.  There is nothing within the UI that you\ncan do to alter the state of the underlying property.  Some bindings are two-way.\nDoing something in the UI (for example, toggling the switch) alters the underlying\nproperty.  This view is a little more complex.  It can be split into two parts - the list\nat the top of the page and the button area at the bottom of the page.  The list\narea uses a template to help with the display of each item.  Note that the  ListView  object has a \"pull-to-refresh\" option that I have wired\nup so that when pulled, it calls the RefreshCommand.  It also has an indicator\nthat I have wired up to the IsBusy indicator.  Anyone who is familiar with the\niOS \"pull-to-refresh\" gesture can probably guess what this does.  There is a view-model that goes along with the view (in  ViewModels\\TaskListViewModel.cs ):  using System;\nusing System.Collections.ObjectModel;\nusing System.Collections.Specialized;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskListViewModel : BaseViewModel\n    {\n        public TaskListViewModel()\n        {\n            Title = \"Task List\";\n            RefreshList();\n        }\n\n        ObservableCollection<TodoItem> items = new ObservableCollection<TodoItem>();\n        public ObservableCollection<TodoItem> Items\n        {\n            get { return items; }\n            set { SetProperty(ref items, value, \"Items\"); }\n        }\n\n        TodoItem selectedItem;\n        public TodoItem SelectedItem\n        {\n            get { return selectedItem; }\n            set\n            {\n                SetProperty(ref selectedItem, value, \"SelectedItem\");\n                if (selectedItem != null)\n                {\n                    Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail(selectedItem));\n                    SelectedItem = null;\n                }\n            }\n        }\n\n        Command refreshCmd;\n        public Command RefreshCommand => refreshCmd ?? (refreshCmd = new Command(async () => await ExecuteRefreshCommand()));\n\n        async Task ExecuteRefreshCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                var table = App.CloudService.GetTable<TodoItem>();\n                var list = await table.ReadAllItemsAsync();\n                Items.Clear();\n                foreach (var item in list)\n                    Items.Add(item);\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskList] Error loading items: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command addNewCmd;\n        public Command AddNewItemCommand => addNewCmd ?? (addNewCmd = new Command(async () => await ExecuteAddNewItemCommand()));\n\n        async Task ExecuteAddNewItemCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                await Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskList] Error in AddNewItem: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        async Task RefreshList()\n        {\n            await ExecuteRefreshCommand();\n            MessagingCenter.Subscribe<TaskDetailViewModel>(this, \"ItemsChanged\", async (sender) =>\n            {\n                await ExecuteRefreshCommand();\n            });\n        }\n    }\n}  This is a combination of the patterns we have seen earlier.  The Add New Item\nand Refresh commands should be fairly normal patterns now.  We navigate to the\ndetail page (more on that later) in the case of selecting an item (which occurs\nwhen the UI sets the  SelectedItem  property through a two-way binding) and when\nthe user clicks on the Add New Item button.  When the Refresh button is clicked\n(or when the user opens the view for the first time), the list is refreshed.  It\nis fairly common to use an  ObservableCollection  or another class that uses the ICollectionChanged  event handler for the list storage.  Doing so allows the UI\nto react to changes in the items.  Note the use of the  ICloudTable  interface here.  We are using the  ReadAllItemsAsync() \nmethod to get a list of items, then we copy the items we received into the  ObservableCollection .  Finally, there is the TaskDetail page.  This is defined in the  Pages\\TaskDetail.xaml \nfile:  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.TaskDetail\"\n             Title=\"{Binding Title}\">\n  <ContentPage.Content>\n    <StackLayout Padding=\"10\" Spacing=\"10\">\n      <Label Text=\"What should I be doing?\"/>\n      <Entry Text=\"{Binding Item.Text}\"/>\n      <Label Text=\"Completed?\"/>\n      <Switch IsToggled=\"{Binding Item.Complete}\"/>\n      <StackLayout VerticalOptions=\"CenterAndExpand\"/>\n      <StackLayout Orientation=\"Vertical\" VerticalOptions=\"End\">\n        <StackLayout HorizontalOptions=\"Center\" Orientation=\"Horizontal\">\n          <Button BackgroundColor=\"#A6E55E\"\n                  Command=\"{Binding SaveCommand}\"\n                  Text=\"Save\" TextColor=\"White\"/>\n          <Button BackgroundColor=\"Red\"\n                  Command=\"{Binding DeleteCommand}\"\n                  Text=\"Delete\" TextColor=\"White\"/>\n        </StackLayout>\n      </StackLayout>\n    </StackLayout>\n  </ContentPage.Content>\n</ContentPage>  This page is a simple form with just two buttons that need to have commands\nwired up.  However, this page is used for both the \"Add New Item\" gesture\nand the \"Edit Item\" gesture.  As a result of this, we need to handle the\npassing of the item to be edited.  This is done in the  Pages\\TaskDetail.xaml.cs \ncode-behind file:  using TaskList.Models;\nusing TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class TaskDetail : ContentPage\n    {\n        public TaskDetail(TodoItem item = null)\n        {\n            InitializeComponent();\n            BindingContext = new TaskDetailViewModel(item);\n        }\n    }\n}  The item that is passed in from the  TaskList  page is used to create a\nspecific view-model for that item.  The view-model is similarly configured\nto use that item:  using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskDetailViewModel : BaseViewModel\n    {\n        ICloudTable<TodoItem> table = App.CloudService.GetTable<TodoItem>();\n\n        public TaskDetailViewModel(TodoItem item = null)\n        {\n            if (item != null)\n            {\n                Item = item;\n                Title = item.Text;\n            }\n            else\n            {\n                Item = new TodoItem { Text = \"New Item\", Complete = false };\n                Title = \"New Item\";\n            }\n        }\n\n        public TodoItem Item { get; set; }\n\n        Command cmdSave;\n        public Command SaveCommand => cmdSave ?? (cmdSave = new Command(async () => await ExecuteSaveCommand()));\n\n        async Task ExecuteSaveCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id == null)\n                {\n                    await table.CreateItemAsync(Item);\n                }\n                else\n                {\n                    await table.UpdateItemAsync(Item);\n                }\n                MessagingCenter.Send<TaskDetailViewModel>(this, \"ItemsChanged\");\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskDetail] Save error: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command cmdDelete;\n        public Command DeleteCommand => cmdDelete ?? (cmdDelete = new Command(async () => await ExecuteDeleteCommand()));\n\n        async Task ExecuteDeleteCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id != null)\n                {\n                    await table.DeleteItemAsync(Item);\n                }\n                MessagingCenter.Send<TaskDetailViewModel>(this, \"ItemsChanged\");\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskDetail] Save error: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}  The save command uses the  ICloudTable  interface again - this time doing\neither  CreateItemAsync()  or  UpdateItemAsync()  to create or update the\nitem.  The delete command, as you would expect, deletes the item with the DeleteItemAsync()  method.  The final thing to note from our views is that I am using the  MessagingCenter \nto communicate between the TaskDetail and TaskList views.  If I change the item\nin the  TaskDetail  list, then I want to update the list in the  TaskList  view.  Note that all the code we have added to the solution thus far is in the common TaskList  project.  Nothing is required for this simple example in a platform\nspecific project.  That isn't normal, as we shall see.",
            "title": "Building the UI for the App"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-the-client-for-universal-windows",
            "text": "I tend to start by building the Universal Windows mobile client.  I'm using\nVisual Studio, after all, and I don't need to use any emulator.  To build the\nclients:   Right-click on the  TaskList.UWP (Universal Windows)  project, then select  Set as StartUp Project .  Right-click on the  TaskList.UWP (Universal Windows)  project again, then select  Build .  Once the build is complete, Right-click on the  TaskList.UWP (Universal Windows)  project again, then select  Deploy .  Click on the  Local Machine  button in your command bar to run the application.   Here are the three screen screens we generated on Windows:   There are some problems with the UWP version.  Most notably, the \"pull-to-refresh\"\ngesture does not exist, so we will need to set up an alternate gesture.  This\ncould be as easy as adding a refresh button right next to the Add New Item\nbutton.  In addition, there is no indication of network activity - this manifests\nas a significant delay between the TaskList page appearing and the data appearing\nin the list.  Aside from this, I did do some styling work to ensure that the final version\nlooked like my mock-ups (with the exception of the UI form of the switch, which\nis platform dependent).  If you want to see what I did to correct this, check out\nthe final version of  the Chapter 1 sample  on GitHub.  If you need to build the project, ensure you redeploy the project after building.\nIt's a step that is easy to miss and can cause some consternation as you change\nthe code and it doesn't seem to have an effect on the application.",
            "title": "Building the Client for Universal Windows"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-the-client-for-android",
            "text": "Building Android with Visual Studio is as easy as building the Universal Windows\nversion of the mobile client:   Right-click on the  TaskList.Droid  project, then select  Set as StartUp Project .  Right-click on the  TaskList.Droid  project again, then select  Build .   The button for running the application has a drop-down that is now significant.\nIt lets you choose the type of device that you will use.  Normally, this runs\neither a 5\" or 7\" KitKat-based Android device.  There is some setup required for\nthe Visual Studio Emulator for Android.  The Visual Studio Emulator for Android\nruns within Hyper-V, so you must install Hyper-V before use.  You get the following\nerror if you don't do this:   To install Hyper-V:   Close all applications (your system will be rebooted during this process).  Search for  Programs and Features .  Click on  Turn Windows features on or off  (in the left-hand menu).  Expand the  Hyper-V  node.  Check all the boxes below the  Hyper-V  node.  This will include Hyper-V Management Tools and Hyper-V Services.  Click on  OK .  Your system will install the required pieces and then ask you to restart.  Click on  Restart now  when prompted.   Once you have done this, the next hurdle is to be added to the Hyper-V Administrators\nsecurity group.  It gets done for you (again - the first time you try to run the\napplication after installing Hyper-V).  Once it is done, close Visual Studio (again),\nthe log out and back in again.  As if that wasn't enough, the emulator also needs an Internet connection to\nstart.   You should be able to just click on  Yes  or  OK  to enable the Internet\nconnection.  My laptop required a reboot before this would work, however.  In\naddition, the process may request elevated privileges.   If you want to run additional Android profiles before starting, run the  Visual Studio Emulator for Android  and download any additional profiles.  For example, if you wish to emulate something similar to a Samsung Galaxy S6, then download the profile for a 5.1\" Marshmallow (6.0.0) XXHDPI Phone.   Finally the Visual Studio Emulator for Android starts when you click on the Run\nbutton.  Fortunately, the setup of the emulator only has to be done once per\nmachine.  The Visual Studio Emulator for Android is also a superior emulator\nto the standard Android Emulator, so this process is well worth going through.   When testing the mobile client manually through the Visual Studio Emulator for Android, you are likely to need to rebuild the application.  You do not have to shut down the emulator between runs.  You can leave it running.  The application will be stopped and replaced before starting again.  This can significantly speed up the debug cycle since you are not waiting for the emulator to start each time.   Watch the Output window.  If the debugger won't connect or the application\nwon't start, you may need to restart your computer again to get the network\nworking.   If your computer doesn't run Hyper-V well (or at all), then the emulator won't run well (or at all) either.  I find laptops to be particularly prone to this problem.  If this happens, you can always run the Google Emulator instead.  Build the application as normal.  You will find the APK file to install in  ...\\TaskList.Droid\\bin\\Debug . Fortunately, there are lots of resources that show how to do this.  You can find the answer on  Stack Overflow   If everything is working, you should see the Visual Studio Emulator for Android\ndisplay your mobile client:    You can also build the Android version on a mac with Xamarin Studio.  However, I find that version mismatches between Mono (which is used on the mac) and Visual Studio - particularly in reference to the version of the .NET framework - cause issues when swapping between the two environments.  For best results, stay in one environment.   Note that the task list view is a \"light\" style and the rest of the app is a\n\"dark\" style.  This is because the default styling on an Android device is\ndark.  We are using the default styling on two of the pages and specifying\ncolors on the list page.  Fortunately, Xamarin Forms allows for  platform-specific\nstyling .  The  final sample  has platform-specific styling for the\nlist page.",
            "title": "Building the Client for Android"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-the-client-for-ios",
            "text": "Finally, we get to the iOS platform.  You will need to ensure your Mac is turned\non and accessible, that it has XCode installed (and you have run XCode once so\nthat you can accept the license agreement), and it has Xamarin Studio installed.  When you created the projects, you were asked to link Visual Studio to your mac.\nThis linkage is used for building the project.  In essence, the entire project\nis sent to the Mac and the build tools that are supplied with Xamarin Studio\nwill be used to build the project.   Right-click on the  TaskList.iOS  project and select  Set as StartUp Project .  Right-click on the  TaskList.iOS  project and select  Build .   You knew it was not going to be that easy, right?  Here are the errors that I\nreceived when building for the first time:   There are two errors right at the top.  Let's cover the first one.  The error\nabout  Build Action 'EmbeddedResource' is not supported  is an annoying one.\nThe fix is to do the following:   Set the iOS project as the StartUp project.  Go through each project, expand the  References  node and ensure that there are no references with a warning (a little yellow triangle).  If there are - fix those first.  Generally, this is fixed by either using the  Restore NuGet Packages  option or removing the reference and then adding it again from NuGet.  Close the solution.  Re-open the solution.  You don't need to close Visual Studio to do this.  Right-click on the iOS project and select  Clean .  Right-click on the iOS project and select  Rebuild .   Once you have done this sequence, the error should go away.  The error about  No valid iOS code signing keys found in keychain  is because\nwe have not yet signed up for an Apple Developer Account and linked it to our\nMac development environment.   Go to the  Apple Developer Center .  Click on  Account  in the top navigation bar.  If you haven't got an Apple ID yet, create one first.  If you have go an Apple ID, then log in.   There are a sequence of sign-up prompts in both cases (first for creating your\nApple ID and secondly for signing up for the Apple Developer program).  Once\nyou have gone through this process, you are registered as an Apple Developer.   If you want to distribute your apps on the Apple App Store, run on real devices or get access to the beta bits, then you might consider signing up for the Apple Developer Program.  The Apple Developer Program is an additional cost and is not required for developing iOS apps that are only run on the iOS simulator.   Once you have created your account and enabled it as a developer account, open\nup XCode.  Go to  Preferences... , then  Account  and\nclick on the  +  in the bottom-left corner of the window:   Sign in with the same account you used to sign up for the developer account.   Click on the  View Details  button.  This will bring up the Signing Identities\nlist.  For a free account, it looks like this:   Click on the Create button next to  iOS Development .  Once the UI comes back,\nclick on  Done .  For more information on this process, refer to the  Apple Documentation .  You can close XCode at this point.  Ensure Xamarin Studio is not running.  Back\nwithin Visual Studio, right-click on the  TaskList.iOS  project and select  Rebuild .\nThis will (finally!) build the application for you.   Getting an error about  Provisioning Profiles  not being available?  This is because you are building for a real device instead of the simulator.  In order to build for a real device, you must have a linked Apple Developer Program.  To get around this, select a Simulator before building.   The  Run  button has received a  Device  label, but there are several simulator options.\nYou should only use  Device  if you have signed up for the Apple Developer Program.  Pick\none of the simulator options like the  iPhone 6 iOS 9.3  simulator, then click on it\nto run the simulator.  Before long, you should see the following:   At some point, you will need a platform initialization call on all platforms.  It's best to\nadd it now.  In TaskList.Droid, this should be added in  MainActivity.cs  and in TaskList.iOS,\nit's  AppDelegate.cs .  In each of these files, there is a line that initializes the Xamarin\nForms system.  // Android Version\nglobal::Xamarin.Forms.Forms.Init(this, bundle);\n// iOS Version\nglobal::Xamarin.Forms.Forms.Init ();  Immediately before this line, you should add the  initializer for Azure Mobile Apps. It's\nimportant that the Azure Mobile Apps subsystem is initialized prior to Xamarin Forms being\ninitialized and any UI code being called.  Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();  This initializer is not required on the UWP project.  Once this is done and you have re-built\nthe project, we can see the fruits of our labor.  You can, of course, run the IPA in the\niOS simulator on the Mac.  However, it's much more satisfying (to me, at least) to be able\nto do everything from within Visual Studio.  For this, you need to install the Xamarin Installer .  This is an MSI for your Windows development system and is\nquickly installed.  Once installed, start (or restart) Visual Studio, select  Tools  -> Options .  Search for  Xamarin , and select the  iOS Settings  page.  There is\na new option:   Note the  Remote Simulator to Windows .  This should be checked.  You may need to\nrebuild the TaskList.iOS project after installing the Xamarin Simulator.  The debug\nwindow will tell you if this is the case.  There are also a few  known issues \nso check the documentation if you run into problems.  The final product screens look like this:",
            "title": "Building the Client for iOS"
        },
        {
            "location": "/chapter1/firstapp_pc/#some-final-thoughts",
            "text": "If you have got through the entire process outlined in this Chapter and built the application\nfor each platform, then congratulations.  There are a lot of places where things can go\nwrong.  You are really integrating the build systems across Visual Studio, Android, Xamarin,\nand XCode.  Fortunately, once these are set up, it's likely that they will continue working and you\nwon't have to think too much about them again. The Android and iOS build tools and simulators\nwill just work.  If you would rather develop code on your mac, the next chapter is for you - it gets into\nthe nitty gritty of developing the exact same app, but using Xamarin Studio instead.  The following 7 chapters each take one aspect of the cloud services that can be provided to\nmobile apps and explores it in detail, using an Azure Mobile App as a beginning. You can\njump around at this point, but be aware that we expect you to cover these topics in order.\nIf you do the data chapter before covering authentication, it's likely you will have missed\nimportant functionality in your app to complete the work.",
            "title": "Some Final Thoughts"
        },
        {
            "location": "/chapter1/firstapp_mac/",
            "text": "Building a Mobile App on a Mac",
            "title": "Your First App - Mac Edition"
        },
        {
            "location": "/chapter1/firstapp_mac/#building-a-mobile-app-on-a-mac",
            "text": "",
            "title": "Building a Mobile App on a Mac"
        },
        {
            "location": "/2_authentication/",
            "text": "Authentication\n\n\nOne of the very first things you will want to do is to provide users with a unique experience.  For our example task list application, this could be as simple as providing a task list for the user who is logged in.  In more complex applications, this is the gateway to role-based access controls, group rules, and sharing with your friends.  In all these cases, properly identifying the user using the phone is the starting point.\n\n\nConcepts\n\n\nAuthentication provides a process by which the user that is using the mobile device can be identified securely.  This is generally done by entering a username and password.  However, modern systems can also provide \nmulti-factor authentication\n, send you a text message to a registered device, or \nuse your fingerprint\n as the password.\n\n\nThe OAuth Process\n\n\nIn just about every single mobile application, a process called \nOAuth\n is used to properly identify a user to the mobile backend.  OAuth is not an authentication mechanism in its own right.  It is used to route the authentication request to the right place and to verify that the authentication took place. There are three actors in the OAuth protocol:\n\n\n\n\nThe \nClient\n is the application attempting to get access to the resource.\n\n\nThe \nResource\n is the mobile backend that the client is attempting to access.\n\n\nThe \nIdentity Provider\n (or IdP) is the service that is responsible for authenticating the client.\n\n\n\n\nAt the end of the process, a cryptographically signed token is minted.  This token is added to every single subsequent request to identify the user.\n\n\nServer Side vs. Client Side Authentication\n\n\nThere are two types of authentication flow: Server-Flow and Client-Flow.  They are so named because of who controls the flow of the actual authentication.\n\n\n\n\nServer-flow is named because the authentication flow is managed by the server through a web connection.  It is generally used in two cases:\n\n\n\n\nYou want a simple placeholder for authentication in your mobile app while you are developing other code.\n\n\nYou are developing a web app.\n\n\n\n\nIn the case of Server Flow:\n\n\n\n\nThe client brings up a web view and asks for the login page from the resource.\n\n\nThe resource redirects the client to the identity provider.\n\n\nThe identity provider does the authentication before redirecting the client\n   back to the resource (with an identity provider token).\n\n\nThe resource validates the identity provider token with the identity provider.\n\n\nFinally, the resource mints a new resource token that it returns to the client.\n\n\n\n\nClient-flow authentication uses an IdP provided SDK to integrate a more native feel to the authentication flow.  The actual flow happens on the client, communicating only with the IdP.\n\n\n\n\nThe client uses the IdP SDK to communicate with the identity provider.\n\n\nThe identity provider does the authentication, returning an identity provider token.\n\n\nThe client presents the identity provider token to the resource.\n\n\nThe resource validates the identity provider token with the identity provider.\n\n\nFinally, the resource mints a new resource token that it returns to the client.\n\n\n\n\nFor example, if you use the Facebook SDK for authentication, your app will seamlessly switch over into the Facebook app and ask you to authorize your client application before switching you back to your client application.\n\n\nIt is generally recommended that you use the IdP SDK when developing an app that will be released on the app store.  This follows the best practice provided by the majority of identity providers and provides the best experience for your end users.\n\n\nAuthentication Providers\n\n\nAzure Mobile Apps supports five identity providers natively:\n\n\n\n\nAzure Active Directory\n\n\nFacebook\n\n\nGoogle\n\n\nMicrosoft (MSA)\n\n\nTwitter\n\n\n\n\nIn addition, you can set up client-flow custom authentication that allows you to mint a ZUMO token to your specifications for any provider using a client-flow.  For example, you could use authentication providers like \nAzure AD B2C\n, \nLinkedIn\n or \nGitHub\n, a third-party authentication provider like  \nAuth0\n, or you could set up an identity table in your database so that you can check  username and password without an identity provider.\n\n\nAdding Authentication to a Mobile Backend\n\n\nThe Azure App Service Authentication / Authorization service integrates seamlessly into an Azure Mobile Apps backend as a piece of middleware that fills in the Identity information for ASP.NET.  That means the only thing we have to worry about is authorization.  The authentication piece (determining that a user is who they say they are) is already taken care of.\n\n\nAuthorization (which is the determination of whether an authenticated user can use a specific API) can happen at either the controller level or an individual operation level.  We can add authorization to an entire table controller by adding the \n[Authorize]\n attribute to the table controller.  For example, here is our table controller from the first chapter with authorization required for all operations:\n\n\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    [Authorize]\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}\n\n\n\n\nAuthorization can also happen on a per-operation basis by adding the \n[Authorize]\n attribute to a single method within the table controller.  For example, instead of requiring authorization on the entire table, we want a version where reading was possible anonymously but updating the database required authentication:\n\n\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        [Authorize]\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        [Authorize]\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        [Authorize]\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}\n\n\n\n\nNote that the \n[Authorize]\n attribute can do much more than what is provided here.  Underneath there are various parameters that you can adjust to see if the user belongs to a specific group or role.  However, the token that is checked to see if the user is authenticated does not pull in any of the other information that is normally needed for such authorization tasks.  As a result, the \n[Authorize]\n tags is really only checking whether a request requires authentication or not.\n\n\nConfiguring an Authentication Provider\n\n\nConfiguration of the identity provider is very dependent on the identity provider and whether the client is using a client-flow or server-flow.  Choose one of the several options for authentication:\n\n\n\n\nEnterprise Authentication\n covers Azure Active Directory.\n\n\nSocial Authentication\n covers Facebook, Google, Microsoft and Twitter.\n\n\n\n\nWe can also configure authentication using custom routes.  This allows us to use other (non-supported) services or to completely customize our flow (for example, to use an existing identity database).\n\n\nEnterprise Authentication\n\n\nEnterprise Authentication is handled by Azure Active Directory, which is fairly commonly configured within Azure.  Every Azure subscription has a default directory associated with it that you can leverage for this section.  In addition, if your organization has an Office 365 subscription, this will likely be tied to an Azure Active Directory domain to allow enterprise sign-in.  In either case, you have a directory you can use for providing authentication to your app.\n\n\nIn general, you will need to get special permissions to update the directory. If you want to use your organizations corporate directory, then you are likely to have to get your IT department involved to set it up.\n\n\nAzure Active Directory: Server-Flow setup\n\n\nThe Azure Active Directory server-flow is perhaps the easiest of all the authentication methods to configure.  No matter if you are doing a client flow or server flow, you need to set up the server flow first.\n\n\n\n\nWe recommend that you implement Client Flow in any non-trivial application.\n\n\n\n\nIf you are using your default directory and you want to add a couple of test users, you will need to set those up first.   Start by going to the \nClassic Azure Portal\n:\n\n\n\n\nClick on the \nDefault Directory\n, then click on \nUSERS\n.  You will notice that your Azure-linked ID is already present.\n\n\n\n\nClick on \nAdd User\n at the bottom of the screen.  Enter a username in the box provided before clicking on the arrow.  Then fill in the personal information and click on the arrow again.  Finally, click on \ncreate\n.  Note the password, before clicking on the tick.  Now you have two users - your Azure ID and the one you just created.  Note the username.  It is based on the tenant, so it will be something like \nadrian@photoadrianoutlook.onmicrosoft.com\n.\n\n\nTo configure your app, switch back to the regular \nAzure Portal\n, find your App Service, click on \nAll Settings\n followed by \nAuthentication / Authorization\n. Finally, select \nAzure Active Directory\n.\n\n\n\n\nClick on \nExpress\n.  Note that all the information is filled in for you.  All you have to do is click on \nOK\n, followed by \nSave\n.\n\n\n\n\nMake sure you create the app service in the right directory / subscription.  If you have access to more than one directory, you can choose the right one by selecting it under your account drop-down in the top-right corner.\n\n\n\n\nThere is also an \nAdvanced\n track.  This is used in client-flow situations and in situations where you have more than one directory.  The Express flow is great for getting started quickly.\n\n\nYou can walk through a server-flow authentication to test that you have all the settings correct.  Point your browser at https://\nyoursite\n.azurewebsites.net/.auth/login/aad.  The browser will take you through an authentication flow before giving you a successful authentication image:\n\n\n\n\nAdding Authentication to a Mobile Client\n\n\nNow that the backend is completely configured, we can move our attention to the mobile client.  We are going to be using the same mobile client that we developed in the first chapter, but we are now going to add authentication to it.  Web views are one of those items that are platform dependent. Fortunately for us, Xamarin has already thought of this and provided a facility for running platform specific code called the \nDependencyService\n.\n\n\n\n\nIf we run our application right now, clicking on the \"Enter the App\" button will result in an error.  You will be able to see the Unauthorized error in the debug window of Visual Studio.\n\n\n\n\nOur first step is to define an \nAbstractions\\ILoginProvider.cs\n interface within the  shared project:\n\n\nusing Microsoft.WindowsAzure.MobileServices;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ILoginProvider\n    {\n        Task LoginAsync(MobileServiceClient client);\n    }\n}\n\n\n\n\nNext, we are going to extend our \nAbstractions\\ICloudService.cs\n interface so that the main application can call the login routine:\n\n\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n    }\n}\n\n\n\n\nOur code will call \nLoginAsync()\n in the \nICloudService\n, which will get the platform-specific version of the login provider and call \nLoginAsync()\n there, but with our defined mobile service client.  That is defined in the \nServices\\AzureCloudService.cs\n class:\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing Xamarin.Forms;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(Locations.AppServiceUrl);\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData => new AzureCloudTable<T>(client);\n\n        public Task LoginAsync()\n        {\n            var loginProvider = DependencyService.Get<ILoginProvider>();\n            return loginProvider.LoginAsync(client);\n        }\n    }\n}\n\n\n\n\nThe method looks up the platform dependent version of the login provider and executes the login method, passing along the client (which we will need later).\n\n\nIn each platform-specific project, we are going to define a concrete implementation of the login provider that uses a web view to hold the actual authentication flow.  Here is the droid \nServices\\DroidLoginProvider.cs\n (in the TaskList.Droid project):\n\n\nusing System.Threading.Tasks;\nusing Android.Content;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        Context context;\n\n        public void Init(Context context)\n        {\n            this.context = context;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(context, \"aad\");\n        }\n    }\n}\n\n\n\n\nLet us take a closer look at this implementation.  The \nLoginAsync()\n method on the Azure Mobile Apps client object takes the Android context (which is normally the main window) and a provider - we can pick any of \"facebook\", \"google\", \"microsoftaccount\", \"twitter\" or \"aad\" depending on what we have defined in the Azure App Service.  The clever piece is the \nXamarin.Forms.Dependency\n call at the top - that registers the class as a platform service so we can access it through the Xamarin dependency service.\n\n\nNote that we need an extra initialization routine for Android that must be called prior the login provider being called to pass along the main window of the app (also known as the context).  This is done in the \nMainActivity.cs\n file \nafter\n the Xamarin Forms initialization call.  The dependency service is not set up until after the Xamarin Forms library is initialized, so we will not be able to get the login provider reference before that point:\n\n\nprotected override void OnCreate(Bundle bundle)\n{\n    base.OnCreate(bundle);\n\n    Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n    global::Xamarin.Forms.Forms.Init(this, bundle);\n\n    ((DroidLoginProvider)DependencyService.Get<ILoginProvider>()).Init(this);\n\n    LoadApplication(new App());\n}\n\n\n\n\niOS is similar, but does not require the initialization step in the main startup class.  The login provider class is in \nServices\\iOSLoginProvider.cs\n (in the \nTaskList.iOS\n project):\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.iOS.Services;\nusing UIKit;\n\n[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]\nnamespace TaskList.iOS.Services\n{\n    public class iOSLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(RootView, \"aad\");\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n    }\n}\n\n\n\n\nNote that we are using the same pattern here for registering the concrete implementation with the dependency service, so we can get it the same way. Finally, here is the UWP \nServices\\UWPLoginProvider.cs\n (in the TaskList.UWP project):\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.UWP.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(\"aad\");\n        }\n    }\n}\n\n\n\n\nNow that we have all the platform-specific login routines registered, we can move on to adding the login routine to the UI.  We have already got a button on the entry page to enter the app.  It makes sense to wire up that button so that it logs us in as well. The Command for the login button is in the \nViewModels\\EntryPageViewModel.cs\n:\n\n\nasync Task ExecuteLoginCommand()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var cloudService = ServiceLocator.Instance.Resolve<ICloudService>();\n        await cloudService.LoginAsync();\n        Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n    }\n    catch (Exception ex)\n    {\n        Debug.WriteLine($\"[ExecuteLoginCommand] Error = {ex.Message}\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}\n\n\n\n\n\n\nThe \nServiceLocator\n class is my basic singleton handler.  It is available in the \nChapter2\n project.  It returns the concrete version of the cloud service, just like the Singleton version we defined in Chapter1.\n\n\n\n\nWhen you run the application, clicking on the \"Enter the App\" button will now present you with an Authenticate window:\n\n\n\n\nGoing through the authentication process will get you to the task list again.  If the authentication process fails, then \nLoginAsync()\n will throw an error, which is caught at the ViewModel.  Right now, the \nEntryPageViewModel\n does nothing more than print a diagnostic message to the debug window of Visual Studio.\n\n\nAzure Active Directory: Client-Flow Setup\n\n\nConfiguring Azure Active Directory for client-flow is a three-step process.  First, we need to create a WEB application.  This represents the resource: in our case, the resource is the Azure Mobile Apps backend.  Then we need to create a NATIVE application.  This represents the client: in our case, the ADAL (Active Directory Access Library) library will need this information.  Finally, we need to give the NATIVE application permission to access the WEB application.\n\n\nIt starts with configuring a server-flow to protect the resource.  We've already done that above. Then configure a \"Native Application\" and give it permissions to the web application:\n\n\n\n\nLog on to the \nClassic Portal\n.\n\n\nSelect the \nDefault Directory\n from your list of all items.\n\n\nClick on the \nAPPLICATIONS\n tab.\n\n\n\n\n\n\n\n\nNote that our existing web application is already there.  You will see more applications, depending on what you have set up.  In this example, I have Visual Studio Team Services and Office 365 set up.\n\n\nClick on the \nADD\n button at the bottom of the page.\n\n\n\n\n\n\n\n\nClick on \nAdd an application my organization is developing\n.\n\n\n\n\n\n\n\n\nEnter a name for the app registration, and select \nNATIVE CLIENT APPLICATION\n.\n\n\nClick on the Next arrow.\n\n\nEnter a valid URI - it can be anything, but it has to be valid\n\n\n\n\n\n\n\n\nClick on the tick to create the application.\n\n\nThe wizard will close, but you will be brought to the app configuration.  Click on the \nCONFIGURE\n tab.\n\n\n\n\n\n\n\n\nAdd a Redirect URI of the form: \nhttps://yoursite.azurewebsites.net/.auth/login/done\n.\n\n\n\n\n\n\n\n\nAt the bottom of the page is the \npermissions to other applications\n section.  Click on the \nAdd application\n button.\n\n\n\n\n\n\n\n\nClick on the \nSHOW\n drop-down and select \nAll Apps\n, then click on the tick next to the search box.\n\n\nClick on the web application that you set up during the server-flow configuration, then click on the  tick in the lower-right corner.\n\n\n\n\n\n\n\n\nClick on \nDelegated Permissions\n next to the web application.  Check the box next to \nAccess\n, then click on \nSave\n at the bottom of the screen.\n\n\n\n\n\n\nAt this point the application configuration will be saved.\n\n\nSo, what did we just do there?  We created a new Azure AD app for the native application.  We then gave permission for the native application to access resources that are protected by the web application.  In our Azure App Service, we configured the service so that the Azure AD web application is used to protect our resources.  The net effect is that our native application OR our web application can access the App Service resources that are protected via the \n[Authorize]\n attribute.\n\n\nBefore continuing, you will need the \nClient ID\n and the \nRedirect URI\n for the NATIVE application. You can enter these into the \nHelpers\\Locations.cs\n file in the shared project:\n\n\nnamespace TaskList.Helpers\n{\n    public static class Locations\n    {\n        public static readonly string AppServiceUrl = \"https://the-book.azurewebsites.net\";\n\n        public static readonly string AadClientId = \"b61c7d68-2086-43a1-a8c9-d93c5732cc84\";\n\n        public static readonly string AadRedirectUri = \"https://the-book.azurewebsites.net/.auth/login/done\";\n\n        public static readonly string AadAuthority = \"https://login.windows.net/photoadrianoutlook.onmicrosoft.com\";\n    }\n}\n\n\n\n\nThe \nAadClientId\n and \nAadRedirectUri\n must match what we have configured in Azure AD for the native app.  The other piece of information we need to add is the Azure AD Authority for the directory.  If you click on the \nDOMAINS\n tab, it will generally tell you what domain you are in. The Authority is just a path on the \nhttps://login.windows.net\n that corresponds to your domain.  There is also a GUID version of this domain.  You can find the GUID by looking at the \nView Endpoints\n in the \nAPPLICATIONS\n tab.  Look at the first path section of most all the endpoints.\n\n\nAdd the \nMicrosoft.IdentityModel.Clients.ActiveDirectory\n NuGet package using \nManage NuGet Packages...\n to each platform project.  This package contains the ADAL library as a portable class library.\n\n\n\n\nNow you can add the client flow to each project.  Start with the login provider in the \nTaskList.UWP\n project, located in the \nServices\\UWPLoginProvider.cs\n file:\n\n\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.UWP.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync()\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters(PromptBehavior.Auto, false));\n            return authResult.AccessToken;\n        }\n\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginADALAsync();\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server-Flow Version\n            // await client.LoginAsync(\"aad\");\n        }\n    }\n}\n\n\n\n\nThe \nLoginADALAsync()\n method does the actual client-flow - using the ADAL library to authenticate the user and return the access token.  The \nLoginAsync()\n method initiates the client-flow.  It uses the token it receives from the client-flow to log in to the App Service, by packaging the token into a JSON object.  I have placed the client and server flow next to each other so you can compare the two.\n\n\nIn the \nTaskList.Droid\n project, we need to deal with the \nContext\n, as is common with Android libraries.  The client flow in \nServices\\DroidLoginProvider.cs\n is remarkably similar though:\n\n\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Android.App;\nusing Android.Content;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\nusing TaskList.Helpers;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        Context context;\n\n        public void Init(Context context)\n        {\n            this.context = context;\n        }\n\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync()\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters((Activity)context));\n            return authResult.AccessToken;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginADALAsync();\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server-Flow Version\n            // await client.LoginAsync(context, \"aad\");\n        }\n    }\n}\n\n\n\n\nThe only real difference between this one and the Universal Windows edition is the PlatformParameters. We need to pass in the context of the MainActivity (which is passed in through the \nInit()\n call).  However, we must also handle the response from the ADAL library.  This is done in \nMainActivity.cs\n. Add the following method to the \nMainActivity\n class:\n\n\nprotected override void OnActivityResult(int requestCode, Result resultCode, Intent data)\n{\n    base.OnActivityResult(requestCode, resultCode, data);\n    AuthenticationAgentContinuationHelper.SetAuthenticationAgentContinuationEventArgs(requestCode, resultCode, data);\n}\n\n\n\n\nFinally, the iOS version also requires access to the root view, so its \nPlatformParameters\n are also slightly different.  Here is \nServices\\iOSLoginProvider.cs\n:\n\n\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.iOS.Services;\nusing UIKit;\n\n[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]\nnamespace TaskList.iOS.Services\n{\n    public class iOSLoginProvider : ILoginProvider\n    {\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync(UIViewController view)\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters(view));\n            return authResult.AccessToken;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            var rootView = UIApplication.SharedApplication.KeyWindow.RootViewController;\n\n            // Client Flow\n            var accessToken = await LoginADALAsync(rootView);\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server Flow\n            //await client.LoginAsync(rootView, \"aad\");\n        }\n    }\n}\n\n\n\n\nNote that we can balance the needs of each platform by using the dependency service.  The code that is unique to the platform is minimized and stored with the platform.\n\n\nIf you aren't interested in social authentication (Facebook, Google, Microsoft or Twitter authentication providers), you can \nskip the social-auth section\n.\n\n\nSocial Authentication\n\n\nAzure App Service provides built-in support for Facebook, Google, Microsoft and Twitter.  Irrespective of whether you intend to use server-flow or client-flow, you will need to configure the Azure App Service Authentication / Authorization service.  The method is pretty similar in each case:\n\n\n\n\nObtain a Developer Account for the provider.\n\n\nCreate a new application, obtaining a Client ID and Secret.\n\n\nTurn on Azure App Service Authentication.\n\n\nEnter the Client ID and Secret into the specific provider setup.\n\n\nSave the configuration.\n\n\n\n\nBefore you start any of this, create a new Azure Mobile Apps as we described in [Chapter 1][int-intro].  If you want a site to deploy for the configuration, the \nBackend\n project in the \nChapter2\n solution is pre-configured for authorization. You just need to deploy it to Azure App Service.\n\n\nFacebook Authentication\n\n\nI am going to assume you have a Facebook account already.  If you do not have a Facebook account, go to \nFacebook\n and sign up.  All your friends are likely there already!  Now log in to the \nFacebook Developers\n web site.  Create a new Facebook application:\n\n\n\n\nNote\n: Facebook updates the look and feel of their developer site on a regular basis.  As a result, the screen shots I have provided here may be different.  If in doubt, follow the bullet descriptions to find your way.\n\n\n\n\nIf you are not already registered, click on the drop-down in the top-right corner and \nRegister as a Developer\n before continuing.\n\n\n\n\n\n\nClick on the \nMy Apps\n link in the top right corner of the screen.\n\n\nClick on \nCreate a New App\n.\n\n\nFill in the form:\n\n\n\n\n\n\n\n\n\n\nIf required, verify your account according to the instructions.  This usually involves adding a credit card number or verifying your mobile phone number.\n\n\n\n\n\n\nClick on the \nGet Started\n button next to \nFacebook Login\n.\n\n\n\n\n\n\n\n\n\n\nEnter your application URL + \n/.auth/login/facebook/callback\n in the \nValid OAuth redirect URIs\n.\n\n\n\n\n\n\n\n\nClick on \nSave Changes\n.\n\n\nClick on the \nSettings\n -> \nBasic\n in the left hand side-bar.\n\n\nClick on the \nShow\n button next to the App Secret\n\n\n\n\nNow that you have the \nApp ID\n and \nApp Secret\n, you can continue configuration of your app within the \nAzure Portal\n.\n\n\n\n\nOpen up your App Service by clicking on \nAll Resources\n or \nApp Services\n followed by the name of your app service.\n\n\nIn the \nSettings\n blade, click on \nAuthentication / Authorization\n which is under \nFeatures\n.\n\n\nTurn \nApp Service Authentication\n to \nOn\n.\n\n\nIn the \nAction to take when request is not authenticated\n, select \nAllow Request (no action)\n.\n\n\n\n\n\n\nIt is very tempting to choose \nLog in with Facebook\n.  However, you need to avoid this.  Selecting this option will mean that all requests need to be authenticated and you will not get the information about the identity on the back end.  Selecting \nAllow Request\n means your app is in charge of what gets authenticated and what does not require authentication.\n\n\n\n\n\n\nClick on \nFacebook\n (which should show \nNot Configured\n).\n\n\nCut and Paste the \nApp ID\n and \nApp Secret\n into the boxes provided.\n\n\nSelect \npublic_profile\n and \nemail\n for Scopes.\n\n\n\n\n\n\nNote that if you request anything but public_profile, user_friends, and email, your app will need further review by Facebook, which will take time.  This process is not worth it for test apps like this one.\n\n\n\n\n\n\nClick on \nOK\n (at the bottom of the blade) to close the Facebook configuration blade.\n\n\nClick on \nSave\n (at the top of the blade) to save your Authentication changes.\n\n\n\n\nYou can test your authentication process by browsing to https://\nyoursite\n.azurewebsites.net/.auth/login/facebook; this is the same endpoint that the Azure Mobile Apps Client SDK calls when it is time to integrate authentication into the mobile client.\n\n\n\n\nIf you are not logged in to facebook already, you will be prompted for your facebook credentials first.  Finally, here is your happy page - the page that signifies you have done everything right:\n\n\n\n\n\n\nMinimal Permissions\n  Every single OAuth provider will ask you what sort of information you want to have access to.  These \"claims\" translate into permissions.  The more permissions you request, the less likely the user is going to accept them.  Be a good net citizen and only request the information you are actually going to use.\n\n\n\n\nGoogle Authentication\n\n\nIt should be no shock that you need a \nGoogle Account\n to get started.  If you do not have one already (or you want a different account for your development activities), create a new account now.  Then log in to the \nGoogle Developer Portal\n.  Click on the \nCreate Project\n link at the top:\n\n\n\n\nEnter a nice name (like mine) and click on \nCreate\n.  The screen will show the progress and eventually the project will be listed in the \nAll Projects\n list.  It takes about 30 seconds to create a project.  Once you have your Google project, click on it to see all the wonderful things you can add to your project:\n\n\n\n\nThere is no \"Google Login\" that can guide you here.  The API you need to add is called \nGoogle+\n and is listed under the \nSocial APIs\n.  Click on it, then click on \nEnable\n at the top of the screen.\n\n\nJust because it is enabled does not mean you automatically get to use it.  Click on \nCredentials\n link in the left-hand side bar.  You will also see a \"Go to Credentials\" button at the top of the screen, but it does not take you to the same screen, so do not click it.\n\n\nOn the Crendetials screen, click on the \nOAuth consent screen\n tab:\n\n\n\n\nFill in the form and click on \nSave\n.  This brings up the next step - creating credentials.  Click on the \nCreate Credentials\n button.  This pops up a drop-down menu.  You want the \nOAuth Client ID\n.\n\n\n\n\nThe specific type of client ID you want is a \nWeb Application\n.  The server flow version of the application is a web-based form authentication, which matches the \nWeb Application\n version of the Client ID.\n\n\nWhen you select \nWeb Application\n, you will get another form:\n\n\n\n\nEnter the URL of your App Service in the \nAuthorized JavaScript origins\n box, and the URL + \n/.auth/login/google/callback\n into the \nAuthorized redirect URIs\n box, then click on \nCreate\n.\n\n\n\n\nGoogle is one of those providers that requires authentication redirect URIs to be secure - so ensure you use the https version of your URL.\n\n\n\n\nAt this point, Google will show you the Client ID and Client Secret for your app.  You can also get the Client ID and Client Secret from the interface by clicking on the \nCredentials\n link on the left-hand side bar.\n\n\nThe process from here is practically the same as Facebook.  Open your App Service within the Azure Portal, click on \nAll Settings\n, then \nAuthentication / Authorization\n and finally \nGoogle\n (assuming you have already turned on the authentication service).  Cut and paste the Client ID and Client Secret\ninto the boxes provided.  Click on \nOK\n (at the bottom) followed by \nSave\n (at the top of the page).\n\n\n\n\nYou can define multiple providers at the same time.  The code in the client determines what authentication mechanism gets used.\n\n\n\n\nYou can test this just like Facebook.  Go to https://\nyoursite\n/.auth/login/google with your browser.  You should get something like the following:\n\n\n\n\nConfirming here should get us to the same happy screen we achieved with Facebook.\n\n\nIf you happen to mis-type the Authorized redirect URI, Google will tell you that the URI is wrong.  I inevitably swap http for https.  When this happens, it is an easy fix, but you have to wait a few minutes before the authentication system updates itself.\n\n\nMicrosoft Account Authentication\n\n\nThe advantage of the Microsoft Account (or MSA, as it is known) is that you already have an account - you need one for Azure.  So this is the first time I am not going to explicitly tell you to sign up for an account.\n\n\nYour first step is to go to the \nMicrosoft Account Developer Center\n and log on with your Microsoft account.  You should use the same one as you use for Azure, but it is not required.\n\n\n\n\nJust to confuse us, there are two \nAdd an App\n buttons. Strangely, they are different. Click on the one next to \nMy applications\n.\n\n\n\n\nEnter an awesome name and click on \nCreate application\n.\n\n\n\n\nClick on \nAdd Platform\n, followed by \nWeb\n.  In the \nRedirect URIs\n, enter your app URL + \n/.auth/login/microsoftaccount/callback\n. Then click on \nSave\n.\n\n\n\n\nNow click on \nGenerate New Password\n under \nApplication Secrets\n.\n\n\n\n\nUnlike the other social providers, this is the only time you will get to see your client secret, so make a note of it or cut and paste it into a notepad.  Once you have it copied somewhere, click on \nOK\n, followed by \nSave\n.\n\n\nYou now have all the information you need to configure the Microsoft Account section within your App Server Authentication / Authorization.  The Client ID you need to enter is the Application ID and the Client Secret is the password you just copied somewhere.\n\n\n\n\nNote that you have to choose claims that you want to read.  The \nwl.basic\n and \nwl.emails\n will give you enough information to get started with this tutorial.\n\n\nClick on \nOK\n (at the bottom), followed by \nSave\n (at the top).  You can test the settings by pointing your browser to https://\nyoursite\n.azurewebsites.net/.auth/login/microsoftaccount.  You will see what should be a normal claims request page:\n\n\n\n\nClicking on \nYes\n should take you to the normal success page.\n\n\nTwitter Authentication\n\n\nI hope you are seeing that all the OAuth providers take a very similar route to configuring their service.  The semantics of the service are slightly different in each case.  Twitter is no different.  As you might expect, before continuing, sign up for \nTwitter\n.  Once you have signed up, the \nTwitter Developers Portal\n is your next stop.  Once there, you can click on \nCreate New App\n:\n\n\n\n\nMost of the fields are self-explanatory.  The \nCallback URL\n is the same thing that the other social providers have called the Redirect URL.  The appropriate value is your app URL + \n/.auth/login/twitter/callback\n.  There is a legal agreement at the bottom of the page, then you can click on \nCreate your Twitter application\n button.\n\n\n\n\nAll social authentication providers have some sort of legal agreement that governs their use.  In general, demo or PoC apps are fair use.  However, you should get a legal opinion before using a social authentication provider in a production app.\n\n\n\n\nOnce you have created the app, you will get a tabbed display with all the settings.  Click on the \nKeys and Access Tokens\n tab:\n\n\n\n\nNote the values for the \nConsumer Key (API Key)\n and \nConsumer Secret (API Secret)\n.  They get entered into the Azure Portal.\n\n\n\n\nThere is a check box in the \nSettings\n tab that says \nAllow this application to be used to Sign in with Twitter\n.  At the time of writing, this is checked by default.  However, if you find you can not log in for some reason, then ensure this checkbox is checked.\n\n\n\n\nBack in the Azure Portal, select your app service, then \nAll Settings\n, \nAuthentication / Authorization\n, and finally \nTwitter\n (assuming you have already turned Authentication on).  You can now cut and paste the Consumer Key and Consumer Secret into the appropriate boxes, before clicking on \nOK\n (at the bottom) followed by \nSave\n (at the top).\n\n\nAs with the other providers, you should test the authentication flow by pointing your browser to https://\nyoursite\n.azurewebsites.net/.auth/login/twitter.\n\n\n\n\nClicking on \nAuthorize app\n should show you our normal successful authentication screen.\n\n\nThe social authentication providers should now all be configured to handle a web-based or server-flow authentication request.  There are times when configuring a client-flow authentication is different.  We will point those out when we get to them.\n\n\n\n\nI'm going to assume you have [returned to the Concepts page][int-concepts] and added the client code for a server flow before continuing.\n\n\n\n\n Client-Flow for Social Providers\n\n\nIn each of the social providers, the identity provider SDK (provided by Facebook, Google, or Twitter) will need to be integrated.  In general, these SDKs are provided for a native platform (Objective-C or Swift for iOS, Java for Android), use callbacks or delegates (as is common practice in native libraries) and are thus more complicated to integrate with your mobile client than those that have a C#/.NET SDK delivered on NuGet.\n\n\nThe reward for doing so are a more integrated experience on mobile devices.  For example, if you integrate the Google Play Services SDK in an Android app, the app will seamlessly authenticate itself with the connected Google account in the background, avoiding the need for repeatedly authenticating the client.  It may ask for a fingerprint instead if the app is not trusted.  If you integrate the Facebook SDK, then the app will automatically switch to the Facebook app and ask you to approve the authentication request there instead of authenticating the user through a web view.  Both of these provide a more integrated experience for the end user, so this work is well worth pursuing.\n\n\nAs an example, here is an implementation of the Facebook authentication using client flow.  I've implemented this using the \nXamarin.Facebook.iOS\n library, which can be downloaded and installed into the iOS project from NuGet.  The \nServices\\iOSLoginProvider.cs\n contains the following:\n\n\n        #region Facebook Client Flow\n        private TaskCompletionSource<string> fbtcs;\n\n        public async Task<string> LoginFacebookAsync()\n        {\n            fbtcs = new TaskCompletionSource<string>();\n            var loginManager = new LoginManager();\n\n            loginManager.LogInWithReadPermissions(new[] { \"public_profile\" }, RootView, LoginTokenHandler);\n            return await fbtcs.Task;\n        }\n\n        private void LoginTokenHandler(LoginManagerLoginResult loginResult, NSError error)\n        {\n            if (loginResult.Token != null)\n            {\n                fbtcs.TrySetResult(loginResult.Token.TokenString);\n            }\n            else\n            {\n                fbtcs.TrySetException(new Exception(\"Facebook Client Flow Login Failed\"));\n            }\n        }\n        #endregion\n\n\n\n\nNote the use of a \nTaskCompletionSource<>()\n here.  This is used often to convert callback APIs into awaitable APIs.  We set off the async call with the callback, then await on the completion (which is signified by the \nTaskCompletionSource\n).  When the callback is called, it sets the value of the \nTaskCompletionSource\n (or causes an exception) and that causes the task to complete.\n\n\nThe \nLoginAsync()\n method can now be updated like this:\n\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            var accessToken = await LoginFacebookAsync();\n\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"facebook\", zumoPayload);\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n\n\n\n\nWith this version, clicking on the login button will seamlessly switch into the Facebook application and ask the user to confirm the request, before switching back authenticated.\n\n\nWhat is in a JWT\n\n\nAt this point you will have the \"Authentication Success\" screen - perhaps several times.  If you bring up the Developer Tools for your browser, you can take a look at the token that is being minted for the authentication session.  Take a look at the URL on the \"successful authentication\" page.\n\n\n\n\nThe authentication token is clearly marked (after you strip away the URL encoding).  You can use a \nURL Decoder / Encoder\n - just cut and paste the entire URL into the box and click on \nDecode\n.  Note that the token is actually a JSON object.  You can now easily extract the \nauthenticationToken\n field from the JSON object.\n\n\n\n\nTechnically, the authentication token is a \nJSON Web Token\n.  This is a mechanism for transferring claims between two systems securely.  The JWT is a cryptographically signed JSON object.  You can decode the JWT using the \njwt.io tool\n.  Cut and paste the authentication token into the \nEncoded\n box and it will be decoded.\n\n\n\n\nNote that the contents of the JWT are revealed even without knowing the secret.  However, we have not supplied a secret.  The secret is kept at the resource - in this case, your app service.  However, we can already see the issuer and audience (in this case, they are both set to your app service address), the identity provider that was used and a subject.\n\n\nTechnically, the JWT can include any data and there are some that place just about everything about the user in the JWT.  App Service keeps the amount of data small because the client will be sending the JWT with every request.  Imagine adding a few kilobytes to every single request that the client makes.  The bandwidth usage will add up quickly, and your app will be known as a bandwidth hog.\n\n\nHowever, there are some fields that are pretty universal.  Your JWT should always have the following fields:\n\n\n\n\nsub = Subject (the identifier for the token)\n\n\nexp = Expiry (when the token expires)\n\n\nnbf = Not Before (the earliest point in time the token is valid)\n\n\niss = Issuer (the site that issued the token)\n\n\naud = Audience (who is the token for)\n\n\n\n\nThe timestamps (exp and nbf) are all UNIX timestamps (i.e. the number of seconds since January 1, 1970).\n\n\nApp Service adds to this:\n\n\n\n\nstable_sid = Security Id of the user\n\n\nidp = the IdP that was used in the authentication request\n\n\nver = the Version of the token\n\n\n\n\nApp Service will be able to validate any token provided to it when presented in an X-ZUMO-AUTH header.  If you are using Azure Active Directory, you can also use the more standard Bearer Authorization header.  If the token does not match, then the X-ZUMO-AUTH header will be stripped from the request before the request is passed to your site.\n\n\nTesting Authentication without a Client\n\n\nTesting your site without a client requires a REST client.  I use \nPostman\n, which is based on Google Chrome.  If you use Firefox, you might want to take a look at \nRESTClient\n.  Telerik also distributes a web debugging proxy called \nFiddler\n that can do API testing.  To test the server, we will need a token.  We can get one by testing authentication configuration by pointing the browser to \n/.auth/login/aad\n.  The return URL will contain a token.\n\n\n\n\nYou can test any of the supported identity providers by replacing \naad\n with the authentication provider name: facebook, google, microsoftaccount and twitter are possibilities here.\n\n\n\n\nWe can then do a request to \n/tables/todoitem\n to try and obtain the list of current tasks.  We will need to add two headers:\n\n\n\n\nZUMO-API-VERSION\n should contain a value of \n2.0.0\n.\n\n\nX-ZUMO-AUTH\n should contain the token you received.\n\n\n\n\nMy first request shows authentication failing:\n\n\n\n\nGo through one of the authentication flows and copy the authentication token.  In Postman, add a new header called \nX-ZUMO-AUTH\n and paste the authentication token in.\n\n\n\n\nNote that we have tested all this without touching the client.  Separating the backend operations from the client operations means we can be sure of where the inevitable bug that creeps in is located.  We have verified that we can do each authentication flow on the server side and that the server is properly rejecting unauthenticated requests, plus it is properly returning data when authenticated requests are issued.\n\n\nDeveloping Locally\n\n\nOne would normally be able to run the ASP.NET backend locally and get full functionality without authentication.  However, authentication puts a stop to that because the redirect URLs, secrets and other authentication configuration settings only work with a known endpoint.  To alleviate that, Azure Mobile Apps allows you to run a local server while using an authentication endpoint in Azure App Service.  When the authentication transaction takes place, it is taking place against the Azure App Service.   When it is not doing the OAuth transaction, however, it is operating against a local server.\n\n\nSetting this up requires a little bit of local machine configuration and a change to the configuration of your client.\n\n\nUpdate your Local Development Environment\n\n\nThe first step in this process is to make your local IIS development environment look more like the Azure App Service, particularly in reference to the authentication settings.  This means setting up a few app settings that should be pulled from your App Service.\n\n\n\n\nLog on to the \nAzure Portal\n.\n\n\nSelect your App Service from the \nApp Services\n list.\n\n\nClick on \nTools\n, then \nKudu\n, then \nGo\n.\n\n\n\n\nKudu is the backend debug console for Azure App Service and there is a lot you can do here.  Of note in this instance is that you can gain access to the keys and audience for your App Service.\n\n\n\n\nClick on \nEnvironment\n in the top banner.\n\n\nClick on \nEnvironment variables\n.\n\n\nScroll down to the environment variables starting with \nWEBSITE_AUTH\n.\n\n\nMake a note of the \nWEBSITE_AUTH_SIGNING_KEY\n and \nWEBSITE_AUTH_ALLOWED_AUDIENCES\n values.\n\n\n\n\nAdd the following to your project Web.config \n<appSettings>\n section:\n\n\n  <appSettings>\n    <add key=\"PreserveLoginUrl\" value=\"true\" />\n    <add key=\"MS_SigningKey\" value=\"Overridden by portal settings\" />\n    <add key=\"EMA_RuntimeUrl\" value=\"Overridden by portal settings\" />\n    <add key=\"MS_NotificationHubName\" value=\"Overridden by portal settings\" />\n    <add key=\"SigningKey\" value=\"{Your WEBSITE_AUTH_SIGNING_KEY}\"/>\n    <add key=\"ValidAudience\" value=\"{Your WEBSITE_AUTH_ALLOWED_AUDIENCES}\"/>\n    <add key=\"ValidIssuer\" value=\"https://{Your WEBSITE_HOSTNAME}/\"/>\n  </appSettings>\n\n\n\n\n\n\nNOTE\n: Both the ValidAudience and ValidIssuer will have a slash on the end and be a https URL.\n\n\n\n\nThe last three keys are the keys you will need to add.  Make sure you do not have a \nHostName\n key as this is how the startup file determines if you are running locally or remote. Talking of which, edit your \nApp_Start\\Startup.MobileApp.cs\n file to include the following:\n\n\n        public static void ConfigureMobileApp(IAppBuilder app)\n        {\n            HttpConfiguration config = new HttpConfiguration();\n\n            new MobileAppConfiguration()\n                .AddTablesWithEntityFramework()\n                .ApplyTo(config);\n\n            // Use Entity Framework Code First to create database tables based on your DbContext\n            Database.SetInitializer(new MobileServiceInitializer());\n\n            MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();\n\n            if (string.IsNullOrEmpty(settings.HostName))\n            {\n                app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions\n                {\n                    SigningKey = ConfigurationManager.AppSettings[\"SigningKey\"],\n                    ValidAudiences = new[] { ConfigurationManager.AppSettings[\"ValidAudience\"] },\n                    ValidIssuers = new[] { ConfigurationManager.AppSettings[\"ValidIssuer\"] },\n                    TokenHandler = config.GetAppServiceTokenHandler()\n                });\n            }\n\n            app.UseWebApi(config);\n        }\n\n\n\n\nThe \nUserAppServiceAuthentication()\n method sets up authentication checking.  This section is not required when running within App Service.\n\n\nIf you are running the server locally, you should either set up a local SQL Server instance and put the connection string into the \nWeb.config\n file, or \nopen the firewall on your SQL Azure\n database so that your local development environment can connect to it, then place the connection string in the \nWeb.config\n.  You can get the connection string of the SQL Azure instance by looking at the Connection Strings in the \nApplication properties\n of your App Service.\n\n\nUpdate your Mobile Client\n\n\nFor this demonstration, I have updated the \nTaskList.UWP\n application so that it is using the server-flow authentication for Azure Active Directory.  This means updating the \nLoginAsync()\n method in the \nServices\\UWPLoginProvider.cs\n file to be the following:\n\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Server-Flow Version\n            await client.LoginAsync(\"aad\");\n        }\n\n\n\n\nThis is because the default local IIS instance is IIS Express.  IIS Express only listens for local connections.  If you run a client from another device (for example, the Android emulator on a Hyper-V service or the iOS simulator on a Mac), then that client would be connecting via a network connection.  You can still debug locally, but you need to \nconvert your environment to IIS\n first.\n\n\nIn the \nTaskList (Portable)\n project, update the \nHelpers\\Locations.cs\n file:\n\n\nnamespace TaskList.Helpers\n{\n    public static class Locations\n    {\n#if DEBUG\n        public static readonly string AppServiceUrl = \"http://localhost:17568/\";\n        public static readonly string AlternateLoginHost = \"https://the-book.azurewebsites.net\";\n#else\n        public static readonly string AppServiceUrl = \"https://the-book.azurewebsites.net\";\n        public static readonly string AlternateLoginHost = null;\n#endif\n    }\n}\n\n\n\n\nThe \nAppServiceUrl\n is always set to the location of your backend.  In this case, I right-clicked on the \nBackend\n project and selected \nProperties\n then \nWeb\n.  The correct URL for local debugging is listed in the \nProject URL\n.  The \nAlternateLoginHost\n is set to the App Service when locally debugging or null if not. You can specify the \nDEBUG\n constant in the \nBuild\n tab.\n\n\nIn the same project, update the \nServices\\AzureCloudService.cs\n constructor to the following:\n\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(Locations.AppServiceUrl);\n            if (Locations.AlternateLoginHost != null)\n                client.AlternateLoginHost = new Uri(Locations.AlternateLoginHost);\n        }\n\n\n\n\n\n\nIt's a good idea to separate the client and server into different solutions.  Although it doesn't hurt anything to have them in the same solution (like we have), having the client and server separated allows you to attach a debugger separately - which allows you to debug both sides of the connection at the same time.\n\n\n\n\nWith these settings, the client will contact the AlternateLoginHost listed for the authentication process and then contact the local server for the rest of the transaction.\n\n\nRun the Local Server\n\n\nRunning the local server and the client takes a larger machine.  You need to run two instances of Visual Studio: one for the client and one for the server. This is really where you will appreciate multiple monitors (my personal favorite) or the snap action to the sides of the screens.\n\n\nEnsure you have your backend and clients in different solutions if you intend to run both client and server.  The debugger in Visual Studio will stop one to run the other when they are in the same solution.\n\n\nCustom authentication\n\n\nFor some situations, the social or enterprise flows are not valid for the mobile client.  Perhaps you want the ability to provide a sign-up process with a username and password rather than using a social provider.  Perhaps you want to use an alternate provider that is not one of the supported five providers.  Whatever the reason, Azure App Service provides the ability to handle all situations.  In this section, I will look at three methods for providing a unique set of usernames with no connection to the social or enterprise authentication.\n\n\nUsing an Identity Database.\n\n\nProbably the most common request is to use a custom identity database.  In general, this is desirable because you already have a database of usernames and password.  However, it's probably the least desirable option because of the security concerns that come along with this technique.  The news is rife with password leakage for very large organizations.  The best way to ensure you do not disclose a users\npassword is to not have it in the first place.\n\n\n\n\nI'm not going to cover the sign-up case here.  This would be an additional process and would use a regular Web API to insert data into the database after validation (and probably verification via email\nor text message).\n\n\n\n\nThe first thing we need to add to our project is a model for the user object.  I created the following in the \nModels\n folder of the \nBackend\n project:\n\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace Backend.Models\n{\n    public class User\n    {\n        [Key]\n        public int Id { get; set; }\n\n        public string Username { get; set; }\n\n        public string Password { get; set; }\n    }\n}\n\n\n\n\nWe also need to modify the \nMobileServiceContext.cs\n file so that the database table is included in the Entity Framework context:\n\n\n    public class MobileServiceContext : DbContext\n    {\n        private const string connectionStringName = \"Name=MS_TableConnectionString\";\n\n        public MobileServiceContext() : base(connectionStringName)\n        {\n        }\n\n        public DbSet<TodoItem> TodoItems { get; set; }\n        public DbSet<User> Users { get; set; }\n\n        protected override void OnModelCreating(DbModelBuilder modelBuilder)\n        {\n            modelBuilder.Conventions.Add(\n                new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n                    \"ServiceTableColumn\", (property, attributes) => attributes.Single().ColumnType.ToString()));\n        }\n    }\n\n\n\n\nFinally, we probably want to put some seed data into the database when it is first created so that we can test it.  Adjust the \nMobileServiceInitializer\n in the \nStartup.MobileApp.cs\n file:\n\n\n        protected override void Seed(MobileServiceContext context)\n        {\n            List<TodoItem> todoItems = new List<TodoItem>\n            {\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"First item\", Complete = false },\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"Second item\", Complete = false }\n            };\n\n            foreach (TodoItem todoItem in todoItems)\n            {\n                context.Set<TodoItem>().Add(todoItem);\n            }\n\n            List<User> users = new List<User>\n            {\n                new User { Id = 1, Username = \"adrian\", Password = \"supersecret\" }\n            };\n\n            foreach (User user in users)\n            {\n                context.Set<User>().Add(user);\n            }\n\n            base.Seed(context);\n        }\n\n\n\n\nNote that we are storing the passwords in plain text.  This is most definitely frowned upon.  We should be using some sort of encryption.  This code is most definitely just for demonstration purposes.  Continuing the code on the backend, we need to handle the request to authenticate from the client.  We will use a custom API controller for this; it is located in \nControllers\\CustomAuthController.cs\n:\n\n\nusing System;\nusing System.IdentityModel.Tokens;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Web.Http;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server.Login;\nusing Newtonsoft.Json;\n\nnamespace Backend.Controllers\n{\n    [Route(\".auth/login/custom\")]\n    public class CustomAuthController : ApiController\n    {\n        private MobileServiceContext db;\n        private string signingKey, audience, issuer;\n\n        public CustomAuthController()\n        {\n            db = new MobileServiceContext();\n            signingKey = Environment.GetEnvironmentVariable(\"WEBSITE_AUTH_SIGNING_KEY\");\n            var website = Environment.GetEnvironmentVariable(\"WEBSITE_HOSTNAME\");\n            audience = $\"https://{website}/\";\n            issuer = $\"https://{website}/\";\n        }\n\n        [HttpPost]\n        public IHttpActionResult Post([FromBody] User body)\n        {\n            if (body == null || body.Username == null || body.Password == null || body.Username.Length == 0 || body.Password.Length == 0)\n            {\n                return BadRequest(); ;\n            }\n\n            if (!IsValidUser(body))\n            {\n                return Unauthorized();\n            }\n\n            var claims = new Claim[]\n            {\n                new Claim(JwtRegisteredClaimNames.Sub, body.Username)\n            };\n\n            JwtSecurityToken token = AppServiceLoginHandler.CreateToken(\n                claims, signingKey, audience, issuer, TimeSpan.FromDays(30));\n            return Ok(new LoginResult()\n            {\n                AuthenticationToken = token.RawData,\n                User = new LoginResultUser { UserId = body.Username }\n            });\n        }\n\n        protected override void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                db.Dispose();\n            }\n            base.Dispose(disposing);\n        }\n\n        private bool IsValidUser(User user)\n        {\n            return db.Users.Count(u => u.Username.Equals(user.Username) && u.Password.Equals(user.Password)) > 0;\n        }\n    }\n\n    public class LoginResult\n    {\n        [JsonProperty(PropertyName = \"authenticationToken\")]\n        public string AuthenticationToken { get; set; }\n\n        [JsonProperty(PropertyName = \"user\")]\n        public LoginResultUser User { get; set; }\n    }\n\n    public class LoginResultUser\n    {\n        [JsonProperty(PropertyName = \"userId\")]\n        public string UserId { get; set; }\n    }\n}\n\n\n\n\nThere is a lot going on here:\n\n\n\n\nThe constructor reads the signing key and other information that we need for constructing the JWT.  Note that the signing key is only available if you have the Authentication / Authorization is turned on.\n\n\nThe \nLoginResult\n and \nLoginResultUser\n provide the response to the client, when serialized by the JSON serializer.\n\n\nThe \nPost()\n method is where the work happens.  It verifies that you have a valid object, then checks that the username and password match something in the user database.  It then constructs the JWT and returns the required JSON object.\n\n\nThe \nIsValidUser()\n method actually validates the username and password provided in the request with the users in the database.  This version is very simplistic.  I expect your version to at least include encryption of the password.\n\n\n\n\n\n\nNote that you must turn on Authentication / Authorization in your App Service.  Set the \nAction to take when request is not authenticated\n to \nAllow Request (no action)\n and do not configure any of the supported authentication providers.\n\n\n\n\nNext, we need to wire the custom authentication controller so that it appears in the same place as all the other authenticators.  We are going to access it via the \n/.auth/login/custom\n endpoint.  The normal ASP.NET methods can be applied for this.  In this project, we can enable \nattribute routing\n:\n\n\npublic static void ConfigureMobileApp(IAppBuilder app)\n{\n    HttpConfiguration config = new HttpConfiguration();\n\n    new MobileAppConfiguration()\n        .AddTablesWithEntityFramework()\n        .ApplyTo(config);\n\n    // Map routes by attribute\n    config.MapHttpAttributeRoutes();\n\n    // Use Entity Framework Code First to create database tables based on your DbContext\n    Database.SetInitializer(new MobileServiceInitializer());\n\n    MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();\n\n    if (string.IsNullOrEmpty(settings.HostName))\n    {\n        app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions\n        {\n            SigningKey = ConfigurationManager.AppSettings[\"SigningKey\"],\n            ValidAudiences = new[] { ConfigurationManager.AppSettings[\"ValidAudience\"] },\n            ValidIssuers = new[] { ConfigurationManager.AppSettings[\"ValidIssuer\"] },\n            TokenHandler = config.GetAppServiceTokenHandler()\n        });\n    }\n\n    app.UseWebApi(config);\n}\n\n\n\n\nAt this point, we can deploy the backend to the App Service and send a suitably formed POST request to\nthe backend.  I use \nPostman\n for this purpose. The request:\n\n\n\n\nA successful POST will return the token and user ID in the response:\n\n\n\n\nAny other request (such as no body or a wrong username or password) should produce the right response.  If the body is correct, but the information is wrong, then a 401 Unauthorized response should be produced.  If the body is invalid, then a 400 Bad Request should be produced.\n\n\n\n\nNote that the format of the response is exactly the same as the token response we saw earlier when we were discussing the contents of a JWT.\n\n\n\n\nWe can now turn our attention to the mobile client.  Custom Authentication is always implemented using a client-flow mechanism. To implement this, we are going to adjust the entry page so that the username and password fields are displayed.  The gathered username and password will then be passed to a new ICloudService \nLoginAsync()\n method.  All of the UI work is done in the shared project.\n\n\nTo start, we need a copy of the \nUser.cs\n model from the backend project.  Unlike Data Transfer Objects, this model is the same:\n\n\nnamespace TaskList.Models\n{\n    public class User\n    {\n        public string Username { get; set; }\n        public string Password { get; set; }\n    }\n}\n\n\n\n\nThe abstraction we use for the cloud service needs to be adjusted so that we can pass the user object into the login method.  This is the \nAbstractions\\ICloudService.cs\n interface:\n\n\nusing System.Threading.Tasks;\nusing TaskList.Models;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n\n        Task LoginAsync(User user);\n    }\n}\n\n\n\n\nNote that I am adding a new version of the \nLoginAsync()\n method.  The concrete version of this method no longer has to go through the dependency service since I can use shared code.  Here is the definition of our new \nLoginAsync()\n method in \nServices\\AzureCloudService.cs\n:\n\n\n        public Task LoginAsync(User user)\n        {\n            return client.LoginAsync(\"custom\", JObject.FromObject(user));\n        }\n\n\n\n\nFinally, we need to update the view-model \nViewModels\\EntryPageViewModel.cs\n so that we can store the username and password in the model.  We will also update the call to the \nLoginAsync()\n method of the cloud service so it calls our new method:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class EntryPageViewModel : BaseViewModel\n    {\n        public EntryPageViewModel()\n        {\n            Title = \"Task List\";\n            User = new Models.User { Username = \"\", Password = \"\" };\n        }\n\n        Command loginCmd;\n        public Command LoginCommand => loginCmd ?? (loginCmd = new Command(async () => await ExecuteLoginCommand()));\n\n        public Models.User User { get; set; }\n\n        async Task ExecuteLoginCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                var cloudService = ServiceLocator.Instance.Resolve<ICloudService>();\n                await cloudService.LoginAsync(User);\n                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[ExecuteLoginCommand] Error = {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}\n\n\n\n\nThere are three new pieces here.  Firstly, we have the User property (for holding the username and password in our form).  Next, the constructor initializes the user object to an empty object.  Finally, the call to \nLoginAsync()\n passes the user object to the cloud service.\n\n\nWe also need some UI changes.  Specifically, we need a couple of fields for the username and password added to the \nPages\\EntryPage.xaml\n file:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage x:Class=\"TaskList.Pages.EntryPage\"\n             xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <StackLayout HorizontalOptions=\"Center\"\n                     Orientation=\"Vertical\"\n                     VerticalOptions=\"Center\">\n            <Label Text=\"Username?\" />\n            <Entry Text=\"{Binding User.Username}\" />\n            <Label Text=\"Password?\" />\n            <Entry IsPassword=\"True\" Text=\"{Binding User.Password}\" />\n\n            <Button BackgroundColor=\"Teal\"\n                    BorderRadius=\"10\"\n                    Command=\"{Binding LoginCommand}\"\n                    Text=\"Enter The App\"\n                    TextColor=\"White\" />\n        </StackLayout>\n    </ContentPage.Content>\n</ContentPage>\n\n\n\n\nThere is lots to complain about in this demonstration (including lack of encryption, storage of passwords, and a generally bad UI).  However, it serves to demonstrate the salient points for using a (perhaps pre-existing) identity database for authentication of the users.\n\n\nUsing Azure Active Directory B2C\n\n\nCustom authentication allows you to really customize the process, but I like to reduce the amount of code I write by using services or libraries.   The whole sign-in and sign-up process is ripe for this.  The code needed for building the sign-in / sign-up process is boiler-plate code.  It also introduces problems that I have to deal with going forward.  I have to store passwords and profile information, which introduces a security concern.  I have to scale the database and ensure my app scales with it as my app gets popular.  Finally, I am being fairly inflexible and causing potential privacy concerns with my users.\n\n\nThere are a couple of services that I can use to get around these concerns.  The first is an Azure service: \nAzure Active Directory B2C\n.  The B2C stands for Business to Consumer.  It is a mechanism by which you can add a sign-in and sign-up flow to your application.  The user can enter a username or password, or, at your option, add on support for one or more social providers.  In addition, there is support for branding the sign-in process, doing email verification of sign-ups and automatic password resets via email.  The Azure AD B2C sign-in / sign-up process is primarily a server-flow proecss, so we will be able to add support in our app with just one line of code.\n\n\nThe Minimal Setup of Azure AD B2C\n\n\nAzure AD is managed from the \nClassic Azure Portal\n, so start by logging in using your Azure Subscription credentials.\n\n\n\n\nClick on the big \n+ NEW\n button in the bottom left of the screen.\n\n\nSelect \nApp Services\n -> \nActive Directory\n -> \nDirectory\n -> \nCustom Create\n.\n\n\n\n\n\n\n\n\nChoose a name for the tenant, then choose a unique domain name (which will appear in the   \nonmicrosoft.com\n domain) and country.  Ensure you check the \nThis is a B2C directory.\n\n\n\n\n\n\n\n\nClick on the tick to create the directory.  As noted, this process will take a couple of minutes to complete.\n\n\n\n\nThis creates a new tenant for you to manage.  If you go back to your \nAzure Portal\n and click on your name (top right corner), you will note that there is a new DIRECTORY entry for your B2C tenant.  This is where you will be managing your B2C tenant.\n\n\nIt's a good idea to pin the B2C settings blade to your dashboard or navigation pane so you can access it faster.  To do this:\n\n\n\n\nLog in to the \nAzure Portal\n.\n\n\nSwitch to your B2C tenant by clicking on your name, then selecting the new tenant in the drop-down.\n\n\nThe portal will probably ask you to confirm your ID and password.\n\n\nClick on \nBrowse>\n in the left-hand navigation bar.\n\n\nSearch for \nB2C\n.\n\n\nClick on the empty star next to \nAzure AD B2C\n.\n\n\n\n\n\n\nThis will make Azure AD B2C appear in your left hand navigation bar.  To place it on the dashboard, click on \nAzure AD B2C\n in the left hand navigation bar, then click on the pin at the top of the \nAZURE AD B2C SETTINGS\n blade.\n\n\nThe next job is to create an application registration within the B2C tenant:\n\n\n\n\nOpen the \nAzure AD B2C\n from your dashboard or the left hand navigation.\n\n\nIn the \nSettings\n blade, click on \nApplications\n.\n\n\n\n\n\n\n\n\nIn the \nNew application\n blade:\n\n\nEnter a unique name for the application.\n\n\nClick on \nYes\n under \nInclude web app / web API\n.\n\n\nIn the Reply URL, enter \nhttps://yoursite.azurewebsites.net/.auth/login/aad/callback\n.\n\n\nClick on \nGenerate key\n - a key will be generated (cut and paste it somewhere).\n\n\n\n\n\n\n\n\nClick on \nCreate\n.\n\n\n\n\nThere is no spinner or deployment here.  After approximately 5-10 seconds, the application registration will appear in the list.  Click on the application registration to see the \nApplication ID\n:\n\n\n\n\nYou will need the Application ID and App Key (which you copied earlier) later on.  The next step is to create a Sign-in/Sign-up policy.  We'll create a policy for signing up with an email address and email confirmation, then signing in with that email address:\n\n\n\n\nIn the \nSettings\n blade, click on \nSign-up or sign-in policies\n.\n\n\nClick on the \n+ Add\n button.\n\n\nGive the policy a name, like \nemailPolicy\n.\n\n\nClick on \nIdentity providers\n:\n\n\nClick on \nEmail signup / Local Account\n (a tick will appear next to the row).\n\n\nClick on \nOK\n.\n\n\nClick on \nSign-up attributes\n:\n\n\nClick on \nEmail Address\n and any other fields you want to gather.\n\n\nClick on \nOK\n.\n\n\nClick on \nApplication claims\n:\n\n\nClick on \nEmail Addresses\n and any other fields you want to provide to the application.\n\n\nClick on \nOK\n\n\nClick on \nCreate\n on the \nAdd policy\n blade.\n\n\nClick on the policy you just created.  It will be named something like \nB2C_1_emailPolicy\n. Make a note of the \nMetadata Endpoint for this policy\n.\n\n\n\n\n\n\nNow that your B2C tenant is configured, you can switch back to your original tenant (by clicking on your name in the top-right corner and selecting the default directory).\n\n\nTo configure the App Service \nAuthentication / Authorization\n.  Open up the \nSettings\n blade, then \nAuthentication / Authorization\n.  Ensure the authentication service is turned on.  Click on \nAzure Active Directory\n. This time, we are going to select the \nAdvanced\n option.  The \nClient ID\n is the application ID of your B2C application registration, and the \nIssuer Url\n is the \nMetadata Endpoint\n for your sign-up policy:\n\n\n\n\nClick on \nOK\n to configure the authentication server flow, the \nSave\n to save the settings.  As before, you can test your server flow by pointing your browser to \nhttps://yoursite.azurewebsites.net/.auth/login/aad\n:\n\n\n\n\nIf you have done everything right, you should be able to register an account, get the email verification code, and finally log in to get the happy login page.\n\n\n\n\nAll that is left to do is to configure your app for Azure Active Directory Server Flow.  We did that earlier when discussing the Enterprise Authentication flow for the mobile client.\n\n\nDrawbacks of Azure Active Directory B2C\n\n\nAzure AD B2C is great for storing your users passwords and doing the sign-up and sign-in process for you.  There are a couple of reasons why you wouldn't want to use Azure Active Directory B2C.\n\n\nThe most obvious one is that this is a server-flow capability.  That means you won't be able to, for example, integrate the Facebook, Google and Twitter identity providers by utilizing their client libraries.  You also do not get access to the underlying identity provider token, so you are restricted from accessing the Graph API for the individual providers.  Finally, since the AAD B2C identity provider is configured with the AAD provider, you can't use both a B2C provider and a regular AAD provider.\n\n\nIf you just want a sign-up / sign-in flow, then AAD B2C is probably the best way to go.  If, however, your plans include integration with other social identity providers, you should consider whether you want to do more work on the client to support that.\n\n\nUsing Third Party Tokens\n\n\nThe final method of authenticating a user we are going to look at is a process by which you use a third party authentication token.   For example, you may want to authenticate via \nGitHub\n or \nmiiCard\n or using an authentication provider like \nAuth0\n to get some single sign-in capabilities.\n\n\nAuthentication with third party tokens works remarkably similar to the custom authentication case.  Instead of a username and password, you pass in the token from the other provider.\n\n\nTo look at this in example form, we are going to implement Auth0 as a provider. Your first stop should be the \nAuth0\n web site to sign up for a developer account. Once you have done that:\n\n\n\n\nClick on the \n+ NEW CLIENT\n button in the \nDashboard\n.\n\n\nGive your app a name, then click on \nNative\n and then \nCREATE\n.\n\n\n\n\n\n\n\n\nClick on the \nXamarin\n icon to get the Xamarin Quickstart.\n\n\nClick on \nSettings\n.\n\n\nEnter the callback URL in the \nAllowed Callback URLs\n.  The callback URL will be something like \nhttps://_youraccount_.auth0.com/mobile\n and will be listed in the Quickstart page.\n\n\nScroll down to the bottom of the page and click on \nSAVE CHANGES\n.\n\n\nMake a note of the Client ID of the application.  You will need it later.\n\n\nClick on \nConnections\n.\n\n\nTurn on any connections that you want to use.  For this example, ensure you turn on the \nUsername-Password-Authentication\n and a couple of social providers.\n\n\n\n\nNow that the Auth0 service is configured, we can turn our attention to the mobile client.  The Xamarin.Auth0Client is a component, so right-click on the \nComponents\n node of a platform project and select \nGet More Components...\n.  In the dialog, find the \nAuth0 SDK\n, then click on \nAdd to App\n.\n\n\nFor our iOS application, we are going to integrate Auth0 into the \nServices\\iOSLoginProvider.cs\n:\n\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginAuth0Async();\n\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"auth0\", zumoPayload);\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n\n        public async Task<string> LoginAuth0Async()\n        {\n            var auth0 = new Auth0.SDK.Auth0Client(\n                \"shellmonger.auth0.com\",\n                \"lmFp5jXnwPpD9lQIYwgwwPmFeofuLpYq\");\n            var user = await auth0.LoginAsync(RootView, scope: \"openid email\");\n            return user.Auth0AccessToken;\n        }\n\n\n\n\nThe parameters for the constructor to the \nAuth0Client\n are your Auth0 domain and client ID.  You can retrieve these from the Auth0 management page for your app.  Note that I am requesting the email address.  This will become a part of my ZUMO token when I create it.\n\n\nSwitching our attention to our \nBackend\n project, we need a new custom authentication controller.  This is located in \nControllers\\Auth0Controller.cs\n:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.IdentityModel.Tokens;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Web.Http;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server.Login;\n\nnamespace Backend.Controllers\n{\n    [Route(\".auth/login/auth0\")]\n    public class Auth0Controller : ApiController\n    {\n        private JwtSecurityTokenHandler tokenHandler;\n        private string clientID, domain;\n        private string signingKey, audience, issuer;\n\n        public Auth0Controller()\n        {\n            // Information for the incoming Auth0 Token\n            domain = Environment.GetEnvironmentVariable(\"AUTH0_DOMAIN\");\n            clientID = Environment.GetEnvironmentVariable(\"AUTH0_CLIENTID\");\n\n            // Information for the outgoing ZUMO Token\n            signingKey = Environment.GetEnvironmentVariable(\"WEBSITE_AUTH_SIGNING_KEY\");\n            var website = Environment.GetEnvironmentVariable(\"WEBSITE_HOSTNAME\");\n            audience = $\"https://{website}/\";\n            issuer = $\"https://{website}/\";\n\n            // Token Handler\n            tokenHandler = new JwtSecurityTokenHandler();\n        }\n\n        [HttpPost]\n        public IHttpActionResult Post([FromBody] Auth0User body)\n        {\n            if (body == null || body.access_token == null || body.access_token.Length == 0)\n            {\n                return BadRequest();\n            }\n\n            try\n            {\n                var token = (JwtSecurityToken)tokenHandler.ReadToken(body.access_token);\n                if (!IsValidUser(token))\n                {\n                    return Unauthorized();\n                }\n\n                var subject = token.Claims.FirstOrDefault(c => c.Type.Equals(\"sub\"))?.Value;\n                var email = token.Claims.FirstOrDefault(c => c.Type.Equals(\"email\"))?.Value;\n                if (subject == null || email == null)\n                {\n                    return BadRequest();\n                }\n\n                var claims = new Claim[]\n                {\n                    new Claim(JwtRegisteredClaimNames.Sub, subject),\n                    new Claim(JwtRegisteredClaimNames.Email, email)\n                };\n\n                JwtSecurityToken zumoToken = AppServiceLoginHandler.CreateToken(\n                    claims, signingKey, audience, issuer, TimeSpan.FromDays(30));\n                return Ok(new LoginResult()\n                {\n                    AuthenticationToken = zumoToken.RawData,\n                    User = new LoginResultUser { UserId = email }\n                });\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"Auth0 JWT Exception = {ex.Message}\");\n                throw ex;\n            }\n        }\n\n        private bool IsValidUser(JwtSecurityToken token)\n        {\n            if (token == null)\n                return false;\n            var audience = token.Audiences.FirstOrDefault();\n            if (!audience.Equals(clientID))\n                return false;\n            if (!token.Issuer.Equals($\"https://{domain}/\"))\n                return false;\n            if (token.ValidTo.AddMinutes(5) < DateTime.Now)\n                return false;\n            return true;\n        }\n    }\n\n    public class Auth0User\n    {\n        public string access_token { get; set; }\n    }\n}\n\n\n\n\nNote that we are reading two new environment variables.  In the Azure App Service, you can read Application Settings by reading the environment variable of the same name.  We need to set the \nAUTH0_CLIENTID\n to the Client ID of our Auth0 application, and the \nAUTH0_DOMAIN\n to the domain of our account.  Both of these values need to match the settings in the client.  These are not \"secure items\".  If using the client secret (to validate the token), then that would be considered secure and should only appear on the server side.\n\n\nThe validation is that the token passed in is valid (i.e. it has the right audience, issuer and expiry times).  In addition, you should check the validity of the token signature.  You can do this by acquiring the token secret and using \ntokenHandler.ValidateToken()\n instead of \ntokenHandler.ReadToken()\n.  My new token lasts for 30 days.  The ZUMO token that is generated in custom authentication does not have to be the same length as the original token. You can make it last for as long as you like.\n\n\nClaims and Authorization\n\n\nNow that we have covered all the techniques for authentication, it's time to look at authorization.  While authentication looked at verifying that a user is who they say they are, authorization looks at if a user is allowed to do a specific operation.\n\n\nAuthorization is handled within the server-side project by the \n[Authorize]\n attribute.  Our Azure Mobile Apps backend is leveraging this to provide authorization based on whether a user is authenticated or not.  The Authorize attribute can also check to see if a user is in a list of users or roles.  However, there is a problem with this.  The user id is not guessable and we have no roles.  To see what I mean, run the \nBackend\n project locally and set a break point on the \nGetAllTodoItems()\n method in the \nTodoItemController\n, then run your server and your UWP application.\n\n\n\n\nOnce you have built and deployed the UWP application, it will appear in your normal Application list.  This allows you to run the application and the server at the same time on the same machine.\n\n\n\n\nOnce you have authenticated, you will be able to set a break point to take a look at \nthis.User.Identity\n:\n\n\n\n\nNote that the \nName\n property is null.  This is the property that is used when you want to authorize individual users.  Expand the \nClaims\n property and then click on \nResults View\n:\n\n\n\n\nThe only claims are the ones in the token, and none of them match the \nRoleClaimType\n, so we can't use roles either.  Clearly, we are going to have to do something else.\n\n\nObtaining User Claims\n\n\nAt some point you are going to need to deal with something other than the claims that are in the token passed for authentication.  Fortunately, the Authentication / Authorization feature has an endpoint for that at \n/.auth/me\n:\n\n\n\n\nOf course, the \n/.auth/me\n endpoint is not of any use if you cannot access it.  The most use of this information is gained during authorization on the server and we will cover this use later on.  However, there are reasons to pull this information on the client as well.  For example, we may want to make the List View title be our name instead of \"Tasks\".\n\n\n\n\nYou can't use the /.auth/me endpoint when using custom authentication.\n\n\n\n\nSince identity provider claims can be anything, they are transferred as a list within a JSON object.  Before we can decode the JSON object, we need to define the models.  This is done in the shared \nTaskList\n project.  I've defined this in \nModels\\AppServiceIdentity.cs\n.\n\n\nusing System.Collections.Generic;\nusing Newtonsoft.Json;\n\nnamespace TaskList.Models\n{\n    public class AppServiceIdentity\n    {\n        [JsonProperty(PropertyName = \"id_token\")]\n        public string IdToken { get; set; }\n\n        [JsonProperty(PropertyName = \"provider_name\")]\n        public string ProviderName { get; set; }\n\n        [JsonProperty(PropertyName = \"user_id\")]\n        public string UserId { get; set; }\n\n        [JsonProperty(PropertyName = \"user_claims\")]\n        public List<UserClaim> UserClaims { get; set; }\n    }\n\n    public class UserClaim\n    {\n        [JsonProperty(PropertyName = \"typ\")]\n        public string Type { get; set; }\n\n        [JsonProperty(PropertyName = \"val\")]\n        public string Value { get; set; }\n    }\n}\n\n\n\n\nThis matches the JSON format from the \n/.auth/me\n call we did earlier.   This is going to be a part of the ICloudService as follows:\n\n\nusing System.Threading.Tasks;\nusing TaskList.Models;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n\n        Task LoginAsync(User user);\n\n        Task<AppServiceIdentity> GetIdentityAsync();\n    }\n}\n\n\n\n\nFinally, we need to actually implement the concrete version in \nAzureCloudService.cs\n:\n\n\nList<AppServiceIdentity> identities = null;\n\npublic async Task<AppServiceIdentity> GetIdentityAsync()\n{\n    if (client.CurrentUser == null || client.CurrentUser?.MobileServiceAuthenticationToken == null)\n    {\n        throw new InvalidOperationException(\"Not Authenticated\");\n    }\n\n    if (identities == null)\n    {\n        identities = await client.InvokeApiAsync<List<AppServiceIdentity>>(\"/.auth/me\");\n    }\n\n    if (identities.Count > 0)\n        return identities[0];\n    return null;\n}\n\n\n\n\nNote that there is no reason to instantiate your own \nHttpClient()\n.  The Azure Mobile Apps SDK has a method for invoking custom API calls (as we shall see later on).  However, if you prefix the path with a slash, it will execute a HTTP GET for any API with any authentication that is currently in force.  We can leverage this to call the \n/.auth/me\n endpoint and decode the response in one line of code.  Adjust the \nExecuteRefreshCommand()\n method in the \nViewModels\\TaskListViewModel.cs\n file to take advantage of this:\n\n\nasync Task ExecuteRefreshCommand()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var identity = await cloudService.GetIdentityAsync();\n        if (identity != null)\n        {\n            var name = identity.UserClaims.FirstOrDefault(c => c.Type.Equals(\"name\")).Value;\n            Title = $\"Tasks for {name}\";\n        }\n        var list = await Table.ReadAllItemsAsync();\n        Items.ReplaceRange(list);\n    }\n    catch (Exception ex)\n    {\n        await Application.Current.MainPage.DisplayAlert(\"Items Not Loaded\", ex.Message, \"OK\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}\n\n\n\n\nThe return value from the \nGetIdentityAsync()\n method is the first identity.  Normally, a user would only authenticate once, so this is fairly safe.  The number of claims returned depends on the identity provider and could easily number in the hundreds.  Even the default configuration for Azure Active Directory returns 18 claims.  These are easily handled using LINQ, however.  The \nType\n property holds the type.  This could be a short (common) name.  It could also be a schema name, which looks more like a URI.  The only way to know what claims are coming back for sure is to look at the \n/.auth/me\n result with something like Postman.\n\n\n\n\nNote\n: If you are using Custom Authentication (e.g. username/password or a third-party token), then the \n/.auth/me\n endpoint is not available to you.  You can still produce a custom API in your backend to provide this information to your client, but you are responsible for the code - it's custom, after all!\n\n\n\n\nAuthorization\n\n\nNow that we have covered all the techniques for authentication, it's time to look at authorization.  While authentication looked at verifying that a user is who they say they are, authorization looks at if a user is allowed to do a specific operation.\n\n\nAuthorization is handled within the server-side project by the \n[Authorize]\n attribute.  Our Azure Mobile Apps backend is leveraging this to provide authorization based on whether a user is authenticated or not.  The Authorize attribute can also check to see if a user is in a list of users or roles.  However, there is a problem with this.  The user id is not guessable and we have no roles.  To see what I mean, run the \nBackend\n project and set a break point on the \nGetAllTodoItems()\n method in the \nTodoItemController\n, then run your server and your UWP application.\n\n\n\n\nOnce you have built and deployed the UWP application, it will appear in your normal Application list.  This allows you to run the application and the server at the same time on the same machine.  Alternatively, you can attach a Debugger to your Azure App Service within Visual Studio's Cloud Explorer.\n\n\n\n\nOnce you have authenticated, you will be able to set a break point to take a look at \nthis.User.Identity\n:\n\n\n\n\nNote that the \nName\n property is null.  This is the property that is used when you want to authorize individual users.  Expand the \nClaims\n property and then click on \nResults View\n:\n\n\n\n\nThe only claims are the ones in the token, and none of them match the \nRoleClaimType\n, so we can't use roles either.  Clearly, we are going to have to do something else.  Fortunately, we already know that we can get some information about the identity provider claims from the \n/.auth/me\n endpoint.  To get the extra information, we need to query the \nUser\n object:\n\n\nvar identity = await User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request);\n\n\n\n\nThere is one \nCredentials\n class for each supported authentication technique - Azure Active Directory, Facebook, Google, Microsoft Account and Twitter.  These are in the \nMicrosoft.Azure.Mobile.Server.Authentication\n namespace.  They all follow the same pattern as the model we created for the client - there are Provider, UserId and UserClaims properties.  The token and any special information will be automatically decoded for you.  For instance, the TenantId is pulled out of the response for Azure AD.\n\n\n\n\nYou can use the AccessToken property to do Graph API lookups for most providers in a custom API. We'll get into this more in a later Chapter.\n\n\n\n\nAdding Group Claims to the Request\n\n\nThere are times when you want to add something else to the token that is returned from Azure AD. The most common requirement is to add group information to the response so you can handle group-based authorization.\n\n\nTo add security groups to the Azure AD token:\n\n\n\n\nLog into the \nClassic Portal\n.\n\n\nClick on your directory (probably called \nDefault Directory\n) in the \nAll Items\n list.\n\n\nClick on \nAPPLICATIONS\n, then your WEB application.\n\n\nClick on \nMANAGE MANIFEST\n (at the bottom of the page), then \nDownload Manifest\n.\n\n\nClick on \nDownload manifest\n.\n\n\n\n\nThis will download a JSON file.  Edit the file with a text editor.  (I use Visual Studio Code).  At the top of the file is this:\n\n\n  \"displayName\": \"webapp-for-the-book\",\n  \"errorUrl\": null,\n  \"groupMembershipClaims\": null,\n  \"homepage\": \"https://the-book.azurewebsites.net\",\n  \"identifierUris\": [\n    \"https://the-book.azurewebsites.net\"\n  ],\n  \"keyCredentials\": [],\n  \"knownClientApplications\": [],\n\n\n\n\nChange the \ngroupMembershipClaims\n to \"SecurityGroup\":\n\n\n  \"displayName\": \"webapp-for-the-book\",\n  \"errorUrl\": null,\n  \"groupMembershipClaims\": \"SecurityGroup\",\n  \"homepage\": \"https://the-book.azurewebsites.net\",\n  \"identifierUris\": [\n    \"https://the-book.azurewebsites.net\"\n  ],\n  \"keyCredentials\": [],\n  \"knownClientApplications\": [],\n\n\n\n\nSave the file.  You can now upload this again.  Go back to the WEB application, click on \nMANAGE MANIFEST\n, then click on \nUpload Manifest\n.  Select the file and click on the tick.\n\n\n\n\nYou can now give the web application additional permissions:\n\n\n\n\nClick on the \nCONFIGURE\n tab.\n\n\nScroll to the bottom, click on \nDelegated Permissions\n.\n\n\nCheck the box for \nRead directory data\n.\n\n\n\n\n\n\n\n\nClick on \nSave\n.\n\n\n\n\nNow that you have configured the application to return groups as part of the claims, you should probably add a couple of groups:\n\n\n\n\nClick on the back-arrow (at the top left) to return to the top level of your directory.\n\n\nClick on \nGROUPS\n.\n\n\nClick on \nADD GROUP\n.\n\n\nFill in the information, select \nSecurity\n as the group type, then click on the tick.\n\n\n\n\n\n\n\n\nClick on the new group, then click on \nPROPERTIES\n.\n\n\n\n\n\n\n\n\nMake a note of the \nOBJECT ID\n.  The claims for groups are listed by the Object ID, so you will need this to refer to the group later.\n\n\n\n\nIt's a good idea to add a couple of groups for testing purposes.  If you are using the organization directory, you will need to request the creation of a couple of groups for application roles.  The view of the groups will be shown when we get the identity of\nthe user using \nUser.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request)\n:\n\n\n\n\nGroup Authorization\n\n\nNow that we have group claims in the claims list for the \n/.auth/me\n endpoint, we can move forward to do authorization based on these claims.  This can be done in a relatively basic\nmanner by implementing a method to check the claims:\n\n\nasync Task<bool> IsAuthorizedAsync()\n{\n    var identity = await User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request);\n    var countofGroups = identity.UserClaims\n        .Where(c => c.Type.Equals(\"groups\") && c.Value.Equals(\"01f214a9-af1f-4bdd-938f-3f16749aef0e\"))\n        .Count();\n    return (countofGroups > 0);\n}\n\n\n\n\nThe \nUserClaims\n object is an \nIEnumerable\n that contains objects with a Type and a Value.  The Type for the group claims is \ngroups\n.  Once we have this knowledge, we can use a LINQ query to obtain a count of the claims that match the conditions we want to test.  The Value we use is the Object ID of the group.  This is available in the \nPROPERTIES\n tab of the group.\n\n\nWe can prevent a new record being added by adjusting the \nPostTodoItem()\n method:\n\n\npublic async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n{\n    if (!await IsAuthorizedAsync())\n    {\n        return Unauthorized();\n    }\n    TodoItem current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}\n\n\n\n\nUnfortunately, most of the table controller methods do not return an \nIHttpActionResult\n, so this has limited value.  What would be better would be an \n[Authorize]\n attribute that tests the claims for us.  For instance, we should be able to do the following:\n\n\n[AuthorizeClaims(\"groups\", \"01f214a9-af1f-4bdd-938f-3f16749aef0e\")]\npublic async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n{\n    TodoItem current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}\n\n\n\n\nThe \n[AuthorizeClaims()]\n attribute does not exist, so we have to provide it ourselves:\n\n\nusing System.Linq;\nusing System.Net;\nusing System.Security.Principal;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.Filters;\nusing Microsoft.Azure.Mobile.Server.Authentication;\n\nnamespace Backend.Helpers\n{\n    public class AuthorizeClaimsAttribute : AuthorizationFilterAttribute\n    {\n        string Type { get; }\n        string Value { get; }\n\n        public AuthorizeClaimsAttribute(string type, string value)\n        {\n            Type = type;\n            Value = value;\n        }\n\n        public override async Task OnAuthorizationAsync(HttpActionContext actionContext, CancellationToken cancellationToken)\n        {\n            var request = actionContext.Request;\n            var user = actionContext.RequestContext.Principal;\n            if (user != null)\n            {\n                var identity = await user.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(request);\n                var countOfMatchingClaims = identity.UserClaims\n                    .Where(c => c.Type.Equals(Type) && c.Value.Equals(Value))\n                    .Count();\n                if (countOfMatchingClaims > 0) return;\n\n            }\n            throw new HttpResponseException(HttpStatusCode.Unauthorized);\n        }\n    }\n}\n\n\n\n\nThis is the same type of authorization filter attribute that the officially provided \nAuthorizeAttribute\n is based on.  However, the AuthorizeAttribute is synchronous.  We require an asynchronous version of the attribute, so we cannot use a sub-class of the AuthorizeAttribute.  Aside from that note, this uses virtually the same code that we used in the \nIsAythorizedAsync()\n method we developped earlier.\n\n\nWe can now use this attribute for testing any claim.  For example, our claims has the identity provider as a claim.  We can use the following:\n\n\n[AuthorizeClaims(\"http://schemas.microsoft.com/identity/claims/identityprovider\", \"live.com\")]\n\n\n\n\n\n\nIf you want to test other claims that are not provided, you can enable the \nRead Directory Data\n permission in the Azure Active Directory permissions and do a query against the Azure Active Directory.  You should think about caching results if this is the case.\n\n\n\n\nCaching Tokens\n\n\nYou will notice that we have to log in with every start of the application.  The token that is generated has a lifetime that is provided and controlled by the identity provider.  Some providers have a relatively short lifetime.  For example, Azure Active Directory tokens have a lifetime of 1 hour.  Others are incredibly long.  Facebook has an expiry time of 60 days.\n\n\nIrrespective of the lifespan of the token, we will want to store it securely and re-use it when we can.  Xamarin has provided a nice component, [Xamarin.Auth], that provides such as secure store in a cross-platform manner.  It starts with an account store:\n\n\nvar accountStore = AccountStore.Create();\n// For Android:\n// var accountStore = AccountStore.Create(Context);\n\n\n\n\nWe can then store the token with the following:\n\n\naccountStore.Save(account, \"descriptor\");\n\n\n\n\nThe descriptor is a string that allows us to find the token again.  The account (which is an \nAccount\n object) is uniquely identified by a key composed of the account's Username property and the descriptor.  The Account class is provided with Xamarin.Auth.  Storage is backed by the \nKeychain\n on iOS and the \nKeyStore\n on Android.\n\n\nTo get the token back, we use the following:\n\n\nvar accounts = accountStore.FindAccountsForService(\"descriptor\");\n\n\n\n\nWhen we receive the token back from the key store, we will want to check the expiry time to ensure the token has not expired.  As a result, there is a little bit more code to caching code than one would expect.\n\n\nLet's start with the Android version in \nTaskList.Droid\n.  As with all the other login code, we are adjusting the \nLoginAsync()\n method in \nServices\\DroidLoginProvider.cs\n:\n\n\nusing System;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Android.App;\nusing Android.Content;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\nusing TaskList.Helpers;\nusing Xamarin.Auth;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        public Context RootView { get; private set; }\n\n        public AccountStore AccountStore { get; private set; }\n\n        public void Init(Context context)\n        {\n            RootView = context;\n            AccountStore = AccountStore.Create(context);\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Check if the token is available within the key store\n            var accounts = AccountStore.FindAccountsForService(\"tasklist\");\n            if (accounts != null)\n            {\n                foreach (var acct in accounts)\n                {\n                    string token;\n\n                    if (acct.Properties.TryGetValue(\"token\", out token))\n                    {\n                        if (!IsTokenExpired(token))\n                        {\n                            client.CurrentUser = new MobileServiceUser(acct.Username);\n                            client.CurrentUser.MobileServiceAuthenticationToken = token;\n                            return;\n                        }\n                    }\n                }\n            }\n\n            // Server Flow\n            await client.LoginAsync(RootView, \"aad\");\n\n            // Store the new token within the store\n            var account = new Account(client.CurrentUser.UserId);\n            account.Properties.Add(\"token\", client.CurrentUser.MobileServiceAuthenticationToken);\n            AccountStore.Save(account, \"tasklist\");\n        }\n\n        bool IsTokenExpired(string token)\n        {\n            // Get just the JWT part of the token (without the signature).\n            var jwt = token.Split(new Char[] { '.' })[1];\n\n            // Undo the URL encoding.\n            jwt = jwt.Replace('-', '+').Replace('_', '/');\n            switch (jwt.Length % 4)\n            {\n                case 0: break;\n                case 2: jwt += \"==\"; break;\n                case 3: jwt += \"=\"; break;\n                default:\n                    throw new ArgumentException(\"The token is not a valid Base64 string.\");\n            }\n\n            // Convert to a JSON String\n            var bytes = Convert.FromBase64String(jwt);\n            string jsonString = UTF8Encoding.UTF8.GetString(bytes, 0, bytes.Length);\n\n            // Parse as JSON object and get the exp field value,\n            // which is the expiration date as a JavaScript primative date.\n            JObject jsonObj = JObject.Parse(jsonString);\n            var exp = Convert.ToDouble(jsonObj[\"exp\"].ToString());\n\n            // Calculate the expiration by adding the exp value (in seconds) to the\n            // base date of 1/1/1970.\n            DateTime minTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);\n            var expire = minTime.AddSeconds(exp);\n            return (expire < DateTime.UtcNow);\n        }\n    }\n}\n\n\n\n\nThere are three new pieces to this code.  The first piece is to check to see if there is an existing token in the KeyStore.  If there is, we check the expiry time and then set up the Azure Mobile Apps client with the username and token from the KeyStore.  If there isn't, we do the normal authentication process.  If the authentication process is successful, we reach the second piece, which is to store the token within the KeyStore.  If there is an existing entry, it will be overwritten.  Finally, there is a method called \nIsTokenExpired()\n whose only job is to check to see if a token is expired or not.  This same code can be used in the \nServices/iOSLoginProvider.cs\n.  The only difference is in the \nAccountStore.Create()\n call (as discussed earlier).\n\n\nI'm using an application specific service ID (or descriptor) for this purpose.  You could also use an identity provider-based service ID which is especially useful if your mobile client supports multiple identity providers.\n\n\nXamarin.Auth only support iOS and Android.  We need to turn to an alternate library for token caching on Universal Windows.  The standard library has a package called \nPasswordVault\n that can be used identically to the \nKeyStore\n and \nKeychain\n libraries.  Here is the Universal Windows version of the same code in \nServices\\UWPLoginProvider.cs\n:\n\n\nusing System;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.UWP.Services;\nusing Windows.Security.Credentials;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public PasswordVault PasswordVault { get; private set; }\n\n        public UWPLoginProvider()\n        {\n            PasswordVault = new PasswordVault();\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Check if the token is available within the password vault\n            var acct = PasswordVault.FindAllByResource(\"tasklist\").FirstOrDefault();\n            if (acct != null)\n            {\n                var token = PasswordVault.Retrieve(\"tasklist\", acct.UserName).Password;\n                if (token != null && token.Length > 0 && !IsTokenExpired(token))\n                {\n                    client.CurrentUser = new MobileServiceUser(acct.UserName);\n                    client.CurrentUser.MobileServiceAuthenticationToken = token;\n                    return;\n                }\n            }\n\n            // Server-Flow Version\n            await client.LoginAsync(\"aad\");\n\n            // Store the token in the password vault\n            PasswordVault.Add(new PasswordCredential(\"tasklist\",\n                client.CurrentUser.UserId,\n                client.CurrentUser.MobileServiceAuthenticationToken));\n        }\n\n        bool IsTokenExpired(string token)\n        {\n            /* Copy code from DroidLoginProvider */\n        }\n    }\n}\n\n\n\n\nThe PasswordVault replaces the KeyStore (Android) and Keychain (iOS), but the concepts are the same.  All three mechanisms provide the basic functionality of storing client secrets securely.\n\n\nRefresh Tokens\n\n\nOur token cache checks the token to see if it is expired and prompts the user if the token is no longer valid.  Since the life of a token is inevitably short (maybe 1 hour), this will still mean that the user is prompted for new credentials most of the time.  In addition, we have an issue when the app is running for a long time.  What happens if the user leaves the app running for 2 hours?  The token we received at the start of the session will be invalid halfway through the session and we will have to restart the app in order to continue.  Both of these situations are undesirable from the point of view of the user.  Access tokens eventually expire and we need to explicitly deal with this situation.\n\n\nThe first part of the solution is to request a \nRefresh Token\n.  This is something the identity provider issues when the scope of the request includes an offline scope.  Only certain identity providers include the ability to request refresh tokens.  For server-flow:\n\n\n\n\nGoogle: Append the \"access_type=offline\" to the request.\n\n\nMicrosoft Account: Select the wl.offline_access scope in the Azure management portal.\n\n\nAzure AD: Configure Azure AD to support access to the Graph API.\n\n\n\n\nFacebook and Twitter do not provider refresh tokens.  Once you have the refresh tokens, you can simply call the refresh API in the Azure Mobile Apps SDK to refresh the token.\n\n\n\n\nRefresh Tokens are one area that require special consideration when using Custom Authentication.  Just like with the /.auth/me endpoint, you are on your own when it comes to handling token expiry for custom authentication.\n\n\n\n\nConfiguring Refresh Tokens\n\n\nAzure Active Directory is perhaps the trickiest to configure.\n\n\n\n\nLog on to the \nClassic Portal\n.\n\n\nNavigate to your Azure Active Directory.\n\n\nGo to \nAPPLICATIONS\n and then your WEB application.\n\n\nGo to the \nCONFIGURE\n tab.\n\n\nScroll down to the \nKeys\n section.\n\n\n\n\n\n\n\n\nIn the \nSelect duration\n drop-down, select \n2 Years\n.\n\n\nClick on \nSAVE\n.  The key will be generated for you.  Copy the key (you will need it below).\n\n\nGo back to the \nAzure Portal\n.\n\n\nGo to \nApp Services\n, then your App Service.\n\n\nClick on \nTools\n, then \nResource explorer\n, then \nGo\n.\n\n\nIn the Resource Explorer, expand \nconfig\n and select \nauthsettings\n.\n\n\nClick on \nEdit\n.\n\n\nSet the clientSecret to the key you copied from above.\n\n\nSet the additionalLoginParams to \n[\"response_type=code id_token\"]\n.\n\n\n\n\n\n\n\n\nClick the \nRead/Write\n toggle button at the top of the page.\n\n\nClick the \nPUT\n button.\n\n\n\n\nThe next time the user logs into our web app side, there will be a one-time prompt to consent to graph API access.  Once granted, the App Service Authentication / Authorization service will start requesting and receiving refresh tokens.\n\n\nUsing Refresh Tokens\n\n\nThe Azure Mobile Apps Client SDK has a built in method for refreshing tokens for you.  It assumes that you are using a supported identity provider (Azure Active Directory, Google or Microsoft Account), and have configured the identity provider to generate the refresh token.\n\n\n\n\nAzure App Service Authentication / Authorization maintains a token store in the XDrive (which is the drive that is shared among all instances of the backend within the same App Service Plan).  The token store is located at \nD:\\\\home\\\\data\\\\.auth\\\\tokens\n on the backend.  The tokens are encrypted and stored in a per-user encrypted file.\n\n\n\n\nLogging out\n\n\nBest Practices",
            "title": "Chapter 2 - Authentication"
        },
        {
            "location": "/2_authentication/#authentication",
            "text": "One of the very first things you will want to do is to provide users with a unique experience.  For our example task list application, this could be as simple as providing a task list for the user who is logged in.  In more complex applications, this is the gateway to role-based access controls, group rules, and sharing with your friends.  In all these cases, properly identifying the user using the phone is the starting point.",
            "title": "Authentication"
        },
        {
            "location": "/2_authentication/#concepts",
            "text": "Authentication provides a process by which the user that is using the mobile device can be identified securely.  This is generally done by entering a username and password.  However, modern systems can also provide  multi-factor authentication , send you a text message to a registered device, or  use your fingerprint  as the password.",
            "title": "Concepts"
        },
        {
            "location": "/2_authentication/#the-oauth-process",
            "text": "In just about every single mobile application, a process called  OAuth  is used to properly identify a user to the mobile backend.  OAuth is not an authentication mechanism in its own right.  It is used to route the authentication request to the right place and to verify that the authentication took place. There are three actors in the OAuth protocol:   The  Client  is the application attempting to get access to the resource.  The  Resource  is the mobile backend that the client is attempting to access.  The  Identity Provider  (or IdP) is the service that is responsible for authenticating the client.   At the end of the process, a cryptographically signed token is minted.  This token is added to every single subsequent request to identify the user.",
            "title": "The OAuth Process"
        },
        {
            "location": "/2_authentication/#server-side-vs-client-side-authentication",
            "text": "There are two types of authentication flow: Server-Flow and Client-Flow.  They are so named because of who controls the flow of the actual authentication.   Server-flow is named because the authentication flow is managed by the server through a web connection.  It is generally used in two cases:   You want a simple placeholder for authentication in your mobile app while you are developing other code.  You are developing a web app.   In the case of Server Flow:   The client brings up a web view and asks for the login page from the resource.  The resource redirects the client to the identity provider.  The identity provider does the authentication before redirecting the client\n   back to the resource (with an identity provider token).  The resource validates the identity provider token with the identity provider.  Finally, the resource mints a new resource token that it returns to the client.   Client-flow authentication uses an IdP provided SDK to integrate a more native feel to the authentication flow.  The actual flow happens on the client, communicating only with the IdP.   The client uses the IdP SDK to communicate with the identity provider.  The identity provider does the authentication, returning an identity provider token.  The client presents the identity provider token to the resource.  The resource validates the identity provider token with the identity provider.  Finally, the resource mints a new resource token that it returns to the client.   For example, if you use the Facebook SDK for authentication, your app will seamlessly switch over into the Facebook app and ask you to authorize your client application before switching you back to your client application.  It is generally recommended that you use the IdP SDK when developing an app that will be released on the app store.  This follows the best practice provided by the majority of identity providers and provides the best experience for your end users.",
            "title": "Server Side vs. Client Side Authentication"
        },
        {
            "location": "/2_authentication/#authentication-providers",
            "text": "Azure Mobile Apps supports five identity providers natively:   Azure Active Directory  Facebook  Google  Microsoft (MSA)  Twitter   In addition, you can set up client-flow custom authentication that allows you to mint a ZUMO token to your specifications for any provider using a client-flow.  For example, you could use authentication providers like  Azure AD B2C ,  LinkedIn  or  GitHub , a third-party authentication provider like   Auth0 , or you could set up an identity table in your database so that you can check  username and password without an identity provider.",
            "title": "Authentication Providers"
        },
        {
            "location": "/2_authentication/#adding-authentication-to-a-mobile-backend",
            "text": "The Azure App Service Authentication / Authorization service integrates seamlessly into an Azure Mobile Apps backend as a piece of middleware that fills in the Identity information for ASP.NET.  That means the only thing we have to worry about is authorization.  The authentication piece (determining that a user is who they say they are) is already taken care of.  Authorization (which is the determination of whether an authenticated user can use a specific API) can happen at either the controller level or an individual operation level.  We can add authorization to an entire table controller by adding the  [Authorize]  attribute to the table controller.  For example, here is our table controller from the first chapter with authorization required for all operations:  using System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    [Authorize]\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}  Authorization can also happen on a per-operation basis by adding the  [Authorize]  attribute to a single method within the table controller.  For example, instead of requiring authorization on the entire table, we want a version where reading was possible anonymously but updating the database required authentication:  using System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        [Authorize]\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        [Authorize]\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        [Authorize]\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}  Note that the  [Authorize]  attribute can do much more than what is provided here.  Underneath there are various parameters that you can adjust to see if the user belongs to a specific group or role.  However, the token that is checked to see if the user is authenticated does not pull in any of the other information that is normally needed for such authorization tasks.  As a result, the  [Authorize]  tags is really only checking whether a request requires authentication or not.",
            "title": "Adding Authentication to a Mobile Backend"
        },
        {
            "location": "/2_authentication/#configuring-an-authentication-provider",
            "text": "Configuration of the identity provider is very dependent on the identity provider and whether the client is using a client-flow or server-flow.  Choose one of the several options for authentication:   Enterprise Authentication  covers Azure Active Directory.  Social Authentication  covers Facebook, Google, Microsoft and Twitter.   We can also configure authentication using custom routes.  This allows us to use other (non-supported) services or to completely customize our flow (for example, to use an existing identity database).",
            "title": "Configuring an Authentication Provider"
        },
        {
            "location": "/2_authentication/#azure-active-directory-server-flow-setup",
            "text": "The Azure Active Directory server-flow is perhaps the easiest of all the authentication methods to configure.  No matter if you are doing a client flow or server flow, you need to set up the server flow first.   We recommend that you implement Client Flow in any non-trivial application.   If you are using your default directory and you want to add a couple of test users, you will need to set those up first.   Start by going to the  Classic Azure Portal :   Click on the  Default Directory , then click on  USERS .  You will notice that your Azure-linked ID is already present.   Click on  Add User  at the bottom of the screen.  Enter a username in the box provided before clicking on the arrow.  Then fill in the personal information and click on the arrow again.  Finally, click on  create .  Note the password, before clicking on the tick.  Now you have two users - your Azure ID and the one you just created.  Note the username.  It is based on the tenant, so it will be something like  adrian@photoadrianoutlook.onmicrosoft.com .  To configure your app, switch back to the regular  Azure Portal , find your App Service, click on  All Settings  followed by  Authentication / Authorization . Finally, select  Azure Active Directory .   Click on  Express .  Note that all the information is filled in for you.  All you have to do is click on  OK , followed by  Save .   Make sure you create the app service in the right directory / subscription.  If you have access to more than one directory, you can choose the right one by selecting it under your account drop-down in the top-right corner.   There is also an  Advanced  track.  This is used in client-flow situations and in situations where you have more than one directory.  The Express flow is great for getting started quickly.  You can walk through a server-flow authentication to test that you have all the settings correct.  Point your browser at https:// yoursite .azurewebsites.net/.auth/login/aad.  The browser will take you through an authentication flow before giving you a successful authentication image:",
            "title": "Azure Active Directory: Server-Flow setup"
        },
        {
            "location": "/2_authentication/#adding-authentication-to-a-mobile-client",
            "text": "Now that the backend is completely configured, we can move our attention to the mobile client.  We are going to be using the same mobile client that we developed in the first chapter, but we are now going to add authentication to it.  Web views are one of those items that are platform dependent. Fortunately for us, Xamarin has already thought of this and provided a facility for running platform specific code called the  DependencyService .   If we run our application right now, clicking on the \"Enter the App\" button will result in an error.  You will be able to see the Unauthorized error in the debug window of Visual Studio.   Our first step is to define an  Abstractions\\ILoginProvider.cs  interface within the  shared project:  using Microsoft.WindowsAzure.MobileServices;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ILoginProvider\n    {\n        Task LoginAsync(MobileServiceClient client);\n    }\n}  Next, we are going to extend our  Abstractions\\ICloudService.cs  interface so that the main application can call the login routine:  using System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n    }\n}  Our code will call  LoginAsync()  in the  ICloudService , which will get the platform-specific version of the login provider and call  LoginAsync()  there, but with our defined mobile service client.  That is defined in the  Services\\AzureCloudService.cs  class:  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing Xamarin.Forms;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(Locations.AppServiceUrl);\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData => new AzureCloudTable<T>(client);\n\n        public Task LoginAsync()\n        {\n            var loginProvider = DependencyService.Get<ILoginProvider>();\n            return loginProvider.LoginAsync(client);\n        }\n    }\n}  The method looks up the platform dependent version of the login provider and executes the login method, passing along the client (which we will need later).  In each platform-specific project, we are going to define a concrete implementation of the login provider that uses a web view to hold the actual authentication flow.  Here is the droid  Services\\DroidLoginProvider.cs  (in the TaskList.Droid project):  using System.Threading.Tasks;\nusing Android.Content;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        Context context;\n\n        public void Init(Context context)\n        {\n            this.context = context;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(context, \"aad\");\n        }\n    }\n}  Let us take a closer look at this implementation.  The  LoginAsync()  method on the Azure Mobile Apps client object takes the Android context (which is normally the main window) and a provider - we can pick any of \"facebook\", \"google\", \"microsoftaccount\", \"twitter\" or \"aad\" depending on what we have defined in the Azure App Service.  The clever piece is the  Xamarin.Forms.Dependency  call at the top - that registers the class as a platform service so we can access it through the Xamarin dependency service.  Note that we need an extra initialization routine for Android that must be called prior the login provider being called to pass along the main window of the app (also known as the context).  This is done in the  MainActivity.cs  file  after  the Xamarin Forms initialization call.  The dependency service is not set up until after the Xamarin Forms library is initialized, so we will not be able to get the login provider reference before that point:  protected override void OnCreate(Bundle bundle)\n{\n    base.OnCreate(bundle);\n\n    Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n    global::Xamarin.Forms.Forms.Init(this, bundle);\n\n    ((DroidLoginProvider)DependencyService.Get<ILoginProvider>()).Init(this);\n\n    LoadApplication(new App());\n}  iOS is similar, but does not require the initialization step in the main startup class.  The login provider class is in  Services\\iOSLoginProvider.cs  (in the  TaskList.iOS  project):  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.iOS.Services;\nusing UIKit;\n\n[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]\nnamespace TaskList.iOS.Services\n{\n    public class iOSLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(RootView, \"aad\");\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n    }\n}  Note that we are using the same pattern here for registering the concrete implementation with the dependency service, so we can get it the same way. Finally, here is the UWP  Services\\UWPLoginProvider.cs  (in the TaskList.UWP project):  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.UWP.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(\"aad\");\n        }\n    }\n}  Now that we have all the platform-specific login routines registered, we can move on to adding the login routine to the UI.  We have already got a button on the entry page to enter the app.  It makes sense to wire up that button so that it logs us in as well. The Command for the login button is in the  ViewModels\\EntryPageViewModel.cs :  async Task ExecuteLoginCommand()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var cloudService = ServiceLocator.Instance.Resolve<ICloudService>();\n        await cloudService.LoginAsync();\n        Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n    }\n    catch (Exception ex)\n    {\n        Debug.WriteLine($\"[ExecuteLoginCommand] Error = {ex.Message}\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}   The  ServiceLocator  class is my basic singleton handler.  It is available in the  Chapter2  project.  It returns the concrete version of the cloud service, just like the Singleton version we defined in Chapter1.   When you run the application, clicking on the \"Enter the App\" button will now present you with an Authenticate window:   Going through the authentication process will get you to the task list again.  If the authentication process fails, then  LoginAsync()  will throw an error, which is caught at the ViewModel.  Right now, the  EntryPageViewModel  does nothing more than print a diagnostic message to the debug window of Visual Studio.",
            "title": "Adding Authentication to a Mobile Client"
        },
        {
            "location": "/2_authentication/#azure-active-directory-client-flow-setup",
            "text": "Configuring Azure Active Directory for client-flow is a three-step process.  First, we need to create a WEB application.  This represents the resource: in our case, the resource is the Azure Mobile Apps backend.  Then we need to create a NATIVE application.  This represents the client: in our case, the ADAL (Active Directory Access Library) library will need this information.  Finally, we need to give the NATIVE application permission to access the WEB application.  It starts with configuring a server-flow to protect the resource.  We've already done that above. Then configure a \"Native Application\" and give it permissions to the web application:   Log on to the  Classic Portal .  Select the  Default Directory  from your list of all items.  Click on the  APPLICATIONS  tab.     Note that our existing web application is already there.  You will see more applications, depending on what you have set up.  In this example, I have Visual Studio Team Services and Office 365 set up.  Click on the  ADD  button at the bottom of the page.     Click on  Add an application my organization is developing .     Enter a name for the app registration, and select  NATIVE CLIENT APPLICATION .  Click on the Next arrow.  Enter a valid URI - it can be anything, but it has to be valid     Click on the tick to create the application.  The wizard will close, but you will be brought to the app configuration.  Click on the  CONFIGURE  tab.     Add a Redirect URI of the form:  https://yoursite.azurewebsites.net/.auth/login/done .     At the bottom of the page is the  permissions to other applications  section.  Click on the  Add application  button.     Click on the  SHOW  drop-down and select  All Apps , then click on the tick next to the search box.  Click on the web application that you set up during the server-flow configuration, then click on the  tick in the lower-right corner.     Click on  Delegated Permissions  next to the web application.  Check the box next to  Access , then click on  Save  at the bottom of the screen.    At this point the application configuration will be saved.  So, what did we just do there?  We created a new Azure AD app for the native application.  We then gave permission for the native application to access resources that are protected by the web application.  In our Azure App Service, we configured the service so that the Azure AD web application is used to protect our resources.  The net effect is that our native application OR our web application can access the App Service resources that are protected via the  [Authorize]  attribute.  Before continuing, you will need the  Client ID  and the  Redirect URI  for the NATIVE application. You can enter these into the  Helpers\\Locations.cs  file in the shared project:  namespace TaskList.Helpers\n{\n    public static class Locations\n    {\n        public static readonly string AppServiceUrl = \"https://the-book.azurewebsites.net\";\n\n        public static readonly string AadClientId = \"b61c7d68-2086-43a1-a8c9-d93c5732cc84\";\n\n        public static readonly string AadRedirectUri = \"https://the-book.azurewebsites.net/.auth/login/done\";\n\n        public static readonly string AadAuthority = \"https://login.windows.net/photoadrianoutlook.onmicrosoft.com\";\n    }\n}  The  AadClientId  and  AadRedirectUri  must match what we have configured in Azure AD for the native app.  The other piece of information we need to add is the Azure AD Authority for the directory.  If you click on the  DOMAINS  tab, it will generally tell you what domain you are in. The Authority is just a path on the  https://login.windows.net  that corresponds to your domain.  There is also a GUID version of this domain.  You can find the GUID by looking at the  View Endpoints  in the  APPLICATIONS  tab.  Look at the first path section of most all the endpoints.  Add the  Microsoft.IdentityModel.Clients.ActiveDirectory  NuGet package using  Manage NuGet Packages...  to each platform project.  This package contains the ADAL library as a portable class library.   Now you can add the client flow to each project.  Start with the login provider in the  TaskList.UWP  project, located in the  Services\\UWPLoginProvider.cs  file:  using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.UWP.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync()\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters(PromptBehavior.Auto, false));\n            return authResult.AccessToken;\n        }\n\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginADALAsync();\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server-Flow Version\n            // await client.LoginAsync(\"aad\");\n        }\n    }\n}  The  LoginADALAsync()  method does the actual client-flow - using the ADAL library to authenticate the user and return the access token.  The  LoginAsync()  method initiates the client-flow.  It uses the token it receives from the client-flow to log in to the App Service, by packaging the token into a JSON object.  I have placed the client and server flow next to each other so you can compare the two.  In the  TaskList.Droid  project, we need to deal with the  Context , as is common with Android libraries.  The client flow in  Services\\DroidLoginProvider.cs  is remarkably similar though:  using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Android.App;\nusing Android.Content;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\nusing TaskList.Helpers;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        Context context;\n\n        public void Init(Context context)\n        {\n            this.context = context;\n        }\n\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync()\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters((Activity)context));\n            return authResult.AccessToken;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginADALAsync();\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server-Flow Version\n            // await client.LoginAsync(context, \"aad\");\n        }\n    }\n}  The only real difference between this one and the Universal Windows edition is the PlatformParameters. We need to pass in the context of the MainActivity (which is passed in through the  Init()  call).  However, we must also handle the response from the ADAL library.  This is done in  MainActivity.cs . Add the following method to the  MainActivity  class:  protected override void OnActivityResult(int requestCode, Result resultCode, Intent data)\n{\n    base.OnActivityResult(requestCode, resultCode, data);\n    AuthenticationAgentContinuationHelper.SetAuthenticationAgentContinuationEventArgs(requestCode, resultCode, data);\n}  Finally, the iOS version also requires access to the root view, so its  PlatformParameters  are also slightly different.  Here is  Services\\iOSLoginProvider.cs :  using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.iOS.Services;\nusing UIKit;\n\n[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]\nnamespace TaskList.iOS.Services\n{\n    public class iOSLoginProvider : ILoginProvider\n    {\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync(UIViewController view)\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters(view));\n            return authResult.AccessToken;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            var rootView = UIApplication.SharedApplication.KeyWindow.RootViewController;\n\n            // Client Flow\n            var accessToken = await LoginADALAsync(rootView);\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server Flow\n            //await client.LoginAsync(rootView, \"aad\");\n        }\n    }\n}  Note that we can balance the needs of each platform by using the dependency service.  The code that is unique to the platform is minimized and stored with the platform.  If you aren't interested in social authentication (Facebook, Google, Microsoft or Twitter authentication providers), you can  skip the social-auth section .",
            "title": "Azure Active Directory: Client-Flow Setup"
        },
        {
            "location": "/2_authentication/#social-authentication",
            "text": "Azure App Service provides built-in support for Facebook, Google, Microsoft and Twitter.  Irrespective of whether you intend to use server-flow or client-flow, you will need to configure the Azure App Service Authentication / Authorization service.  The method is pretty similar in each case:   Obtain a Developer Account for the provider.  Create a new application, obtaining a Client ID and Secret.  Turn on Azure App Service Authentication.  Enter the Client ID and Secret into the specific provider setup.  Save the configuration.   Before you start any of this, create a new Azure Mobile Apps as we described in [Chapter 1][int-intro].  If you want a site to deploy for the configuration, the  Backend  project in the  Chapter2  solution is pre-configured for authorization. You just need to deploy it to Azure App Service.",
            "title": "Social Authentication"
        },
        {
            "location": "/2_authentication/#facebook-authentication",
            "text": "I am going to assume you have a Facebook account already.  If you do not have a Facebook account, go to  Facebook  and sign up.  All your friends are likely there already!  Now log in to the  Facebook Developers  web site.  Create a new Facebook application:   Note : Facebook updates the look and feel of their developer site on a regular basis.  As a result, the screen shots I have provided here may be different.  If in doubt, follow the bullet descriptions to find your way.   If you are not already registered, click on the drop-down in the top-right corner and  Register as a Developer  before continuing.    Click on the  My Apps  link in the top right corner of the screen.  Click on  Create a New App .  Fill in the form:      If required, verify your account according to the instructions.  This usually involves adding a credit card number or verifying your mobile phone number.    Click on the  Get Started  button next to  Facebook Login .      Enter your application URL +  /.auth/login/facebook/callback  in the  Valid OAuth redirect URIs .     Click on  Save Changes .  Click on the  Settings  ->  Basic  in the left hand side-bar.  Click on the  Show  button next to the App Secret   Now that you have the  App ID  and  App Secret , you can continue configuration of your app within the  Azure Portal .   Open up your App Service by clicking on  All Resources  or  App Services  followed by the name of your app service.  In the  Settings  blade, click on  Authentication / Authorization  which is under  Features .  Turn  App Service Authentication  to  On .  In the  Action to take when request is not authenticated , select  Allow Request (no action) .    It is very tempting to choose  Log in with Facebook .  However, you need to avoid this.  Selecting this option will mean that all requests need to be authenticated and you will not get the information about the identity on the back end.  Selecting  Allow Request  means your app is in charge of what gets authenticated and what does not require authentication.    Click on  Facebook  (which should show  Not Configured ).  Cut and Paste the  App ID  and  App Secret  into the boxes provided.  Select  public_profile  and  email  for Scopes.    Note that if you request anything but public_profile, user_friends, and email, your app will need further review by Facebook, which will take time.  This process is not worth it for test apps like this one.    Click on  OK  (at the bottom of the blade) to close the Facebook configuration blade.  Click on  Save  (at the top of the blade) to save your Authentication changes.   You can test your authentication process by browsing to https:// yoursite .azurewebsites.net/.auth/login/facebook; this is the same endpoint that the Azure Mobile Apps Client SDK calls when it is time to integrate authentication into the mobile client.   If you are not logged in to facebook already, you will be prompted for your facebook credentials first.  Finally, here is your happy page - the page that signifies you have done everything right:    Minimal Permissions   Every single OAuth provider will ask you what sort of information you want to have access to.  These \"claims\" translate into permissions.  The more permissions you request, the less likely the user is going to accept them.  Be a good net citizen and only request the information you are actually going to use.",
            "title": "Facebook Authentication"
        },
        {
            "location": "/2_authentication/#google-authentication",
            "text": "It should be no shock that you need a  Google Account  to get started.  If you do not have one already (or you want a different account for your development activities), create a new account now.  Then log in to the  Google Developer Portal .  Click on the  Create Project  link at the top:   Enter a nice name (like mine) and click on  Create .  The screen will show the progress and eventually the project will be listed in the  All Projects  list.  It takes about 30 seconds to create a project.  Once you have your Google project, click on it to see all the wonderful things you can add to your project:   There is no \"Google Login\" that can guide you here.  The API you need to add is called  Google+  and is listed under the  Social APIs .  Click on it, then click on  Enable  at the top of the screen.  Just because it is enabled does not mean you automatically get to use it.  Click on  Credentials  link in the left-hand side bar.  You will also see a \"Go to Credentials\" button at the top of the screen, but it does not take you to the same screen, so do not click it.  On the Crendetials screen, click on the  OAuth consent screen  tab:   Fill in the form and click on  Save .  This brings up the next step - creating credentials.  Click on the  Create Credentials  button.  This pops up a drop-down menu.  You want the  OAuth Client ID .   The specific type of client ID you want is a  Web Application .  The server flow version of the application is a web-based form authentication, which matches the  Web Application  version of the Client ID.  When you select  Web Application , you will get another form:   Enter the URL of your App Service in the  Authorized JavaScript origins  box, and the URL +  /.auth/login/google/callback  into the  Authorized redirect URIs  box, then click on  Create .   Google is one of those providers that requires authentication redirect URIs to be secure - so ensure you use the https version of your URL.   At this point, Google will show you the Client ID and Client Secret for your app.  You can also get the Client ID and Client Secret from the interface by clicking on the  Credentials  link on the left-hand side bar.  The process from here is practically the same as Facebook.  Open your App Service within the Azure Portal, click on  All Settings , then  Authentication / Authorization  and finally  Google  (assuming you have already turned on the authentication service).  Cut and paste the Client ID and Client Secret\ninto the boxes provided.  Click on  OK  (at the bottom) followed by  Save  (at the top of the page).   You can define multiple providers at the same time.  The code in the client determines what authentication mechanism gets used.   You can test this just like Facebook.  Go to https:// yoursite /.auth/login/google with your browser.  You should get something like the following:   Confirming here should get us to the same happy screen we achieved with Facebook.  If you happen to mis-type the Authorized redirect URI, Google will tell you that the URI is wrong.  I inevitably swap http for https.  When this happens, it is an easy fix, but you have to wait a few minutes before the authentication system updates itself.",
            "title": "Google Authentication"
        },
        {
            "location": "/2_authentication/#microsoft-account-authentication",
            "text": "The advantage of the Microsoft Account (or MSA, as it is known) is that you already have an account - you need one for Azure.  So this is the first time I am not going to explicitly tell you to sign up for an account.  Your first step is to go to the  Microsoft Account Developer Center  and log on with your Microsoft account.  You should use the same one as you use for Azure, but it is not required.   Just to confuse us, there are two  Add an App  buttons. Strangely, they are different. Click on the one next to  My applications .   Enter an awesome name and click on  Create application .   Click on  Add Platform , followed by  Web .  In the  Redirect URIs , enter your app URL +  /.auth/login/microsoftaccount/callback . Then click on  Save .   Now click on  Generate New Password  under  Application Secrets .   Unlike the other social providers, this is the only time you will get to see your client secret, so make a note of it or cut and paste it into a notepad.  Once you have it copied somewhere, click on  OK , followed by  Save .  You now have all the information you need to configure the Microsoft Account section within your App Server Authentication / Authorization.  The Client ID you need to enter is the Application ID and the Client Secret is the password you just copied somewhere.   Note that you have to choose claims that you want to read.  The  wl.basic  and  wl.emails  will give you enough information to get started with this tutorial.  Click on  OK  (at the bottom), followed by  Save  (at the top).  You can test the settings by pointing your browser to https:// yoursite .azurewebsites.net/.auth/login/microsoftaccount.  You will see what should be a normal claims request page:   Clicking on  Yes  should take you to the normal success page.",
            "title": "Microsoft Account Authentication"
        },
        {
            "location": "/2_authentication/#twitter-authentication",
            "text": "I hope you are seeing that all the OAuth providers take a very similar route to configuring their service.  The semantics of the service are slightly different in each case.  Twitter is no different.  As you might expect, before continuing, sign up for  Twitter .  Once you have signed up, the  Twitter Developers Portal  is your next stop.  Once there, you can click on  Create New App :   Most of the fields are self-explanatory.  The  Callback URL  is the same thing that the other social providers have called the Redirect URL.  The appropriate value is your app URL +  /.auth/login/twitter/callback .  There is a legal agreement at the bottom of the page, then you can click on  Create your Twitter application  button.   All social authentication providers have some sort of legal agreement that governs their use.  In general, demo or PoC apps are fair use.  However, you should get a legal opinion before using a social authentication provider in a production app.   Once you have created the app, you will get a tabbed display with all the settings.  Click on the  Keys and Access Tokens  tab:   Note the values for the  Consumer Key (API Key)  and  Consumer Secret (API Secret) .  They get entered into the Azure Portal.   There is a check box in the  Settings  tab that says  Allow this application to be used to Sign in with Twitter .  At the time of writing, this is checked by default.  However, if you find you can not log in for some reason, then ensure this checkbox is checked.   Back in the Azure Portal, select your app service, then  All Settings ,  Authentication / Authorization , and finally  Twitter  (assuming you have already turned Authentication on).  You can now cut and paste the Consumer Key and Consumer Secret into the appropriate boxes, before clicking on  OK  (at the bottom) followed by  Save  (at the top).  As with the other providers, you should test the authentication flow by pointing your browser to https:// yoursite .azurewebsites.net/.auth/login/twitter.   Clicking on  Authorize app  should show you our normal successful authentication screen.  The social authentication providers should now all be configured to handle a web-based or server-flow authentication request.  There are times when configuring a client-flow authentication is different.  We will point those out when we get to them.   I'm going to assume you have [returned to the Concepts page][int-concepts] and added the client code for a server flow before continuing.",
            "title": "Twitter Authentication"
        },
        {
            "location": "/2_authentication/#testing-authentication-without-a-client",
            "text": "Testing your site without a client requires a REST client.  I use  Postman , which is based on Google Chrome.  If you use Firefox, you might want to take a look at  RESTClient .  Telerik also distributes a web debugging proxy called  Fiddler  that can do API testing.  To test the server, we will need a token.  We can get one by testing authentication configuration by pointing the browser to  /.auth/login/aad .  The return URL will contain a token.   You can test any of the supported identity providers by replacing  aad  with the authentication provider name: facebook, google, microsoftaccount and twitter are possibilities here.   We can then do a request to  /tables/todoitem  to try and obtain the list of current tasks.  We will need to add two headers:   ZUMO-API-VERSION  should contain a value of  2.0.0 .  X-ZUMO-AUTH  should contain the token you received.   My first request shows authentication failing:   Go through one of the authentication flows and copy the authentication token.  In Postman, add a new header called  X-ZUMO-AUTH  and paste the authentication token in.   Note that we have tested all this without touching the client.  Separating the backend operations from the client operations means we can be sure of where the inevitable bug that creeps in is located.  We have verified that we can do each authentication flow on the server side and that the server is properly rejecting unauthenticated requests, plus it is properly returning data when authenticated requests are issued.",
            "title": "Testing Authentication without a Client"
        },
        {
            "location": "/2_authentication/#developing-locally",
            "text": "One would normally be able to run the ASP.NET backend locally and get full functionality without authentication.  However, authentication puts a stop to that because the redirect URLs, secrets and other authentication configuration settings only work with a known endpoint.  To alleviate that, Azure Mobile Apps allows you to run a local server while using an authentication endpoint in Azure App Service.  When the authentication transaction takes place, it is taking place against the Azure App Service.   When it is not doing the OAuth transaction, however, it is operating against a local server.  Setting this up requires a little bit of local machine configuration and a change to the configuration of your client.",
            "title": "Developing Locally"
        },
        {
            "location": "/2_authentication/#update-your-local-development-environment",
            "text": "The first step in this process is to make your local IIS development environment look more like the Azure App Service, particularly in reference to the authentication settings.  This means setting up a few app settings that should be pulled from your App Service.   Log on to the  Azure Portal .  Select your App Service from the  App Services  list.  Click on  Tools , then  Kudu , then  Go .   Kudu is the backend debug console for Azure App Service and there is a lot you can do here.  Of note in this instance is that you can gain access to the keys and audience for your App Service.   Click on  Environment  in the top banner.  Click on  Environment variables .  Scroll down to the environment variables starting with  WEBSITE_AUTH .  Make a note of the  WEBSITE_AUTH_SIGNING_KEY  and  WEBSITE_AUTH_ALLOWED_AUDIENCES  values.   Add the following to your project Web.config  <appSettings>  section:    <appSettings>\n    <add key=\"PreserveLoginUrl\" value=\"true\" />\n    <add key=\"MS_SigningKey\" value=\"Overridden by portal settings\" />\n    <add key=\"EMA_RuntimeUrl\" value=\"Overridden by portal settings\" />\n    <add key=\"MS_NotificationHubName\" value=\"Overridden by portal settings\" />\n    <add key=\"SigningKey\" value=\"{Your WEBSITE_AUTH_SIGNING_KEY}\"/>\n    <add key=\"ValidAudience\" value=\"{Your WEBSITE_AUTH_ALLOWED_AUDIENCES}\"/>\n    <add key=\"ValidIssuer\" value=\"https://{Your WEBSITE_HOSTNAME}/\"/>\n  </appSettings>   NOTE : Both the ValidAudience and ValidIssuer will have a slash on the end and be a https URL.   The last three keys are the keys you will need to add.  Make sure you do not have a  HostName  key as this is how the startup file determines if you are running locally or remote. Talking of which, edit your  App_Start\\Startup.MobileApp.cs  file to include the following:          public static void ConfigureMobileApp(IAppBuilder app)\n        {\n            HttpConfiguration config = new HttpConfiguration();\n\n            new MobileAppConfiguration()\n                .AddTablesWithEntityFramework()\n                .ApplyTo(config);\n\n            // Use Entity Framework Code First to create database tables based on your DbContext\n            Database.SetInitializer(new MobileServiceInitializer());\n\n            MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();\n\n            if (string.IsNullOrEmpty(settings.HostName))\n            {\n                app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions\n                {\n                    SigningKey = ConfigurationManager.AppSettings[\"SigningKey\"],\n                    ValidAudiences = new[] { ConfigurationManager.AppSettings[\"ValidAudience\"] },\n                    ValidIssuers = new[] { ConfigurationManager.AppSettings[\"ValidIssuer\"] },\n                    TokenHandler = config.GetAppServiceTokenHandler()\n                });\n            }\n\n            app.UseWebApi(config);\n        }  The  UserAppServiceAuthentication()  method sets up authentication checking.  This section is not required when running within App Service.  If you are running the server locally, you should either set up a local SQL Server instance and put the connection string into the  Web.config  file, or  open the firewall on your SQL Azure  database so that your local development environment can connect to it, then place the connection string in the  Web.config .  You can get the connection string of the SQL Azure instance by looking at the Connection Strings in the  Application properties  of your App Service.",
            "title": "Update your Local Development Environment"
        },
        {
            "location": "/2_authentication/#update-your-mobile-client",
            "text": "For this demonstration, I have updated the  TaskList.UWP  application so that it is using the server-flow authentication for Azure Active Directory.  This means updating the  LoginAsync()  method in the  Services\\UWPLoginProvider.cs  file to be the following:          public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Server-Flow Version\n            await client.LoginAsync(\"aad\");\n        }  This is because the default local IIS instance is IIS Express.  IIS Express only listens for local connections.  If you run a client from another device (for example, the Android emulator on a Hyper-V service or the iOS simulator on a Mac), then that client would be connecting via a network connection.  You can still debug locally, but you need to  convert your environment to IIS  first.  In the  TaskList (Portable)  project, update the  Helpers\\Locations.cs  file:  namespace TaskList.Helpers\n{\n    public static class Locations\n    {\n#if DEBUG\n        public static readonly string AppServiceUrl = \"http://localhost:17568/\";\n        public static readonly string AlternateLoginHost = \"https://the-book.azurewebsites.net\";\n#else\n        public static readonly string AppServiceUrl = \"https://the-book.azurewebsites.net\";\n        public static readonly string AlternateLoginHost = null;\n#endif\n    }\n}  The  AppServiceUrl  is always set to the location of your backend.  In this case, I right-clicked on the  Backend  project and selected  Properties  then  Web .  The correct URL for local debugging is listed in the  Project URL .  The  AlternateLoginHost  is set to the App Service when locally debugging or null if not. You can specify the  DEBUG  constant in the  Build  tab.  In the same project, update the  Services\\AzureCloudService.cs  constructor to the following:          public AzureCloudService()\n        {\n            client = new MobileServiceClient(Locations.AppServiceUrl);\n            if (Locations.AlternateLoginHost != null)\n                client.AlternateLoginHost = new Uri(Locations.AlternateLoginHost);\n        }   It's a good idea to separate the client and server into different solutions.  Although it doesn't hurt anything to have them in the same solution (like we have), having the client and server separated allows you to attach a debugger separately - which allows you to debug both sides of the connection at the same time.   With these settings, the client will contact the AlternateLoginHost listed for the authentication process and then contact the local server for the rest of the transaction.",
            "title": "Update your Mobile Client"
        },
        {
            "location": "/2_authentication/#run-the-local-server",
            "text": "Running the local server and the client takes a larger machine.  You need to run two instances of Visual Studio: one for the client and one for the server. This is really where you will appreciate multiple monitors (my personal favorite) or the snap action to the sides of the screens.  Ensure you have your backend and clients in different solutions if you intend to run both client and server.  The debugger in Visual Studio will stop one to run the other when they are in the same solution.",
            "title": "Run the Local Server"
        },
        {
            "location": "/2_authentication/#custom-authentication",
            "text": "For some situations, the social or enterprise flows are not valid for the mobile client.  Perhaps you want the ability to provide a sign-up process with a username and password rather than using a social provider.  Perhaps you want to use an alternate provider that is not one of the supported five providers.  Whatever the reason, Azure App Service provides the ability to handle all situations.  In this section, I will look at three methods for providing a unique set of usernames with no connection to the social or enterprise authentication.",
            "title": "Custom authentication"
        },
        {
            "location": "/2_authentication/#using-an-identity-database",
            "text": "Probably the most common request is to use a custom identity database.  In general, this is desirable because you already have a database of usernames and password.  However, it's probably the least desirable option because of the security concerns that come along with this technique.  The news is rife with password leakage for very large organizations.  The best way to ensure you do not disclose a users\npassword is to not have it in the first place.   I'm not going to cover the sign-up case here.  This would be an additional process and would use a regular Web API to insert data into the database after validation (and probably verification via email\nor text message).   The first thing we need to add to our project is a model for the user object.  I created the following in the  Models  folder of the  Backend  project:  using System.ComponentModel.DataAnnotations;\n\nnamespace Backend.Models\n{\n    public class User\n    {\n        [Key]\n        public int Id { get; set; }\n\n        public string Username { get; set; }\n\n        public string Password { get; set; }\n    }\n}  We also need to modify the  MobileServiceContext.cs  file so that the database table is included in the Entity Framework context:      public class MobileServiceContext : DbContext\n    {\n        private const string connectionStringName = \"Name=MS_TableConnectionString\";\n\n        public MobileServiceContext() : base(connectionStringName)\n        {\n        }\n\n        public DbSet<TodoItem> TodoItems { get; set; }\n        public DbSet<User> Users { get; set; }\n\n        protected override void OnModelCreating(DbModelBuilder modelBuilder)\n        {\n            modelBuilder.Conventions.Add(\n                new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n                    \"ServiceTableColumn\", (property, attributes) => attributes.Single().ColumnType.ToString()));\n        }\n    }  Finally, we probably want to put some seed data into the database when it is first created so that we can test it.  Adjust the  MobileServiceInitializer  in the  Startup.MobileApp.cs  file:          protected override void Seed(MobileServiceContext context)\n        {\n            List<TodoItem> todoItems = new List<TodoItem>\n            {\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"First item\", Complete = false },\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"Second item\", Complete = false }\n            };\n\n            foreach (TodoItem todoItem in todoItems)\n            {\n                context.Set<TodoItem>().Add(todoItem);\n            }\n\n            List<User> users = new List<User>\n            {\n                new User { Id = 1, Username = \"adrian\", Password = \"supersecret\" }\n            };\n\n            foreach (User user in users)\n            {\n                context.Set<User>().Add(user);\n            }\n\n            base.Seed(context);\n        }  Note that we are storing the passwords in plain text.  This is most definitely frowned upon.  We should be using some sort of encryption.  This code is most definitely just for demonstration purposes.  Continuing the code on the backend, we need to handle the request to authenticate from the client.  We will use a custom API controller for this; it is located in  Controllers\\CustomAuthController.cs :  using System;\nusing System.IdentityModel.Tokens;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Web.Http;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server.Login;\nusing Newtonsoft.Json;\n\nnamespace Backend.Controllers\n{\n    [Route(\".auth/login/custom\")]\n    public class CustomAuthController : ApiController\n    {\n        private MobileServiceContext db;\n        private string signingKey, audience, issuer;\n\n        public CustomAuthController()\n        {\n            db = new MobileServiceContext();\n            signingKey = Environment.GetEnvironmentVariable(\"WEBSITE_AUTH_SIGNING_KEY\");\n            var website = Environment.GetEnvironmentVariable(\"WEBSITE_HOSTNAME\");\n            audience = $\"https://{website}/\";\n            issuer = $\"https://{website}/\";\n        }\n\n        [HttpPost]\n        public IHttpActionResult Post([FromBody] User body)\n        {\n            if (body == null || body.Username == null || body.Password == null || body.Username.Length == 0 || body.Password.Length == 0)\n            {\n                return BadRequest(); ;\n            }\n\n            if (!IsValidUser(body))\n            {\n                return Unauthorized();\n            }\n\n            var claims = new Claim[]\n            {\n                new Claim(JwtRegisteredClaimNames.Sub, body.Username)\n            };\n\n            JwtSecurityToken token = AppServiceLoginHandler.CreateToken(\n                claims, signingKey, audience, issuer, TimeSpan.FromDays(30));\n            return Ok(new LoginResult()\n            {\n                AuthenticationToken = token.RawData,\n                User = new LoginResultUser { UserId = body.Username }\n            });\n        }\n\n        protected override void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                db.Dispose();\n            }\n            base.Dispose(disposing);\n        }\n\n        private bool IsValidUser(User user)\n        {\n            return db.Users.Count(u => u.Username.Equals(user.Username) && u.Password.Equals(user.Password)) > 0;\n        }\n    }\n\n    public class LoginResult\n    {\n        [JsonProperty(PropertyName = \"authenticationToken\")]\n        public string AuthenticationToken { get; set; }\n\n        [JsonProperty(PropertyName = \"user\")]\n        public LoginResultUser User { get; set; }\n    }\n\n    public class LoginResultUser\n    {\n        [JsonProperty(PropertyName = \"userId\")]\n        public string UserId { get; set; }\n    }\n}  There is a lot going on here:   The constructor reads the signing key and other information that we need for constructing the JWT.  Note that the signing key is only available if you have the Authentication / Authorization is turned on.  The  LoginResult  and  LoginResultUser  provide the response to the client, when serialized by the JSON serializer.  The  Post()  method is where the work happens.  It verifies that you have a valid object, then checks that the username and password match something in the user database.  It then constructs the JWT and returns the required JSON object.  The  IsValidUser()  method actually validates the username and password provided in the request with the users in the database.  This version is very simplistic.  I expect your version to at least include encryption of the password.    Note that you must turn on Authentication / Authorization in your App Service.  Set the  Action to take when request is not authenticated  to  Allow Request (no action)  and do not configure any of the supported authentication providers.   Next, we need to wire the custom authentication controller so that it appears in the same place as all the other authenticators.  We are going to access it via the  /.auth/login/custom  endpoint.  The normal ASP.NET methods can be applied for this.  In this project, we can enable  attribute routing :  public static void ConfigureMobileApp(IAppBuilder app)\n{\n    HttpConfiguration config = new HttpConfiguration();\n\n    new MobileAppConfiguration()\n        .AddTablesWithEntityFramework()\n        .ApplyTo(config);\n\n    // Map routes by attribute\n    config.MapHttpAttributeRoutes();\n\n    // Use Entity Framework Code First to create database tables based on your DbContext\n    Database.SetInitializer(new MobileServiceInitializer());\n\n    MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();\n\n    if (string.IsNullOrEmpty(settings.HostName))\n    {\n        app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions\n        {\n            SigningKey = ConfigurationManager.AppSettings[\"SigningKey\"],\n            ValidAudiences = new[] { ConfigurationManager.AppSettings[\"ValidAudience\"] },\n            ValidIssuers = new[] { ConfigurationManager.AppSettings[\"ValidIssuer\"] },\n            TokenHandler = config.GetAppServiceTokenHandler()\n        });\n    }\n\n    app.UseWebApi(config);\n}  At this point, we can deploy the backend to the App Service and send a suitably formed POST request to\nthe backend.  I use  Postman  for this purpose. The request:   A successful POST will return the token and user ID in the response:   Any other request (such as no body or a wrong username or password) should produce the right response.  If the body is correct, but the information is wrong, then a 401 Unauthorized response should be produced.  If the body is invalid, then a 400 Bad Request should be produced.   Note that the format of the response is exactly the same as the token response we saw earlier when we were discussing the contents of a JWT.   We can now turn our attention to the mobile client.  Custom Authentication is always implemented using a client-flow mechanism. To implement this, we are going to adjust the entry page so that the username and password fields are displayed.  The gathered username and password will then be passed to a new ICloudService  LoginAsync()  method.  All of the UI work is done in the shared project.  To start, we need a copy of the  User.cs  model from the backend project.  Unlike Data Transfer Objects, this model is the same:  namespace TaskList.Models\n{\n    public class User\n    {\n        public string Username { get; set; }\n        public string Password { get; set; }\n    }\n}  The abstraction we use for the cloud service needs to be adjusted so that we can pass the user object into the login method.  This is the  Abstractions\\ICloudService.cs  interface:  using System.Threading.Tasks;\nusing TaskList.Models;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n\n        Task LoginAsync(User user);\n    }\n}  Note that I am adding a new version of the  LoginAsync()  method.  The concrete version of this method no longer has to go through the dependency service since I can use shared code.  Here is the definition of our new  LoginAsync()  method in  Services\\AzureCloudService.cs :          public Task LoginAsync(User user)\n        {\n            return client.LoginAsync(\"custom\", JObject.FromObject(user));\n        }  Finally, we need to update the view-model  ViewModels\\EntryPageViewModel.cs  so that we can store the username and password in the model.  We will also update the call to the  LoginAsync()  method of the cloud service so it calls our new method:  using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class EntryPageViewModel : BaseViewModel\n    {\n        public EntryPageViewModel()\n        {\n            Title = \"Task List\";\n            User = new Models.User { Username = \"\", Password = \"\" };\n        }\n\n        Command loginCmd;\n        public Command LoginCommand => loginCmd ?? (loginCmd = new Command(async () => await ExecuteLoginCommand()));\n\n        public Models.User User { get; set; }\n\n        async Task ExecuteLoginCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                var cloudService = ServiceLocator.Instance.Resolve<ICloudService>();\n                await cloudService.LoginAsync(User);\n                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[ExecuteLoginCommand] Error = {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}  There are three new pieces here.  Firstly, we have the User property (for holding the username and password in our form).  Next, the constructor initializes the user object to an empty object.  Finally, the call to  LoginAsync()  passes the user object to the cloud service.  We also need some UI changes.  Specifically, we need a couple of fields for the username and password added to the  Pages\\EntryPage.xaml  file:  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage x:Class=\"TaskList.Pages.EntryPage\"\n             xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <StackLayout HorizontalOptions=\"Center\"\n                     Orientation=\"Vertical\"\n                     VerticalOptions=\"Center\">\n            <Label Text=\"Username?\" />\n            <Entry Text=\"{Binding User.Username}\" />\n            <Label Text=\"Password?\" />\n            <Entry IsPassword=\"True\" Text=\"{Binding User.Password}\" />\n\n            <Button BackgroundColor=\"Teal\"\n                    BorderRadius=\"10\"\n                    Command=\"{Binding LoginCommand}\"\n                    Text=\"Enter The App\"\n                    TextColor=\"White\" />\n        </StackLayout>\n    </ContentPage.Content>\n</ContentPage>  There is lots to complain about in this demonstration (including lack of encryption, storage of passwords, and a generally bad UI).  However, it serves to demonstrate the salient points for using a (perhaps pre-existing) identity database for authentication of the users.",
            "title": "Using an Identity Database."
        },
        {
            "location": "/2_authentication/#using-azure-active-directory-b2c",
            "text": "Custom authentication allows you to really customize the process, but I like to reduce the amount of code I write by using services or libraries.   The whole sign-in and sign-up process is ripe for this.  The code needed for building the sign-in / sign-up process is boiler-plate code.  It also introduces problems that I have to deal with going forward.  I have to store passwords and profile information, which introduces a security concern.  I have to scale the database and ensure my app scales with it as my app gets popular.  Finally, I am being fairly inflexible and causing potential privacy concerns with my users.  There are a couple of services that I can use to get around these concerns.  The first is an Azure service:  Azure Active Directory B2C .  The B2C stands for Business to Consumer.  It is a mechanism by which you can add a sign-in and sign-up flow to your application.  The user can enter a username or password, or, at your option, add on support for one or more social providers.  In addition, there is support for branding the sign-in process, doing email verification of sign-ups and automatic password resets via email.  The Azure AD B2C sign-in / sign-up process is primarily a server-flow proecss, so we will be able to add support in our app with just one line of code.",
            "title": "Using Azure Active Directory B2C"
        },
        {
            "location": "/2_authentication/#the-minimal-setup-of-azure-ad-b2c",
            "text": "Azure AD is managed from the  Classic Azure Portal , so start by logging in using your Azure Subscription credentials.   Click on the big  + NEW  button in the bottom left of the screen.  Select  App Services  ->  Active Directory  ->  Directory  ->  Custom Create .     Choose a name for the tenant, then choose a unique domain name (which will appear in the    onmicrosoft.com  domain) and country.  Ensure you check the  This is a B2C directory.     Click on the tick to create the directory.  As noted, this process will take a couple of minutes to complete.   This creates a new tenant for you to manage.  If you go back to your  Azure Portal  and click on your name (top right corner), you will note that there is a new DIRECTORY entry for your B2C tenant.  This is where you will be managing your B2C tenant.  It's a good idea to pin the B2C settings blade to your dashboard or navigation pane so you can access it faster.  To do this:   Log in to the  Azure Portal .  Switch to your B2C tenant by clicking on your name, then selecting the new tenant in the drop-down.  The portal will probably ask you to confirm your ID and password.  Click on  Browse>  in the left-hand navigation bar.  Search for  B2C .  Click on the empty star next to  Azure AD B2C .    This will make Azure AD B2C appear in your left hand navigation bar.  To place it on the dashboard, click on  Azure AD B2C  in the left hand navigation bar, then click on the pin at the top of the  AZURE AD B2C SETTINGS  blade.  The next job is to create an application registration within the B2C tenant:   Open the  Azure AD B2C  from your dashboard or the left hand navigation.  In the  Settings  blade, click on  Applications .     In the  New application  blade:  Enter a unique name for the application.  Click on  Yes  under  Include web app / web API .  In the Reply URL, enter  https://yoursite.azurewebsites.net/.auth/login/aad/callback .  Click on  Generate key  - a key will be generated (cut and paste it somewhere).     Click on  Create .   There is no spinner or deployment here.  After approximately 5-10 seconds, the application registration will appear in the list.  Click on the application registration to see the  Application ID :   You will need the Application ID and App Key (which you copied earlier) later on.  The next step is to create a Sign-in/Sign-up policy.  We'll create a policy for signing up with an email address and email confirmation, then signing in with that email address:   In the  Settings  blade, click on  Sign-up or sign-in policies .  Click on the  + Add  button.  Give the policy a name, like  emailPolicy .  Click on  Identity providers :  Click on  Email signup / Local Account  (a tick will appear next to the row).  Click on  OK .  Click on  Sign-up attributes :  Click on  Email Address  and any other fields you want to gather.  Click on  OK .  Click on  Application claims :  Click on  Email Addresses  and any other fields you want to provide to the application.  Click on  OK  Click on  Create  on the  Add policy  blade.  Click on the policy you just created.  It will be named something like  B2C_1_emailPolicy . Make a note of the  Metadata Endpoint for this policy .    Now that your B2C tenant is configured, you can switch back to your original tenant (by clicking on your name in the top-right corner and selecting the default directory).  To configure the App Service  Authentication / Authorization .  Open up the  Settings  blade, then  Authentication / Authorization .  Ensure the authentication service is turned on.  Click on  Azure Active Directory . This time, we are going to select the  Advanced  option.  The  Client ID  is the application ID of your B2C application registration, and the  Issuer Url  is the  Metadata Endpoint  for your sign-up policy:   Click on  OK  to configure the authentication server flow, the  Save  to save the settings.  As before, you can test your server flow by pointing your browser to  https://yoursite.azurewebsites.net/.auth/login/aad :   If you have done everything right, you should be able to register an account, get the email verification code, and finally log in to get the happy login page.   All that is left to do is to configure your app for Azure Active Directory Server Flow.  We did that earlier when discussing the Enterprise Authentication flow for the mobile client.",
            "title": "The Minimal Setup of Azure AD B2C"
        },
        {
            "location": "/2_authentication/#drawbacks-of-azure-active-directory-b2c",
            "text": "Azure AD B2C is great for storing your users passwords and doing the sign-up and sign-in process for you.  There are a couple of reasons why you wouldn't want to use Azure Active Directory B2C.  The most obvious one is that this is a server-flow capability.  That means you won't be able to, for example, integrate the Facebook, Google and Twitter identity providers by utilizing their client libraries.  You also do not get access to the underlying identity provider token, so you are restricted from accessing the Graph API for the individual providers.  Finally, since the AAD B2C identity provider is configured with the AAD provider, you can't use both a B2C provider and a regular AAD provider.  If you just want a sign-up / sign-in flow, then AAD B2C is probably the best way to go.  If, however, your plans include integration with other social identity providers, you should consider whether you want to do more work on the client to support that.",
            "title": "Drawbacks of Azure Active Directory B2C"
        },
        {
            "location": "/2_authentication/#using-third-party-tokens",
            "text": "The final method of authenticating a user we are going to look at is a process by which you use a third party authentication token.   For example, you may want to authenticate via  GitHub  or  miiCard  or using an authentication provider like  Auth0  to get some single sign-in capabilities.  Authentication with third party tokens works remarkably similar to the custom authentication case.  Instead of a username and password, you pass in the token from the other provider.  To look at this in example form, we are going to implement Auth0 as a provider. Your first stop should be the  Auth0  web site to sign up for a developer account. Once you have done that:   Click on the  + NEW CLIENT  button in the  Dashboard .  Give your app a name, then click on  Native  and then  CREATE .     Click on the  Xamarin  icon to get the Xamarin Quickstart.  Click on  Settings .  Enter the callback URL in the  Allowed Callback URLs .  The callback URL will be something like  https://_youraccount_.auth0.com/mobile  and will be listed in the Quickstart page.  Scroll down to the bottom of the page and click on  SAVE CHANGES .  Make a note of the Client ID of the application.  You will need it later.  Click on  Connections .  Turn on any connections that you want to use.  For this example, ensure you turn on the  Username-Password-Authentication  and a couple of social providers.   Now that the Auth0 service is configured, we can turn our attention to the mobile client.  The Xamarin.Auth0Client is a component, so right-click on the  Components  node of a platform project and select  Get More Components... .  In the dialog, find the  Auth0 SDK , then click on  Add to App .  For our iOS application, we are going to integrate Auth0 into the  Services\\iOSLoginProvider.cs :          public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginAuth0Async();\n\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"auth0\", zumoPayload);\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n\n        public async Task<string> LoginAuth0Async()\n        {\n            var auth0 = new Auth0.SDK.Auth0Client(\n                \"shellmonger.auth0.com\",\n                \"lmFp5jXnwPpD9lQIYwgwwPmFeofuLpYq\");\n            var user = await auth0.LoginAsync(RootView, scope: \"openid email\");\n            return user.Auth0AccessToken;\n        }  The parameters for the constructor to the  Auth0Client  are your Auth0 domain and client ID.  You can retrieve these from the Auth0 management page for your app.  Note that I am requesting the email address.  This will become a part of my ZUMO token when I create it.  Switching our attention to our  Backend  project, we need a new custom authentication controller.  This is located in  Controllers\\Auth0Controller.cs :  using System;\nusing System.Diagnostics;\nusing System.IdentityModel.Tokens;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Web.Http;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server.Login;\n\nnamespace Backend.Controllers\n{\n    [Route(\".auth/login/auth0\")]\n    public class Auth0Controller : ApiController\n    {\n        private JwtSecurityTokenHandler tokenHandler;\n        private string clientID, domain;\n        private string signingKey, audience, issuer;\n\n        public Auth0Controller()\n        {\n            // Information for the incoming Auth0 Token\n            domain = Environment.GetEnvironmentVariable(\"AUTH0_DOMAIN\");\n            clientID = Environment.GetEnvironmentVariable(\"AUTH0_CLIENTID\");\n\n            // Information for the outgoing ZUMO Token\n            signingKey = Environment.GetEnvironmentVariable(\"WEBSITE_AUTH_SIGNING_KEY\");\n            var website = Environment.GetEnvironmentVariable(\"WEBSITE_HOSTNAME\");\n            audience = $\"https://{website}/\";\n            issuer = $\"https://{website}/\";\n\n            // Token Handler\n            tokenHandler = new JwtSecurityTokenHandler();\n        }\n\n        [HttpPost]\n        public IHttpActionResult Post([FromBody] Auth0User body)\n        {\n            if (body == null || body.access_token == null || body.access_token.Length == 0)\n            {\n                return BadRequest();\n            }\n\n            try\n            {\n                var token = (JwtSecurityToken)tokenHandler.ReadToken(body.access_token);\n                if (!IsValidUser(token))\n                {\n                    return Unauthorized();\n                }\n\n                var subject = token.Claims.FirstOrDefault(c => c.Type.Equals(\"sub\"))?.Value;\n                var email = token.Claims.FirstOrDefault(c => c.Type.Equals(\"email\"))?.Value;\n                if (subject == null || email == null)\n                {\n                    return BadRequest();\n                }\n\n                var claims = new Claim[]\n                {\n                    new Claim(JwtRegisteredClaimNames.Sub, subject),\n                    new Claim(JwtRegisteredClaimNames.Email, email)\n                };\n\n                JwtSecurityToken zumoToken = AppServiceLoginHandler.CreateToken(\n                    claims, signingKey, audience, issuer, TimeSpan.FromDays(30));\n                return Ok(new LoginResult()\n                {\n                    AuthenticationToken = zumoToken.RawData,\n                    User = new LoginResultUser { UserId = email }\n                });\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"Auth0 JWT Exception = {ex.Message}\");\n                throw ex;\n            }\n        }\n\n        private bool IsValidUser(JwtSecurityToken token)\n        {\n            if (token == null)\n                return false;\n            var audience = token.Audiences.FirstOrDefault();\n            if (!audience.Equals(clientID))\n                return false;\n            if (!token.Issuer.Equals($\"https://{domain}/\"))\n                return false;\n            if (token.ValidTo.AddMinutes(5) < DateTime.Now)\n                return false;\n            return true;\n        }\n    }\n\n    public class Auth0User\n    {\n        public string access_token { get; set; }\n    }\n}  Note that we are reading two new environment variables.  In the Azure App Service, you can read Application Settings by reading the environment variable of the same name.  We need to set the  AUTH0_CLIENTID  to the Client ID of our Auth0 application, and the  AUTH0_DOMAIN  to the domain of our account.  Both of these values need to match the settings in the client.  These are not \"secure items\".  If using the client secret (to validate the token), then that would be considered secure and should only appear on the server side.  The validation is that the token passed in is valid (i.e. it has the right audience, issuer and expiry times).  In addition, you should check the validity of the token signature.  You can do this by acquiring the token secret and using  tokenHandler.ValidateToken()  instead of  tokenHandler.ReadToken() .  My new token lasts for 30 days.  The ZUMO token that is generated in custom authentication does not have to be the same length as the original token. You can make it last for as long as you like.",
            "title": "Using Third Party Tokens"
        },
        {
            "location": "/2_authentication/#claims-and-authorization",
            "text": "Now that we have covered all the techniques for authentication, it's time to look at authorization.  While authentication looked at verifying that a user is who they say they are, authorization looks at if a user is allowed to do a specific operation.  Authorization is handled within the server-side project by the  [Authorize]  attribute.  Our Azure Mobile Apps backend is leveraging this to provide authorization based on whether a user is authenticated or not.  The Authorize attribute can also check to see if a user is in a list of users or roles.  However, there is a problem with this.  The user id is not guessable and we have no roles.  To see what I mean, run the  Backend  project locally and set a break point on the  GetAllTodoItems()  method in the  TodoItemController , then run your server and your UWP application.   Once you have built and deployed the UWP application, it will appear in your normal Application list.  This allows you to run the application and the server at the same time on the same machine.   Once you have authenticated, you will be able to set a break point to take a look at  this.User.Identity :   Note that the  Name  property is null.  This is the property that is used when you want to authorize individual users.  Expand the  Claims  property and then click on  Results View :   The only claims are the ones in the token, and none of them match the  RoleClaimType , so we can't use roles either.  Clearly, we are going to have to do something else.",
            "title": "Claims and Authorization"
        },
        {
            "location": "/2_authentication/#obtaining-user-claims",
            "text": "At some point you are going to need to deal with something other than the claims that are in the token passed for authentication.  Fortunately, the Authentication / Authorization feature has an endpoint for that at  /.auth/me :   Of course, the  /.auth/me  endpoint is not of any use if you cannot access it.  The most use of this information is gained during authorization on the server and we will cover this use later on.  However, there are reasons to pull this information on the client as well.  For example, we may want to make the List View title be our name instead of \"Tasks\".   You can't use the /.auth/me endpoint when using custom authentication.   Since identity provider claims can be anything, they are transferred as a list within a JSON object.  Before we can decode the JSON object, we need to define the models.  This is done in the shared  TaskList  project.  I've defined this in  Models\\AppServiceIdentity.cs .  using System.Collections.Generic;\nusing Newtonsoft.Json;\n\nnamespace TaskList.Models\n{\n    public class AppServiceIdentity\n    {\n        [JsonProperty(PropertyName = \"id_token\")]\n        public string IdToken { get; set; }\n\n        [JsonProperty(PropertyName = \"provider_name\")]\n        public string ProviderName { get; set; }\n\n        [JsonProperty(PropertyName = \"user_id\")]\n        public string UserId { get; set; }\n\n        [JsonProperty(PropertyName = \"user_claims\")]\n        public List<UserClaim> UserClaims { get; set; }\n    }\n\n    public class UserClaim\n    {\n        [JsonProperty(PropertyName = \"typ\")]\n        public string Type { get; set; }\n\n        [JsonProperty(PropertyName = \"val\")]\n        public string Value { get; set; }\n    }\n}  This matches the JSON format from the  /.auth/me  call we did earlier.   This is going to be a part of the ICloudService as follows:  using System.Threading.Tasks;\nusing TaskList.Models;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n\n        Task LoginAsync(User user);\n\n        Task<AppServiceIdentity> GetIdentityAsync();\n    }\n}  Finally, we need to actually implement the concrete version in  AzureCloudService.cs :  List<AppServiceIdentity> identities = null;\n\npublic async Task<AppServiceIdentity> GetIdentityAsync()\n{\n    if (client.CurrentUser == null || client.CurrentUser?.MobileServiceAuthenticationToken == null)\n    {\n        throw new InvalidOperationException(\"Not Authenticated\");\n    }\n\n    if (identities == null)\n    {\n        identities = await client.InvokeApiAsync<List<AppServiceIdentity>>(\"/.auth/me\");\n    }\n\n    if (identities.Count > 0)\n        return identities[0];\n    return null;\n}  Note that there is no reason to instantiate your own  HttpClient() .  The Azure Mobile Apps SDK has a method for invoking custom API calls (as we shall see later on).  However, if you prefix the path with a slash, it will execute a HTTP GET for any API with any authentication that is currently in force.  We can leverage this to call the  /.auth/me  endpoint and decode the response in one line of code.  Adjust the  ExecuteRefreshCommand()  method in the  ViewModels\\TaskListViewModel.cs  file to take advantage of this:  async Task ExecuteRefreshCommand()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var identity = await cloudService.GetIdentityAsync();\n        if (identity != null)\n        {\n            var name = identity.UserClaims.FirstOrDefault(c => c.Type.Equals(\"name\")).Value;\n            Title = $\"Tasks for {name}\";\n        }\n        var list = await Table.ReadAllItemsAsync();\n        Items.ReplaceRange(list);\n    }\n    catch (Exception ex)\n    {\n        await Application.Current.MainPage.DisplayAlert(\"Items Not Loaded\", ex.Message, \"OK\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}  The return value from the  GetIdentityAsync()  method is the first identity.  Normally, a user would only authenticate once, so this is fairly safe.  The number of claims returned depends on the identity provider and could easily number in the hundreds.  Even the default configuration for Azure Active Directory returns 18 claims.  These are easily handled using LINQ, however.  The  Type  property holds the type.  This could be a short (common) name.  It could also be a schema name, which looks more like a URI.  The only way to know what claims are coming back for sure is to look at the  /.auth/me  result with something like Postman.   Note : If you are using Custom Authentication (e.g. username/password or a third-party token), then the  /.auth/me  endpoint is not available to you.  You can still produce a custom API in your backend to provide this information to your client, but you are responsible for the code - it's custom, after all!",
            "title": "Obtaining User Claims"
        },
        {
            "location": "/2_authentication/#authorization",
            "text": "Now that we have covered all the techniques for authentication, it's time to look at authorization.  While authentication looked at verifying that a user is who they say they are, authorization looks at if a user is allowed to do a specific operation.  Authorization is handled within the server-side project by the  [Authorize]  attribute.  Our Azure Mobile Apps backend is leveraging this to provide authorization based on whether a user is authenticated or not.  The Authorize attribute can also check to see if a user is in a list of users or roles.  However, there is a problem with this.  The user id is not guessable and we have no roles.  To see what I mean, run the  Backend  project and set a break point on the  GetAllTodoItems()  method in the  TodoItemController , then run your server and your UWP application.   Once you have built and deployed the UWP application, it will appear in your normal Application list.  This allows you to run the application and the server at the same time on the same machine.  Alternatively, you can attach a Debugger to your Azure App Service within Visual Studio's Cloud Explorer.   Once you have authenticated, you will be able to set a break point to take a look at  this.User.Identity :   Note that the  Name  property is null.  This is the property that is used when you want to authorize individual users.  Expand the  Claims  property and then click on  Results View :   The only claims are the ones in the token, and none of them match the  RoleClaimType , so we can't use roles either.  Clearly, we are going to have to do something else.  Fortunately, we already know that we can get some information about the identity provider claims from the  /.auth/me  endpoint.  To get the extra information, we need to query the  User  object:  var identity = await User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request);  There is one  Credentials  class for each supported authentication technique - Azure Active Directory, Facebook, Google, Microsoft Account and Twitter.  These are in the  Microsoft.Azure.Mobile.Server.Authentication  namespace.  They all follow the same pattern as the model we created for the client - there are Provider, UserId and UserClaims properties.  The token and any special information will be automatically decoded for you.  For instance, the TenantId is pulled out of the response for Azure AD.   You can use the AccessToken property to do Graph API lookups for most providers in a custom API. We'll get into this more in a later Chapter.",
            "title": "Authorization"
        },
        {
            "location": "/2_authentication/#group-authorization",
            "text": "Now that we have group claims in the claims list for the  /.auth/me  endpoint, we can move forward to do authorization based on these claims.  This can be done in a relatively basic\nmanner by implementing a method to check the claims:  async Task<bool> IsAuthorizedAsync()\n{\n    var identity = await User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request);\n    var countofGroups = identity.UserClaims\n        .Where(c => c.Type.Equals(\"groups\") && c.Value.Equals(\"01f214a9-af1f-4bdd-938f-3f16749aef0e\"))\n        .Count();\n    return (countofGroups > 0);\n}  The  UserClaims  object is an  IEnumerable  that contains objects with a Type and a Value.  The Type for the group claims is  groups .  Once we have this knowledge, we can use a LINQ query to obtain a count of the claims that match the conditions we want to test.  The Value we use is the Object ID of the group.  This is available in the  PROPERTIES  tab of the group.  We can prevent a new record being added by adjusting the  PostTodoItem()  method:  public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n{\n    if (!await IsAuthorizedAsync())\n    {\n        return Unauthorized();\n    }\n    TodoItem current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}  Unfortunately, most of the table controller methods do not return an  IHttpActionResult , so this has limited value.  What would be better would be an  [Authorize]  attribute that tests the claims for us.  For instance, we should be able to do the following:  [AuthorizeClaims(\"groups\", \"01f214a9-af1f-4bdd-938f-3f16749aef0e\")]\npublic async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n{\n    TodoItem current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}  The  [AuthorizeClaims()]  attribute does not exist, so we have to provide it ourselves:  using System.Linq;\nusing System.Net;\nusing System.Security.Principal;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.Filters;\nusing Microsoft.Azure.Mobile.Server.Authentication;\n\nnamespace Backend.Helpers\n{\n    public class AuthorizeClaimsAttribute : AuthorizationFilterAttribute\n    {\n        string Type { get; }\n        string Value { get; }\n\n        public AuthorizeClaimsAttribute(string type, string value)\n        {\n            Type = type;\n            Value = value;\n        }\n\n        public override async Task OnAuthorizationAsync(HttpActionContext actionContext, CancellationToken cancellationToken)\n        {\n            var request = actionContext.Request;\n            var user = actionContext.RequestContext.Principal;\n            if (user != null)\n            {\n                var identity = await user.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(request);\n                var countOfMatchingClaims = identity.UserClaims\n                    .Where(c => c.Type.Equals(Type) && c.Value.Equals(Value))\n                    .Count();\n                if (countOfMatchingClaims > 0) return;\n\n            }\n            throw new HttpResponseException(HttpStatusCode.Unauthorized);\n        }\n    }\n}  This is the same type of authorization filter attribute that the officially provided  AuthorizeAttribute  is based on.  However, the AuthorizeAttribute is synchronous.  We require an asynchronous version of the attribute, so we cannot use a sub-class of the AuthorizeAttribute.  Aside from that note, this uses virtually the same code that we used in the  IsAythorizedAsync()  method we developped earlier.  We can now use this attribute for testing any claim.  For example, our claims has the identity provider as a claim.  We can use the following:  [AuthorizeClaims(\"http://schemas.microsoft.com/identity/claims/identityprovider\", \"live.com\")]   If you want to test other claims that are not provided, you can enable the  Read Directory Data  permission in the Azure Active Directory permissions and do a query against the Azure Active Directory.  You should think about caching results if this is the case.",
            "title": "Group Authorization"
        },
        {
            "location": "/2_authentication/#caching-tokens",
            "text": "You will notice that we have to log in with every start of the application.  The token that is generated has a lifetime that is provided and controlled by the identity provider.  Some providers have a relatively short lifetime.  For example, Azure Active Directory tokens have a lifetime of 1 hour.  Others are incredibly long.  Facebook has an expiry time of 60 days.  Irrespective of the lifespan of the token, we will want to store it securely and re-use it when we can.  Xamarin has provided a nice component, [Xamarin.Auth], that provides such as secure store in a cross-platform manner.  It starts with an account store:  var accountStore = AccountStore.Create();\n// For Android:\n// var accountStore = AccountStore.Create(Context);  We can then store the token with the following:  accountStore.Save(account, \"descriptor\");  The descriptor is a string that allows us to find the token again.  The account (which is an  Account  object) is uniquely identified by a key composed of the account's Username property and the descriptor.  The Account class is provided with Xamarin.Auth.  Storage is backed by the  Keychain  on iOS and the  KeyStore  on Android.  To get the token back, we use the following:  var accounts = accountStore.FindAccountsForService(\"descriptor\");  When we receive the token back from the key store, we will want to check the expiry time to ensure the token has not expired.  As a result, there is a little bit more code to caching code than one would expect.  Let's start with the Android version in  TaskList.Droid .  As with all the other login code, we are adjusting the  LoginAsync()  method in  Services\\DroidLoginProvider.cs :  using System;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Android.App;\nusing Android.Content;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\nusing TaskList.Helpers;\nusing Xamarin.Auth;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        public Context RootView { get; private set; }\n\n        public AccountStore AccountStore { get; private set; }\n\n        public void Init(Context context)\n        {\n            RootView = context;\n            AccountStore = AccountStore.Create(context);\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Check if the token is available within the key store\n            var accounts = AccountStore.FindAccountsForService(\"tasklist\");\n            if (accounts != null)\n            {\n                foreach (var acct in accounts)\n                {\n                    string token;\n\n                    if (acct.Properties.TryGetValue(\"token\", out token))\n                    {\n                        if (!IsTokenExpired(token))\n                        {\n                            client.CurrentUser = new MobileServiceUser(acct.Username);\n                            client.CurrentUser.MobileServiceAuthenticationToken = token;\n                            return;\n                        }\n                    }\n                }\n            }\n\n            // Server Flow\n            await client.LoginAsync(RootView, \"aad\");\n\n            // Store the new token within the store\n            var account = new Account(client.CurrentUser.UserId);\n            account.Properties.Add(\"token\", client.CurrentUser.MobileServiceAuthenticationToken);\n            AccountStore.Save(account, \"tasklist\");\n        }\n\n        bool IsTokenExpired(string token)\n        {\n            // Get just the JWT part of the token (without the signature).\n            var jwt = token.Split(new Char[] { '.' })[1];\n\n            // Undo the URL encoding.\n            jwt = jwt.Replace('-', '+').Replace('_', '/');\n            switch (jwt.Length % 4)\n            {\n                case 0: break;\n                case 2: jwt += \"==\"; break;\n                case 3: jwt += \"=\"; break;\n                default:\n                    throw new ArgumentException(\"The token is not a valid Base64 string.\");\n            }\n\n            // Convert to a JSON String\n            var bytes = Convert.FromBase64String(jwt);\n            string jsonString = UTF8Encoding.UTF8.GetString(bytes, 0, bytes.Length);\n\n            // Parse as JSON object and get the exp field value,\n            // which is the expiration date as a JavaScript primative date.\n            JObject jsonObj = JObject.Parse(jsonString);\n            var exp = Convert.ToDouble(jsonObj[\"exp\"].ToString());\n\n            // Calculate the expiration by adding the exp value (in seconds) to the\n            // base date of 1/1/1970.\n            DateTime minTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);\n            var expire = minTime.AddSeconds(exp);\n            return (expire < DateTime.UtcNow);\n        }\n    }\n}  There are three new pieces to this code.  The first piece is to check to see if there is an existing token in the KeyStore.  If there is, we check the expiry time and then set up the Azure Mobile Apps client with the username and token from the KeyStore.  If there isn't, we do the normal authentication process.  If the authentication process is successful, we reach the second piece, which is to store the token within the KeyStore.  If there is an existing entry, it will be overwritten.  Finally, there is a method called  IsTokenExpired()  whose only job is to check to see if a token is expired or not.  This same code can be used in the  Services/iOSLoginProvider.cs .  The only difference is in the  AccountStore.Create()  call (as discussed earlier).  I'm using an application specific service ID (or descriptor) for this purpose.  You could also use an identity provider-based service ID which is especially useful if your mobile client supports multiple identity providers.  Xamarin.Auth only support iOS and Android.  We need to turn to an alternate library for token caching on Universal Windows.  The standard library has a package called  PasswordVault  that can be used identically to the  KeyStore  and  Keychain  libraries.  Here is the Universal Windows version of the same code in  Services\\UWPLoginProvider.cs :  using System;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.UWP.Services;\nusing Windows.Security.Credentials;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public PasswordVault PasswordVault { get; private set; }\n\n        public UWPLoginProvider()\n        {\n            PasswordVault = new PasswordVault();\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Check if the token is available within the password vault\n            var acct = PasswordVault.FindAllByResource(\"tasklist\").FirstOrDefault();\n            if (acct != null)\n            {\n                var token = PasswordVault.Retrieve(\"tasklist\", acct.UserName).Password;\n                if (token != null && token.Length > 0 && !IsTokenExpired(token))\n                {\n                    client.CurrentUser = new MobileServiceUser(acct.UserName);\n                    client.CurrentUser.MobileServiceAuthenticationToken = token;\n                    return;\n                }\n            }\n\n            // Server-Flow Version\n            await client.LoginAsync(\"aad\");\n\n            // Store the token in the password vault\n            PasswordVault.Add(new PasswordCredential(\"tasklist\",\n                client.CurrentUser.UserId,\n                client.CurrentUser.MobileServiceAuthenticationToken));\n        }\n\n        bool IsTokenExpired(string token)\n        {\n            /* Copy code from DroidLoginProvider */\n        }\n    }\n}  The PasswordVault replaces the KeyStore (Android) and Keychain (iOS), but the concepts are the same.  All three mechanisms provide the basic functionality of storing client secrets securely.",
            "title": "Caching Tokens"
        },
        {
            "location": "/2_authentication/#refresh-tokens",
            "text": "Our token cache checks the token to see if it is expired and prompts the user if the token is no longer valid.  Since the life of a token is inevitably short (maybe 1 hour), this will still mean that the user is prompted for new credentials most of the time.  In addition, we have an issue when the app is running for a long time.  What happens if the user leaves the app running for 2 hours?  The token we received at the start of the session will be invalid halfway through the session and we will have to restart the app in order to continue.  Both of these situations are undesirable from the point of view of the user.  Access tokens eventually expire and we need to explicitly deal with this situation.  The first part of the solution is to request a  Refresh Token .  This is something the identity provider issues when the scope of the request includes an offline scope.  Only certain identity providers include the ability to request refresh tokens.  For server-flow:   Google: Append the \"access_type=offline\" to the request.  Microsoft Account: Select the wl.offline_access scope in the Azure management portal.  Azure AD: Configure Azure AD to support access to the Graph API.   Facebook and Twitter do not provider refresh tokens.  Once you have the refresh tokens, you can simply call the refresh API in the Azure Mobile Apps SDK to refresh the token.   Refresh Tokens are one area that require special consideration when using Custom Authentication.  Just like with the /.auth/me endpoint, you are on your own when it comes to handling token expiry for custom authentication.",
            "title": "Refresh Tokens"
        },
        {
            "location": "/2_authentication/#configuring-refresh-tokens",
            "text": "Azure Active Directory is perhaps the trickiest to configure.   Log on to the  Classic Portal .  Navigate to your Azure Active Directory.  Go to  APPLICATIONS  and then your WEB application.  Go to the  CONFIGURE  tab.  Scroll down to the  Keys  section.     In the  Select duration  drop-down, select  2 Years .  Click on  SAVE .  The key will be generated for you.  Copy the key (you will need it below).  Go back to the  Azure Portal .  Go to  App Services , then your App Service.  Click on  Tools , then  Resource explorer , then  Go .  In the Resource Explorer, expand  config  and select  authsettings .  Click on  Edit .  Set the clientSecret to the key you copied from above.  Set the additionalLoginParams to  [\"response_type=code id_token\"] .     Click the  Read/Write  toggle button at the top of the page.  Click the  PUT  button.   The next time the user logs into our web app side, there will be a one-time prompt to consent to graph API access.  Once granted, the App Service Authentication / Authorization service will start requesting and receiving refresh tokens.",
            "title": "Configuring Refresh Tokens"
        },
        {
            "location": "/2_authentication/#using-refresh-tokens",
            "text": "The Azure Mobile Apps Client SDK has a built in method for refreshing tokens for you.  It assumes that you are using a supported identity provider (Azure Active Directory, Google or Microsoft Account), and have configured the identity provider to generate the refresh token.   Azure App Service Authentication / Authorization maintains a token store in the XDrive (which is the drive that is shared among all instances of the backend within the same App Service Plan).  The token store is located at  D:\\\\home\\\\data\\\\.auth\\\\tokens  on the backend.  The tokens are encrypted and stored in a per-user encrypted file.",
            "title": "Using Refresh Tokens"
        },
        {
            "location": "/2_authentication/#logging-out",
            "text": "",
            "title": "Logging out"
        },
        {
            "location": "/2_authentication/#best-practices",
            "text": "",
            "title": "Best Practices"
        },
        {
            "location": "/data/",
            "text": "Data Access and Offline Sync\n\n\nData Access Concepts\n\n\nData Access Protocol\n\n\nHow Offline Sync Works\n\n\nTesting Data Access\n\n\nAdding a SQL Table Controller\n\n\nUsing an Existing SQL Table\n\n\nUsing Code Behind\n\n\nWhy use Code Behind?\n\n\nImplementing Code Behind\n\n\nCode Behind Recipes\n\n\nWorking with Data in your Client\n\n\nImplementing an Online Table\n\n\nImplementing an Offline Table\n\n\nUsing a Non-SQL Data Source\n\n\nThe ASP.NET Domain Manager\n\n\nImplementing a DocumentDB Domain Manager\n\n\nImplementing an Azure Table Storage Domain Manager",
            "title": "Data Access and Offline Sync"
        },
        {
            "location": "/data/#data-access-and-offline-sync",
            "text": "",
            "title": "Data Access and Offline Sync"
        },
        {
            "location": "/data/#data-access-concepts",
            "text": "",
            "title": "Data Access Concepts"
        },
        {
            "location": "/data/#data-access-protocol",
            "text": "",
            "title": "Data Access Protocol"
        },
        {
            "location": "/data/#how-offline-sync-works",
            "text": "",
            "title": "How Offline Sync Works"
        },
        {
            "location": "/data/#testing-data-access",
            "text": "",
            "title": "Testing Data Access"
        },
        {
            "location": "/data/#adding-a-sql-table-controller",
            "text": "",
            "title": "Adding a SQL Table Controller"
        },
        {
            "location": "/data/#using-an-existing-sql-table",
            "text": "",
            "title": "Using an Existing SQL Table"
        },
        {
            "location": "/data/#using-code-behind",
            "text": "",
            "title": "Using Code Behind"
        },
        {
            "location": "/data/#why-use-code-behind",
            "text": "",
            "title": "Why use Code Behind?"
        },
        {
            "location": "/data/#implementing-code-behind",
            "text": "",
            "title": "Implementing Code Behind"
        },
        {
            "location": "/data/#code-behind-recipes",
            "text": "",
            "title": "Code Behind Recipes"
        },
        {
            "location": "/data/#working-with-data-in-your-client",
            "text": "",
            "title": "Working with Data in your Client"
        },
        {
            "location": "/data/#implementing-an-online-table",
            "text": "",
            "title": "Implementing an Online Table"
        },
        {
            "location": "/data/#implementing-an-offline-table",
            "text": "",
            "title": "Implementing an Offline Table"
        },
        {
            "location": "/data/#using-a-non-sql-data-source",
            "text": "",
            "title": "Using a Non-SQL Data Source"
        },
        {
            "location": "/data/#the-aspnet-domain-manager",
            "text": "",
            "title": "The ASP.NET Domain Manager"
        },
        {
            "location": "/data/#implementing-a-documentdb-domain-manager",
            "text": "",
            "title": "Implementing a DocumentDB Domain Manager"
        },
        {
            "location": "/data/#implementing-an-azure-table-storage-domain-manager",
            "text": "",
            "title": "Implementing an Azure Table Storage Domain Manager"
        },
        {
            "location": "/authdata/",
            "text": "Authenticated Data Access\n\n\nAdjusting the querying\n\n\nPotential things you can do\n- Per User Tables (with ID)\n- Per Email Tables\n- See My Friends Data",
            "title": "Authenticated Data Access"
        },
        {
            "location": "/authdata/#authenticated-data-access",
            "text": "Adjusting the querying  Potential things you can do\n- Per User Tables (with ID)\n- Per Email Tables\n- See My Friends Data",
            "title": "Authenticated Data Access"
        },
        {
            "location": "/files/",
            "text": "File Management\n\n\nAzure Storage Concepts\n\n\nBlobs, Table, Queues and files\n\n\nThe SAS Tokens\n\n\nFile Sync with Azure Mobile Apps\n\n\nDealing with Files\n\n\nUploading a File to Blob Storage\n\n\nDownload a File from Blob Storage\n\n\nFile Sync with Azure Mobile Apps\n\n\nConfiguring the Mobile Backend\n\n\nDeveloping the Mobile Client",
            "title": "File Management"
        },
        {
            "location": "/files/#file-management",
            "text": "",
            "title": "File Management"
        },
        {
            "location": "/files/#azure-storage-concepts",
            "text": "",
            "title": "Azure Storage Concepts"
        },
        {
            "location": "/files/#blobs-table-queues-and-files",
            "text": "",
            "title": "Blobs, Table, Queues and files"
        },
        {
            "location": "/files/#the-sas-tokens",
            "text": "",
            "title": "The SAS Tokens"
        },
        {
            "location": "/files/#file-sync-with-azure-mobile-apps",
            "text": "",
            "title": "File Sync with Azure Mobile Apps"
        },
        {
            "location": "/files/#dealing-with-files",
            "text": "",
            "title": "Dealing with Files"
        },
        {
            "location": "/files/#uploading-a-file-to-blob-storage",
            "text": "",
            "title": "Uploading a File to Blob Storage"
        },
        {
            "location": "/files/#download-a-file-from-blob-storage",
            "text": "",
            "title": "Download a File from Blob Storage"
        },
        {
            "location": "/files/#file-sync-with-azure-mobile-apps_1",
            "text": "",
            "title": "File Sync with Azure Mobile Apps"
        },
        {
            "location": "/files/#configuring-the-mobile-backend",
            "text": "",
            "title": "Configuring the Mobile Backend"
        },
        {
            "location": "/files/#developing-the-mobile-client",
            "text": "",
            "title": "Developing the Mobile Client"
        },
        {
            "location": "/push/",
            "text": "Push Notifications\n\n\nPush Notification Concepts\n\n\nHow Push Notifications Works\n\n\nWorking with Notification Hubs\n\n\nTesting Push Notifications\n\n\nPush Notifications for Android\n\n\nConfiguring the Notification Hub\n\n\nRegistering for Push Notifications\n\n\nHandling Push Notifications\n\n\nPush Notifications for iOS\n\n\nConfiguring the Notification Hub\n\n\nRegistering for Push Notifications\n\n\nHandling Push Notifications\n\n\nPush Notifications for Universal Windows\n\n\nConfiguring the Notification Hub\n\n\nRegistering for Push Notifications\n\n\nHandling Push Notifications\n\n\nPush Notification Recipes\n\n\nCross-Platform Templates\n\n\nPushing to Tags",
            "title": "Push Notifications"
        },
        {
            "location": "/push/#push-notifications",
            "text": "",
            "title": "Push Notifications"
        },
        {
            "location": "/push/#push-notification-concepts",
            "text": "",
            "title": "Push Notification Concepts"
        },
        {
            "location": "/push/#how-push-notifications-works",
            "text": "",
            "title": "How Push Notifications Works"
        },
        {
            "location": "/push/#working-with-notification-hubs",
            "text": "",
            "title": "Working with Notification Hubs"
        },
        {
            "location": "/push/#testing-push-notifications",
            "text": "",
            "title": "Testing Push Notifications"
        },
        {
            "location": "/push/#push-notifications-for-android",
            "text": "",
            "title": "Push Notifications for Android"
        },
        {
            "location": "/push/#configuring-the-notification-hub",
            "text": "",
            "title": "Configuring the Notification Hub"
        },
        {
            "location": "/push/#registering-for-push-notifications",
            "text": "",
            "title": "Registering for Push Notifications"
        },
        {
            "location": "/push/#handling-push-notifications",
            "text": "",
            "title": "Handling Push Notifications"
        },
        {
            "location": "/push/#push-notifications-for-ios",
            "text": "",
            "title": "Push Notifications for iOS"
        },
        {
            "location": "/push/#configuring-the-notification-hub_1",
            "text": "",
            "title": "Configuring the Notification Hub"
        },
        {
            "location": "/push/#registering-for-push-notifications_1",
            "text": "",
            "title": "Registering for Push Notifications"
        },
        {
            "location": "/push/#handling-push-notifications_1",
            "text": "",
            "title": "Handling Push Notifications"
        },
        {
            "location": "/push/#push-notifications-for-universal-windows",
            "text": "",
            "title": "Push Notifications for Universal Windows"
        },
        {
            "location": "/push/#configuring-the-notification-hub_2",
            "text": "",
            "title": "Configuring the Notification Hub"
        },
        {
            "location": "/push/#registering-for-push-notifications_2",
            "text": "",
            "title": "Registering for Push Notifications"
        },
        {
            "location": "/push/#handling-push-notifications_2",
            "text": "",
            "title": "Handling Push Notifications"
        },
        {
            "location": "/push/#push-notification-recipes",
            "text": "",
            "title": "Push Notification Recipes"
        },
        {
            "location": "/push/#cross-platform-templates",
            "text": "",
            "title": "Cross-Platform Templates"
        },
        {
            "location": "/push/#pushing-to-tags",
            "text": "",
            "title": "Pushing to Tags"
        },
        {
            "location": "/custom/",
            "text": "Server Side\n\n\nWorking with Server Side\n\n\nCustom APIs\n\n\nFunctions\n\n\nServer Side Recipes",
            "title": "Server Side Code"
        },
        {
            "location": "/custom/#server-side",
            "text": "",
            "title": "Server Side"
        },
        {
            "location": "/custom/#working-with-server-side",
            "text": "",
            "title": "Working with Server Side"
        },
        {
            "location": "/custom/#custom-apis",
            "text": "",
            "title": "Custom APIs"
        },
        {
            "location": "/custom/#functions",
            "text": "",
            "title": "Functions"
        },
        {
            "location": "/custom/#server-side-recipes",
            "text": "",
            "title": "Server Side Recipes"
        },
        {
            "location": "/media/",
            "text": "Using Media Services\n\n\nWhat can Media Services do?\n\n\nUploading Videos from Mobile\n\n\nAutomatically Processing Videos\n\n\nStreaming Videos to Mobile\n\n\nCase Study: Video Learning App",
            "title": "Media Services"
        },
        {
            "location": "/media/#using-media-services",
            "text": "",
            "title": "Using Media Services"
        },
        {
            "location": "/media/#what-can-media-services-do",
            "text": "",
            "title": "What can Media Services do?"
        },
        {
            "location": "/media/#uploading-videos-from-mobile",
            "text": "",
            "title": "Uploading Videos from Mobile"
        },
        {
            "location": "/media/#automatically-processing-videos",
            "text": "",
            "title": "Automatically Processing Videos"
        },
        {
            "location": "/media/#streaming-videos-to-mobile",
            "text": "",
            "title": "Streaming Videos to Mobile"
        },
        {
            "location": "/media/#case-study-video-learning-app",
            "text": "",
            "title": "Case Study: Video Learning App"
        },
        {
            "location": "/search/",
            "text": "Integrating Mobile Search\n\n\nDiscovering Search capabilities\n\n\nConfiguring Azure Search\n\n\nUsing Azure Search",
            "title": "Leveraging Search"
        },
        {
            "location": "/search/#integrating-mobile-search",
            "text": "",
            "title": "Integrating Mobile Search"
        },
        {
            "location": "/search/#discovering-search-capabilities",
            "text": "",
            "title": "Discovering Search capabilities"
        },
        {
            "location": "/search/#configuring-azure-search",
            "text": "",
            "title": "Configuring Azure Search"
        },
        {
            "location": "/search/#using-azure-search",
            "text": "",
            "title": "Using Azure Search"
        },
        {
            "location": "/combined/",
            "text": "Web and Mobile Apps\n\n\nServer Side Development\n\n\nSharing the Database Between Web and Mobile Apps\n\n\nAuthentication for Web and Mobile Apps\n\n\nClient Side Development\n\n\nAccessing Mobile Data from a Single Page Application\n\n\nAuthentication for Single Page Applications\n\n\nRecipes for Single Page Applications\n\n\nAngular 1.x\n\n\nAngular 2.x\n\n\nEmber 1.x\n\n\nReact",
            "title": "Web and Mobile Apps"
        },
        {
            "location": "/combined/#web-and-mobile-apps",
            "text": "",
            "title": "Web and Mobile Apps"
        },
        {
            "location": "/combined/#server-side-development",
            "text": "",
            "title": "Server Side Development"
        },
        {
            "location": "/combined/#sharing-the-database-between-web-and-mobile-apps",
            "text": "",
            "title": "Sharing the Database Between Web and Mobile Apps"
        },
        {
            "location": "/combined/#authentication-for-web-and-mobile-apps",
            "text": "",
            "title": "Authentication for Web and Mobile Apps"
        },
        {
            "location": "/combined/#client-side-development",
            "text": "",
            "title": "Client Side Development"
        },
        {
            "location": "/combined/#accessing-mobile-data-from-a-single-page-application",
            "text": "",
            "title": "Accessing Mobile Data from a Single Page Application"
        },
        {
            "location": "/combined/#authentication-for-single-page-applications",
            "text": "",
            "title": "Authentication for Single Page Applications"
        },
        {
            "location": "/combined/#recipes-for-single-page-applications",
            "text": "",
            "title": "Recipes for Single Page Applications"
        },
        {
            "location": "/combined/#angular-1x",
            "text": "",
            "title": "Angular 1.x"
        },
        {
            "location": "/combined/#angular-2x",
            "text": "",
            "title": "Angular 2.x"
        },
        {
            "location": "/combined/#ember-1x",
            "text": "",
            "title": "Ember 1.x"
        },
        {
            "location": "/combined/#react",
            "text": "",
            "title": "React"
        },
        {
            "location": "/developing/",
            "text": "The Development Environment\n\n\nWorking with Azure mobile Apps Locally\n\n\nHandling Authentication\n\n\nHandling Push Notifications\n\n\nDebugging your Cloud Mobile Backend\n\n\nDiagnostic Logging\n\n\nUsing the Visual Studio Debugger",
            "title": "The Development Environment"
        },
        {
            "location": "/developing/#the-development-environment",
            "text": "",
            "title": "The Development Environment"
        },
        {
            "location": "/developing/#working-with-azure-mobile-apps-locally",
            "text": "",
            "title": "Working with Azure mobile Apps Locally"
        },
        {
            "location": "/developing/#handling-authentication",
            "text": "",
            "title": "Handling Authentication"
        },
        {
            "location": "/developing/#handling-push-notifications",
            "text": "",
            "title": "Handling Push Notifications"
        },
        {
            "location": "/developing/#debugging-your-cloud-mobile-backend",
            "text": "",
            "title": "Debugging your Cloud Mobile Backend"
        },
        {
            "location": "/developing/#diagnostic-logging",
            "text": "",
            "title": "Diagnostic Logging"
        },
        {
            "location": "/developing/#using-the-visual-studio-debugger",
            "text": "",
            "title": "Using the Visual Studio Debugger"
        },
        {
            "location": "/testing/",
            "text": "Testing your Mobile Application\n\n\nTesting your Mobile Client\n\n\nIntroduction to Mobile Client Testing\n\n\nIntroduction to Xamarin Test Cloud\n\n\nUsing Mock Data Services\n\n\nUnit Testing\n\n\nTesting your Mobile Backend\n\n\nIntroduction to Mobile Backend Testing\n\n\nUnit Testing\n\n\nLoad Testing\n\n\nEnd to End Testing",
            "title": "Testing your Application"
        },
        {
            "location": "/testing/#testing-your-mobile-application",
            "text": "",
            "title": "Testing your Mobile Application"
        },
        {
            "location": "/testing/#testing-your-mobile-client",
            "text": "",
            "title": "Testing your Mobile Client"
        },
        {
            "location": "/testing/#introduction-to-mobile-client-testing",
            "text": "",
            "title": "Introduction to Mobile Client Testing"
        },
        {
            "location": "/testing/#introduction-to-xamarin-test-cloud",
            "text": "",
            "title": "Introduction to Xamarin Test Cloud"
        },
        {
            "location": "/testing/#using-mock-data-services",
            "text": "",
            "title": "Using Mock Data Services"
        },
        {
            "location": "/testing/#unit-testing",
            "text": "",
            "title": "Unit Testing"
        },
        {
            "location": "/testing/#testing-your-mobile-backend",
            "text": "",
            "title": "Testing your Mobile Backend"
        },
        {
            "location": "/testing/#introduction-to-mobile-backend-testing",
            "text": "",
            "title": "Introduction to Mobile Backend Testing"
        },
        {
            "location": "/testing/#unit-testing_1",
            "text": "",
            "title": "Unit Testing"
        },
        {
            "location": "/testing/#load-testing",
            "text": "",
            "title": "Load Testing"
        },
        {
            "location": "/testing/#end-to-end-testing",
            "text": "",
            "title": "End to End Testing"
        },
        {
            "location": "/troubleshooting/",
            "text": "Troubleshooting\n\n\nTroubleshooting the Mobile Backend\n\n\nIntroduction to Azure Application Insights\n\n\nTroubleshooting the Mobile Client\n\n\nIntroduction to HockeyApp\n\n\nIntroduction to Xamarin Insights",
            "title": "Troubleshooting"
        },
        {
            "location": "/troubleshooting/#troubleshooting",
            "text": "",
            "title": "Troubleshooting"
        },
        {
            "location": "/troubleshooting/#troubleshooting-the-mobile-backend",
            "text": "",
            "title": "Troubleshooting the Mobile Backend"
        },
        {
            "location": "/troubleshooting/#introduction-to-azure-application-insights",
            "text": "",
            "title": "Introduction to Azure Application Insights"
        },
        {
            "location": "/troubleshooting/#troubleshooting-the-mobile-client",
            "text": "",
            "title": "Troubleshooting the Mobile Client"
        },
        {
            "location": "/troubleshooting/#introduction-to-hockeyapp",
            "text": "",
            "title": "Introduction to HockeyApp"
        },
        {
            "location": "/troubleshooting/#introduction-to-xamarin-insights",
            "text": "",
            "title": "Introduction to Xamarin Insights"
        },
        {
            "location": "/production/",
            "text": "Going to Production\n\n\nDeploying Beta Editions of your Application\n\n\nUsing Slots for the Mobile Backend\n\n\nUsing HockeyApp for the Mobile Client\n\n\nScaling your Backend\n\n\nMonitoring your Production Application\n\n\nApplication Insights vs. Xamarin Insights\n\n\nConfiguration as Code (DevOps)\n\n\nIntroduction to Azure Resource Manager\n\n\nDeploying your site with Azure Resource Manager",
            "title": "Going to Production"
        },
        {
            "location": "/production/#going-to-production",
            "text": "",
            "title": "Going to Production"
        },
        {
            "location": "/production/#deploying-beta-editions-of-your-application",
            "text": "",
            "title": "Deploying Beta Editions of your Application"
        },
        {
            "location": "/production/#using-slots-for-the-mobile-backend",
            "text": "",
            "title": "Using Slots for the Mobile Backend"
        },
        {
            "location": "/production/#using-hockeyapp-for-the-mobile-client",
            "text": "",
            "title": "Using HockeyApp for the Mobile Client"
        },
        {
            "location": "/production/#scaling-your-backend",
            "text": "",
            "title": "Scaling your Backend"
        },
        {
            "location": "/production/#monitoring-your-production-application",
            "text": "",
            "title": "Monitoring your Production Application"
        },
        {
            "location": "/production/#application-insights-vs-xamarin-insights",
            "text": "",
            "title": "Application Insights vs. Xamarin Insights"
        },
        {
            "location": "/production/#configuration-as-code-devops",
            "text": "",
            "title": "Configuration as Code (DevOps)"
        },
        {
            "location": "/production/#introduction-to-azure-resource-manager",
            "text": "",
            "title": "Introduction to Azure Resource Manager"
        },
        {
            "location": "/production/#deploying-your-site-with-azure-resource-manager",
            "text": "",
            "title": "Deploying your site with Azure Resource Manager"
        },
        {
            "location": "/xamarin_tips/",
            "text": "Xamarin Forms Tips\n\n\nOver the many months I have spent coding Xamarin Forms, a number of people\nfrom the community and the Xamarin team have given me little tips to improve\nmy Xamarin Forms code.  I hope you find them as useful as I did.\n\n\nImprove your ListView performance\n\n\nIt should be no surprise that performance matters.  Little things like smooth\nscrolling and fast load times are a must.  A lot of improvement can be gained\nby the techniques we have shown in this book since most of the perceived delays\nare caused by the back end loading times.\n\n\nEventually, a lot of apps generate a list.  The normal way for implementing\nthis is with a \nListView\n that has an \nObservableCollection\n  You load your\ndata into the ObservableCollection and then update that whenever the data\nchanges.  That, in turn, updates the ListView.\n\n\nThere are two problems that are inherent here.  The first is in the ObservableCollection\nand the second is in the ListView.  Let's tackle the ObservableCollection first.\n\n\nThe problem with the ObservableCollection is that it's very hard to update.\nWhat normally ends up happening is code like this:\n\n\n// Earlier in the code\nvar listContents = new ObservableCollection<Model>();\n\n// When updating the code\nvar items = await table.ReadAllItemsAsync();\nlistContents.Clear();\nfor (var item in items) {\n    listContents.Add(item);\n}\n\n\n\n\nThe point of the ObservableCollection is that it emits an event whenever the\nlist changes.  In the case where the table has thousands of entries, thousands\nof events will cause thousands of redraws, causing a major slow down in your\ncode that you probably won't know until you have a large enough data set to\nnote the problem.\n\n\nFortunately, one of the top Xamarin Evangelists, \nJames Montemagno\n, has\ncreated a set of helper classes that assist with this sort of problem.  The\nsolution to this problem is to use the \nObservableRangeCollection\n, like\nthis:\n\n\n// Earlier in the code\nvar listContents = new ObservableRangeCollection<Model>();\n\n// When updating the code\nvar items = await table.ReadAllItemsAsync();\nlistContents.ReplaceRange(items);\n\n\n\n\nWith this code, Xamarin Forms gets notified once instead of thousands of times.\nThere are actually several versions of this same behavior in the NuGet repository.\n\n\nAs to the second problem.  A \nListView\n with thousands of items will not be\nshowing all the items at once.  A ListView will update all the items that have\nbeen updated, irrespective of whether they are visible or not.  The answer is\nto use a caching strategy.  There are two potential caching strategies.  with\n\nRetainElement\n, the ListView will generate a cell for each item in the list.\nThis is the default, but it's really only good for certain situations (most\nnotably when the cell has a large number of bindings).  For almost all situations,\nthe \nRecycleElement\n caching strategy should be used.  In this caching strategy,\nthe ListView will minimize the memory foot print and execution speed by only\nupdating cells when they are in the viewable area.  This is good pretty much\nall the time, but explicitly when the cell has a small number of bindings or\nwhen each cell in the list has the same template.  All data about the cell must\ncome from the binding context when using the \nRecycleElement\n caching strategy.\n\n\nYou can set the caching strategy right in the XAML:\n\n\n<ListView CachingStrategy=\"RecycleElement\" ...>\n\n\n\n\nAlternatively, if you are creating a ListView in code, you can specify the\ncaching strategy in the constructor:\n\n\nvar listView = new ListView(ListViewCachingStrategy.RecycleElement);\n\n\n\n\nThere are more techniques for improving ListView performance in the\n\nXamarin documentation\n\n\nBuilding a Floating Action Button\n\n\nOne of the things that I wanted to do to my apps was to give them a little more in the\nway of normal UI design.  My original design (which I introduced back in [Chapter ][ch1])\nhad teal buttons at the bottom of the page.  These buttons scrolled off the page when\nthere were more items on the page than could reasonably be fit on the page.  To fix this,\nI wanted to create a button that was always relative to the viewport.\n\n\nThere are two steps to this.  Firstly, you need to convert the layout to a \nRelativeLayout\n.\nFor instance, my new \nListView.xaml\n file:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage x:Class=\"TaskList.Pages.TaskList\"\n             xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <RelativeLayout>\n            <StackLayout RelativeLayout.HeightConstraint=\"{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=1}\"\n                         RelativeLayout.WidthConstraint=\"{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=1}\">\n\n\n\n\nThe original \nStackLayout\n layout renderer is placed inside the newly added \nRelativeLayout\n.\nThe height and width constraints tell the StackLayout to consume the whole screen.\n\n\nAt the bottom of the page, I can add my button:\n\n\n            </StackLayout>\n\n            <!--  The Floating Button  -->\n            <Button BackgroundColor=\"Teal\"\n                    Command=\"{Binding AddNewItemCommand}\"\n                    RelativeLayout.XConstraint=\"{ConstraintExpression Type=RelativeToParent,\n                                                                      Property=Width,\n                                                                      Factor=1,\n                                                                      Constant=-60}\"\n                    RelativeLayout.YConstraint=\"{ConstraintExpression Type=RelativeToParent,\n                                                                      Property=Height,\n                                                                      Factor=1,\n                                                                      Constant=-60}\"\n                    Text=\"+\"\n                    TextColor=\"White\" />\n        </RelativeLayout>\n    </ContentPage.Content>\n</ContentPage>\n\n\n\n\nThe \nStackLayout\n is the end of the StackLayout I introduced in the previous listing.  Now\nI can add a button (or any other View type control, including a custom control that I may\nhave downloaded from NuGet or the Xamarin Plugins site) as well.  The button will float\nabove the other content since it is added later.  The constraints in this case provide\nthe location of the button.\n\n\nThere is more work to do.  For instance, you cannot click on the thing behind the button -\nthe button always receives the click, which will (in this case) initiate the addition of\na new item.  A custom control will allow you to provide iconography for the button, handle\nsituations where you want to scroll behind and provide for the circular styling of the button\nwhich seems to be in-vogue right now.\n\n\nIf you want to place commands that are not normally used, you may want to consider the ToolbarItem\narea of the ContentPage.  Here is a snippet:\n\n\n    <ContentPage.ToolbarItems>\n        <ToolbarItem Name=\"Refresh\"\n                     Command=\"{Binding RefreshCommand}\"\n                     Icon=\"refresh.png\"\n                     Order=\"Primary\"\n                     Priority=\"0\" />\n    </ContentPage.ToolbarItems>\n\n\n\n\nOn Universal Windows (where this is actually important due to a lack of \"pull-to-refresh\" logic), you\nwill see the familiar triple-dot on the app bar - clicking on the triple dot gives you access to\nthe refresh command.\n\n\nInstalling NuGet Packages in Multiple Projects\n\n\nOne of the common requirements we have in Xamarin Forms is to install NuGet packages\nin all the Xamarin Forms projects.  To do this, right-click on the solution and select\n\nManage NuGet Packages for Solution...\n.  When you install a package here, you can\nselect which projects it should be applied to, allowing you to install a package once\nacross all the dependent projects.\n\n\nAuto-Deploy Universal Windows Apps\n\n\nOne of the more annoying things is that you have to \nDeploy\n the Universal Windows app.\nThis gets in the way of the build process.  I like to build then run.  Having the extra\nDeploy step in there might not seem like much until you find yourself deploying several\ntimes an hour.\n\n\nFortunately, there is a simple fix for this.  Set up the \nConfiguration Manager\n to\nautomatically deploy the right libraries on every successful build.  To do this:\n\n\n\n\nIn Visual Studio, select \nBuild\n -> \nConfiguration Manager...\n\n\nCheck the boxes you can under \nDeploy\n\n\n\n\n\n\n\n\nClick on \nClose\n\n\n\n\nThis setting is saved within the solution, so you only need to do it once per project.",
            "title": "Xamarin Forms Tips"
        },
        {
            "location": "/xamarin_tips/#xamarin-forms-tips",
            "text": "Over the many months I have spent coding Xamarin Forms, a number of people\nfrom the community and the Xamarin team have given me little tips to improve\nmy Xamarin Forms code.  I hope you find them as useful as I did.",
            "title": "Xamarin Forms Tips"
        },
        {
            "location": "/xamarin_tips/#improve-your-listview-performance",
            "text": "It should be no surprise that performance matters.  Little things like smooth\nscrolling and fast load times are a must.  A lot of improvement can be gained\nby the techniques we have shown in this book since most of the perceived delays\nare caused by the back end loading times.  Eventually, a lot of apps generate a list.  The normal way for implementing\nthis is with a  ListView  that has an  ObservableCollection   You load your\ndata into the ObservableCollection and then update that whenever the data\nchanges.  That, in turn, updates the ListView.  There are two problems that are inherent here.  The first is in the ObservableCollection\nand the second is in the ListView.  Let's tackle the ObservableCollection first.  The problem with the ObservableCollection is that it's very hard to update.\nWhat normally ends up happening is code like this:  // Earlier in the code\nvar listContents = new ObservableCollection<Model>();\n\n// When updating the code\nvar items = await table.ReadAllItemsAsync();\nlistContents.Clear();\nfor (var item in items) {\n    listContents.Add(item);\n}  The point of the ObservableCollection is that it emits an event whenever the\nlist changes.  In the case where the table has thousands of entries, thousands\nof events will cause thousands of redraws, causing a major slow down in your\ncode that you probably won't know until you have a large enough data set to\nnote the problem.  Fortunately, one of the top Xamarin Evangelists,  James Montemagno , has\ncreated a set of helper classes that assist with this sort of problem.  The\nsolution to this problem is to use the  ObservableRangeCollection , like\nthis:  // Earlier in the code\nvar listContents = new ObservableRangeCollection<Model>();\n\n// When updating the code\nvar items = await table.ReadAllItemsAsync();\nlistContents.ReplaceRange(items);  With this code, Xamarin Forms gets notified once instead of thousands of times.\nThere are actually several versions of this same behavior in the NuGet repository.  As to the second problem.  A  ListView  with thousands of items will not be\nshowing all the items at once.  A ListView will update all the items that have\nbeen updated, irrespective of whether they are visible or not.  The answer is\nto use a caching strategy.  There are two potential caching strategies.  with RetainElement , the ListView will generate a cell for each item in the list.\nThis is the default, but it's really only good for certain situations (most\nnotably when the cell has a large number of bindings).  For almost all situations,\nthe  RecycleElement  caching strategy should be used.  In this caching strategy,\nthe ListView will minimize the memory foot print and execution speed by only\nupdating cells when they are in the viewable area.  This is good pretty much\nall the time, but explicitly when the cell has a small number of bindings or\nwhen each cell in the list has the same template.  All data about the cell must\ncome from the binding context when using the  RecycleElement  caching strategy.  You can set the caching strategy right in the XAML:  <ListView CachingStrategy=\"RecycleElement\" ...>  Alternatively, if you are creating a ListView in code, you can specify the\ncaching strategy in the constructor:  var listView = new ListView(ListViewCachingStrategy.RecycleElement);  There are more techniques for improving ListView performance in the Xamarin documentation",
            "title": "Improve your ListView performance"
        },
        {
            "location": "/xamarin_tips/#building-a-floating-action-button",
            "text": "One of the things that I wanted to do to my apps was to give them a little more in the\nway of normal UI design.  My original design (which I introduced back in [Chapter ][ch1])\nhad teal buttons at the bottom of the page.  These buttons scrolled off the page when\nthere were more items on the page than could reasonably be fit on the page.  To fix this,\nI wanted to create a button that was always relative to the viewport.  There are two steps to this.  Firstly, you need to convert the layout to a  RelativeLayout .\nFor instance, my new  ListView.xaml  file:  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage x:Class=\"TaskList.Pages.TaskList\"\n             xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <RelativeLayout>\n            <StackLayout RelativeLayout.HeightConstraint=\"{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=1}\"\n                         RelativeLayout.WidthConstraint=\"{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=1}\">  The original  StackLayout  layout renderer is placed inside the newly added  RelativeLayout .\nThe height and width constraints tell the StackLayout to consume the whole screen.  At the bottom of the page, I can add my button:              </StackLayout>\n\n            <!--  The Floating Button  -->\n            <Button BackgroundColor=\"Teal\"\n                    Command=\"{Binding AddNewItemCommand}\"\n                    RelativeLayout.XConstraint=\"{ConstraintExpression Type=RelativeToParent,\n                                                                      Property=Width,\n                                                                      Factor=1,\n                                                                      Constant=-60}\"\n                    RelativeLayout.YConstraint=\"{ConstraintExpression Type=RelativeToParent,\n                                                                      Property=Height,\n                                                                      Factor=1,\n                                                                      Constant=-60}\"\n                    Text=\"+\"\n                    TextColor=\"White\" />\n        </RelativeLayout>\n    </ContentPage.Content>\n</ContentPage>  The  StackLayout  is the end of the StackLayout I introduced in the previous listing.  Now\nI can add a button (or any other View type control, including a custom control that I may\nhave downloaded from NuGet or the Xamarin Plugins site) as well.  The button will float\nabove the other content since it is added later.  The constraints in this case provide\nthe location of the button.  There is more work to do.  For instance, you cannot click on the thing behind the button -\nthe button always receives the click, which will (in this case) initiate the addition of\na new item.  A custom control will allow you to provide iconography for the button, handle\nsituations where you want to scroll behind and provide for the circular styling of the button\nwhich seems to be in-vogue right now.  If you want to place commands that are not normally used, you may want to consider the ToolbarItem\narea of the ContentPage.  Here is a snippet:      <ContentPage.ToolbarItems>\n        <ToolbarItem Name=\"Refresh\"\n                     Command=\"{Binding RefreshCommand}\"\n                     Icon=\"refresh.png\"\n                     Order=\"Primary\"\n                     Priority=\"0\" />\n    </ContentPage.ToolbarItems>  On Universal Windows (where this is actually important due to a lack of \"pull-to-refresh\" logic), you\nwill see the familiar triple-dot on the app bar - clicking on the triple dot gives you access to\nthe refresh command.",
            "title": "Building a Floating Action Button"
        },
        {
            "location": "/xamarin_tips/#installing-nuget-packages-in-multiple-projects",
            "text": "One of the common requirements we have in Xamarin Forms is to install NuGet packages\nin all the Xamarin Forms projects.  To do this, right-click on the solution and select Manage NuGet Packages for Solution... .  When you install a package here, you can\nselect which projects it should be applied to, allowing you to install a package once\nacross all the dependent projects.",
            "title": "Installing NuGet Packages in Multiple Projects"
        },
        {
            "location": "/xamarin_tips/#auto-deploy-universal-windows-apps",
            "text": "One of the more annoying things is that you have to  Deploy  the Universal Windows app.\nThis gets in the way of the build process.  I like to build then run.  Having the extra\nDeploy step in there might not seem like much until you find yourself deploying several\ntimes an hour.  Fortunately, there is a simple fix for this.  Set up the  Configuration Manager  to\nautomatically deploy the right libraries on every successful build.  To do this:   In Visual Studio, select  Build  ->  Configuration Manager...  Check the boxes you can under  Deploy     Click on  Close   This setting is saved within the solution, so you only need to do it once per project.",
            "title": "Auto-Deploy Universal Windows Apps"
        },
        {
            "location": "/android_appendix/",
            "text": "Android Developer Notes\n\n\nThis chapter contains random notes that I discovered while developing mobile apps\nwith Xamarin Forms on the Android platform.  I hope they are useful to you.\n\n\nHandling Callbacks with an Android SDK\n\n\nDissecting the Google Plus Login Process",
            "title": "Android Developer Notes"
        },
        {
            "location": "/android_appendix/#android-developer-notes",
            "text": "This chapter contains random notes that I discovered while developing mobile apps\nwith Xamarin Forms on the Android platform.  I hope they are useful to you.",
            "title": "Android Developer Notes"
        },
        {
            "location": "/android_appendix/#handling-callbacks-with-an-android-sdk",
            "text": "",
            "title": "Handling Callbacks with an Android SDK"
        },
        {
            "location": "/android_appendix/#dissecting-the-google-plus-login-process",
            "text": "",
            "title": "Dissecting the Google Plus Login Process"
        },
        {
            "location": "/references/",
            "text": "References\n\n\nFurther Reading\n\n\nAPI References\n\n\nSamples\n\n\nHow to get Help",
            "title": "References"
        },
        {
            "location": "/references/#references",
            "text": "",
            "title": "References"
        },
        {
            "location": "/references/#further-reading",
            "text": "",
            "title": "Further Reading"
        },
        {
            "location": "/references/#api-references",
            "text": "",
            "title": "API References"
        },
        {
            "location": "/references/#samples",
            "text": "",
            "title": "Samples"
        },
        {
            "location": "/references/#how-to-get-help",
            "text": "",
            "title": "How to get Help"
        },
        {
            "location": "/credits/",
            "text": "Credits\n\n\nI got a lot of assistance during the writing of this book.  The following people assisted (in no\nparticular order):\n\n\n\n\nJames Montemagno\n\n\nPierce Boggan\n\n\nMike James\n\n\nChris Gillum\n\n\nChris Risner",
            "title": "Credits"
        },
        {
            "location": "/credits/#credits",
            "text": "I got a lot of assistance during the writing of this book.  The following people assisted (in no\nparticular order):   James Montemagno  Pierce Boggan  Mike James  Chris Gillum  Chris Risner",
            "title": "Credits"
        }
    ]
}