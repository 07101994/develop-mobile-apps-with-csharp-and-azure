{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\u00b6\n\n\nWelcome to my first book.  It's free, it's open source, and it's comprehensive.\nThose attributes also describe two of my favorite technologies, and I'm basing\nmy first book on them.  The first is \nXamarin Forms\n , a technology that\nallows you to develop cross-platform mobile applications using C# and the .NET\nframework.  The second is \nAzure Mobile Apps\n, a technology that allows\nyou to connect your mobile app to  resources that are important in cloud\nconnected mobile applications such as table data, authentication, and push\nnotifications.\n\n\nThis book does not tell you everything there is to know about either topic.  It\nfocuses on the topics necessary to get your mobile apps connected to the cloud.\n\n\nWhat are Cloud Connected Mobile Apps?\n\u00b6\n\n\nI guess I should define some of the terminology that I am going to use.  When I\nrefer to a \nmobile application\n or \nmobile app\n, I mean every piece of\nsoftware that is related to the application you want to use.  This includes, for\nexample, the \nmobile client\n. This is the piece of code you run on your iPhone\nor Android phone.  It also includes the \nmobile backend\n which is the service\nthat you run in the cloud to provide important services to your mobile client.\n\n\nA \ncloud connected mobile application\n is a mobile client that connects to a\nmobile backend for shared services.  Quite a few of the apps on your phone are\ncloud connected already.  For example, Instagram uses the cloud for photo\nstorage, and Facebook uses the cloud to store the news feeds of you and your\nfriends.\n\n\nWhy Cross-Platform Native Development is important?\n\u00b6\n\n\nIt should come as no surprise that Apple and Google have pretty much won the\nmobile OS wars.  Over 90% of the smart phones being sold today run either iOS\nor Android.  However, these are two very different mobile operating systems,\nwith different programming models.  iOS is based on either \nSwift\n or\nObjective-C.  Android is based on \nJava\n.  If you want to develop for the\n80% case (and you should), then you need to know both Swift and Java.  That's\na tall order even for the most dedicated mobile developer.\n\n\nHowever, there are alternatives out there.  Most notable, you can write your\nmobile application with one code-base and just write exceptions for when the\nplatforms diverge.  You have to pick a single language and a tool set that\nsupports cross-platform development to do this.  Not all cross-platform tool\nsets are created equal, however.  Some do not compile your code to native\nbinaries, which means that you do not get access to all the functionality of\nthe mobile platforms you are targeting.\n\n\nXamarin, recently acquired by Microsoft, allows you to target all major\nplatforms - iOS, Android and Windows - to gain greater than 95% coverage of\nthe mobile smart phone market.  It does this by leveraging the .NET framework\nand compiling your code to a native binary for each platform.\n\n\nXamarin.Forms is a cross-platform framework, based on XAML and .NET, that\nallows you to use common UI pages to develop your apps.\n\n\nWhy Azure Mobile Apps?\n\u00b6\n\n\nWhen you think about the major apps in the marketplace for each mobile\nplatform, the thing that they have in common is that they have some sort\nof cloud infrastructure driving them.  It might be as simple as storing\nyour task list, or as complex as your Facebook news feed.  It could be a\ngaming leader board, or the social sharing of your photos.  Whatever it\nis, cloud connectivity is a must.\n\n\nNot all clouds are created equal.  There are some common features that you\nshould think about including irrespective of the application.  I like to use\nAzure Mobile Apps for these features because they are all included and you\ncan get started with most of the features for zero cost.  Even the features\nthat cannot be obtained without spending a little money are relatively cheap.\n\n\n\n\nAzure Mobile Apps is a feature of Azure App Service.  Azure App Service is\na collection of services that commonly are used together to develop modern\nInternet Apps.  This includes web hosting, API hosting and Mobile SDKs.\n\n\n\n\nFeatures of Cloud Connected Mobile Apps\n\u00b6\n\n\nA cloud connected mobile application will use one or more services in the\nfollowing areas:\n\n\n\n\nAuthentication\n\n\nStorage of structured data (like a task list)\n\n\nStorage of unstructured data (like photographs)\n\n\nPush notifications\n\n\nInvocation of Custom Code\n\n\n\n\nI am going to cover each of these in great detail.  In addition, I will also\ncover some common issues and solutions that developers run into while developing\ncloud connected mobile applications such as testing and going to production.\n\n\nAside from the actual features of mobile apps, there are other things to\nconsider while developing your mobile application.  Here is my list, in no\nparticular order:\n\n\n\n\nContinuous Deployment\n\n\nSlots or Staging Sites\n\n\nAutomatic Scalability\n\n\nDatabase Backups\n\n\nCombined Web\n\n\n\n\nThe point here is that my intent is to write a production quality application.\nI need to be able to deploy my site with confidence without resorting to jumping\nthrough hoops.  I want to run multiple versions of the backend so that I can run\na staging site for testing purposes.  I want to be able to roll back my\nproduction site to a previous version at a moments notice.  I want to be able to\nhandle the load when my app is successful, and I want things to be backed up\n(since bad things inevitably happen when I am least prepared).\n\n\nAll of these features are available in Azure App Service, and the Mobile Apps\nSDK that I will use throughout the book is supported only on Azure App Service.\n\n\nWho is This Book For?\n\u00b6\n\n\nThis book is for intermediate to experienced C# developers who have already\nbuilt a mobile app with Xamarin and want to take their mobile apps to the next\nlevel by utilizing cloud services.\n\n\nThis book is not for the beginner.  Explicitly, I already expect you to know how\nto develop mobile applications with C# and Xamarin technologies.  If you are\nunfamiliar with the C# language, you can get started with a free course on the\nInternet.  The basics of the language can be learned at \nwww.learncs.org\n.\nOnce you have the language basics under your belt, you can move on to building\nmobile applications with Xamarin. You can learn more about developing cross-platform\nmobile development with Xamarin at the \nXamarin\n website.  Although you do\nnot need to understand ASP.NET to get value out of this book, be aware that the\nmobile back ends that I will be covering are written in C# and ASP.NET.  A good\nunderstanding of ASP.NET will assist you.\n\n\nThings You Should Know!\n\u00b6\n\n\nBefore you get started with development, spend some time learning the tools of\nthe trade.  The command prompt on the Mac is \nbash\n and the command prompt\non the PC is \nPowerShell\n.  You should be proficient in the shell on the\nplatforms that you use.\n\n\nAdditionally, you should become familiar with the source code control system\nthat you will use.  For most, this means becoming familiar with\n\ngit\n.  Don't even think of developing without using source control.\n\n\nWhat You Will Need\n\u00b6\n\n\nThe list of hardware and software for mobile development is longer than your\ntypical development projects.  It is still, thankfully, relatively short and\neasy to acquire.\n\n\nHardware\n\u00b6\n\n\nYou will want a computer on which to develop code.  If you develop iOS\napplications, then you \nMUST\n have a Mac running the latest version of Mac\nOSX.  If you develop Universal Windows applications, then you \nMUST\n have a\nPC running Windows 10.  Android applications can be developed on either platform.\n\n\nMy own experience has taught me that the tooling for developing mobile backends\nin C# and ASP.NET (our primary languages during the course of this book) are\nbetter on a PC running Windows 10.  Thus, my hardware choice is a rather beefy\n\nWindows 10 PC\n for my main development system.  In addition, I have a\n\nMac Mini\n underneath my desk that I use to build the iOS portions of the\napplications.\n\n\nSoftware\n\u00b6\n\n\nAll of the following software are freely available.  You should install each\npackage and update it (if appropriate) so that it is fully patched.\n\n\nOn your Mac\n\u00b6\n\n\n\n\nXCode\n (available on the Mac App Store)\n\n\nXamarin Studio\n\n\nAndroid Studio and Tools\n (if you intend to build Android apps on the Mac)\n\n\n\n\nYou must run XCode at least once after installation so that you can accept the\nlicense agreement.\n\n\nOn your Windows PC\n\u00b6\n\n\n\n\nAndroid Studio and Tools\n\n\nVisual Studio Community\n\n\nAzure SDK\n\n\n\n\nWhen installing Visual Studio, you will want to install the components for\nWeb applications and Cross-platform Mobile development.  If you have already\ninstalled Visual Studio and did not install these components, run the installer\nagain to add the components.\n\n\n\n\nDevelopment Tools are big, multi-gigabyte installers.  If you are on a slow or\nrestricted link, you may want to download the installers onto a thumb drive for\nlocal installation.\n\n\n\n\nCloud Services\n\u00b6\n\n\nYou will need an Azure account to complete most of the tutorials in this book.\nIn fact, you won't be able to get very far without one. If you have an MSDN\naccount, you already have access to free Azure resources.  You just need to log\ninto your \nMSDN account\n and activate your Azure benefit.  Students may be\nable to get access to \nDreamspark\n from school resources, but this is not\nsuitable for developing mobile applications.  This is because storage costs\nmoney.  If you don't have MSDN, then there is a \nfree trial\n available.\nOnce the trial period ends, you can move to a Pay-As-You-Go account and continue\nto use free services without incurring a charge. I'll point out when you are\ngoing to incur charges on your Azure account, but I will be using free resources\nmost of the time.\n\n\nAside from Azure resources, you will want some place to store your code.  This\ndoesn't have to be in the cloud.  If you want to use the cloud, you can use\nGitHub or Visual Studio Team Services.  Both are free to use.  GitHub provides\npublic repositories for free.  Visual Studio Team Services provides private\nrespositories for free.  Visual Studio Team Services also includes other\nservices that I will talk about during the course of the book, some of which may\nincur cost.  I will be publishing all my samples and tutorial code on GitHub so\nthat you can easily download it.  You don't have to use one of these resources,\nbut I won't be covering other service usage.\n\n\nYou will need a \nDeveloper Account\n for the appropriate app store if you\nintend to distribute your mobile clients or if you intend to use specific cloud\nservices.  Apple is specific - if you intend to use push notifications or\ndistribute iOS apps, then you need an \nApple Developer Account\n,\n\nGoogle Developer Account\n and/or \nWindows Store Developer Account\n.\nThe terms of the accounts are changed constantly, so review the current terms\nwhen you sign up.  My recommendation is to defer signing up for these programs\nuntil you need something they offer.\n\n\nNow, let's get developing!  Our next section is dependent on where you are developing:\n\n\n\n\nOn a Mac, skip ahead to the \nMac section\n.\n\n\nOn a PC, the \nnext section\n covers Visual Studio.",
            "title": "Getting Started"
        },
        {
            "location": "/#introduction",
            "text": "Welcome to my first book.  It's free, it's open source, and it's comprehensive.\nThose attributes also describe two of my favorite technologies, and I'm basing\nmy first book on them.  The first is  Xamarin Forms  , a technology that\nallows you to develop cross-platform mobile applications using C# and the .NET\nframework.  The second is  Azure Mobile Apps , a technology that allows\nyou to connect your mobile app to  resources that are important in cloud\nconnected mobile applications such as table data, authentication, and push\nnotifications.  This book does not tell you everything there is to know about either topic.  It\nfocuses on the topics necessary to get your mobile apps connected to the cloud.",
            "title": "Introduction"
        },
        {
            "location": "/#what-are-cloud-connected-mobile-apps",
            "text": "I guess I should define some of the terminology that I am going to use.  When I\nrefer to a  mobile application  or  mobile app , I mean every piece of\nsoftware that is related to the application you want to use.  This includes, for\nexample, the  mobile client . This is the piece of code you run on your iPhone\nor Android phone.  It also includes the  mobile backend  which is the service\nthat you run in the cloud to provide important services to your mobile client.  A  cloud connected mobile application  is a mobile client that connects to a\nmobile backend for shared services.  Quite a few of the apps on your phone are\ncloud connected already.  For example, Instagram uses the cloud for photo\nstorage, and Facebook uses the cloud to store the news feeds of you and your\nfriends.",
            "title": "What are Cloud Connected Mobile Apps?"
        },
        {
            "location": "/#why-cross-platform-native-development-is-important",
            "text": "It should come as no surprise that Apple and Google have pretty much won the\nmobile OS wars.  Over 90% of the smart phones being sold today run either iOS\nor Android.  However, these are two very different mobile operating systems,\nwith different programming models.  iOS is based on either  Swift  or\nObjective-C.  Android is based on  Java .  If you want to develop for the\n80% case (and you should), then you need to know both Swift and Java.  That's\na tall order even for the most dedicated mobile developer.  However, there are alternatives out there.  Most notable, you can write your\nmobile application with one code-base and just write exceptions for when the\nplatforms diverge.  You have to pick a single language and a tool set that\nsupports cross-platform development to do this.  Not all cross-platform tool\nsets are created equal, however.  Some do not compile your code to native\nbinaries, which means that you do not get access to all the functionality of\nthe mobile platforms you are targeting.  Xamarin, recently acquired by Microsoft, allows you to target all major\nplatforms - iOS, Android and Windows - to gain greater than 95% coverage of\nthe mobile smart phone market.  It does this by leveraging the .NET framework\nand compiling your code to a native binary for each platform.  Xamarin.Forms is a cross-platform framework, based on XAML and .NET, that\nallows you to use common UI pages to develop your apps.",
            "title": "Why Cross-Platform Native Development is important?"
        },
        {
            "location": "/#why-azure-mobile-apps",
            "text": "When you think about the major apps in the marketplace for each mobile\nplatform, the thing that they have in common is that they have some sort\nof cloud infrastructure driving them.  It might be as simple as storing\nyour task list, or as complex as your Facebook news feed.  It could be a\ngaming leader board, or the social sharing of your photos.  Whatever it\nis, cloud connectivity is a must.  Not all clouds are created equal.  There are some common features that you\nshould think about including irrespective of the application.  I like to use\nAzure Mobile Apps for these features because they are all included and you\ncan get started with most of the features for zero cost.  Even the features\nthat cannot be obtained without spending a little money are relatively cheap.   Azure Mobile Apps is a feature of Azure App Service.  Azure App Service is\na collection of services that commonly are used together to develop modern\nInternet Apps.  This includes web hosting, API hosting and Mobile SDKs.",
            "title": "Why Azure Mobile Apps?"
        },
        {
            "location": "/#features-of-cloud-connected-mobile-apps",
            "text": "A cloud connected mobile application will use one or more services in the\nfollowing areas:   Authentication  Storage of structured data (like a task list)  Storage of unstructured data (like photographs)  Push notifications  Invocation of Custom Code   I am going to cover each of these in great detail.  In addition, I will also\ncover some common issues and solutions that developers run into while developing\ncloud connected mobile applications such as testing and going to production.  Aside from the actual features of mobile apps, there are other things to\nconsider while developing your mobile application.  Here is my list, in no\nparticular order:   Continuous Deployment  Slots or Staging Sites  Automatic Scalability  Database Backups  Combined Web   The point here is that my intent is to write a production quality application.\nI need to be able to deploy my site with confidence without resorting to jumping\nthrough hoops.  I want to run multiple versions of the backend so that I can run\na staging site for testing purposes.  I want to be able to roll back my\nproduction site to a previous version at a moments notice.  I want to be able to\nhandle the load when my app is successful, and I want things to be backed up\n(since bad things inevitably happen when I am least prepared).  All of these features are available in Azure App Service, and the Mobile Apps\nSDK that I will use throughout the book is supported only on Azure App Service.",
            "title": "Features of Cloud Connected Mobile Apps"
        },
        {
            "location": "/#who-is-this-book-for",
            "text": "This book is for intermediate to experienced C# developers who have already\nbuilt a mobile app with Xamarin and want to take their mobile apps to the next\nlevel by utilizing cloud services.  This book is not for the beginner.  Explicitly, I already expect you to know how\nto develop mobile applications with C# and Xamarin technologies.  If you are\nunfamiliar with the C# language, you can get started with a free course on the\nInternet.  The basics of the language can be learned at  www.learncs.org .\nOnce you have the language basics under your belt, you can move on to building\nmobile applications with Xamarin. You can learn more about developing cross-platform\nmobile development with Xamarin at the  Xamarin  website.  Although you do\nnot need to understand ASP.NET to get value out of this book, be aware that the\nmobile back ends that I will be covering are written in C# and ASP.NET.  A good\nunderstanding of ASP.NET will assist you.",
            "title": "Who is This Book For?"
        },
        {
            "location": "/#things-you-should-know",
            "text": "Before you get started with development, spend some time learning the tools of\nthe trade.  The command prompt on the Mac is  bash  and the command prompt\non the PC is  PowerShell .  You should be proficient in the shell on the\nplatforms that you use.  Additionally, you should become familiar with the source code control system\nthat you will use.  For most, this means becoming familiar with git .  Don't even think of developing without using source control.",
            "title": "Things You Should Know!"
        },
        {
            "location": "/#what-you-will-need",
            "text": "The list of hardware and software for mobile development is longer than your\ntypical development projects.  It is still, thankfully, relatively short and\neasy to acquire.",
            "title": "What You Will Need"
        },
        {
            "location": "/#hardware",
            "text": "You will want a computer on which to develop code.  If you develop iOS\napplications, then you  MUST  have a Mac running the latest version of Mac\nOSX.  If you develop Universal Windows applications, then you  MUST  have a\nPC running Windows 10.  Android applications can be developed on either platform.  My own experience has taught me that the tooling for developing mobile backends\nin C# and ASP.NET (our primary languages during the course of this book) are\nbetter on a PC running Windows 10.  Thus, my hardware choice is a rather beefy Windows 10 PC  for my main development system.  In addition, I have a Mac Mini  underneath my desk that I use to build the iOS portions of the\napplications.",
            "title": "Hardware"
        },
        {
            "location": "/#software",
            "text": "All of the following software are freely available.  You should install each\npackage and update it (if appropriate) so that it is fully patched.",
            "title": "Software"
        },
        {
            "location": "/#on-your-mac",
            "text": "XCode  (available on the Mac App Store)  Xamarin Studio  Android Studio and Tools  (if you intend to build Android apps on the Mac)   You must run XCode at least once after installation so that you can accept the\nlicense agreement.",
            "title": "On your Mac"
        },
        {
            "location": "/#on-your-windows-pc",
            "text": "Android Studio and Tools  Visual Studio Community  Azure SDK   When installing Visual Studio, you will want to install the components for\nWeb applications and Cross-platform Mobile development.  If you have already\ninstalled Visual Studio and did not install these components, run the installer\nagain to add the components.   Development Tools are big, multi-gigabyte installers.  If you are on a slow or\nrestricted link, you may want to download the installers onto a thumb drive for\nlocal installation.",
            "title": "On your Windows PC"
        },
        {
            "location": "/#cloud-services",
            "text": "You will need an Azure account to complete most of the tutorials in this book.\nIn fact, you won't be able to get very far without one. If you have an MSDN\naccount, you already have access to free Azure resources.  You just need to log\ninto your  MSDN account  and activate your Azure benefit.  Students may be\nable to get access to  Dreamspark  from school resources, but this is not\nsuitable for developing mobile applications.  This is because storage costs\nmoney.  If you don't have MSDN, then there is a  free trial  available.\nOnce the trial period ends, you can move to a Pay-As-You-Go account and continue\nto use free services without incurring a charge. I'll point out when you are\ngoing to incur charges on your Azure account, but I will be using free resources\nmost of the time.  Aside from Azure resources, you will want some place to store your code.  This\ndoesn't have to be in the cloud.  If you want to use the cloud, you can use\nGitHub or Visual Studio Team Services.  Both are free to use.  GitHub provides\npublic repositories for free.  Visual Studio Team Services provides private\nrespositories for free.  Visual Studio Team Services also includes other\nservices that I will talk about during the course of the book, some of which may\nincur cost.  I will be publishing all my samples and tutorial code on GitHub so\nthat you can easily download it.  You don't have to use one of these resources,\nbut I won't be covering other service usage.  You will need a  Developer Account  for the appropriate app store if you\nintend to distribute your mobile clients or if you intend to use specific cloud\nservices.  Apple is specific - if you intend to use push notifications or\ndistribute iOS apps, then you need an  Apple Developer Account , Google Developer Account  and/or  Windows Store Developer Account .\nThe terms of the accounts are changed constantly, so review the current terms\nwhen you sign up.  My recommendation is to defer signing up for these programs\nuntil you need something they offer.  Now, let's get developing!  Our next section is dependent on where you are developing:   On a Mac, skip ahead to the  Mac section .  On a PC, the  next section  covers Visual Studio.",
            "title": "Cloud Services"
        },
        {
            "location": "/chapter1/firstapp_pc/",
            "text": "Your First Mobile App\n\u00b6\n\n\nThere is a lot of detail to absorb about the possible services that the mobile\nclient can consume and I will go into significant depth on those subjects.\nFirst, wouldn't it be nice to write some code and get something working?\nMicrosoft Azure has a great \nfirst-steps tutorial\n that takes you via the\nquickest possible route from creating a mobile backend to having a functional\nbackend.  I would like to take things a little slower so that we can understand\nwhat is going on while we are doing the process.  We will have practically the\nsame application at the end.  The primary reason for going through this slowly\nis to ensure that all our build and run processes are set up properly.  If this\nis the first mobile app you have ever written, you will see that there are quite\na few things that need to be set up.  This chapter covers the set up required\nfor a Windows PC.  If you wish to develop your applications on a Mac, then skip\nto the \nnext section\n.\n\n\nThe application we are going to build together is a simple task list.  The\nmobile client will have three screens - an entry screen, a task list and a task\ndetails page.  I have mocked these pages up using \nMockingBot\n.\n\n\n\n\nMocking your screens before you start coding is a great habit to get into.\nThere are some great tools available including free tools like \nMockingBot\n.\nDoing mockups before you start coding is a good way to prevent wasted time later\non.\n\n\n\n\n\n\n\n\nWhy include a back button?  If you are using iOS, then you may want to remove\nthe back button as the style guides suggest you don't need one.  Other platforms\nwill need it though, so it's best to start with the least common denominator.\nIt's the same reason I add a refresh button even though it's only valid on\nWindows Phone!\n\n\n\n\nMy ideas for this app include:\n\n\n\n\nTapping on a task title in the task list will bring up the details page.\n\n\nToggling the completed link in the task list will set the completed flag.\n\n\nTapping the spinner will initiate a network refresh.\n\n\n\n\nNow that we have our client screens planned out, we can move onto the thinking\nabout the mobile backend.\n\n\nThe Mobile Backend\n\u00b6\n\n\nThe mobile backend is an ASP.NET WebApi that is served from within Azure App\nService: a highly scalable and redundant web hosting facility that supports all\nthe major web languages (like ASP.NET, Node, PHP and Python).  Azure Mobile\nApps is an SDK (which is available in ASP.NET and Node) that runs on top of\nAzure App Service.\n\n\nCreating a Simple Azure Mobile Apps Backend\n\u00b6\n\n\nMicrosoft Azure has included a comprehensive starter kit template in the\nAzure SDK.  To get started:\n\n\n\n\nFire up Visual Studio 2015\n\n\nAdd a new project with File -> New Project...\n\n\n\n\nIn the \nNew Project\n window:\n\n\n\n\nOpen up Templates -> Visual C# -> Web and select \nASP.NET Web Application (.NET Framework)\n.\n\n\nEnter \nBackend\n for the Name and \nChapter1\n for the Solution name.\n\n\nPick a suitable directory for the Location field.\n\n\nClick on OK.\n\n\n\n\n\n\n\n\n\n\nIn the \nNew ASP.NET Web Application\n window:\n\n\n\n\nClick on \nAzure Mobile App\n.\n\n\nDo \nNOT\n check \"Host in the cloud\" or any other checkboxes.\n\n\nClick on OK.\n\n\n\n\n\n\n\n\nAt this point, Visual Studio will create your backend project.\n\n\n\n\nIt's very tempting to select \nAzure Mobile Services\n instead - it sounds\ncloser to what you want.  Azure Mobile Services is the \nOLD\n service and is\nbeing shut down.  You should not select Azure Mobile Services for any project.\n\n\n\n\nThere are a few files of which you should take note.  The Mobile Apps SDK is\ninitialized within \nApp_Start\\Startup.MobileApp.cs\n (with the call to the\nconfiguration routine happening within \nStartup.cs\n).  The default startup\nroutine is reasonable but it hides what it is doing behind extension methods.\nThis technique is fairly common in ASP.NET programs.  Let's expand the\nconfiguration routine to only include what we need:\n\n\npublic static void ConfigureMobileApp(IAppBuilder app)\n{\n    var config = new HttpConfiguration();\n    var mobileConfig = new MobileAppConfiguration();\n\n    mobileConfig\n        .AddTablesWithEntityFramework()\n        .ApplyTo(config);\n\n    Database.SetInitializer(new MobileServiceInitializer());\n\n    app.UseWebApi(config);\n}\n\n\n\n\nThe minimal version of the mobile backend initialization is actually shorter\nthan the original.  It also only includes a data access layer.  Other services\nlike authentication, storage and push notifications are not configured.\n\n\nThere is another method in the \nApp_Start\\Startup.MobileApp.cs\n file for\nseeding data into the database for us.  We can leave that alone for now, but\nremember it is there in case you need to seed data into a new database for\nyour own backend.\n\n\n\n\nWe refer to \"seeding data\" into a database.  This means that we are going to introduce some data into the database so that we aren't operating on an empty database.  The data will be there when we query the database later on.\n\n\n\n\nThe next important file is the \nDbContext\n - located in\n\nModels\\MobileServiceContext.cs\n. Azure Mobile Apps is heavily dependent on\n\nEntity Framework v6.x\n and the \nDbContext\n is a central part of that\nlibrary.  Fortunately, we don't need to do anything to this file right now.\n\n\nFinally, we get to the meat of the backend.  The whole point of this\ndemonstration is to project a single database table - the TodoItem table - into\nthe mobile realm with the aid of an opinionated \nOData v3\n feed.  To that\nend, we need three items:\n\n\n\n\nA \nDbSet<>\n within the \nDbContext\n\n\nA Data Transfer Object (or DTO)\n\n\nA Table Controller\n\n\n\n\nWhen we create the project, a sample of each one of these for the TodoItem table\nis added for us.  You can see the \nDbSet<>\n in the \nModels\\MobileServiceContext.cs\n\nfile, for example.  Let's take a look at the DTO and Table Controller for this\nexample table as well.  The DTO for the TodoItem table is located within the\n\nDataObjects\n directory:\n\n\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.DataObjects\n{\n    public class TodoItem : EntityData\n    {\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n    }\n}\n\n\n\n\nNote that the model uses \nEntityData\n as a base class.  The \nEntityData\n class\nadds five additional properties to the class - we'll discuss those in more\ndetails during the \nData Access and Offline Sync\n chapter.\n\n\nFinally, let's look at the table controller for the example TodoItem table.  This\nis located in \nControllers\\TodoItemController.cs\n:\n\n\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}\n\n\n\n\nThe \nTableController\n is the central processing for the database access layer.\nIt handles all the OData capabilities for us and exposes these as REST endpoints\nwithin our WebAPI.  This means that the actual code for this controller is tiny - just 12 lines of code.\n\n\n\n\nOData\n is a specification for accessing table data on the Internet.  It provides a mechanism for querying and manipulating data within a table.  Entity Framework is a common data access layer for ASP.NET applications.\n\n\n\n\nWe can build the project at this point.  If Visual Studio hasn't done so already,\nthe missing NuGet packages for Azure Mobile Apps will be downloaded.  There\nshould not be any errors.  If there are, check the typing for any changes you\nmade.\n\n\n\n\nYou can delete or ignore the \nControllers\\ValuesController.cs\n file if you like - it isn't important for this walkthrough.\n\n\n\n\nBuilding an Azure App Service for Mobile Apps\n\u00b6\n\n\nThe next step in the process is to build the resources on Azure that will\nrun your mobile backend.  Start by logging into the \nAzure Portal\n, then\nfollow these instructions:\n\n\n\n\nClick on the big \n+ New\n button in the top-left corner.\n\n\nClick on \nWeb + Mobile\n, then \nMobile App\n.\n\n\n\n\nEnter a unique name in the \nApp name\n box.\n\n\n\n\nSince the name doesn't matter and it has to be unique, you can use \na\nGUID generator\n to generate a unique name. GUIDs are not the best\nnames to use when you need to actually find resources, but using GUIDS\nprevents conflicts when deploying, so I prefer them as a naming scheme.\nYou can prefix the GUID  (example: chapter1-GUID) to aid in discovery\nlater on.  Generally, the first four digits of a GUID are enough to\nidentify individual resources.\n\n\n\n\n\n\n\n\nIf you have more than one subscription (for example, you have a trial\n   and an MSDN subscription), then ensure you select the right subscription\n   in the \nSubscription\n drop-down.\n\n\n\n\n\n\nSelect \nCreate new\n under resource group and enter a name for this\n   mobile application.\n\n\n\n\nResource groups are great for grouping all the resources associated with a mobile application together.  During development, it means you can delete all the resources in one operation.  For production, it means you can see how much the service is costing you and how the resources are being used.\n\n\n\n\n\n\n\n\nFinally, select or create a new \nApp Service Plan\n.\n\n\n\n\nThe App Service Plan is the thing that actually bills you - not the web or mobile backend.  You can run a number of web or mobile backends on the same App Service Plan.\n\n\n\n\nI tend to create a new App Service Plan for each mobile application.  This\nis because the App Service Plan lives inside the Resource Group that you\ncreate.  The process for creating an App Service Plan is straight forward.\nYou have two decisions to make.  The first decision is where is the service\ngoing to run.  In a production environment, the correct choice is \"near your\ncustomers\".  \"Close to the developers\" is a good choice during development.\nUnfortunately, neither of those is an option you can actually choose in the\nportal, so you will have to translate into some sort of geographic location.\nWith 16 regions to choose from, you have a lot of choice.\n\n\nThe second decision you have to make is what to run the service on; also\nknown as the Pricing tier.   If you click on \nView all\n, you will see you\nhave lots of choices.  F1 Free and D1 Shared, for example, run on shared\nresources and are CPU limited. You should avoid these as the service will\nstop responding when you are over the CPU quota.  That leaves Basic,\nStandard and Premium.  Basic has no automatic scaling and can run up to 3\ninstances - perfect for development tasks.  Standard and Premium both have\nautomatic scaling, automatic backups, and large amounts of storage; they\ndiffer in features: the number of sites or instances you can run on them,\nfor example.  Finally, there is a number after the plan.  This tells you how\nbig the virtual machine is that the plan is running on.  The numbers differ\nby number of cores and memory.\n\n\nFor our purposes, an F1 Free site is enough to run this small demonstration\nproject.  More complex development projects should use something in the\nBasic range of pricing plans.  Production apps should be set up in Standard\nor Premium pricing plans.\n\n\n\n\n\n\nOnce you have created your app service plan and saved it, click on \nCreate\n.\n\n\n\n\n\n\nThe creation of the service can take a couple of minutes.  You can monitor the\nprocess of deployment by clicking on the Notifications icon.  This is in the top\nbar on the right-hand side and looks like a Bell.  Clicking on a specific\nnotification will provide more information about the activity.  Once you have\ncreated your app service, the App Service blade will open.\n\n\n\n\nWhat's the difference between a Web App, a Mobile App and an API App?  Not a\nlot.  The type determines which Quick start projects are available in the Quick\nstart menu under \nAll settings\n.  Since we selected a Mobile app, a set of\nstarter client projects for mobile devices will be presented.\n\n\n\n\nWe will also want a place to store our data.  This role is taken on by a\nSQL Azure instance.  We could link an existing database if we had one\ndefined.  However, we can also create a test database.\n\n\n\n\nCreating a Test Database through the App Service Data Connections (as\nI describe here) allows you to create a free database.  This option is\nnot normally available through other SQL database creation flows.\n\n\n\n\n\n\nClick on \nResource groups\n in the left hand side menu.\n\n\nClick on the resource group you created.\n\n\nClick on the App Service your created.\n\n\n\n\nClick on \nAll settings\n.\n\n\n\n\nIf you pinned your App Service to the dashboard, you can click on the\npinned App Service instead.  It will bring you to the same place.\n\n\n\n\n\n\n\n\nClick on \nData connections\n in the \nMOBILE\n menu.\n\n\n\n\n\n\nClick on \nAdd\n.\n\n\n\n\nIn the \nType\n box, select \nSQL Database\n.\n\n\nClick on the unconfigured \nSQL Database\n link:\n\n\n\n\n\n\n\n\nIn the \nDatabase\n blade, select \nCreate a new database\n.\n\n\nEnter a name for the database (like \nchapter1-db\n).\n\n\nSelect a Pricing Tier (look for \nF Free\n at the bottom).\n\n\nClick on the unconfigured \nServer\n.\n\n\n\n\n\n\n\n\nEnter a unique name for the server (a GUID is a good idea here).\n\n\nEnter a username and password for the server.\n\n\nClick on \nOK\n to close the \nNew Server\n blade.\n\n\nClick on \nOK\n to close the \nNew Database\n blade.\n\n\nClick on \nOK\n to close the \nAdd Data Connection\n blade.\n\n\n\n\n\n\n\n\nThis produces another deployment step that creates a SQL Server and a SQL\ndatabase with your settings.  Once complete, the connection\n\nMS_TableConnectionString\n will be listed in Data Connections blade.\n\n\n\n\n\n\nIf you want a completely free mobile backend, search for the \nMobile\nApps Quickstart\n in the Azure Marketplace.  This template does not\nrequire a database.  It relies on a Node backend, however, so you won't\nbe developing a C# backend.\n\n\n\n\nDeploying the Azure Mobile Apps Backend\n\u00b6\n\n\nDeploying to Azure as a developer can be accomplished while entirely within\nVisual Studio:\n\n\n\n\nRight-click on the \nBackend\n project, then select \nPublish...\n.\n\n\n\n\nMake sure you see this screen shot:\n\n\n\n\nIf you do not see this image, then it is likely you have an older version\nof the Azure SDK installed.  Make sure the Azure SDK version is v2.9 or\nlater.\n\n\n\n\n\n\nClick on \nMicrosoft Azure App Service\n.\n\n\n\n\nYou may be prompted to enter your Azure credentials here.  Enter the same\n    information that you enter to access the Azure Portal.\n\n\nIn the lower box, expand the resource group that you created and select the\n    app service you created in the portal.\n\n\nClick on \nOK\n.\n\n\nClick on \nPublish\n.\n\n\n\n\nVisual Studio will open a browser.  Add \n/tables/todoitem?ZUMO-API-VERSION=2.0.0\n\nto the end of the URL.  This will show the JSON contents of the table that we\ndefined in the backend.\n\n\n\n\nYou will see the word ZUMO all over the SDK, including in optional HTTP headers\nand throughout the SDK source code.  ZUMO was the original code name within Microsoft\nfor A\nZU\nre \nMO\nbile.\n\n\n\n\nThe Mobile Client\n\u00b6\n\n\nNow that the mobile backend is created and deployed, we can move onto the client\nside of things.  First of all, let's prepare the Visual Studio instance.  If you\nhave installed the Cross-Platform Mobile tools during the installation, most of\nthe work has already been done.  However, you may want to install the \nXamarin\nForms Templates\n using the Tools -> Extensions and Updates...\n\n\n\n\nThis template pack provides additional templates for Xamarin Forms development\nthat I find useful.  Most notably, there is a specific template for a mobile\ncross-platform project covering the Android, iOS and UWP mobile platforms.\n\n\n\n\nWhen you compile a Xamarin.Forms application for a specific platform, you are\nproducing a true native application for that platform - whether it be iOS,\nAndroid or Windows.\n\n\n\n\nCreating a Simple Mobile Client with Xamarin\n\u00b6\n\n\nNow that we have prepared your Visual Studio instance, we can create the\nproject. Right-click on the solution and select \nAdd\n -> \nNew Project...\n.\nThis will bring up the familiar New Project dialog.  The project you want is\nunder \nVisual C#\n -> \nCross-Platform\n, and is called \nXamarin.Forms\n(UWP/Android/iOS)\n.  If you did not install the Xamarin Forms Template add-on,\nthen choose the \nBlank Xaml App (Xamarin.Forms Portable)\n project.  Give the\nproject a name, then click on \nOK\n.\n\n\n\n\n\n\nIf you did not install the Xamarin Forms Templates, then you can create a\n\nBlank Xaml App (Xamarin.Forms Portable)\n project instead.\n\n\n\n\nProject creation will take longer than you expect, but there is a lot going on.\nIf you have never created a mobile or UWP project before, you will be prompted\nto turn on Windows 10 Developer Mode:\n\n\n\n\nDeveloper mode in Windows 10 allows you to run unsigned binaries for development\npurposes and to turn on debugging so that you can step through your UWP programs\nwithin Visual Studio.\n\n\nWe will also get asked to choose what version of the Universal Windows platform\nwe want to target:\n\n\n\n\nVersion 10240 was the first version of Windows 10 that was released to the general\npublic, so that's a good minimum version to pick.  In general, the defaults for\nthe Universal Windows Platform choice are good enough.\n\n\nXamarin allows us to build iOS applications directly from Visual Studio. For\nthis to work, we must have access to a Mac. This could be anything from a\nMacBook Air/Pro, to a Mac Mini in a drawer or closet in the office, or maybe\neven a \nMac in the cloud\n.  The Xamarin tools use SSH to connect to the Mac,\nwhich must be \nconfigured to build iOS apps from Visual Studio\n.\n\n\n\n\nIf you don't have a Mac and are not interested in building iOS applications,\ndon't give up now!  You can cancel through the Mac specific project setup and\ncontinue with building a great Android and Universal Windows app.  You can\ndelete the iOS specific project after it has been created.\n\n\n\n\nWhen prompted about the Xamarin Mac Agent, click on \nOK\n to get the list of\nlocal mac agents:\n\n\n\n\nHighlight your mac (in case there are multiples), then click on \nConnect...\n.\nIf your mac is not listed or you are using a Mac in the cloud, then you can\nalways enter the IP address for your mac.\n\n\n\n\nFor more troubleshooting tips, visit  https://developer.xamarin.com/guides/ios/getting_started/installation/windows/connecting-to-mac/troubleshooting/\n\n\n\n\nYou will be prompted for your username and password:\n\n\n\n\nJust enter the username and password that you use to log in to your mac and click\non \nLogin\n.\n\n\n\n\nWhat's my username?\n  Apple tries very hard to hide the real username of\nyour account from you.  The easiest way to find your mac username is to open up\nthe Finder.  The name next to your home icon is the name of your account.\n\n\n\n\nIf the connection has successed, you will see a green icon in the Xamarin Visual\nStudio toolbar area. It may take a minute or two to connect and verify that the\nmac can be used.\n\n\nOnce the project is created, you will see that four new projects have been\ncreated: a common library which you named plus one project for each platform\nthat has been chosen.  Since we chose a project with three platforms, we get\nfour projects:\n\n\n\n\nMost of our work will happen in the common library.  However, we can introduce\nplatform-specific code at any point.  The platform-specific code is stored in\nthe platform-specific project.\n\n\nThere is one final item we must do before we leave the set up of the project.\nThere are a number of platform upgrades that inevitably have to happen.  The\nXamarin Platform is updated much more often than the Visual Studio plugin - the\nupdates are released via NuGet: the standard method of distributing libraries\nfor .NET applications.  In addition to the inevitable Xamarin Platform update,\nwe also will want to add the following NuGet packages:\n\n\n\n\nMicrosoft.Azure.Mobile.Client v2.0.0 or later\n\n\nNewtonsoft.Json v6.0.3 or later\n\n\n\n\n\n\nAlthough it is tempting, do not include a v1.x version of the Mobile Client.\nThis is for the earlier Azure Mobile Services.  There are many differences between\nthe wire protocols of the two products.\n\n\n\n\nYou can install the NuGet packages by right-clicking on the project and selecting\n\nManage NuGet Packages...\n.\n\n\n\n\nYou must install the updates and the new NuGet packages on all four projects.\nThis involves repeating the same process for each client project in your\nsolution.\n\n\n\n\nAndroid generally has more updates than the other platforms.  Ensure that you\nupdate the main Xamarin.Forms package and then refresh the update list.  This will\nensure the right list of packages is updated.\n\n\n\n\nBuilding the Common Library\n\u00b6\n\n\nThere are two parts that we must concentrate on within the common library.  The\nfirst is the connection to Azure Mobile Apps and the second is in the pages\nthat the user interacts with.  In both cases, there are best practices to observe.\n\n\nBuilding an Azure Mobile Apps Connection\n\u00b6\n\n\nWe will rely on interfaces for defining the shape for the class for any service\nthat we interact with.  This is really not important in small projects like this\none.  This technique allows us to mock the backend service, as we shall see\nlater on.  Mocking the backend service is a great technique to rapidly iterate\non the front end mobile client without getting tied into what the backend is doing.\n\n\nLet's start with the cloud service - this is defined in\n\nAbstractions\\ICloudService.cs\n.  It is basically used for initializing\nthe connection and getting a table definition:\n\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        public ICloudTable<T> GetTable<T>() where T : TableData;\n    }\n}\n\n\n\n\nThere is a dependent implementation here: the \nICloudTable\n generic interface.  This\nrepresents a CRUD interface into our tables and is defined in \nAbstractions\\ICloudTable.cs\n:\n\n\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudTable<T> where T : TableData\n    {\n        Task<T> CreateItemAsync(T item);\n        Task<T> ReadItemAsync(string id);\n        Task<T> UpdateItemAsync(T item);\n        Task DeleteItemAsync(T item);\n\n        Task<ICollection<T>> ReadAllItemsAsync() where T : TableData;\n    }\n}\n\n\n\n\nThe \nICloudTable<T>\n interface defines the normal CRUD operations: Create, Read,\nUpdate and Delete.  However, it does so asynchronously.  We are dealing with network\noperations in general so it is easy for those operations to tie up the UI thread\nfor an appreciable amount of time.  Making them async provides the ability to\nrespond to other events.  I also provide a \nReadAllItemsAsync()\n method that\nreturns a collection of all the items.\n\n\nThere are some fields that every single record within an Azure Mobile Apps table\nprovides.  These fields are required for offline sync capabilities like incremental\nsync and conflict resolution.  The fields are provided by an abstract base class\non the client called \nTableData\n:\n\n\nusing System;\n\nnamespace TaskList.Abstractions\n{\n    public abstract class TableData\n    {\n        public string Id { get; set; }\n        public DateTimeOffset? UpdatedAt { get; set; }\n        public DateTimeOffset? CreatedAt { get; set; }\n        public byte[] Version { get; set; }\n    }\n}\n\n\n\n\nAs we will learn when we deal with \ntable data\n, these fields need to\nbe defined with the same name and semantics as on the server.  Our model on\nthe server was sub-classed from \nEntityData\n and the \nEntityData\n class on the\nserver defines these fields.\n\n\nIt's tempting to call the client version of the class the same as the server\nversion.  If we did that, the models on both the client and server would look\nthe same.  However, I find that this confuses the issue.  The models on the\nclient and server are not the same.  They are missing the \nDeleted\n flag and\nthey do not contain any relationship information on the client.  I choose to\ndeliberately call the base class something else on the client to avoid this\nconfusion.\n\n\nWe will be adding to these interfaces in future chapters as we add more\ncapabilities to the application.\n\n\nThe concrete implementations of these classes are similarly easily defined.  The\nAzure Mobile Apps Client SDK does most of the work for us.  Here is the concrete\nimplementation of the \nICloudService\n (in \nServices\\AzureCloudService.cs\n):\n\n\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(\"https://my-backend.azurewebsites.net\");\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData\n        {\n            return new AzureCloudTable<T>(client);\n        }\n    }\n}\n\n\n\n\nThe Azure Mobile Apps Client SDK takes a lot of the pain out of communicating\nwith the mobile backend that we have already published.  Just swap out the\nname of your mobile backend and the rest is silently dealt with.\n\n\n\n\nThe name \nMicrosoft.WindowsAzure.MobileServices\n is a hold-over from the old Azure\nMobile Services code-base.  Don't be fooled - clients for Azure Mobile Services are\nnot interchangeable with clients for Azure Mobile Apps.\n\n\n\n\nWe also need a concrete implementation of the \nICloudTable<T>\n interface (in \nServices\\AzureCloudTable.cs\n):\n\n\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudTable<T> : ICloudTable<T> where T : TableData\n    {\n        MobileServiceClient client;\n        IMobileServiceTable<T> table;\n\n        public AzureCloudTable(MobileServiceClient client)\n        {\n            this.client = client;\n            this.table = client.GetTable<T>();\n        }\n\n        #region ICloudTable implementation\n        public async Task<T> CreateItemAsync(T item)\n        {\n            await table.InsertAsync(item);\n            return item;\n        }\n\n        public async Task<T> DeleteItemAsync(T item)\n        {\n            await table.DeleteAsync(item);\n        }\n\n        public async Task<ICollection<T>> ReadAllItemsAsync()\n        {\n            return await table.ToListAsync();\n        }\n\n        public async Task<T> ReadItemAsync(string id)\n        {\n            return await table.LookupAsync(id);\n        }\n\n        public async Task<T> UpdateItemAsync(T item)\n        {\n          await table.UpdateAsync(item);\n          return item;\n        }\n        #endregion\n    }\n}\n\n\n\n\nIt's important to note here that the Azure Mobile Apps Client SDK does a lot of\nthe work for us.  In fact, we are just wrapping the basic interface here.  This\nwon't normally be the case, but you can see that the majority of the code for\ndealing with the remote server is done for us.\n\n\n\n\nYou can use a shorthand (called a lambda expression) for methods with only one line.\nFor instance, the delete method could just as easily have been written as \npublic async Task<T> DeleteItemAsync(T item) => await table.DeleteAsync(item);\n.\nYou may see this sort of short hand in samples.\n\n\n\n\nWe also need to create the model that we will use for the data.  This should\nlook very similar to the model on the server - including having the same name\nand fields.  In this case, it's \nModels\\TodoItem.cs\n:\n\n\nusing TaskList.Abstractions\n\nnamespace TaskList.Models\n{\n    public class TodoItem : TableData\n    {\n        public string Text { get; set; }\n        public bool Complete { get; set; }\n    }\n}\n\n\n\n\nWe have a final piece of code to write before we move on to the views, but it's\nan important piece.  The \nICloudService\n must be a singleton in the client.  We\nwill add authentication and offline sync capabilities in future versions of this\ncode.  The singleton becomes critical when using those features.  For right now,\nit's good practice and saves on memory if you only have one copy of the \nICloudService\n\nin your mobile client.  Since there is only one copy of the \nApp.cs\n in any\ngiven app, I can place it there.  Ideally, I'd use some sort of dependency\ninjection system or a singleton manager to deal with this.  Here is the \nApp.cs\n:\n\n\nusing TaskList.Abstractions;\nusing TaskList.Services;\nusing Xamarin.Forms;\n\nnamespace TaskList\n{\n    public class App : Application\n    {\n        public static ICloudService CloudService { get; set; }\n\n        public App()\n        {\n            CloudService = new AzureCloudService();\n            MainPage = new NavigationPage(new Pages.EntryPage());\n        }\n\n        // There are lifecycle methods here...\n    }\n}\n\n\n\n\nWe haven't written \nPages.EntryPage\n yet, but that's coming.  The original \nApp.cs\n\nclass file had several methods for handling lifecycle events like starting, suspending\nor resuming the app.  I did not touch those methods for this example.\n\n\nBuilding the UI for the App\n\u00b6\n\n\nEarlier, I showed the mockup for my UI.  It included three pages - an entry\npage, a list page and a detail page.  These pages have three elements - a\nXAML definition file, a (simple) code-behind file and a view model.\n\n\n\n\nThis book is not intending to introduce you to everything that there is to know\nabout Xamarin and UI programming with XAML.  If you wish to have that sort of introduction,\nthen I recommend reading the excellent book by Charles Petzold: \nCreating Mobile Apps with Xamarin.Forms\n.\n\n\n\n\nI tend to use MVVM (or Model-View-ViewModel) for UI development in Xamarin\nbased applications.  It's a nice clean pattern and is well understood and\ndocumented.  In MVVM, there is a 1:1 correlation between the view and the\nview-model, 2-way communication between the view and the view-model and\nproperties within the view-model are bound directly to UI elements.  In\ngeneral (and in all my code), view-models expose an INotifyPropertyChanged\nevent to tell the UI that something within the view-model has been changed.\n\n\nTo do this, we will use a \nBaseViewModel\n class that implements the base functionality\nfor each view.  Aside from the \nINotifyPropertyChanged\n interface, there are\nsome common properties we need for each page.  Each page needs a title, for\nexample, and each page needs an indicator of network activity.  These can be\nplaced in the \nAbstractions\\BaseViewModel.cs\n class:\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\n\nnamespace TaskList.Abstractions\n{\n    public class BaseViewModel : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n        string _propTitle = string.Empty;\n        bool _propIsBusy;\n\n        public string Title\n        {\n            get { return _propTitle; }\n            set { SetProperty(ref _propTitle, value, \"Title\"); }\n        }\n\n        public bool IsBusy\n        {\n            get { return _propIsBusy; }\n            set { SetProperty(ref _propIsBusy, value, \"IsBusy\"); }\n        }\n\n        protected void SetProperty<T>(ref T store, T value, string propName, Action onChanged = null)\n        {\n            if (EqualityComparer<T>.Default.Equals(store, value))\n                return;\n            store = value;\n            if (onChanged != null)\n                onChanged();\n            OnPropertyChanged(propName);\n        }\n\n        public void OnPropertyChanged(string propName)\n        {\n            if (PropertyChanged == null)\n                return;\n            PropertyChanged(this, new PropertyChangedEventArgs(propName));\n        }\n    }\n}\n\n\n\n\nThis is a fairly common \nINotifyPropertyChanged\n interface implementation pattern.\nEach property that we want to expose is a standard property, but the \nset\n operation\nis replaced by the \nSetProperty()\n call.  The \nSetProperty()\n call deals with the\nnotification; calling the event emitter if the property has changed value.  We\nonly need two properties on the \nBaseViewModel\n: the title and the network indicator.\n\n\nI tend to write my apps in two stages.  I concentrate on the functionality of the\napp in the first stage.  There is no fancy graphics, custom UI widgets, or anything\nelse to clutter the thinking.   The page is all about the functionality of the\nvarious interactions.  Once I have the functionality working, I work on the styling\nof the page.  We won't be doing any styling work in the demonstration apps that we\nwrite during the course of this book.\n\n\nThe EntryPage has just one thing to do.  It provides a button that enters the app.\nWhen we cover authentication later on, we'll use this to log in to the backend.  If\nyou are looking at the perfect app, this is a great place to put the introductory\nscreen.\n\n\nCreating a XAML file is relatively simple.  First, create a \nPages\n directory to\nhold the pages of our application.  Then right-click on the \nPages\n directory in\nthe solution explorer and choose \nAdd\n -> \nNew Item...\n.  In the \nAdd New Item\n\ndialog, pick \nVisual C#\n -> \nCross-Platform\n -> \nForms Xaml Page\n.  Name the\nnew page \nEntryPage.cs\n.  This will create two files - \nEntryPage.xaml\n and\n\nEntryPage.xaml.cs\n.  Let's center a button on the page and wire it up with\na command.  Here is the \nPages\\EntryPage.xaml\n file:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.EntryPage\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <StackLayout HorizontalOptions=\"Center\"\n                     Orientation=\"Vertical\"\n                     VerticalOptions=\"Center\">\n            <Button BackgroundColor=\"Teal\"\n                    BorderRadius=\"10\"\n                    Command=\"{Binding LoginCommand}\"\n                    Text=\"Login\"\n                    TextColor=\"White\" />\n        </StackLayout>\n    </ContentPage.Content>\n</ContentPage>\n\n\n\n\nThere are a couple of interesting things to note here.  The \nStackLayout\n element\nis our layout element.  It occupies the entire screen (since it is a direct child\nof the content page) and the options just center whatever the contents are.  The\nonly contents are a button.\n\n\nThere are two bindings.  These are bound from the view-model.  We've already seen\nthe Title property - this is a text field that specifies the title of the page.\nThe other binding is a login command.  When the button is tapped, the login command\nwill be run.  We'll get onto that in the view-model later.\n\n\nThe other part of the XAML is the code-behind file.  Because we are moving all\nof the non-UI code into a view-model, the code-behind file is trivial:\n\n\nusing TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class EntryPage : ContentPage\n    {\n        public EntryPage()\n        {\n            InitializeComponent();\n            BindingContext = new EntryPageViewModel();\n        }\n    }\n}\n\n\n\n\nThis is a recipe that will be repeated over and over again for the code-behind\nwhen you are using a XAML-based project with MVVM.  We initialize the UI, then\nbind all the bindings to a new instantiation of the view model.\n\n\nTalking of which, the view-model needs just to handle the login click.  Note that\nthe location or namespace is \nTaskList.ViewModels\n.  I'm of two minds about location.\nThere tends to be a 1:1 relationship between the XAML file and the View Model, so\nit makes sense that they are stored together.  However, just about all the sample\ncode that I see has the view-models in a separate namespace.  Which one is correct?\nI'll go with copying the samples for now.  Here is the code for \nViewModels\\EntryPageViewModel.cs\n:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class EntryPageViewModel : BaseViewModel\n    {\n        public EntryPageViewModel()\n        {\n            Title = \"Task List\";\n        }\n\n        Command loginCmd;\n        public Command LoginCommand => loginCmd ?? (loginCmd = new Command(async () => await ExecuteLoginCommand()));\n\n        async Task ExecuteLoginCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[Login] Error = {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}\n\n\n\n\nThis is a fairly simple view-model but there are some patterns here that are\nworth explaining.  Firstly, note the way we create the \nLoginCommand\n property.\nThis is the property that is bound to the \nCommand\n parameter in the \nButton\n\nof our view.  This recipe is the method of invoking a UI action asynchronously.\nIt isn't important now, but we will want this technique repeatedly as our UI\nactions kick off network activity.\n\n\nThe second is the pattern for the \nExecuteLoginCommand\n method.  Firstly, I\nensure nothing else is happening by checking the IsBusy flag.   If nothing\nis happening, I set the IsBusy flag.  Then I do what I need to do in a try/catch\nblock.  If an exception is thrown, I deal with it.  Most of the time this\ninvolves displaying an error condition.  There are several cross-platform dialog\npackages to choose from or you can roll your own.  That is not covered here.  We\njust write a debug log statement so we can see the result in the debug log.  Once\neverything is done, we clear the IsBusy flag.\n\n\nThe only thing we are doing now is swapping out our main page for a new main\npage.  This is where we will attach authentication later on.\n\n\nThe next page is the Task List page, which is in \nPages\\TaskList.xaml\n:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.TaskList\"\n             Title=\"{Binding Title}\">\n  <ContentPage.Content>\n    <StackLayout>\n      <ListView BackgroundColor=\"#7F7F7F\"\n                CachingStrategy=\"RecycleElement\"\n                IsPullToRefreshEnabled=\"True\"\n                IsRefreshing=\"{Binding IsBusy, Mode=OneWay}\"\n                ItemsSource=\"{Binding Items}\"\n                RefreshCommand=\"{Binding RefreshCommand}\"\n                RowHeight=\"50\"\n                SelectedItem=\"{Binding SelectedItem, Mode=TwoWay}\">\n        <ListView.ItemTemplate>\n          <DataTemplate>\n            <ViewCell>\n              <StackLayout HorizontalOptions=\"FillAndExpand\"\n                           Orientation=\"Horizontal\"\n                           Padding=\"10\"\n                           VerticalOptions=\"CenterAndExpand\">\n                <Label HorizontalOptions=\"FillAndExpand\"\n                       Text=\"{Binding Text}\"\n                       TextColor=\"#272832\" />\n                <Switch IsToggled=\"{Binding Complete, Mode=OneWay}\" />\n              </StackLayout>\n            </ViewCell>\n          </DataTemplate>\n        </ListView.ItemTemplate>\n      </ListView>\n      <StackLayout HorizontalOptions=\"Center\"\n                   Orientation=\"Horizontal\">\n        <Button BackgroundColor=\"Teal\"\n                Command=\"{Binding AddNewItemCommand}\"\n                Text=\"Add New Item\"\n                TextColor=\"White\" />\n      </StackLayout>\n    </StackLayout>\n  </ContentPage.Content>\n</ContentPage>\n\n\n\n\nNote that some bindings here are one-way.  This means that the value in the\nview-model drives the value in the UI.  There is nothing within the UI that you\ncan do to alter the state of the underlying property.  Some bindings are two-way.\nDoing something in the UI (for example, toggling the switch) alters the underlying\nproperty.\n\n\nThis view is a little more complex.  It can be split into two parts - the list\nat the top of the page and the button area at the bottom of the page.  The list\narea uses a template to help with the display of each item.\n\n\nNote that the \nListView\n object has a \"pull-to-refresh\" option that I have wired\nup so that when pulled, it calls the RefreshCommand.  It also has an indicator\nthat I have wired up to the IsBusy indicator.  Anyone who is familiar with the\niOS \"pull-to-refresh\" gesture can probably guess what this does.\n\n\nThere is a view-model that goes along with the view (in \nViewModels\\TaskListViewModel.cs\n):\n\n\nusing System;\nusing System.Collections.ObjectModel;\nusing System.Collections.Specialized;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskListViewModel : BaseViewModel\n    {\n        public TaskListViewModel()\n        {\n            Title = \"Task List\";\n            RefreshList();\n        }\n\n        ObservableCollection<TodoItem> items = new ObservableCollection<TodoItem>();\n        public ObservableCollection<TodoItem> Items\n        {\n            get { return items; }\n            set { SetProperty(ref items, value, \"Items\"); }\n        }\n\n        TodoItem selectedItem;\n        public TodoItem SelectedItem\n        {\n            get { return selectedItem; }\n            set\n            {\n                SetProperty(ref selectedItem, value, \"SelectedItem\");\n                if (selectedItem != null)\n                {\n                    Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail(selectedItem));\n                    SelectedItem = null;\n                }\n            }\n        }\n\n        Command refreshCmd;\n        public Command RefreshCommand => refreshCmd ?? (refreshCmd = new Command(async () => await ExecuteRefreshCommand()));\n\n        async Task ExecuteRefreshCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                var table = App.CloudService.GetTable<TodoItem>();\n                var list = await table.ReadAllItemsAsync();\n                Items.Clear();\n                foreach (var item in list)\n                    Items.Add(item);\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskList] Error loading items: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command addNewCmd;\n        public Command AddNewItemCommand => addNewCmd ?? (addNewCmd = new Command(async () => await ExecuteAddNewItemCommand()));\n\n        async Task ExecuteAddNewItemCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                await Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskList] Error in AddNewItem: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        async Task RefreshList()\n        {\n            await ExecuteRefreshCommand();\n            MessagingCenter.Subscribe<TaskDetailViewModel>(this, \"ItemsChanged\", async (sender) =>\n            {\n                await ExecuteRefreshCommand();\n            });\n        }\n    }\n}\n\n\n\n\nThis is a combination of the patterns we have seen earlier.  The Add New Item\nand Refresh commands should be fairly normal patterns now.  We navigate to the\ndetail page (more on that later) in the case of selecting an item (which occurs\nwhen the UI sets the \nSelectedItem\n property through a two-way binding) and when\nthe user clicks on the Add New Item button.  When the Refresh button is clicked\n(or when the user opens the view for the first time), the list is refreshed.  It\nis fairly common to use an \nObservableCollection\n or another class that uses the\n\nICollectionChanged\n event handler for the list storage.  Doing so allows the UI\nto react to changes in the items.\n\n\nNote the use of the \nICloudTable\n interface here.  We are using the \nReadAllItemsAsync()\n\nmethod to get a list of items, then we copy the items we received into the \nObservableCollection\n.\n\n\nFinally, there is the TaskDetail page.  This is defined in the \nPages\\TaskDetail.xaml\n\nfile:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.TaskDetail\"\n             Title=\"{Binding Title}\">\n  <ContentPage.Content>\n    <StackLayout Padding=\"10\" Spacing=\"10\">\n      <Label Text=\"What should I be doing?\"/>\n      <Entry Text=\"{Binding Item.Text}\"/>\n      <Label Text=\"Completed?\"/>\n      <Switch IsToggled=\"{Binding Item.Complete}\"/>\n      <StackLayout VerticalOptions=\"CenterAndExpand\"/>\n      <StackLayout Orientation=\"Vertical\" VerticalOptions=\"End\">\n        <StackLayout HorizontalOptions=\"Center\" Orientation=\"Horizontal\">\n          <Button BackgroundColor=\"#A6E55E\"\n                  Command=\"{Binding SaveCommand}\"\n                  Text=\"Save\" TextColor=\"White\"/>\n          <Button BackgroundColor=\"Red\"\n                  Command=\"{Binding DeleteCommand}\"\n                  Text=\"Delete\" TextColor=\"White\"/>\n        </StackLayout>\n      </StackLayout>\n    </StackLayout>\n  </ContentPage.Content>\n</ContentPage>\n\n\n\n\nThis page is a simple form with just two buttons that need to have commands\nwired up.  However, this page is used for both the \"Add New Item\" gesture\nand the \"Edit Item\" gesture.  As a result of this, we need to handle the\npassing of the item to be edited.  This is done in the \nPages\\TaskDetail.xaml.cs\n\ncode-behind file:\n\n\nusing TaskList.Models;\nusing TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class TaskDetail : ContentPage\n    {\n        public TaskDetail(TodoItem item = null)\n        {\n            InitializeComponent();\n            BindingContext = new TaskDetailViewModel(item);\n        }\n    }\n}\n\n\n\n\nThe item that is passed in from the \nTaskList\n page is used to create a\nspecific view-model for that item.  The view-model is similarly configured\nto use that item:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskDetailViewModel : BaseViewModel\n    {\n        ICloudTable<TodoItem> table = App.CloudService.GetTable<TodoItem>();\n\n        public TaskDetailViewModel(TodoItem item = null)\n        {\n            if (item != null)\n            {\n                Item = item;\n                Title = item.Text;\n            }\n            else\n            {\n                Item = new TodoItem { Text = \"New Item\", Complete = false };\n                Title = \"New Item\";\n            }\n        }\n\n        public TodoItem Item { get; set; }\n\n        Command cmdSave;\n        public Command SaveCommand => cmdSave ?? (cmdSave = new Command(async () => await ExecuteSaveCommand()));\n\n        async Task ExecuteSaveCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id == null)\n                {\n                    await table.CreateItemAsync(Item);\n                }\n                else\n                {\n                    await table.UpdateItemAsync(Item);\n                }\n                MessagingCenter.Send<TaskDetailViewModel>(this, \"ItemsChanged\");\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskDetail] Save error: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command cmdDelete;\n        public Command DeleteCommand => cmdDelete ?? (cmdDelete = new Command(async () => await ExecuteDeleteCommand()));\n\n        async Task ExecuteDeleteCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id != null)\n                {\n                    await table.DeleteItemAsync(Item);\n                }\n                MessagingCenter.Send<TaskDetailViewModel>(this, \"ItemsChanged\");\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskDetail] Save error: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}\n\n\n\n\nThe save command uses the \nICloudTable\n interface again - this time doing\neither \nCreateItemAsync()\n or \nUpdateItemAsync()\n to create or update the\nitem.  The delete command, as you would expect, deletes the item with the\n\nDeleteItemAsync()\n method.\n\n\nThe final thing to note from our views is that I am using the \nMessagingCenter\n\nto communicate between the TaskDetail and TaskList views.  If I change the item\nin the \nTaskDetail\n list, then I want to update the list in the \nTaskList\n view.\n\n\nNote that all the code we have added to the solution thus far is in the common\n\nTaskList\n project.  Nothing is required for this simple example in a platform\nspecific project.  That isn't normal, as we shall see.\n\n\nBuilding the Client for Universal Windows\n\u00b6\n\n\nI tend to start by building the Universal Windows mobile client.  I'm using\nVisual Studio, after all, and I don't need to use any emulator.  To build the\nclients:\n\n\n\n\nRight-click on the \nTaskList.UWP (Universal Windows)\n project, then select \nSet as StartUp Project\n.\n\n\nRight-click on the \nTaskList.UWP (Universal Windows)\n project again, then select \nBuild\n.\n\n\nOnce the build is complete, Right-click on the \nTaskList.UWP (Universal Windows)\n project again, then select \nDeploy\n.\n\n\nClick on the \nLocal Machine\n button in your command bar to run the application.\n\n\n\n\nHere are the three screen screens we generated on Windows:\n\n\n\n\nThere are some problems with the UWP version.  Most notably, the \"pull-to-refresh\"\ngesture does not exist, so we will need to set up an alternate gesture.  This\ncould be as easy as adding a refresh button right next to the Add New Item\nbutton.  In addition, there is no indication of network activity - this manifests\nas a significant delay between the TaskList page appearing and the data appearing\nin the list.\n\n\nAside from this, I did do some styling work to ensure that the final version\nlooked like my mock-ups (with the exception of the UI form of the switch, which\nis platform dependent).  If you want to see what I did to correct this, check out\nthe final version of \nthe Chapter 1 sample\n on GitHub.\n\n\nIf you need to build the project, ensure you redeploy the project after building.\nIt's a step that is easy to miss and can cause some consternation as you change\nthe code and it doesn't seem to have an effect on the application.\n\n\nBuilding the Client for Android\n\u00b6\n\n\nBuilding Android with Visual Studio is as easy as building the Universal Windows\nversion of the mobile client:\n\n\n\n\nRight-click on the \nTaskList.Droid\n project, then select \nSet as StartUp Project\n.\n\n\nRight-click on the \nTaskList.Droid\n project again, then select \nBuild\n.\n\n\n\n\nThe button for running the application has a drop-down that is now significant.\nIt lets you choose the type of device that you will use.  Normally, this runs\neither a 5\" or 7\" KitKat-based Android device.  There is some setup required for\nthe Visual Studio Emulator for Android.  The Visual Studio Emulator for Android\nruns within Hyper-V, so you must install Hyper-V before use.  You get the following\nerror if you don't do this:\n\n\n\n\nTo install Hyper-V:\n\n\n\n\nClose all applications (your system will be rebooted during this process).\n\n\nSearch for \nPrograms and Features\n.\n\n\nClick on \nTurn Windows features on or off\n (in the left-hand menu).\n\n\nExpand the \nHyper-V\n node.\n\n\nCheck all the boxes below the \nHyper-V\n node.  This will include Hyper-V Management Tools and Hyper-V Services.\n\n\nClick on \nOK\n.\n\n\nYour system will install the required pieces and then ask you to restart.  Click on \nRestart now\n when prompted.\n\n\n\n\nOnce you have done this, the next hurdle is to be added to the Hyper-V Administrators\nsecurity group.  It gets done for you (again - the first time you try to run the\napplication after installing Hyper-V).  Once it is done, close Visual Studio (again),\nthe log out and back in again.\n\n\nAs if that wasn't enough, the emulator also needs an Internet connection to\nstart.\n\n\n\n\nYou should be able to just click on \nYes\n or \nOK\n to enable the Internet\nconnection.  My laptop required a reboot before this would work, however.  In\naddition, the process may request elevated privileges.\n\n\n\n\nIf you want to run additional Android profiles before starting, run the \nVisual Studio Emulator for Android\n and download any additional profiles.  For example, if you wish to emulate something similar to a Samsung Galaxy S6, then download the profile for a 5.1\" Marshmallow (6.0.0) XXHDPI Phone.\n\n\n\n\nFinally the Visual Studio Emulator for Android starts when you click on the Run\nbutton.  Fortunately, the setup of the emulator only has to be done once per\nmachine.  The Visual Studio Emulator for Android is also a superior emulator\nto the standard Android Emulator, so this process is well worth going through.\n\n\n\n\nWhen testing the mobile client manually through the Visual Studio Emulator for Android, you are likely to need to rebuild the application.  You do not have to shut down the emulator between runs.  You can leave it running.  The application will be stopped and replaced before starting again.  This can significantly speed up the debug cycle since you are not waiting for the emulator to start each time.\n\n\n\n\nWatch the Output window.  If the debugger won't connect or the application\nwon't start, you may need to restart your computer again to get the network\nworking.\n\n\n\n\nIf your computer doesn't run Hyper-V well (or at all), then the emulator won't run well (or at all) either.  I find laptops to be particularly prone to this problem.  If this happens, you can always run the Google Emulator instead.  Build the application as normal.  You will find the APK file to install in \n...\\TaskList.Droid\\bin\\Debug\n. Fortunately, there are lots of resources that show how to do this.  You can find the answer on \nStack Overflow\n\n\n\n\nIf everything is working, you should see the Visual Studio Emulator for Android\ndisplay your mobile client:\n\n\n\n\n\n\nYou can also build the Android version on a mac with Xamarin Studio.  However, I find that version mismatches between Mono (which is used on the mac) and Visual Studio - particularly in reference to the version of the .NET framework - cause issues when swapping between the two environments.  For best results, stay in one environment.\n\n\n\n\nNote that the task list view is a \"light\" style and the rest of the app is a\n\"dark\" style.  This is because the default styling on an Android device is\ndark.  We are using the default styling on two of the pages and specifying\ncolors on the list page.  Fortunately, Xamarin Forms allows for \nplatform-specific\nstyling\n.  The \nfinal sample\n has platform-specific styling for the\nlist page.\n\n\nBuilding the Client for iOS\n\u00b6\n\n\nFinally, we get to the iOS platform.  You will need to ensure your Mac is turned\non and accessible, that it has XCode installed (and you have run XCode once so\nthat you can accept the license agreement), and it has Xamarin Studio installed.\n\n\nWhen you created the projects, you were asked to link Visual Studio to your mac.\nThis linkage is used for building the project.  In essence, the entire project\nis sent to the Mac and the build tools that are supplied with Xamarin Studio\nwill be used to build the project.\n\n\n\n\nRight-click on the \nTaskList.iOS\n project and select \nSet as StartUp Project\n.\n\n\nRight-click on the \nTaskList.iOS\n project and select \nBuild\n.\n\n\n\n\nYou knew it was not going to be that easy, right?  Here are the errors that I\nreceived when building for the first time:\n\n\n\n\nThere are two errors right at the top.  Let's cover the first one.  The error\nabout \nBuild Action 'EmbeddedResource' is not supported\n is an annoying one.\nThe fix is to do the following:\n\n\n\n\nSet the iOS project as the StartUp project.\n\n\nGo through each project, expand the \nReferences\n node and ensure that there are no references with a warning (a little yellow triangle).  If there are - fix those first.  Generally, this is fixed by either using the \nRestore NuGet Packages\n option or removing the reference and then adding it again from NuGet.\n\n\nClose the solution.\n\n\nRe-open the solution.  You don't need to close Visual Studio to do this.\n\n\nRight-click on the iOS project and select \nClean\n.\n\n\nRight-click on the iOS project and select \nRebuild\n.\n\n\n\n\nOnce you have done this sequence, the error should go away.\n\n\nThe error about \nNo valid iOS code signing keys found in keychain\n is because\nwe have not yet signed up for an Apple Developer Account and linked it to our\nMac development environment.\n\n\n\n\nGo to the \nApple Developer Center\n.\n\n\nClick on \nAccount\n in the top navigation bar.\n\n\nIf you haven't got an Apple ID yet, create one first.\n\n\nIf you have go an Apple ID, then log in.\n\n\n\n\nThere are a sequence of sign-up prompts in both cases (first for creating your\nApple ID and secondly for signing up for the Apple Developer program).  Once\nyou have gone through this process, you are registered as an Apple Developer.\n\n\n\n\nIf you want to distribute your apps on the Apple App Store, run on real devices or get access to the beta bits, then you might consider signing up for the Apple Developer Program.  The Apple Developer Program is an additional cost and is not required for developing iOS apps that are only run on the iOS simulator.\n\n\n\n\nOnce you have created your account and enabled it as a developer account, open\nup XCode.  Go to \nPreferences...\n, then \nAccount\n and\nclick on the \n+\n in the bottom-left corner of the window:\n\n\n\n\nSign in with the same account you used to sign up for the developer account.\n\n\n\n\nClick on the \nView Details\n button.  This will bring up the Signing Identities\nlist.  For a free account, it looks like this:\n\n\n\n\nClick on the Create button next to \niOS Development\n.  Once the UI comes back,\nclick on \nDone\n.  For more information on this process, refer to the \nApple Documentation\n.\n\n\nYou can close XCode at this point.  Ensure Xamarin Studio is not running.  Back\nwithin Visual Studio, right-click on the \nTaskList.iOS\n project and select \nRebuild\n.\nThis will (finally!) build the application for you.\n\n\n\n\nGetting an error about \nProvisioning Profiles\n not being available?  This is because you are building for a real device instead of the simulator.  In order to build for a real device, you must have a linked Apple Developer Program.  To get around this, select a Simulator before building.\n\n\n\n\nThe \nRun\n button has received a \nDevice\n label, but there are several simulator options.\nYou should only use \nDevice\n if you have signed up for the Apple Developer Program.  Pick\none of the simulator options like the \niPhone 6 iOS 9.3\n simulator, then click on it\nto run the simulator.  Before long, you should see the following:\n\n\n\n\nAt some point, you will need a platform initialization call on all platforms.  It's best to\nadd it now.  In TaskList.Droid, this should be added in \nMainActivity.cs\n and in TaskList.iOS,\nit's \nAppDelegate.cs\n.  In each of these files, there is a line that initializes the Xamarin\nForms system.\n\n\n// Android Version\nglobal::Xamarin.Forms.Forms.Init(this, bundle);\n// iOS Version\nglobal::Xamarin.Forms.Forms.Init ();\n\n\n\n\nImmediately before this line, you should add the  initializer for Azure Mobile Apps. It's\nimportant that the Azure Mobile Apps subsystem is initialized prior to Xamarin Forms being\ninitialized and any UI code being called.\n\n\nMicrosoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n\n\n\nThis initializer is not required on the UWP project.  Once this is done and you have re-built\nthe project, we can see the fruits of our labor.  You can, of course, run the IPA in the\niOS simulator on the Mac.  However, it's much more satisfying (to me, at least) to be able\nto do everything from within Visual Studio.  For this, you need to install the\n\nXamarin Installer\n.  This is an MSI for your Windows development system and is\nquickly installed.  Once installed, start (or restart) Visual Studio, select \nTools\n ->\n\nOptions\n.  Search for \nXamarin\n, and select the \niOS Settings\n page.  There is\na new option:\n\n\n\n\nNote the \nRemote Simulator to Windows\n.  This should be checked.  You may need to\nrebuild the TaskList.iOS project after installing the Xamarin Simulator.  The debug\nwindow will tell you if this is the case.  There are also a few \nknown issues\n\nso check the documentation if you run into problems.\n\n\nThe final product screens look like this:\n\n\n\n\nSome Final Thoughts\n\u00b6\n\n\nIf you have got through the entire process outlined in this Chapter and built the application\nfor each platform, then congratulations.  There are a lot of places where things can go\nwrong.  You are really integrating the build systems across Visual Studio, Android, Xamarin,\nand XCode.\n\n\nFortunately, once these are set up, it's likely that they will continue working and you\nwon't have to think too much about them again. The Android and iOS build tools and simulators\nwill just work.\n\n\nIf you would rather develop code on your mac, the next chapter is for you - it gets into\nthe nitty gritty of developing the exact same app, but using Xamarin Studio instead.\n\n\nThe following 7 chapters each take one aspect of the cloud services that can be provided to\nmobile apps and explores it in detail, using an Azure Mobile App as a beginning. You can\njump around at this point, but be aware that we expect you to cover these topics in order.\nIf you do the data chapter before covering authentication, it's likely you will have missed\nimportant functionality in your app to complete the work.",
            "title": "Your First App - PC Edition"
        },
        {
            "location": "/chapter1/firstapp_pc/#your-first-mobile-app",
            "text": "There is a lot of detail to absorb about the possible services that the mobile\nclient can consume and I will go into significant depth on those subjects.\nFirst, wouldn't it be nice to write some code and get something working?\nMicrosoft Azure has a great  first-steps tutorial  that takes you via the\nquickest possible route from creating a mobile backend to having a functional\nbackend.  I would like to take things a little slower so that we can understand\nwhat is going on while we are doing the process.  We will have practically the\nsame application at the end.  The primary reason for going through this slowly\nis to ensure that all our build and run processes are set up properly.  If this\nis the first mobile app you have ever written, you will see that there are quite\na few things that need to be set up.  This chapter covers the set up required\nfor a Windows PC.  If you wish to develop your applications on a Mac, then skip\nto the  next section .  The application we are going to build together is a simple task list.  The\nmobile client will have three screens - an entry screen, a task list and a task\ndetails page.  I have mocked these pages up using  MockingBot .   Mocking your screens before you start coding is a great habit to get into.\nThere are some great tools available including free tools like  MockingBot .\nDoing mockups before you start coding is a good way to prevent wasted time later\non.     Why include a back button?  If you are using iOS, then you may want to remove\nthe back button as the style guides suggest you don't need one.  Other platforms\nwill need it though, so it's best to start with the least common denominator.\nIt's the same reason I add a refresh button even though it's only valid on\nWindows Phone!   My ideas for this app include:   Tapping on a task title in the task list will bring up the details page.  Toggling the completed link in the task list will set the completed flag.  Tapping the spinner will initiate a network refresh.   Now that we have our client screens planned out, we can move onto the thinking\nabout the mobile backend.",
            "title": "Your First Mobile App"
        },
        {
            "location": "/chapter1/firstapp_pc/#the-mobile-backend",
            "text": "The mobile backend is an ASP.NET WebApi that is served from within Azure App\nService: a highly scalable and redundant web hosting facility that supports all\nthe major web languages (like ASP.NET, Node, PHP and Python).  Azure Mobile\nApps is an SDK (which is available in ASP.NET and Node) that runs on top of\nAzure App Service.",
            "title": "The Mobile Backend"
        },
        {
            "location": "/chapter1/firstapp_pc/#creating-a-simple-azure-mobile-apps-backend",
            "text": "Microsoft Azure has included a comprehensive starter kit template in the\nAzure SDK.  To get started:   Fire up Visual Studio 2015  Add a new project with File -> New Project...   In the  New Project  window:   Open up Templates -> Visual C# -> Web and select  ASP.NET Web Application (.NET Framework) .  Enter  Backend  for the Name and  Chapter1  for the Solution name.  Pick a suitable directory for the Location field.  Click on OK.      In the  New ASP.NET Web Application  window:   Click on  Azure Mobile App .  Do  NOT  check \"Host in the cloud\" or any other checkboxes.  Click on OK.     At this point, Visual Studio will create your backend project.   It's very tempting to select  Azure Mobile Services  instead - it sounds\ncloser to what you want.  Azure Mobile Services is the  OLD  service and is\nbeing shut down.  You should not select Azure Mobile Services for any project.   There are a few files of which you should take note.  The Mobile Apps SDK is\ninitialized within  App_Start\\Startup.MobileApp.cs  (with the call to the\nconfiguration routine happening within  Startup.cs ).  The default startup\nroutine is reasonable but it hides what it is doing behind extension methods.\nThis technique is fairly common in ASP.NET programs.  Let's expand the\nconfiguration routine to only include what we need:  public static void ConfigureMobileApp(IAppBuilder app)\n{\n    var config = new HttpConfiguration();\n    var mobileConfig = new MobileAppConfiguration();\n\n    mobileConfig\n        .AddTablesWithEntityFramework()\n        .ApplyTo(config);\n\n    Database.SetInitializer(new MobileServiceInitializer());\n\n    app.UseWebApi(config);\n}  The minimal version of the mobile backend initialization is actually shorter\nthan the original.  It also only includes a data access layer.  Other services\nlike authentication, storage and push notifications are not configured.  There is another method in the  App_Start\\Startup.MobileApp.cs  file for\nseeding data into the database for us.  We can leave that alone for now, but\nremember it is there in case you need to seed data into a new database for\nyour own backend.   We refer to \"seeding data\" into a database.  This means that we are going to introduce some data into the database so that we aren't operating on an empty database.  The data will be there when we query the database later on.   The next important file is the  DbContext  - located in Models\\MobileServiceContext.cs . Azure Mobile Apps is heavily dependent on Entity Framework v6.x  and the  DbContext  is a central part of that\nlibrary.  Fortunately, we don't need to do anything to this file right now.  Finally, we get to the meat of the backend.  The whole point of this\ndemonstration is to project a single database table - the TodoItem table - into\nthe mobile realm with the aid of an opinionated  OData v3  feed.  To that\nend, we need three items:   A  DbSet<>  within the  DbContext  A Data Transfer Object (or DTO)  A Table Controller   When we create the project, a sample of each one of these for the TodoItem table\nis added for us.  You can see the  DbSet<>  in the  Models\\MobileServiceContext.cs \nfile, for example.  Let's take a look at the DTO and Table Controller for this\nexample table as well.  The DTO for the TodoItem table is located within the DataObjects  directory:  using Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.DataObjects\n{\n    public class TodoItem : EntityData\n    {\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n    }\n}  Note that the model uses  EntityData  as a base class.  The  EntityData  class\nadds five additional properties to the class - we'll discuss those in more\ndetails during the  Data Access and Offline Sync  chapter.  Finally, let's look at the table controller for the example TodoItem table.  This\nis located in  Controllers\\TodoItemController.cs :  using System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}  The  TableController  is the central processing for the database access layer.\nIt handles all the OData capabilities for us and exposes these as REST endpoints\nwithin our WebAPI.  This means that the actual code for this controller is tiny - just 12 lines of code.   OData  is a specification for accessing table data on the Internet.  It provides a mechanism for querying and manipulating data within a table.  Entity Framework is a common data access layer for ASP.NET applications.   We can build the project at this point.  If Visual Studio hasn't done so already,\nthe missing NuGet packages for Azure Mobile Apps will be downloaded.  There\nshould not be any errors.  If there are, check the typing for any changes you\nmade.   You can delete or ignore the  Controllers\\ValuesController.cs  file if you like - it isn't important for this walkthrough.",
            "title": "Creating a Simple Azure Mobile Apps Backend"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-an-azure-app-service-for-mobile-apps",
            "text": "The next step in the process is to build the resources on Azure that will\nrun your mobile backend.  Start by logging into the  Azure Portal , then\nfollow these instructions:   Click on the big  + New  button in the top-left corner.  Click on  Web + Mobile , then  Mobile App .   Enter a unique name in the  App name  box.   Since the name doesn't matter and it has to be unique, you can use  a\nGUID generator  to generate a unique name. GUIDs are not the best\nnames to use when you need to actually find resources, but using GUIDS\nprevents conflicts when deploying, so I prefer them as a naming scheme.\nYou can prefix the GUID  (example: chapter1-GUID) to aid in discovery\nlater on.  Generally, the first four digits of a GUID are enough to\nidentify individual resources.     If you have more than one subscription (for example, you have a trial\n   and an MSDN subscription), then ensure you select the right subscription\n   in the  Subscription  drop-down.    Select  Create new  under resource group and enter a name for this\n   mobile application.   Resource groups are great for grouping all the resources associated with a mobile application together.  During development, it means you can delete all the resources in one operation.  For production, it means you can see how much the service is costing you and how the resources are being used.     Finally, select or create a new  App Service Plan .   The App Service Plan is the thing that actually bills you - not the web or mobile backend.  You can run a number of web or mobile backends on the same App Service Plan.   I tend to create a new App Service Plan for each mobile application.  This\nis because the App Service Plan lives inside the Resource Group that you\ncreate.  The process for creating an App Service Plan is straight forward.\nYou have two decisions to make.  The first decision is where is the service\ngoing to run.  In a production environment, the correct choice is \"near your\ncustomers\".  \"Close to the developers\" is a good choice during development.\nUnfortunately, neither of those is an option you can actually choose in the\nportal, so you will have to translate into some sort of geographic location.\nWith 16 regions to choose from, you have a lot of choice.  The second decision you have to make is what to run the service on; also\nknown as the Pricing tier.   If you click on  View all , you will see you\nhave lots of choices.  F1 Free and D1 Shared, for example, run on shared\nresources and are CPU limited. You should avoid these as the service will\nstop responding when you are over the CPU quota.  That leaves Basic,\nStandard and Premium.  Basic has no automatic scaling and can run up to 3\ninstances - perfect for development tasks.  Standard and Premium both have\nautomatic scaling, automatic backups, and large amounts of storage; they\ndiffer in features: the number of sites or instances you can run on them,\nfor example.  Finally, there is a number after the plan.  This tells you how\nbig the virtual machine is that the plan is running on.  The numbers differ\nby number of cores and memory.  For our purposes, an F1 Free site is enough to run this small demonstration\nproject.  More complex development projects should use something in the\nBasic range of pricing plans.  Production apps should be set up in Standard\nor Premium pricing plans.    Once you have created your app service plan and saved it, click on  Create .    The creation of the service can take a couple of minutes.  You can monitor the\nprocess of deployment by clicking on the Notifications icon.  This is in the top\nbar on the right-hand side and looks like a Bell.  Clicking on a specific\nnotification will provide more information about the activity.  Once you have\ncreated your app service, the App Service blade will open.   What's the difference between a Web App, a Mobile App and an API App?  Not a\nlot.  The type determines which Quick start projects are available in the Quick\nstart menu under  All settings .  Since we selected a Mobile app, a set of\nstarter client projects for mobile devices will be presented.   We will also want a place to store our data.  This role is taken on by a\nSQL Azure instance.  We could link an existing database if we had one\ndefined.  However, we can also create a test database.   Creating a Test Database through the App Service Data Connections (as\nI describe here) allows you to create a free database.  This option is\nnot normally available through other SQL database creation flows.    Click on  Resource groups  in the left hand side menu.  Click on the resource group you created.  Click on the App Service your created.   Click on  All settings .   If you pinned your App Service to the dashboard, you can click on the\npinned App Service instead.  It will bring you to the same place.     Click on  Data connections  in the  MOBILE  menu.    Click on  Add .   In the  Type  box, select  SQL Database .  Click on the unconfigured  SQL Database  link:     In the  Database  blade, select  Create a new database .  Enter a name for the database (like  chapter1-db ).  Select a Pricing Tier (look for  F Free  at the bottom).  Click on the unconfigured  Server .     Enter a unique name for the server (a GUID is a good idea here).  Enter a username and password for the server.  Click on  OK  to close the  New Server  blade.  Click on  OK  to close the  New Database  blade.  Click on  OK  to close the  Add Data Connection  blade.     This produces another deployment step that creates a SQL Server and a SQL\ndatabase with your settings.  Once complete, the connection MS_TableConnectionString  will be listed in Data Connections blade.    If you want a completely free mobile backend, search for the  Mobile\nApps Quickstart  in the Azure Marketplace.  This template does not\nrequire a database.  It relies on a Node backend, however, so you won't\nbe developing a C# backend.",
            "title": "Building an Azure App Service for Mobile Apps"
        },
        {
            "location": "/chapter1/firstapp_pc/#deploying-the-azure-mobile-apps-backend",
            "text": "Deploying to Azure as a developer can be accomplished while entirely within\nVisual Studio:   Right-click on the  Backend  project, then select  Publish... .   Make sure you see this screen shot:   If you do not see this image, then it is likely you have an older version\nof the Azure SDK installed.  Make sure the Azure SDK version is v2.9 or\nlater.    Click on  Microsoft Azure App Service .   You may be prompted to enter your Azure credentials here.  Enter the same\n    information that you enter to access the Azure Portal.  In the lower box, expand the resource group that you created and select the\n    app service you created in the portal.  Click on  OK .  Click on  Publish .   Visual Studio will open a browser.  Add  /tables/todoitem?ZUMO-API-VERSION=2.0.0 \nto the end of the URL.  This will show the JSON contents of the table that we\ndefined in the backend.   You will see the word ZUMO all over the SDK, including in optional HTTP headers\nand throughout the SDK source code.  ZUMO was the original code name within Microsoft\nfor A ZU re  MO bile.",
            "title": "Deploying the Azure Mobile Apps Backend"
        },
        {
            "location": "/chapter1/firstapp_pc/#the-mobile-client",
            "text": "Now that the mobile backend is created and deployed, we can move onto the client\nside of things.  First of all, let's prepare the Visual Studio instance.  If you\nhave installed the Cross-Platform Mobile tools during the installation, most of\nthe work has already been done.  However, you may want to install the  Xamarin\nForms Templates  using the Tools -> Extensions and Updates...   This template pack provides additional templates for Xamarin Forms development\nthat I find useful.  Most notably, there is a specific template for a mobile\ncross-platform project covering the Android, iOS and UWP mobile platforms.   When you compile a Xamarin.Forms application for a specific platform, you are\nproducing a true native application for that platform - whether it be iOS,\nAndroid or Windows.",
            "title": "The Mobile Client"
        },
        {
            "location": "/chapter1/firstapp_pc/#creating-a-simple-mobile-client-with-xamarin",
            "text": "Now that we have prepared your Visual Studio instance, we can create the\nproject. Right-click on the solution and select  Add  ->  New Project... .\nThis will bring up the familiar New Project dialog.  The project you want is\nunder  Visual C#  ->  Cross-Platform , and is called  Xamarin.Forms\n(UWP/Android/iOS) .  If you did not install the Xamarin Forms Template add-on,\nthen choose the  Blank Xaml App (Xamarin.Forms Portable)  project.  Give the\nproject a name, then click on  OK .    If you did not install the Xamarin Forms Templates, then you can create a Blank Xaml App (Xamarin.Forms Portable)  project instead.   Project creation will take longer than you expect, but there is a lot going on.\nIf you have never created a mobile or UWP project before, you will be prompted\nto turn on Windows 10 Developer Mode:   Developer mode in Windows 10 allows you to run unsigned binaries for development\npurposes and to turn on debugging so that you can step through your UWP programs\nwithin Visual Studio.  We will also get asked to choose what version of the Universal Windows platform\nwe want to target:   Version 10240 was the first version of Windows 10 that was released to the general\npublic, so that's a good minimum version to pick.  In general, the defaults for\nthe Universal Windows Platform choice are good enough.  Xamarin allows us to build iOS applications directly from Visual Studio. For\nthis to work, we must have access to a Mac. This could be anything from a\nMacBook Air/Pro, to a Mac Mini in a drawer or closet in the office, or maybe\neven a  Mac in the cloud .  The Xamarin tools use SSH to connect to the Mac,\nwhich must be  configured to build iOS apps from Visual Studio .   If you don't have a Mac and are not interested in building iOS applications,\ndon't give up now!  You can cancel through the Mac specific project setup and\ncontinue with building a great Android and Universal Windows app.  You can\ndelete the iOS specific project after it has been created.   When prompted about the Xamarin Mac Agent, click on  OK  to get the list of\nlocal mac agents:   Highlight your mac (in case there are multiples), then click on  Connect... .\nIf your mac is not listed or you are using a Mac in the cloud, then you can\nalways enter the IP address for your mac.   For more troubleshooting tips, visit  https://developer.xamarin.com/guides/ios/getting_started/installation/windows/connecting-to-mac/troubleshooting/   You will be prompted for your username and password:   Just enter the username and password that you use to log in to your mac and click\non  Login .   What's my username?   Apple tries very hard to hide the real username of\nyour account from you.  The easiest way to find your mac username is to open up\nthe Finder.  The name next to your home icon is the name of your account.   If the connection has successed, you will see a green icon in the Xamarin Visual\nStudio toolbar area. It may take a minute or two to connect and verify that the\nmac can be used.  Once the project is created, you will see that four new projects have been\ncreated: a common library which you named plus one project for each platform\nthat has been chosen.  Since we chose a project with three platforms, we get\nfour projects:   Most of our work will happen in the common library.  However, we can introduce\nplatform-specific code at any point.  The platform-specific code is stored in\nthe platform-specific project.  There is one final item we must do before we leave the set up of the project.\nThere are a number of platform upgrades that inevitably have to happen.  The\nXamarin Platform is updated much more often than the Visual Studio plugin - the\nupdates are released via NuGet: the standard method of distributing libraries\nfor .NET applications.  In addition to the inevitable Xamarin Platform update,\nwe also will want to add the following NuGet packages:   Microsoft.Azure.Mobile.Client v2.0.0 or later  Newtonsoft.Json v6.0.3 or later    Although it is tempting, do not include a v1.x version of the Mobile Client.\nThis is for the earlier Azure Mobile Services.  There are many differences between\nthe wire protocols of the two products.   You can install the NuGet packages by right-clicking on the project and selecting Manage NuGet Packages... .   You must install the updates and the new NuGet packages on all four projects.\nThis involves repeating the same process for each client project in your\nsolution.   Android generally has more updates than the other platforms.  Ensure that you\nupdate the main Xamarin.Forms package and then refresh the update list.  This will\nensure the right list of packages is updated.",
            "title": "Creating a Simple Mobile Client with Xamarin"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-the-common-library",
            "text": "There are two parts that we must concentrate on within the common library.  The\nfirst is the connection to Azure Mobile Apps and the second is in the pages\nthat the user interacts with.  In both cases, there are best practices to observe.",
            "title": "Building the Common Library"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-an-azure-mobile-apps-connection",
            "text": "We will rely on interfaces for defining the shape for the class for any service\nthat we interact with.  This is really not important in small projects like this\none.  This technique allows us to mock the backend service, as we shall see\nlater on.  Mocking the backend service is a great technique to rapidly iterate\non the front end mobile client without getting tied into what the backend is doing.  Let's start with the cloud service - this is defined in Abstractions\\ICloudService.cs .  It is basically used for initializing\nthe connection and getting a table definition:  namespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        public ICloudTable<T> GetTable<T>() where T : TableData;\n    }\n}  There is a dependent implementation here: the  ICloudTable  generic interface.  This\nrepresents a CRUD interface into our tables and is defined in  Abstractions\\ICloudTable.cs :  using System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudTable<T> where T : TableData\n    {\n        Task<T> CreateItemAsync(T item);\n        Task<T> ReadItemAsync(string id);\n        Task<T> UpdateItemAsync(T item);\n        Task DeleteItemAsync(T item);\n\n        Task<ICollection<T>> ReadAllItemsAsync() where T : TableData;\n    }\n}  The  ICloudTable<T>  interface defines the normal CRUD operations: Create, Read,\nUpdate and Delete.  However, it does so asynchronously.  We are dealing with network\noperations in general so it is easy for those operations to tie up the UI thread\nfor an appreciable amount of time.  Making them async provides the ability to\nrespond to other events.  I also provide a  ReadAllItemsAsync()  method that\nreturns a collection of all the items.  There are some fields that every single record within an Azure Mobile Apps table\nprovides.  These fields are required for offline sync capabilities like incremental\nsync and conflict resolution.  The fields are provided by an abstract base class\non the client called  TableData :  using System;\n\nnamespace TaskList.Abstractions\n{\n    public abstract class TableData\n    {\n        public string Id { get; set; }\n        public DateTimeOffset? UpdatedAt { get; set; }\n        public DateTimeOffset? CreatedAt { get; set; }\n        public byte[] Version { get; set; }\n    }\n}  As we will learn when we deal with  table data , these fields need to\nbe defined with the same name and semantics as on the server.  Our model on\nthe server was sub-classed from  EntityData  and the  EntityData  class on the\nserver defines these fields.  It's tempting to call the client version of the class the same as the server\nversion.  If we did that, the models on both the client and server would look\nthe same.  However, I find that this confuses the issue.  The models on the\nclient and server are not the same.  They are missing the  Deleted  flag and\nthey do not contain any relationship information on the client.  I choose to\ndeliberately call the base class something else on the client to avoid this\nconfusion.  We will be adding to these interfaces in future chapters as we add more\ncapabilities to the application.  The concrete implementations of these classes are similarly easily defined.  The\nAzure Mobile Apps Client SDK does most of the work for us.  Here is the concrete\nimplementation of the  ICloudService  (in  Services\\AzureCloudService.cs ):  using Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(\"https://my-backend.azurewebsites.net\");\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData\n        {\n            return new AzureCloudTable<T>(client);\n        }\n    }\n}  The Azure Mobile Apps Client SDK takes a lot of the pain out of communicating\nwith the mobile backend that we have already published.  Just swap out the\nname of your mobile backend and the rest is silently dealt with.   The name  Microsoft.WindowsAzure.MobileServices  is a hold-over from the old Azure\nMobile Services code-base.  Don't be fooled - clients for Azure Mobile Services are\nnot interchangeable with clients for Azure Mobile Apps.   We also need a concrete implementation of the  ICloudTable<T>  interface (in  Services\\AzureCloudTable.cs ):  using System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudTable<T> : ICloudTable<T> where T : TableData\n    {\n        MobileServiceClient client;\n        IMobileServiceTable<T> table;\n\n        public AzureCloudTable(MobileServiceClient client)\n        {\n            this.client = client;\n            this.table = client.GetTable<T>();\n        }\n\n        #region ICloudTable implementation\n        public async Task<T> CreateItemAsync(T item)\n        {\n            await table.InsertAsync(item);\n            return item;\n        }\n\n        public async Task<T> DeleteItemAsync(T item)\n        {\n            await table.DeleteAsync(item);\n        }\n\n        public async Task<ICollection<T>> ReadAllItemsAsync()\n        {\n            return await table.ToListAsync();\n        }\n\n        public async Task<T> ReadItemAsync(string id)\n        {\n            return await table.LookupAsync(id);\n        }\n\n        public async Task<T> UpdateItemAsync(T item)\n        {\n          await table.UpdateAsync(item);\n          return item;\n        }\n        #endregion\n    }\n}  It's important to note here that the Azure Mobile Apps Client SDK does a lot of\nthe work for us.  In fact, we are just wrapping the basic interface here.  This\nwon't normally be the case, but you can see that the majority of the code for\ndealing with the remote server is done for us.   You can use a shorthand (called a lambda expression) for methods with only one line.\nFor instance, the delete method could just as easily have been written as  public async Task<T> DeleteItemAsync(T item) => await table.DeleteAsync(item); .\nYou may see this sort of short hand in samples.   We also need to create the model that we will use for the data.  This should\nlook very similar to the model on the server - including having the same name\nand fields.  In this case, it's  Models\\TodoItem.cs :  using TaskList.Abstractions\n\nnamespace TaskList.Models\n{\n    public class TodoItem : TableData\n    {\n        public string Text { get; set; }\n        public bool Complete { get; set; }\n    }\n}  We have a final piece of code to write before we move on to the views, but it's\nan important piece.  The  ICloudService  must be a singleton in the client.  We\nwill add authentication and offline sync capabilities in future versions of this\ncode.  The singleton becomes critical when using those features.  For right now,\nit's good practice and saves on memory if you only have one copy of the  ICloudService \nin your mobile client.  Since there is only one copy of the  App.cs  in any\ngiven app, I can place it there.  Ideally, I'd use some sort of dependency\ninjection system or a singleton manager to deal with this.  Here is the  App.cs :  using TaskList.Abstractions;\nusing TaskList.Services;\nusing Xamarin.Forms;\n\nnamespace TaskList\n{\n    public class App : Application\n    {\n        public static ICloudService CloudService { get; set; }\n\n        public App()\n        {\n            CloudService = new AzureCloudService();\n            MainPage = new NavigationPage(new Pages.EntryPage());\n        }\n\n        // There are lifecycle methods here...\n    }\n}  We haven't written  Pages.EntryPage  yet, but that's coming.  The original  App.cs \nclass file had several methods for handling lifecycle events like starting, suspending\nor resuming the app.  I did not touch those methods for this example.",
            "title": "Building an Azure Mobile Apps Connection"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-the-ui-for-the-app",
            "text": "Earlier, I showed the mockup for my UI.  It included three pages - an entry\npage, a list page and a detail page.  These pages have three elements - a\nXAML definition file, a (simple) code-behind file and a view model.   This book is not intending to introduce you to everything that there is to know\nabout Xamarin and UI programming with XAML.  If you wish to have that sort of introduction,\nthen I recommend reading the excellent book by Charles Petzold:  Creating Mobile Apps with Xamarin.Forms .   I tend to use MVVM (or Model-View-ViewModel) for UI development in Xamarin\nbased applications.  It's a nice clean pattern and is well understood and\ndocumented.  In MVVM, there is a 1:1 correlation between the view and the\nview-model, 2-way communication between the view and the view-model and\nproperties within the view-model are bound directly to UI elements.  In\ngeneral (and in all my code), view-models expose an INotifyPropertyChanged\nevent to tell the UI that something within the view-model has been changed.  To do this, we will use a  BaseViewModel  class that implements the base functionality\nfor each view.  Aside from the  INotifyPropertyChanged  interface, there are\nsome common properties we need for each page.  Each page needs a title, for\nexample, and each page needs an indicator of network activity.  These can be\nplaced in the  Abstractions\\BaseViewModel.cs  class:  using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\n\nnamespace TaskList.Abstractions\n{\n    public class BaseViewModel : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n        string _propTitle = string.Empty;\n        bool _propIsBusy;\n\n        public string Title\n        {\n            get { return _propTitle; }\n            set { SetProperty(ref _propTitle, value, \"Title\"); }\n        }\n\n        public bool IsBusy\n        {\n            get { return _propIsBusy; }\n            set { SetProperty(ref _propIsBusy, value, \"IsBusy\"); }\n        }\n\n        protected void SetProperty<T>(ref T store, T value, string propName, Action onChanged = null)\n        {\n            if (EqualityComparer<T>.Default.Equals(store, value))\n                return;\n            store = value;\n            if (onChanged != null)\n                onChanged();\n            OnPropertyChanged(propName);\n        }\n\n        public void OnPropertyChanged(string propName)\n        {\n            if (PropertyChanged == null)\n                return;\n            PropertyChanged(this, new PropertyChangedEventArgs(propName));\n        }\n    }\n}  This is a fairly common  INotifyPropertyChanged  interface implementation pattern.\nEach property that we want to expose is a standard property, but the  set  operation\nis replaced by the  SetProperty()  call.  The  SetProperty()  call deals with the\nnotification; calling the event emitter if the property has changed value.  We\nonly need two properties on the  BaseViewModel : the title and the network indicator.  I tend to write my apps in two stages.  I concentrate on the functionality of the\napp in the first stage.  There is no fancy graphics, custom UI widgets, or anything\nelse to clutter the thinking.   The page is all about the functionality of the\nvarious interactions.  Once I have the functionality working, I work on the styling\nof the page.  We won't be doing any styling work in the demonstration apps that we\nwrite during the course of this book.  The EntryPage has just one thing to do.  It provides a button that enters the app.\nWhen we cover authentication later on, we'll use this to log in to the backend.  If\nyou are looking at the perfect app, this is a great place to put the introductory\nscreen.  Creating a XAML file is relatively simple.  First, create a  Pages  directory to\nhold the pages of our application.  Then right-click on the  Pages  directory in\nthe solution explorer and choose  Add  ->  New Item... .  In the  Add New Item \ndialog, pick  Visual C#  ->  Cross-Platform  ->  Forms Xaml Page .  Name the\nnew page  EntryPage.cs .  This will create two files -  EntryPage.xaml  and EntryPage.xaml.cs .  Let's center a button on the page and wire it up with\na command.  Here is the  Pages\\EntryPage.xaml  file:  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.EntryPage\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <StackLayout HorizontalOptions=\"Center\"\n                     Orientation=\"Vertical\"\n                     VerticalOptions=\"Center\">\n            <Button BackgroundColor=\"Teal\"\n                    BorderRadius=\"10\"\n                    Command=\"{Binding LoginCommand}\"\n                    Text=\"Login\"\n                    TextColor=\"White\" />\n        </StackLayout>\n    </ContentPage.Content>\n</ContentPage>  There are a couple of interesting things to note here.  The  StackLayout  element\nis our layout element.  It occupies the entire screen (since it is a direct child\nof the content page) and the options just center whatever the contents are.  The\nonly contents are a button.  There are two bindings.  These are bound from the view-model.  We've already seen\nthe Title property - this is a text field that specifies the title of the page.\nThe other binding is a login command.  When the button is tapped, the login command\nwill be run.  We'll get onto that in the view-model later.  The other part of the XAML is the code-behind file.  Because we are moving all\nof the non-UI code into a view-model, the code-behind file is trivial:  using TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class EntryPage : ContentPage\n    {\n        public EntryPage()\n        {\n            InitializeComponent();\n            BindingContext = new EntryPageViewModel();\n        }\n    }\n}  This is a recipe that will be repeated over and over again for the code-behind\nwhen you are using a XAML-based project with MVVM.  We initialize the UI, then\nbind all the bindings to a new instantiation of the view model.  Talking of which, the view-model needs just to handle the login click.  Note that\nthe location or namespace is  TaskList.ViewModels .  I'm of two minds about location.\nThere tends to be a 1:1 relationship between the XAML file and the View Model, so\nit makes sense that they are stored together.  However, just about all the sample\ncode that I see has the view-models in a separate namespace.  Which one is correct?\nI'll go with copying the samples for now.  Here is the code for  ViewModels\\EntryPageViewModel.cs :  using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class EntryPageViewModel : BaseViewModel\n    {\n        public EntryPageViewModel()\n        {\n            Title = \"Task List\";\n        }\n\n        Command loginCmd;\n        public Command LoginCommand => loginCmd ?? (loginCmd = new Command(async () => await ExecuteLoginCommand()));\n\n        async Task ExecuteLoginCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[Login] Error = {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}  This is a fairly simple view-model but there are some patterns here that are\nworth explaining.  Firstly, note the way we create the  LoginCommand  property.\nThis is the property that is bound to the  Command  parameter in the  Button \nof our view.  This recipe is the method of invoking a UI action asynchronously.\nIt isn't important now, but we will want this technique repeatedly as our UI\nactions kick off network activity.  The second is the pattern for the  ExecuteLoginCommand  method.  Firstly, I\nensure nothing else is happening by checking the IsBusy flag.   If nothing\nis happening, I set the IsBusy flag.  Then I do what I need to do in a try/catch\nblock.  If an exception is thrown, I deal with it.  Most of the time this\ninvolves displaying an error condition.  There are several cross-platform dialog\npackages to choose from or you can roll your own.  That is not covered here.  We\njust write a debug log statement so we can see the result in the debug log.  Once\neverything is done, we clear the IsBusy flag.  The only thing we are doing now is swapping out our main page for a new main\npage.  This is where we will attach authentication later on.  The next page is the Task List page, which is in  Pages\\TaskList.xaml :  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.TaskList\"\n             Title=\"{Binding Title}\">\n  <ContentPage.Content>\n    <StackLayout>\n      <ListView BackgroundColor=\"#7F7F7F\"\n                CachingStrategy=\"RecycleElement\"\n                IsPullToRefreshEnabled=\"True\"\n                IsRefreshing=\"{Binding IsBusy, Mode=OneWay}\"\n                ItemsSource=\"{Binding Items}\"\n                RefreshCommand=\"{Binding RefreshCommand}\"\n                RowHeight=\"50\"\n                SelectedItem=\"{Binding SelectedItem, Mode=TwoWay}\">\n        <ListView.ItemTemplate>\n          <DataTemplate>\n            <ViewCell>\n              <StackLayout HorizontalOptions=\"FillAndExpand\"\n                           Orientation=\"Horizontal\"\n                           Padding=\"10\"\n                           VerticalOptions=\"CenterAndExpand\">\n                <Label HorizontalOptions=\"FillAndExpand\"\n                       Text=\"{Binding Text}\"\n                       TextColor=\"#272832\" />\n                <Switch IsToggled=\"{Binding Complete, Mode=OneWay}\" />\n              </StackLayout>\n            </ViewCell>\n          </DataTemplate>\n        </ListView.ItemTemplate>\n      </ListView>\n      <StackLayout HorizontalOptions=\"Center\"\n                   Orientation=\"Horizontal\">\n        <Button BackgroundColor=\"Teal\"\n                Command=\"{Binding AddNewItemCommand}\"\n                Text=\"Add New Item\"\n                TextColor=\"White\" />\n      </StackLayout>\n    </StackLayout>\n  </ContentPage.Content>\n</ContentPage>  Note that some bindings here are one-way.  This means that the value in the\nview-model drives the value in the UI.  There is nothing within the UI that you\ncan do to alter the state of the underlying property.  Some bindings are two-way.\nDoing something in the UI (for example, toggling the switch) alters the underlying\nproperty.  This view is a little more complex.  It can be split into two parts - the list\nat the top of the page and the button area at the bottom of the page.  The list\narea uses a template to help with the display of each item.  Note that the  ListView  object has a \"pull-to-refresh\" option that I have wired\nup so that when pulled, it calls the RefreshCommand.  It also has an indicator\nthat I have wired up to the IsBusy indicator.  Anyone who is familiar with the\niOS \"pull-to-refresh\" gesture can probably guess what this does.  There is a view-model that goes along with the view (in  ViewModels\\TaskListViewModel.cs ):  using System;\nusing System.Collections.ObjectModel;\nusing System.Collections.Specialized;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskListViewModel : BaseViewModel\n    {\n        public TaskListViewModel()\n        {\n            Title = \"Task List\";\n            RefreshList();\n        }\n\n        ObservableCollection<TodoItem> items = new ObservableCollection<TodoItem>();\n        public ObservableCollection<TodoItem> Items\n        {\n            get { return items; }\n            set { SetProperty(ref items, value, \"Items\"); }\n        }\n\n        TodoItem selectedItem;\n        public TodoItem SelectedItem\n        {\n            get { return selectedItem; }\n            set\n            {\n                SetProperty(ref selectedItem, value, \"SelectedItem\");\n                if (selectedItem != null)\n                {\n                    Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail(selectedItem));\n                    SelectedItem = null;\n                }\n            }\n        }\n\n        Command refreshCmd;\n        public Command RefreshCommand => refreshCmd ?? (refreshCmd = new Command(async () => await ExecuteRefreshCommand()));\n\n        async Task ExecuteRefreshCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                var table = App.CloudService.GetTable<TodoItem>();\n                var list = await table.ReadAllItemsAsync();\n                Items.Clear();\n                foreach (var item in list)\n                    Items.Add(item);\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskList] Error loading items: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command addNewCmd;\n        public Command AddNewItemCommand => addNewCmd ?? (addNewCmd = new Command(async () => await ExecuteAddNewItemCommand()));\n\n        async Task ExecuteAddNewItemCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                await Application.Current.MainPage.Navigation.PushAsync(new Pages.TaskDetail());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskList] Error in AddNewItem: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        async Task RefreshList()\n        {\n            await ExecuteRefreshCommand();\n            MessagingCenter.Subscribe<TaskDetailViewModel>(this, \"ItemsChanged\", async (sender) =>\n            {\n                await ExecuteRefreshCommand();\n            });\n        }\n    }\n}  This is a combination of the patterns we have seen earlier.  The Add New Item\nand Refresh commands should be fairly normal patterns now.  We navigate to the\ndetail page (more on that later) in the case of selecting an item (which occurs\nwhen the UI sets the  SelectedItem  property through a two-way binding) and when\nthe user clicks on the Add New Item button.  When the Refresh button is clicked\n(or when the user opens the view for the first time), the list is refreshed.  It\nis fairly common to use an  ObservableCollection  or another class that uses the ICollectionChanged  event handler for the list storage.  Doing so allows the UI\nto react to changes in the items.  Note the use of the  ICloudTable  interface here.  We are using the  ReadAllItemsAsync() \nmethod to get a list of items, then we copy the items we received into the  ObservableCollection .  Finally, there is the TaskDetail page.  This is defined in the  Pages\\TaskDetail.xaml \nfile:  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             x:Class=\"TaskList.Pages.TaskDetail\"\n             Title=\"{Binding Title}\">\n  <ContentPage.Content>\n    <StackLayout Padding=\"10\" Spacing=\"10\">\n      <Label Text=\"What should I be doing?\"/>\n      <Entry Text=\"{Binding Item.Text}\"/>\n      <Label Text=\"Completed?\"/>\n      <Switch IsToggled=\"{Binding Item.Complete}\"/>\n      <StackLayout VerticalOptions=\"CenterAndExpand\"/>\n      <StackLayout Orientation=\"Vertical\" VerticalOptions=\"End\">\n        <StackLayout HorizontalOptions=\"Center\" Orientation=\"Horizontal\">\n          <Button BackgroundColor=\"#A6E55E\"\n                  Command=\"{Binding SaveCommand}\"\n                  Text=\"Save\" TextColor=\"White\"/>\n          <Button BackgroundColor=\"Red\"\n                  Command=\"{Binding DeleteCommand}\"\n                  Text=\"Delete\" TextColor=\"White\"/>\n        </StackLayout>\n      </StackLayout>\n    </StackLayout>\n  </ContentPage.Content>\n</ContentPage>  This page is a simple form with just two buttons that need to have commands\nwired up.  However, this page is used for both the \"Add New Item\" gesture\nand the \"Edit Item\" gesture.  As a result of this, we need to handle the\npassing of the item to be edited.  This is done in the  Pages\\TaskDetail.xaml.cs \ncode-behind file:  using TaskList.Models;\nusing TaskList.ViewModels;\nusing Xamarin.Forms;\n\nnamespace TaskList.Pages\n{\n    public partial class TaskDetail : ContentPage\n    {\n        public TaskDetail(TodoItem item = null)\n        {\n            InitializeComponent();\n            BindingContext = new TaskDetailViewModel(item);\n        }\n    }\n}  The item that is passed in from the  TaskList  page is used to create a\nspecific view-model for that item.  The view-model is similarly configured\nto use that item:  using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class TaskDetailViewModel : BaseViewModel\n    {\n        ICloudTable<TodoItem> table = App.CloudService.GetTable<TodoItem>();\n\n        public TaskDetailViewModel(TodoItem item = null)\n        {\n            if (item != null)\n            {\n                Item = item;\n                Title = item.Text;\n            }\n            else\n            {\n                Item = new TodoItem { Text = \"New Item\", Complete = false };\n                Title = \"New Item\";\n            }\n        }\n\n        public TodoItem Item { get; set; }\n\n        Command cmdSave;\n        public Command SaveCommand => cmdSave ?? (cmdSave = new Command(async () => await ExecuteSaveCommand()));\n\n        async Task ExecuteSaveCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id == null)\n                {\n                    await table.CreateItemAsync(Item);\n                }\n                else\n                {\n                    await table.UpdateItemAsync(Item);\n                }\n                MessagingCenter.Send<TaskDetailViewModel>(this, \"ItemsChanged\");\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskDetail] Save error: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n\n        Command cmdDelete;\n        public Command DeleteCommand => cmdDelete ?? (cmdDelete = new Command(async () => await ExecuteDeleteCommand()));\n\n        async Task ExecuteDeleteCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                if (Item.Id != null)\n                {\n                    await table.DeleteItemAsync(Item);\n                }\n                MessagingCenter.Send<TaskDetailViewModel>(this, \"ItemsChanged\");\n                await Application.Current.MainPage.Navigation.PopAsync();\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[TaskDetail] Save error: {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}  The save command uses the  ICloudTable  interface again - this time doing\neither  CreateItemAsync()  or  UpdateItemAsync()  to create or update the\nitem.  The delete command, as you would expect, deletes the item with the DeleteItemAsync()  method.  The final thing to note from our views is that I am using the  MessagingCenter \nto communicate between the TaskDetail and TaskList views.  If I change the item\nin the  TaskDetail  list, then I want to update the list in the  TaskList  view.  Note that all the code we have added to the solution thus far is in the common TaskList  project.  Nothing is required for this simple example in a platform\nspecific project.  That isn't normal, as we shall see.",
            "title": "Building the UI for the App"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-the-client-for-universal-windows",
            "text": "I tend to start by building the Universal Windows mobile client.  I'm using\nVisual Studio, after all, and I don't need to use any emulator.  To build the\nclients:   Right-click on the  TaskList.UWP (Universal Windows)  project, then select  Set as StartUp Project .  Right-click on the  TaskList.UWP (Universal Windows)  project again, then select  Build .  Once the build is complete, Right-click on the  TaskList.UWP (Universal Windows)  project again, then select  Deploy .  Click on the  Local Machine  button in your command bar to run the application.   Here are the three screen screens we generated on Windows:   There are some problems with the UWP version.  Most notably, the \"pull-to-refresh\"\ngesture does not exist, so we will need to set up an alternate gesture.  This\ncould be as easy as adding a refresh button right next to the Add New Item\nbutton.  In addition, there is no indication of network activity - this manifests\nas a significant delay between the TaskList page appearing and the data appearing\nin the list.  Aside from this, I did do some styling work to ensure that the final version\nlooked like my mock-ups (with the exception of the UI form of the switch, which\nis platform dependent).  If you want to see what I did to correct this, check out\nthe final version of  the Chapter 1 sample  on GitHub.  If you need to build the project, ensure you redeploy the project after building.\nIt's a step that is easy to miss and can cause some consternation as you change\nthe code and it doesn't seem to have an effect on the application.",
            "title": "Building the Client for Universal Windows"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-the-client-for-android",
            "text": "Building Android with Visual Studio is as easy as building the Universal Windows\nversion of the mobile client:   Right-click on the  TaskList.Droid  project, then select  Set as StartUp Project .  Right-click on the  TaskList.Droid  project again, then select  Build .   The button for running the application has a drop-down that is now significant.\nIt lets you choose the type of device that you will use.  Normally, this runs\neither a 5\" or 7\" KitKat-based Android device.  There is some setup required for\nthe Visual Studio Emulator for Android.  The Visual Studio Emulator for Android\nruns within Hyper-V, so you must install Hyper-V before use.  You get the following\nerror if you don't do this:   To install Hyper-V:   Close all applications (your system will be rebooted during this process).  Search for  Programs and Features .  Click on  Turn Windows features on or off  (in the left-hand menu).  Expand the  Hyper-V  node.  Check all the boxes below the  Hyper-V  node.  This will include Hyper-V Management Tools and Hyper-V Services.  Click on  OK .  Your system will install the required pieces and then ask you to restart.  Click on  Restart now  when prompted.   Once you have done this, the next hurdle is to be added to the Hyper-V Administrators\nsecurity group.  It gets done for you (again - the first time you try to run the\napplication after installing Hyper-V).  Once it is done, close Visual Studio (again),\nthe log out and back in again.  As if that wasn't enough, the emulator also needs an Internet connection to\nstart.   You should be able to just click on  Yes  or  OK  to enable the Internet\nconnection.  My laptop required a reboot before this would work, however.  In\naddition, the process may request elevated privileges.   If you want to run additional Android profiles before starting, run the  Visual Studio Emulator for Android  and download any additional profiles.  For example, if you wish to emulate something similar to a Samsung Galaxy S6, then download the profile for a 5.1\" Marshmallow (6.0.0) XXHDPI Phone.   Finally the Visual Studio Emulator for Android starts when you click on the Run\nbutton.  Fortunately, the setup of the emulator only has to be done once per\nmachine.  The Visual Studio Emulator for Android is also a superior emulator\nto the standard Android Emulator, so this process is well worth going through.   When testing the mobile client manually through the Visual Studio Emulator for Android, you are likely to need to rebuild the application.  You do not have to shut down the emulator between runs.  You can leave it running.  The application will be stopped and replaced before starting again.  This can significantly speed up the debug cycle since you are not waiting for the emulator to start each time.   Watch the Output window.  If the debugger won't connect or the application\nwon't start, you may need to restart your computer again to get the network\nworking.   If your computer doesn't run Hyper-V well (or at all), then the emulator won't run well (or at all) either.  I find laptops to be particularly prone to this problem.  If this happens, you can always run the Google Emulator instead.  Build the application as normal.  You will find the APK file to install in  ...\\TaskList.Droid\\bin\\Debug . Fortunately, there are lots of resources that show how to do this.  You can find the answer on  Stack Overflow   If everything is working, you should see the Visual Studio Emulator for Android\ndisplay your mobile client:    You can also build the Android version on a mac with Xamarin Studio.  However, I find that version mismatches between Mono (which is used on the mac) and Visual Studio - particularly in reference to the version of the .NET framework - cause issues when swapping between the two environments.  For best results, stay in one environment.   Note that the task list view is a \"light\" style and the rest of the app is a\n\"dark\" style.  This is because the default styling on an Android device is\ndark.  We are using the default styling on two of the pages and specifying\ncolors on the list page.  Fortunately, Xamarin Forms allows for  platform-specific\nstyling .  The  final sample  has platform-specific styling for the\nlist page.",
            "title": "Building the Client for Android"
        },
        {
            "location": "/chapter1/firstapp_pc/#building-the-client-for-ios",
            "text": "Finally, we get to the iOS platform.  You will need to ensure your Mac is turned\non and accessible, that it has XCode installed (and you have run XCode once so\nthat you can accept the license agreement), and it has Xamarin Studio installed.  When you created the projects, you were asked to link Visual Studio to your mac.\nThis linkage is used for building the project.  In essence, the entire project\nis sent to the Mac and the build tools that are supplied with Xamarin Studio\nwill be used to build the project.   Right-click on the  TaskList.iOS  project and select  Set as StartUp Project .  Right-click on the  TaskList.iOS  project and select  Build .   You knew it was not going to be that easy, right?  Here are the errors that I\nreceived when building for the first time:   There are two errors right at the top.  Let's cover the first one.  The error\nabout  Build Action 'EmbeddedResource' is not supported  is an annoying one.\nThe fix is to do the following:   Set the iOS project as the StartUp project.  Go through each project, expand the  References  node and ensure that there are no references with a warning (a little yellow triangle).  If there are - fix those first.  Generally, this is fixed by either using the  Restore NuGet Packages  option or removing the reference and then adding it again from NuGet.  Close the solution.  Re-open the solution.  You don't need to close Visual Studio to do this.  Right-click on the iOS project and select  Clean .  Right-click on the iOS project and select  Rebuild .   Once you have done this sequence, the error should go away.  The error about  No valid iOS code signing keys found in keychain  is because\nwe have not yet signed up for an Apple Developer Account and linked it to our\nMac development environment.   Go to the  Apple Developer Center .  Click on  Account  in the top navigation bar.  If you haven't got an Apple ID yet, create one first.  If you have go an Apple ID, then log in.   There are a sequence of sign-up prompts in both cases (first for creating your\nApple ID and secondly for signing up for the Apple Developer program).  Once\nyou have gone through this process, you are registered as an Apple Developer.   If you want to distribute your apps on the Apple App Store, run on real devices or get access to the beta bits, then you might consider signing up for the Apple Developer Program.  The Apple Developer Program is an additional cost and is not required for developing iOS apps that are only run on the iOS simulator.   Once you have created your account and enabled it as a developer account, open\nup XCode.  Go to  Preferences... , then  Account  and\nclick on the  +  in the bottom-left corner of the window:   Sign in with the same account you used to sign up for the developer account.   Click on the  View Details  button.  This will bring up the Signing Identities\nlist.  For a free account, it looks like this:   Click on the Create button next to  iOS Development .  Once the UI comes back,\nclick on  Done .  For more information on this process, refer to the  Apple Documentation .  You can close XCode at this point.  Ensure Xamarin Studio is not running.  Back\nwithin Visual Studio, right-click on the  TaskList.iOS  project and select  Rebuild .\nThis will (finally!) build the application for you.   Getting an error about  Provisioning Profiles  not being available?  This is because you are building for a real device instead of the simulator.  In order to build for a real device, you must have a linked Apple Developer Program.  To get around this, select a Simulator before building.   The  Run  button has received a  Device  label, but there are several simulator options.\nYou should only use  Device  if you have signed up for the Apple Developer Program.  Pick\none of the simulator options like the  iPhone 6 iOS 9.3  simulator, then click on it\nto run the simulator.  Before long, you should see the following:   At some point, you will need a platform initialization call on all platforms.  It's best to\nadd it now.  In TaskList.Droid, this should be added in  MainActivity.cs  and in TaskList.iOS,\nit's  AppDelegate.cs .  In each of these files, there is a line that initializes the Xamarin\nForms system.  // Android Version\nglobal::Xamarin.Forms.Forms.Init(this, bundle);\n// iOS Version\nglobal::Xamarin.Forms.Forms.Init ();  Immediately before this line, you should add the  initializer for Azure Mobile Apps. It's\nimportant that the Azure Mobile Apps subsystem is initialized prior to Xamarin Forms being\ninitialized and any UI code being called.  Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();  This initializer is not required on the UWP project.  Once this is done and you have re-built\nthe project, we can see the fruits of our labor.  You can, of course, run the IPA in the\niOS simulator on the Mac.  However, it's much more satisfying (to me, at least) to be able\nto do everything from within Visual Studio.  For this, you need to install the Xamarin Installer .  This is an MSI for your Windows development system and is\nquickly installed.  Once installed, start (or restart) Visual Studio, select  Tools  -> Options .  Search for  Xamarin , and select the  iOS Settings  page.  There is\na new option:   Note the  Remote Simulator to Windows .  This should be checked.  You may need to\nrebuild the TaskList.iOS project after installing the Xamarin Simulator.  The debug\nwindow will tell you if this is the case.  There are also a few  known issues \nso check the documentation if you run into problems.  The final product screens look like this:",
            "title": "Building the Client for iOS"
        },
        {
            "location": "/chapter1/firstapp_pc/#some-final-thoughts",
            "text": "If you have got through the entire process outlined in this Chapter and built the application\nfor each platform, then congratulations.  There are a lot of places where things can go\nwrong.  You are really integrating the build systems across Visual Studio, Android, Xamarin,\nand XCode.  Fortunately, once these are set up, it's likely that they will continue working and you\nwon't have to think too much about them again. The Android and iOS build tools and simulators\nwill just work.  If you would rather develop code on your mac, the next chapter is for you - it gets into\nthe nitty gritty of developing the exact same app, but using Xamarin Studio instead.  The following 7 chapters each take one aspect of the cloud services that can be provided to\nmobile apps and explores it in detail, using an Azure Mobile App as a beginning. You can\njump around at this point, but be aware that we expect you to cover these topics in order.\nIf you do the data chapter before covering authentication, it's likely you will have missed\nimportant functionality in your app to complete the work.",
            "title": "Some Final Thoughts"
        },
        {
            "location": "/chapter1/firstapp_mac/",
            "text": "Building a Mobile App on a Mac\n\u00b6",
            "title": "Your First App - Mac Edition"
        },
        {
            "location": "/chapter1/firstapp_mac/#building-a-mobile-app-on-a-mac",
            "text": "",
            "title": "Building a Mobile App on a Mac"
        },
        {
            "location": "/chapter2/authconcepts/",
            "text": "Authentication Concepts\n\u00b6\n\n\nOne of the very first things you want to do when developing a mobile app is to provide users with a unique\nexperience.  For our example task list application, this could be as simple as providing a task list for the\nuser who is logged in.  In more complex applications, this is the gateway to role-based access controls, group\nrules, and sharing with your friends.  In all these cases, properly identifying the user using the phone is the\nstarting point.\n\n\nAuthentication provides a process by which the user that is using the mobile device can be identified securely.\nThis is generally done by entering a username and password.  However, modern systems can also provide\n\nmulti-factor authentication\n, send you a text message to a registered device, or \nuse your fingerprint\n\nas the password.\n\n\nThe OAuth Process\n\u00b6\n\n\nIn just about every single mobile application, a process called \nOAuth\n is used to properly identify a user\nto the mobile backend.  OAuth is not an authentication mechanism in its own right.  It is used to route the\nauthentication request to the right place and to verify that the authentication took place. There are three\nactors in the OAuth protocol:\n\n\n\n\nThe \nClient\n is the application attempting to get access to the resource.\n\n\nThe \nResource\n is the mobile backend that the client is attempting to access.\n\n\nThe \nIdentity Provider\n (or IdP) is the service that is responsible for authenticating the client.\n\n\n\n\nAt the end of the process, a cryptographically signed token is minted.  This token is added to every request\nmade by the client to the resource to securely identify the user.\n\n\nServer Side vs. Client Side\n\u00b6\n\n\nThere are two types of authentication flow: Server-flow and Client-flow.  They are so named because of who\ncontrols the flow of the actual authentication.\n\n\n\n\nServer-flow is named because the authentication flow is managed by the Azure App Service (the server) through a\nwebview-based work flow.  It is generally used in two cases:\n\n\n\n\nYou want a simple placeholder for authentication in your mobile app while you are developing other code.\n\n\nYou are developing a traditional web app.\n\n\n\n\n\n\nIf you are developing a single-page application (SPA), then client-flow is the more appropriate model for\nauthentication.  The SPA looks more like a mobile client than a traditional web app.  In particular, you will\nbe redirected away from your single page and returned to the app at a specific entry point, removing any\ncontext from the app.\n\n\n\n\nIn the case of server-flow:\n\n\n\n\nThe client brings up a web view and asks for the login page from the resource.\n\n\nThe resource redirects the client to the identity provider.\n\n\nThe identity provider does the authentication before redirecting the client\n   back to the resource (with an identity provider token).\n\n\nThe resource validates the identity provider token with the identity provider.\n\n\nFinally, the resource mints a new resource token that it returns to the client.\n\n\n\n\nClient-flow authentication uses an IdP provided SDK to integrate a more native feel to the authentication\nflow.  The actual flow happens on the client, communicating only with the identity provider.  It is used\nis most cases:\n\n\n\n\nYou want a more integrated experience for your users.\n\n\nYou want the most native feel to your authentication flow.\n\n\nYou are developing a single-page web application.\n\n\n\n\nA client-flow feels similar to the server-flow, but using a native SDK instead of a web view.\n\n\n\n\nThe client uses the identity provider SDK to communicate with the identity provider.\n\n\nThe identity provider authenticates the user, returning an identity provider token.\n\n\nThe client presents the identity provider token to the resource.\n\n\nThe resource validates the identity provider token with the identity provider.\n\n\nFinally, the resource mints a new resource token that it returns to the client.\n\n\n\n\nFor example, if you use the Facebook SDK for authentication, your app will seamlessly switch over into the\nFacebook app and ask you to authorize your client application before switching you back to your client application.\n\n\nYou should use the identity provider SDK when developing an app that will be released on the app store.  The\nidentity providers will advise you to use their SDK and it provides the best experience for your end users.\n\n\n\n\nThe Azure App Service Authentication / Authorization service works with any App Service, including web apps\nand API apps.  It's not just for Mobile Apps.\n\n\n\n\nAuthentication Providers\n\u00b6\n\n\nAzure Mobile Apps supports five identity providers natively:\n\n\n\n\nAzure Active Directory\n\n\nFacebook\n\n\nGoogle\n\n\nMicrosoft (MSA)\n\n\nTwitter\n\n\n\n\n\n\nAzure App Service Authentication / Authorization maintains a token store in the XDrive (which is the drive that is\nshared among all instances of the backend within the same App Service Plan).  The token store is located at\n\nD:\\\\home\\\\data\\\\.auth\\\\tokens\n on the backend.  The tokens are encrypted and stored in a per-user encrypted file.\n\n\n\n\nIn addition, you can set up client-flow custom authentication that allows you to mint a ZUMO token to your\nspecifications for any provider using a client-flow.  For example, you could use authentication providers\nlike \nAzure AD B2C\n, \nLinkedIn\n or \nGitHub\n, a third-party authentication provider like  \nAuth0\n,\nor you could set up an identity table in your database so that you can check  username and password without\nan identity provider.",
            "title": "Concepts"
        },
        {
            "location": "/chapter2/authconcepts/#authentication-concepts",
            "text": "One of the very first things you want to do when developing a mobile app is to provide users with a unique\nexperience.  For our example task list application, this could be as simple as providing a task list for the\nuser who is logged in.  In more complex applications, this is the gateway to role-based access controls, group\nrules, and sharing with your friends.  In all these cases, properly identifying the user using the phone is the\nstarting point.  Authentication provides a process by which the user that is using the mobile device can be identified securely.\nThis is generally done by entering a username and password.  However, modern systems can also provide multi-factor authentication , send you a text message to a registered device, or  use your fingerprint \nas the password.",
            "title": "Authentication Concepts"
        },
        {
            "location": "/chapter2/authconcepts/#the-oauth-process",
            "text": "In just about every single mobile application, a process called  OAuth  is used to properly identify a user\nto the mobile backend.  OAuth is not an authentication mechanism in its own right.  It is used to route the\nauthentication request to the right place and to verify that the authentication took place. There are three\nactors in the OAuth protocol:   The  Client  is the application attempting to get access to the resource.  The  Resource  is the mobile backend that the client is attempting to access.  The  Identity Provider  (or IdP) is the service that is responsible for authenticating the client.   At the end of the process, a cryptographically signed token is minted.  This token is added to every request\nmade by the client to the resource to securely identify the user.",
            "title": "The OAuth Process"
        },
        {
            "location": "/chapter2/authconcepts/#server-side-vs-client-side",
            "text": "There are two types of authentication flow: Server-flow and Client-flow.  They are so named because of who\ncontrols the flow of the actual authentication.   Server-flow is named because the authentication flow is managed by the Azure App Service (the server) through a\nwebview-based work flow.  It is generally used in two cases:   You want a simple placeholder for authentication in your mobile app while you are developing other code.  You are developing a traditional web app.    If you are developing a single-page application (SPA), then client-flow is the more appropriate model for\nauthentication.  The SPA looks more like a mobile client than a traditional web app.  In particular, you will\nbe redirected away from your single page and returned to the app at a specific entry point, removing any\ncontext from the app.   In the case of server-flow:   The client brings up a web view and asks for the login page from the resource.  The resource redirects the client to the identity provider.  The identity provider does the authentication before redirecting the client\n   back to the resource (with an identity provider token).  The resource validates the identity provider token with the identity provider.  Finally, the resource mints a new resource token that it returns to the client.   Client-flow authentication uses an IdP provided SDK to integrate a more native feel to the authentication\nflow.  The actual flow happens on the client, communicating only with the identity provider.  It is used\nis most cases:   You want a more integrated experience for your users.  You want the most native feel to your authentication flow.  You are developing a single-page web application.   A client-flow feels similar to the server-flow, but using a native SDK instead of a web view.   The client uses the identity provider SDK to communicate with the identity provider.  The identity provider authenticates the user, returning an identity provider token.  The client presents the identity provider token to the resource.  The resource validates the identity provider token with the identity provider.  Finally, the resource mints a new resource token that it returns to the client.   For example, if you use the Facebook SDK for authentication, your app will seamlessly switch over into the\nFacebook app and ask you to authorize your client application before switching you back to your client application.  You should use the identity provider SDK when developing an app that will be released on the app store.  The\nidentity providers will advise you to use their SDK and it provides the best experience for your end users.   The Azure App Service Authentication / Authorization service works with any App Service, including web apps\nand API apps.  It's not just for Mobile Apps.",
            "title": "Server Side vs. Client Side"
        },
        {
            "location": "/chapter2/authconcepts/#authentication-providers",
            "text": "Azure Mobile Apps supports five identity providers natively:   Azure Active Directory  Facebook  Google  Microsoft (MSA)  Twitter    Azure App Service Authentication / Authorization maintains a token store in the XDrive (which is the drive that is\nshared among all instances of the backend within the same App Service Plan).  The token store is located at D:\\\\home\\\\data\\\\.auth\\\\tokens  on the backend.  The tokens are encrypted and stored in a per-user encrypted file.   In addition, you can set up client-flow custom authentication that allows you to mint a ZUMO token to your\nspecifications for any provider using a client-flow.  For example, you could use authentication providers\nlike  Azure AD B2C ,  LinkedIn  or  GitHub , a third-party authentication provider like   Auth0 ,\nor you could set up an identity table in your database so that you can check  username and password without\nan identity provider.",
            "title": "Authentication Providers"
        },
        {
            "location": "/chapter2/backend/",
            "text": "Adding Authentication to a Mobile Backend\n\u00b6\n\n\nThe Azure App Service Authentication / Authorization service integrates seamlessly into an Azure Mobile Apps\nbackend as a piece of middleware that fills in the Identity information for ASP.NET.  That means the only\nthing we have to worry about is authorization.  The authentication piece (determining that a user is who they\nsay they are) is already taken care of.\n\n\nAuthorization (which is the determination of whether an authenticated user can use a specific API) can happen\nat either the controller level or an individual operation level.  We can add authorization to an entire table\ncontroller by adding the \n[Authorize]\n attribute to the table controller.  For example, here is our table\ncontroller from the first chapter with authorization required for all operations:\n\n\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    [Authorize]\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}\n\n\n\n\nAuthorization can also happen on a per-operation basis by adding the \n[Authorize]\n attribute to a single method\nwithin the table controller.  For example, instead of requiring authorization on the entire table, we want a\nversion where reading was possible anonymously but updating the database required authentication:\n\n\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        [Authorize]\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        [Authorize]\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        [Authorize]\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}\n\n\n\n\nNote that the \n[Authorize]\n attribute can do much more than what is provided here.  Underneath there are various\nparameters that you can adjust to see if the user belongs to a specific group or role.  However, the token that\nis checked to see if the user is authenticated does not pull in any of the other information that is normally\nneeded for such authorization tasks.  As a result, the \n[Authorize]\n tags is really only checking whether a\nrequest requires authentication or not.\n\n\nConfiguring an Authentication Provider\n\u00b6\n\n\nConfiguration of the identity provider is very dependent on the identity provider and whether the client is using\na client-flow or server-flow.  Choose one of the several options for authentication:\n\n\n\n\nEnterprise Authentication\n covers Azure Active Directory.\n\n\nSocial Authentication\n covers Facebook, Google, Microsoft and Twitter.\n\n\n\n\nWe can also configure authentication using custom routes.  This allows us to use other (non-supported) services\nor to completely customize our flow (for example, to use an existing identity database).  We will cover custom\nauthentication later on.",
            "title": "Authentication in the Backend"
        },
        {
            "location": "/chapter2/backend/#adding-authentication-to-a-mobile-backend",
            "text": "The Azure App Service Authentication / Authorization service integrates seamlessly into an Azure Mobile Apps\nbackend as a piece of middleware that fills in the Identity information for ASP.NET.  That means the only\nthing we have to worry about is authorization.  The authentication piece (determining that a user is who they\nsay they are) is already taken care of.  Authorization (which is the determination of whether an authenticated user can use a specific API) can happen\nat either the controller level or an individual operation level.  We can add authorization to an entire table\ncontroller by adding the  [Authorize]  attribute to the table controller.  For example, here is our table\ncontroller from the first chapter with authorization required for all operations:  using System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    [Authorize]\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}  Authorization can also happen on a per-operation basis by adding the  [Authorize]  attribute to a single method\nwithin the table controller.  For example, instead of requiring authorization on the entire table, we want a\nversion where reading was possible anonymously but updating the database required authentication:  using System.Linq;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.OData;\nusing Backend.DataObjects;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Backend.Controllers\n{\n    public class TodoItemController : TableController<TodoItem>\n    {\n        protected override void Initialize(HttpControllerContext controllerContext)\n        {\n            base.Initialize(controllerContext);\n            MobileServiceContext context = new MobileServiceContext();\n            DomainManager = new EntityDomainManager<TodoItem>(context, Request);\n        }\n\n        // GET tables/TodoItem\n        public IQueryable<TodoItem> GetAllTodoItems() => Query();\n\n        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        public SingleResult<TodoItem> GetTodoItem(string id) => Lookup(id);\n\n        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        [Authorize]\n        public Task<TodoItem> PatchTodoItem(string id, Delta<TodoItem> patch) => UpdateAsync(id, patch);\n\n        // POST tables/TodoItem\n        [Authorize]\n        public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n        {\n            TodoItem current = await InsertAsync(item);\n            return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n        }\n\n        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959\n        [Authorize]\n        public Task DeleteTodoItem(string id) => DeleteAsync(id);\n    }\n}  Note that the  [Authorize]  attribute can do much more than what is provided here.  Underneath there are various\nparameters that you can adjust to see if the user belongs to a specific group or role.  However, the token that\nis checked to see if the user is authenticated does not pull in any of the other information that is normally\nneeded for such authorization tasks.  As a result, the  [Authorize]  tags is really only checking whether a\nrequest requires authentication or not.",
            "title": "Adding Authentication to a Mobile Backend"
        },
        {
            "location": "/chapter2/backend/#configuring-an-authentication-provider",
            "text": "Configuration of the identity provider is very dependent on the identity provider and whether the client is using\na client-flow or server-flow.  Choose one of the several options for authentication:   Enterprise Authentication  covers Azure Active Directory.  Social Authentication  covers Facebook, Google, Microsoft and Twitter.   We can also configure authentication using custom routes.  This allows us to use other (non-supported) services\nor to completely customize our flow (for example, to use an existing identity database).  We will cover custom\nauthentication later on.",
            "title": "Configuring an Authentication Provider"
        },
        {
            "location": "/chapter2/enterprise/",
            "text": "Enterprise Authentication\n\u00b6\n\n\nEnterprise Authentication is handled by Azure Active Directory, which is fairly commonly configured within Azure.\nEvery Azure subscription has a default directory associated with it that you can leverage for this section.  In\naddition, if your organization has an Office 365 subscription, this will likely be tied to an Azure Active Directory\ndomain to allow enterprise sign-in.  In either case, you have a directory you can use for providing authentication\nto your app.\n\n\nIn general, you will need to get special permissions to update the directory. If you want to use your organizations\ncorporate directory, then you are likely to have to get your IT department involved to set it up.\n\n\nAzure Active Directory: Server-Flow setup\n\u00b6\n\n\nThe Azure Active Directory server-flow is perhaps the easiest of all the authentication methods to configure.  No\nmatter if you are doing a client flow or server flow, you need to set up the server flow first.\n\n\n\n\nWe recommend that you implement Client Flow in any non-trivial application.\n\n\n\n\nIf you are using your default directory and you want to add a couple of test users, you will need to set those up\nfirst.   Start by going to the \nClassic Azure Portal\n:\n\n\n\n\nClick on the \nDefault Directory\n, then click on \nUSERS\n.  You will notice that your Azure-linked ID is already\npresent.\n\n\n\n\nClick on \nAdd User\n at the bottom of the screen.  Enter a username in the box provided before clicking on the\narrow.  Then fill in the personal information and click on the arrow again.  Finally, click on \ncreate\n.  Note\nthe password, before clicking on the tick.  Now you have two users - your Azure ID and the one you just created.\nNote the username.  It is based on the tenant, so it will be something like \nadrian@photoadrianoutlook.onmicrosoft.com\n.\n\n\nTo configure your app, switch back to the regular \nAzure Portal\n, find your App Service, click on\n\nAll Settings\n followed by \nAuthentication / Authorization\n. Finally, select \nAzure Active Directory\n.\n\n\n\n\nClick on \nExpress\n.  Note that all the information is filled in for you.  All you have to do is click on \nOK\n,\nfollowed by \nSave\n.\n\n\n\n\nMake sure you create the app service in the right directory / subscription.  If you have access to more than one\n directory, you can choose the right one by selecting it under your account drop-down in the top-right corner.\n\n\n\n\nThere is also an \nAdvanced\n track.  This is used in client-flow situations and in situations where you have more\nthan one directory.  The Express flow is great for getting started quickly.\n\n\nYou can walk through a server-flow authentication to test that you have all the settings correct.  Point your browser\nat https://\nyoursite\n.azurewebsites.net/.auth/login/aad.  The browser will take you through an authentication flow\nbefore giving you a successful authentication image:\n\n\n\n\nAdding Authentication to a Mobile Client\n\u00b6\n\n\nNow that the backend is completely configured, we can move our attention to the mobile client.  We are going to be\nusing the same mobile client that we developed in the first chapter, but we are now going to add authentication to\nit.  Web views are one of those items that are platform dependent. Fortunately for us, Xamarin has already thought\nof this and provided a facility for running platform specific code called the \nDependencyService\n.\n\n\n\n\nIf we run our application right now, clicking on the \"Enter the App\" button will result in an error.  You will be\nable to see the Unauthorized error in the debug window of Visual Studio.\n\n\n\n\nOur first step is to define an \nAbstractions\\ILoginProvider.cs\n interface within the  shared project:\n\n\nusing Microsoft.WindowsAzure.MobileServices;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ILoginProvider\n    {\n        Task LoginAsync(MobileServiceClient client);\n    }\n}\n\n\n\n\nNext, we are going to extend our \nAbstractions\\ICloudService.cs\n interface so that the main application can call\nthe login routine:\n\n\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n    }\n}\n\n\n\n\nOur code will call \nLoginAsync()\n in the \nICloudService\n, which will get the platform-specific version of the\nlogin provider and call \nLoginAsync()\n there, but with our defined mobile service client.  That is defined in the\n\nServices\\AzureCloudService.cs\n class:\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing Xamarin.Forms;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(Locations.AppServiceUrl);\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData => new AzureCloudTable<T>(client);\n\n        public Task LoginAsync()\n        {\n            var loginProvider = DependencyService.Get<ILoginProvider>();\n            return loginProvider.LoginAsync(client);\n        }\n    }\n}\n\n\n\n\nThe method looks up the platform dependent version of the login provider and executes the login method, passing\nalong the client (which we will need later).\n\n\nIn each platform-specific project, we are going to define a concrete implementation of the login provider that uses\na web view to hold the actual authentication flow.  Here is the droid \nServices\\DroidLoginProvider.cs\n (in the\nTaskList.Droid project):\n\n\nusing System.Threading.Tasks;\nusing Android.Content;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        Context context;\n\n        public void Init(Context context)\n        {\n            this.context = context;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(context, \"aad\");\n        }\n    }\n}\n\n\n\n\nLet us take a closer look at this implementation.  The \nLoginAsync()\n method on the Azure Mobile Apps client object\ntakes the Android context (which is normally the main window) and a provider - we can pick any of \"facebook\",\n\"google\", \"microsoftaccount\", \"twitter\" or \"aad\" depending on what we have defined in the Azure App Service.  The\nclever piece is the \nXamarin.Forms.Dependency\n call at the top - that registers the class as a platform service\nso we can access it through the Xamarin dependency service.\n\n\nNote that we need an extra initialization routine for Android that must be called prior the login provider being\ncalled to pass along the main window of the app (also known as the context).  This is done in the \nMainActivity.cs\n\nfile \nafter\n the Xamarin Forms initialization call.  The dependency service is not set up until after the Xamarin\nForms library is initialized, so we will not be able to get the login provider reference before that point:\n\n\nprotected override void OnCreate(Bundle bundle)\n{\n    base.OnCreate(bundle);\n\n    Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n    global::Xamarin.Forms.Forms.Init(this, bundle);\n\n    ((DroidLoginProvider)DependencyService.Get<ILoginProvider>()).Init(this);\n\n    LoadApplication(new App());\n}\n\n\n\n\niOS is similar, but does not require the initialization step in the main startup class.  The login provider class\nis in \nServices\\iOSLoginProvider.cs\n (in the \nTaskList.iOS\n project):\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.iOS.Services;\nusing UIKit;\n\n[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]\nnamespace TaskList.iOS.Services\n{\n    public class iOSLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(RootView, \"aad\");\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n    }\n}\n\n\n\n\nNote that we are using the same pattern here for registering the concrete implementation with the dependency service,\nso we can get it the same way. Finally, here is the UWP \nServices\\UWPLoginProvider.cs\n (in the TaskList.UWP project):\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.UWP.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(\"aad\");\n        }\n    }\n}\n\n\n\n\nNow that we have all the platform-specific login routines registered, we can move on to adding the login routine to\nthe UI.  We have already got a button on the entry page to enter the app.  It makes sense to wire up that button so\nthat it logs us in as well. The Command for the login button is in the \nViewModels\\EntryPageViewModel.cs\n:\n\n\nasync Task ExecuteLoginCommand()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var cloudService = ServiceLocator.Instance.Resolve<ICloudService>();\n        await cloudService.LoginAsync();\n        Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n    }\n    catch (Exception ex)\n    {\n        Debug.WriteLine($\"[ExecuteLoginCommand] Error = {ex.Message}\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}\n\n\n\n\n\n\nThe \nServiceLocator\n class is my basic singleton handler.  It is available in the \nChapter2\n project.  It\nreturns the concrete version of the cloud service, just like the Singleton version we defined in Chapter1.\n\n\n\n\nWhen you run the application, clicking on the \"Enter the App\" button will now present you with an Authenticate window:\n\n\n\n\nGoing through the authentication process will get you to the task list again.  If the authentication process fails,\nthen \nLoginAsync()\n will throw an error, which is caught at the ViewModel.  Right now, the \nEntryPageViewModel\n\ndoes nothing more than print a diagnostic message to the debug window of Visual Studio.\n\n\nAzure Active Directory: Client-Flow Setup\n\u00b6\n\n\nConfiguring Azure Active Directory for client-flow is a three-step process.  First, we need to create a WEB\napplication.  This represents the resource: in our case, the resource is the Azure Mobile Apps backend.  Then\nwe need to create a NATIVE application.  This represents the client: in our case, the ADAL (Active Directory\nAccess Library) library will need this information.  Finally, we need to give the NATIVE application permission\nto access the WEB application.\n\n\nIt starts with configuring a server-flow to protect the resource.  We've already done that above. Then configure\na \"Native Application\" and give it permissions to the web application:\n\n\n\n\nLog on to the \nClassic Portal\n.\n\n\nSelect the \nDefault Directory\n from your list of all items.\n\n\nClick on the \nAPPLICATIONS\n tab.\n\n\n\n\n\n\n\n\nNote that our existing web application is already there.  You will see more applications, depending on what you\n  have set up.  In this example, I have Visual Studio Team Services and Office 365 set up.\n\n\nClick on the \nADD\n button at the bottom of the page.\n\n\n\n\n\n\n\n\nClick on \nAdd an application my organization is developing\n.\n\n\n\n\n\n\n\n\nEnter a name for the app registration, and select \nNATIVE CLIENT APPLICATION\n.\n\n\nClick on the Next arrow.\n\n\nEnter a valid URI - it can be anything, but it has to be valid\n\n\n\n\n\n\n\n\nClick on the tick to create the application.\n\n\nThe wizard will close, but you will be brought to the app configuration.  Click on the \nCONFIGURE\n tab.\n\n\n\n\n\n\n\n\nAdd a Redirect URI of the form: \nhttps://yoursite.azurewebsites.net/.auth/login/done\n.\n\n\n\n\n\n\n\n\nAt the bottom of the page is the \npermissions to other applications\n section.  Click on the \nAdd application\n button.\n\n\n\n\n\n\n\n\nClick on the \nSHOW\n drop-down and select \nAll Apps\n, then click on the tick next to the search box.\n\n\nClick on the web application that you set up during the server-flow configuration, then click on the  tick in\n  the lower-right corner.\n\n\n\n\n\n\n\n\nClick on \nDelegated Permissions\n next to the web application.  Check the box next to \nAccess\n, then click\n  on \nSave\n at the bottom of the screen.\n\n\n\n\n\n\nAt this point the application configuration will be saved.\n\n\nSo, what did we just do there?  We created a new Azure AD app for the native application.  We then gave permission\nfor the native application to access resources that are protected by the web application.  In our Azure App Service,\nwe configured the service so that the Azure AD web application is used to protect our resources.  The net effect is\n that our native application OR our web application can access the App Service resources that are protected via the\n \n[Authorize]\n attribute.\n\n\nBefore continuing, you will need the \nClient ID\n and the \nRedirect URI\n for the NATIVE application. You can enter\nthese into the \nHelpers\\Locations.cs\n file in the shared project:\n\n\nnamespace TaskList.Helpers\n{\n    public static class Locations\n    {\n        public static readonly string AppServiceUrl = \"https://the-book.azurewebsites.net\";\n\n        public static readonly string AadClientId = \"b61c7d68-2086-43a1-a8c9-d93c5732cc84\";\n\n        public static readonly string AadRedirectUri = \"https://the-book.azurewebsites.net/.auth/login/done\";\n\n        public static readonly string AadAuthority = \"https://login.windows.net/photoadrianoutlook.onmicrosoft.com\";\n    }\n}\n\n\n\n\nThe \nAadClientId\n and \nAadRedirectUri\n must match what we have configured in Azure AD for the native app.  The\nother piece of information we need to add is the Azure AD Authority for the directory.  If you click on the\n\nDOMAINS\n tab, it will generally tell you what domain you are in. The Authority is just a path on the\n\nhttps://login.windows.net\n that corresponds to your domain.  There is also a GUID version of this domain.  You\ncan find the GUID by looking at the \nView Endpoints\n in the \nAPPLICATIONS\n tab.  Look at the first path section\nof most all the endpoints.\n\n\nAdd the \nMicrosoft.IdentityModel.Clients.ActiveDirectory\n NuGet package using \nManage NuGet Packages...\n to\neach platform project.  This package contains the ADAL library as a portable class library.\n\n\n\n\nNow you can add the client flow to each project.  Start with the login provider in the \nTaskList.UWP\n project,\nlocated in the \nServices\\UWPLoginProvider.cs\n file:\n\n\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.UWP.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync()\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters(PromptBehavior.Auto, false));\n            return authResult.AccessToken;\n        }\n\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginADALAsync();\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server-Flow Version\n            // await client.LoginAsync(\"aad\");\n        }\n    }\n}\n\n\n\n\nThe \nLoginADALAsync()\n method does the actual client-flow - using the ADAL library to authenticate the user and\nreturn the access token.  The \nLoginAsync()\n method initiates the client-flow.  It uses the token it receives\nfrom the client-flow to log in to the App Service, by packaging the token into a JSON object.  I have placed\nthe client and server flow next to each other so you can compare the two.\n\n\nIn the \nTaskList.Droid\n project, we need to deal with the \nContext\n, as is common with Android libraries.  The\nclient flow in \nServices\\DroidLoginProvider.cs\n is remarkably similar though:\n\n\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Android.App;\nusing Android.Content;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\nusing TaskList.Helpers;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        Context context;\n\n        public void Init(Context context)\n        {\n            this.context = context;\n        }\n\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync()\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters((Activity)context));\n            return authResult.AccessToken;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginADALAsync();\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server-Flow Version\n            // await client.LoginAsync(context, \"aad\");\n        }\n    }\n}\n\n\n\n\nThe only real difference between this one and the Universal Windows edition is the PlatformParameters. We need to\npass in the context of the MainActivity (which is passed in through the \nInit()\n call).  However, we must also handle\nthe response from the ADAL library.  This is done in \nMainActivity.cs\n. Add the following method to the \nMainActivity\n\nclass:\n\n\nprotected override void OnActivityResult(int requestCode, Result resultCode, Intent data)\n{\n    base.OnActivityResult(requestCode, resultCode, data);\n    AuthenticationAgentContinuationHelper.SetAuthenticationAgentContinuationEventArgs(requestCode, resultCode, data);\n}\n\n\n\n\nFinally, the iOS version also requires access to the root view, so its \nPlatformParameters\n are also slightly\ndifferent.  Here is \nServices\\iOSLoginProvider.cs\n:\n\n\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.iOS.Services;\nusing UIKit;\n\n[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]\nnamespace TaskList.iOS.Services\n{\n    public class iOSLoginProvider : ILoginProvider\n    {\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync(UIViewController view)\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters(view));\n            return authResult.AccessToken;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            var rootView = UIApplication.SharedApplication.KeyWindow.RootViewController;\n\n            // Client Flow\n            var accessToken = await LoginADALAsync(rootView);\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server Flow\n            //await client.LoginAsync(rootView, \"aad\");\n        }\n    }\n}\n\n\n\n\nNote that we can balance the needs of each platform by using the dependency service.  The code that is unique to\nthe platform is minimized and stored with the platform.\n\n\nIf you aren't interested in social authentication (Facebook, Google, Microsoft or Twitter authentication providers),\nyou can \nskip the Social Authentication section\n.",
            "title": "Enterprise Authentication"
        },
        {
            "location": "/chapter2/enterprise/#enterprise-authentication",
            "text": "Enterprise Authentication is handled by Azure Active Directory, which is fairly commonly configured within Azure.\nEvery Azure subscription has a default directory associated with it that you can leverage for this section.  In\naddition, if your organization has an Office 365 subscription, this will likely be tied to an Azure Active Directory\ndomain to allow enterprise sign-in.  In either case, you have a directory you can use for providing authentication\nto your app.  In general, you will need to get special permissions to update the directory. If you want to use your organizations\ncorporate directory, then you are likely to have to get your IT department involved to set it up.",
            "title": "Enterprise Authentication"
        },
        {
            "location": "/chapter2/enterprise/#azure-active-directory-server-flow-setup",
            "text": "The Azure Active Directory server-flow is perhaps the easiest of all the authentication methods to configure.  No\nmatter if you are doing a client flow or server flow, you need to set up the server flow first.   We recommend that you implement Client Flow in any non-trivial application.   If you are using your default directory and you want to add a couple of test users, you will need to set those up\nfirst.   Start by going to the  Classic Azure Portal :   Click on the  Default Directory , then click on  USERS .  You will notice that your Azure-linked ID is already\npresent.   Click on  Add User  at the bottom of the screen.  Enter a username in the box provided before clicking on the\narrow.  Then fill in the personal information and click on the arrow again.  Finally, click on  create .  Note\nthe password, before clicking on the tick.  Now you have two users - your Azure ID and the one you just created.\nNote the username.  It is based on the tenant, so it will be something like  adrian@photoadrianoutlook.onmicrosoft.com .  To configure your app, switch back to the regular  Azure Portal , find your App Service, click on All Settings  followed by  Authentication / Authorization . Finally, select  Azure Active Directory .   Click on  Express .  Note that all the information is filled in for you.  All you have to do is click on  OK ,\nfollowed by  Save .   Make sure you create the app service in the right directory / subscription.  If you have access to more than one\n directory, you can choose the right one by selecting it under your account drop-down in the top-right corner.   There is also an  Advanced  track.  This is used in client-flow situations and in situations where you have more\nthan one directory.  The Express flow is great for getting started quickly.  You can walk through a server-flow authentication to test that you have all the settings correct.  Point your browser\nat https:// yoursite .azurewebsites.net/.auth/login/aad.  The browser will take you through an authentication flow\nbefore giving you a successful authentication image:",
            "title": "Azure Active Directory: Server-Flow setup"
        },
        {
            "location": "/chapter2/enterprise/#adding-authentication-to-a-mobile-client",
            "text": "Now that the backend is completely configured, we can move our attention to the mobile client.  We are going to be\nusing the same mobile client that we developed in the first chapter, but we are now going to add authentication to\nit.  Web views are one of those items that are platform dependent. Fortunately for us, Xamarin has already thought\nof this and provided a facility for running platform specific code called the  DependencyService .   If we run our application right now, clicking on the \"Enter the App\" button will result in an error.  You will be\nable to see the Unauthorized error in the debug window of Visual Studio.   Our first step is to define an  Abstractions\\ILoginProvider.cs  interface within the  shared project:  using Microsoft.WindowsAzure.MobileServices;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ILoginProvider\n    {\n        Task LoginAsync(MobileServiceClient client);\n    }\n}  Next, we are going to extend our  Abstractions\\ICloudService.cs  interface so that the main application can call\nthe login routine:  using System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n    }\n}  Our code will call  LoginAsync()  in the  ICloudService , which will get the platform-specific version of the\nlogin provider and call  LoginAsync()  there, but with our defined mobile service client.  That is defined in the Services\\AzureCloudService.cs  class:  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing Xamarin.Forms;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(Locations.AppServiceUrl);\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData => new AzureCloudTable<T>(client);\n\n        public Task LoginAsync()\n        {\n            var loginProvider = DependencyService.Get<ILoginProvider>();\n            return loginProvider.LoginAsync(client);\n        }\n    }\n}  The method looks up the platform dependent version of the login provider and executes the login method, passing\nalong the client (which we will need later).  In each platform-specific project, we are going to define a concrete implementation of the login provider that uses\na web view to hold the actual authentication flow.  Here is the droid  Services\\DroidLoginProvider.cs  (in the\nTaskList.Droid project):  using System.Threading.Tasks;\nusing Android.Content;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        Context context;\n\n        public void Init(Context context)\n        {\n            this.context = context;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(context, \"aad\");\n        }\n    }\n}  Let us take a closer look at this implementation.  The  LoginAsync()  method on the Azure Mobile Apps client object\ntakes the Android context (which is normally the main window) and a provider - we can pick any of \"facebook\",\n\"google\", \"microsoftaccount\", \"twitter\" or \"aad\" depending on what we have defined in the Azure App Service.  The\nclever piece is the  Xamarin.Forms.Dependency  call at the top - that registers the class as a platform service\nso we can access it through the Xamarin dependency service.  Note that we need an extra initialization routine for Android that must be called prior the login provider being\ncalled to pass along the main window of the app (also known as the context).  This is done in the  MainActivity.cs \nfile  after  the Xamarin Forms initialization call.  The dependency service is not set up until after the Xamarin\nForms library is initialized, so we will not be able to get the login provider reference before that point:  protected override void OnCreate(Bundle bundle)\n{\n    base.OnCreate(bundle);\n\n    Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n    global::Xamarin.Forms.Forms.Init(this, bundle);\n\n    ((DroidLoginProvider)DependencyService.Get<ILoginProvider>()).Init(this);\n\n    LoadApplication(new App());\n}  iOS is similar, but does not require the initialization step in the main startup class.  The login provider class\nis in  Services\\iOSLoginProvider.cs  (in the  TaskList.iOS  project):  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.iOS.Services;\nusing UIKit;\n\n[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]\nnamespace TaskList.iOS.Services\n{\n    public class iOSLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(RootView, \"aad\");\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n    }\n}  Note that we are using the same pattern here for registering the concrete implementation with the dependency service,\nso we can get it the same way. Finally, here is the UWP  Services\\UWPLoginProvider.cs  (in the TaskList.UWP project):  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.UWP.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(\"aad\");\n        }\n    }\n}  Now that we have all the platform-specific login routines registered, we can move on to adding the login routine to\nthe UI.  We have already got a button on the entry page to enter the app.  It makes sense to wire up that button so\nthat it logs us in as well. The Command for the login button is in the  ViewModels\\EntryPageViewModel.cs :  async Task ExecuteLoginCommand()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var cloudService = ServiceLocator.Instance.Resolve<ICloudService>();\n        await cloudService.LoginAsync();\n        Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n    }\n    catch (Exception ex)\n    {\n        Debug.WriteLine($\"[ExecuteLoginCommand] Error = {ex.Message}\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}   The  ServiceLocator  class is my basic singleton handler.  It is available in the  Chapter2  project.  It\nreturns the concrete version of the cloud service, just like the Singleton version we defined in Chapter1.   When you run the application, clicking on the \"Enter the App\" button will now present you with an Authenticate window:   Going through the authentication process will get you to the task list again.  If the authentication process fails,\nthen  LoginAsync()  will throw an error, which is caught at the ViewModel.  Right now, the  EntryPageViewModel \ndoes nothing more than print a diagnostic message to the debug window of Visual Studio.",
            "title": "Adding Authentication to a Mobile Client"
        },
        {
            "location": "/chapter2/enterprise/#azure-active-directory-client-flow-setup",
            "text": "Configuring Azure Active Directory for client-flow is a three-step process.  First, we need to create a WEB\napplication.  This represents the resource: in our case, the resource is the Azure Mobile Apps backend.  Then\nwe need to create a NATIVE application.  This represents the client: in our case, the ADAL (Active Directory\nAccess Library) library will need this information.  Finally, we need to give the NATIVE application permission\nto access the WEB application.  It starts with configuring a server-flow to protect the resource.  We've already done that above. Then configure\na \"Native Application\" and give it permissions to the web application:   Log on to the  Classic Portal .  Select the  Default Directory  from your list of all items.  Click on the  APPLICATIONS  tab.     Note that our existing web application is already there.  You will see more applications, depending on what you\n  have set up.  In this example, I have Visual Studio Team Services and Office 365 set up.  Click on the  ADD  button at the bottom of the page.     Click on  Add an application my organization is developing .     Enter a name for the app registration, and select  NATIVE CLIENT APPLICATION .  Click on the Next arrow.  Enter a valid URI - it can be anything, but it has to be valid     Click on the tick to create the application.  The wizard will close, but you will be brought to the app configuration.  Click on the  CONFIGURE  tab.     Add a Redirect URI of the form:  https://yoursite.azurewebsites.net/.auth/login/done .     At the bottom of the page is the  permissions to other applications  section.  Click on the  Add application  button.     Click on the  SHOW  drop-down and select  All Apps , then click on the tick next to the search box.  Click on the web application that you set up during the server-flow configuration, then click on the  tick in\n  the lower-right corner.     Click on  Delegated Permissions  next to the web application.  Check the box next to  Access , then click\n  on  Save  at the bottom of the screen.    At this point the application configuration will be saved.  So, what did we just do there?  We created a new Azure AD app for the native application.  We then gave permission\nfor the native application to access resources that are protected by the web application.  In our Azure App Service,\nwe configured the service so that the Azure AD web application is used to protect our resources.  The net effect is\n that our native application OR our web application can access the App Service resources that are protected via the\n  [Authorize]  attribute.  Before continuing, you will need the  Client ID  and the  Redirect URI  for the NATIVE application. You can enter\nthese into the  Helpers\\Locations.cs  file in the shared project:  namespace TaskList.Helpers\n{\n    public static class Locations\n    {\n        public static readonly string AppServiceUrl = \"https://the-book.azurewebsites.net\";\n\n        public static readonly string AadClientId = \"b61c7d68-2086-43a1-a8c9-d93c5732cc84\";\n\n        public static readonly string AadRedirectUri = \"https://the-book.azurewebsites.net/.auth/login/done\";\n\n        public static readonly string AadAuthority = \"https://login.windows.net/photoadrianoutlook.onmicrosoft.com\";\n    }\n}  The  AadClientId  and  AadRedirectUri  must match what we have configured in Azure AD for the native app.  The\nother piece of information we need to add is the Azure AD Authority for the directory.  If you click on the DOMAINS  tab, it will generally tell you what domain you are in. The Authority is just a path on the https://login.windows.net  that corresponds to your domain.  There is also a GUID version of this domain.  You\ncan find the GUID by looking at the  View Endpoints  in the  APPLICATIONS  tab.  Look at the first path section\nof most all the endpoints.  Add the  Microsoft.IdentityModel.Clients.ActiveDirectory  NuGet package using  Manage NuGet Packages...  to\neach platform project.  This package contains the ADAL library as a portable class library.   Now you can add the client flow to each project.  Start with the login provider in the  TaskList.UWP  project,\nlocated in the  Services\\UWPLoginProvider.cs  file:  using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.UWP.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync()\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters(PromptBehavior.Auto, false));\n            return authResult.AccessToken;\n        }\n\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginADALAsync();\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server-Flow Version\n            // await client.LoginAsync(\"aad\");\n        }\n    }\n}  The  LoginADALAsync()  method does the actual client-flow - using the ADAL library to authenticate the user and\nreturn the access token.  The  LoginAsync()  method initiates the client-flow.  It uses the token it receives\nfrom the client-flow to log in to the App Service, by packaging the token into a JSON object.  I have placed\nthe client and server flow next to each other so you can compare the two.  In the  TaskList.Droid  project, we need to deal with the  Context , as is common with Android libraries.  The\nclient flow in  Services\\DroidLoginProvider.cs  is remarkably similar though:  using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Android.App;\nusing Android.Content;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\nusing TaskList.Helpers;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        Context context;\n\n        public void Init(Context context)\n        {\n            this.context = context;\n        }\n\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync()\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters((Activity)context));\n            return authResult.AccessToken;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginADALAsync();\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server-Flow Version\n            // await client.LoginAsync(context, \"aad\");\n        }\n    }\n}  The only real difference between this one and the Universal Windows edition is the PlatformParameters. We need to\npass in the context of the MainActivity (which is passed in through the  Init()  call).  However, we must also handle\nthe response from the ADAL library.  This is done in  MainActivity.cs . Add the following method to the  MainActivity \nclass:  protected override void OnActivityResult(int requestCode, Result resultCode, Intent data)\n{\n    base.OnActivityResult(requestCode, resultCode, data);\n    AuthenticationAgentContinuationHelper.SetAuthenticationAgentContinuationEventArgs(requestCode, resultCode, data);\n}  Finally, the iOS version also requires access to the root view, so its  PlatformParameters  are also slightly\ndifferent.  Here is  Services\\iOSLoginProvider.cs :  using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.iOS.Services;\nusing UIKit;\n\n[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]\nnamespace TaskList.iOS.Services\n{\n    public class iOSLoginProvider : ILoginProvider\n    {\n        /// <summary>\n        /// Login via ADAL\n        /// </summary>\n        /// <returns>(async) token from the ADAL process</returns>\n        public async Task<string> LoginADALAsync(UIViewController view)\n        {\n            Uri returnUri = new Uri(Locations.AadRedirectUri);\n\n            var authContext = new AuthenticationContext(Locations.AadAuthority);\n            if (authContext.TokenCache.ReadItems().Count() > 0)\n            {\n                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);\n            }\n            var authResult = await authContext.AcquireTokenAsync(\n                Locations.AppServiceUrl, /* The resource we want to access  */\n                Locations.AadClientId,   /* The Client ID of the Native App */\n                returnUri,               /* The Return URI we configured    */\n                new PlatformParameters(view));\n            return authResult.AccessToken;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            var rootView = UIApplication.SharedApplication.KeyWindow.RootViewController;\n\n            // Client Flow\n            var accessToken = await LoginADALAsync(rootView);\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"aad\", zumoPayload);\n\n            // Server Flow\n            //await client.LoginAsync(rootView, \"aad\");\n        }\n    }\n}  Note that we can balance the needs of each platform by using the dependency service.  The code that is unique to\nthe platform is minimized and stored with the platform.  If you aren't interested in social authentication (Facebook, Google, Microsoft or Twitter authentication providers),\nyou can  skip the Social Authentication section .",
            "title": "Azure Active Directory: Client-Flow Setup"
        },
        {
            "location": "/chapter2/social/",
            "text": "Social Authentication\n\u00b6\n\n\nAzure App Service provides built-in support for Facebook, Google, Microsoft and Twitter.  Irrespective of whether\nyou intend to use server-flow or client-flow, you will need to configure the Azure App Service Authentication /\nAuthorization service.  The method is pretty similar in each case:\n\n\n\n\nObtain a Developer Account for the provider.\n\n\nCreate a new application, obtaining a Client ID and Secret.\n\n\nTurn on Azure App Service Authentication.\n\n\nEnter the Client ID and Secret into the specific provider setup.\n\n\nSave the configuration.\n\n\n\n\nBefore you start any of this, create a new Azure Mobile Apps as we described in \nChapter 1\n.  If you want\na site to deploy for the configuration, the \nBackend\n project in the \nChapter2\n solution is pre-configured for\nauthorization. You just need to deploy it to Azure App Service.\n\n\nFacebook Configuration\n\u00b6\n\n\nI am going to assume you have a Facebook account already.  If you do not have a Facebook account, go to \nFacebook\n\nand sign up.  All your friends are likely there already!  Now log in to the \nFacebook Developers\n web site.  Create\na new Facebook application:\n\n\n\n\nNote\n: Facebook updates the look and feel of their developer site on a regular basis.  As a result, the screen shots\nI have provided here may be different.  If in doubt, follow the bullet descriptions to find your way.\n\n\n\n\nIf you are not already registered, click on the drop-down in the top-right corner and \nRegister as a Developer\n\nbefore continuing.\n\n\n\n\n\n\nClick on the \nMy Apps\n link in the top right corner of the screen.\n\n\nClick on \nCreate a New App\n.\n\n\nFill in the form:\n\n\n\n\n\n\n\n\n\n\nIf required, verify your account according to the instructions.  This usually involves adding a credit card number\nor verifying your mobile phone number.\n\n\n\n\n\n\nClick on the \nGet Started\n button next to \nFacebook Login\n.\n\n\n\n\n\n\n\n\n\n\nEnter your application URL + \n/.auth/login/facebook/callback\n in the \nValid OAuth redirect URIs\n.\n\n\n\n\n\n\n\n\nClick on \nSave Changes\n.\n\n\nClick on the \nSettings\n -> \nBasic\n in the left hand side-bar.\n\n\nClick on the \nShow\n button next to the App Secret\n\n\n\n\nNow that you have the \nApp ID\n and \nApp Secret\n, you can continue configuration of your app within the\n\nAzure Portal\n.\n\n\n\n\nOpen up your App Service by clicking on \nAll Resources\n or \nApp Services\n followed by the name of your app service.\n\n\nIn the \nSettings\n blade, click on \nAuthentication / Authorization\n which is under \nFeatures\n.\n\n\nTurn \nApp Service Authentication\n to \nOn\n.\n\n\nIn the \nAction to take when request is not authenticated\n, select \nAllow Request (no action)\n.\n\n\n\n\n\n\nIt is very tempting to choose \nLog in with Facebook\n.  However, you need to avoid this.  Selecting this option\nwill mean that all requests need to be authenticated and you will not get the information about the identity on the\nback end.  Selecting \nAllow Request\n means your app is in charge of what gets authenticated and what does not\nrequire authentication.\n\n\n\n\n\n\nClick on \nFacebook\n (which should show \nNot Configured\n).\n\n\nCut and Paste the \nApp ID\n and \nApp Secret\n into the boxes provided.\n\n\nSelect \npublic_profile\n and \nemail\n for Scopes.\n\n\n\n\n\n\nNote that if you request anything but public_profile, user_friends, and email, your app will need further review by\nFacebook, which will take time.  This process is not worth it for test apps like this one.\n\n\n\n\n\n\nClick on \nOK\n (at the bottom of the blade) to close the Facebook configuration blade.\n\n\nClick on \nSave\n (at the top of the blade) to save your Authentication changes.\n\n\n\n\nYou can test your authentication process by browsing to https://\nyoursite\n.azurewebsites.net/.auth/login/facebook;\nthis is the same endpoint that the Azure Mobile Apps Client SDK calls when it is time to integrate authentication\ninto the mobile client.\n\n\n\n\nIf you are not logged in to facebook already, you will be prompted for your facebook credentials first.  Finally,\nhere is your happy page - the page that signifies you have done everything right:\n\n\n\n\n\n\nMinimal Permissions\n  Every single OAuth provider will ask you what sort of information you want to have access\nto.  These \"claims\" translate into permissions.  The more permissions you request, the less likely the user is going\nto accept them.  Be a good net citizen and only request the information you are actually going to use.\n\n\n\n\nGoogle Configuration\n\u00b6\n\n\nIt should be no shock that you need a \nGoogle Account\n to get started.  If you do not have one already (or you\nwant a different account for your development activities), create a new account now.  Then log in to the\n\nGoogle Developer Portal\n.  Click on the \nCreate Project\n link at the top:\n\n\n\n\nEnter a nice name (like mine) and click on \nCreate\n.  The screen will show the progress and eventually the project\nwill be listed in the \nAll Projects\n list.  It takes about 30 seconds to create a project.  Once you have your\nGoogle project, click on it to see all the wonderful things you can add to your project:\n\n\n\n\nThere is no \"Google Login\" that can guide you here.  The API you need to add is called \nGoogle+\n and is listed under\nthe \nSocial APIs\n.  Click on it, then click on \nEnable\n at the top of the screen.\n\n\nJust because it is enabled does not mean you automatically get to use it.  Click on \nCredentials\n link in the\nleft-hand side bar.  You will also see a \"Go to Credentials\" button at the top of the screen, but it does not take\nyou to the same screen, so do not click it.\n\n\nOn the Crendetials screen, click on the \nOAuth consent screen\n tab:\n\n\n\n\nFill in the form and click on \nSave\n.  This brings up the next step - creating credentials.  Click on the\n\nCreate Credentials\n button.  This pops up a drop-down menu.  You want the \nOAuth Client ID\n.\n\n\n\n\nThe specific type of client ID you want is a \nWeb Application\n.  The server flow version of the application is\na web-based form authentication, which matches the \nWeb Application\n version of the Client ID.\n\n\nWhen you select \nWeb Application\n, you will get another form:\n\n\n\n\nEnter the URL of your App Service in the \nAuthorized JavaScript origins\n box, and the URL +\n\n/.auth/login/google/callback\n into the \nAuthorized redirect URIs\n box, then click on \nCreate\n.\n\n\n\n\nGoogle is one of those providers that requires authentication redirect URIs to be secure - so ensure you use the\nhttps version of your URL.\n\n\n\n\nAt this point, Google will show you the Client ID and Client Secret for your app.  You can also get the Client ID and\nClient Secret from the interface by clicking on the \nCredentials\n link on the left-hand side bar.\n\n\nThe process from here is practically the same as Facebook.  Open your App Service within the Azure Portal, click on\n\nAll Settings\n, then \nAuthentication / Authorization\n and finally \nGoogle\n (assuming you have already turned\non the authentication service).  Cut and paste the Client ID and Client Secret into the boxes provided.  Click on\n\nOK\n (at the bottom) followed by \nSave\n (at the top of the page).\n\n\n\n\nYou can define multiple providers at the same time.  The code in the client determines what authentication mechanism\ngets used.\n\n\n\n\nYou can test this just like Facebook.  Go to https://\nyoursite\n/.auth/login/google with your browser.  You should get\nsomething like the following:\n\n\n\n\nConfirming here should get us to the same happy screen we achieved with Facebook.\n\n\nIf you happen to mis-type the Authorized redirect URI, Google will tell you that the URI is wrong.  I inevitably swap\nhttp for https.  When this happens, it is an easy fix, but you have to wait a few minutes before the authentication\nsystem updates itself.\n\n\nMicrosoft Account Configuration\n\u00b6\n\n\nThe advantage of the Microsoft Account (or MSA, as it is known) is that you already have an account - you need one for\nAzure.  So this is the first time I am not going to explicitly tell you to sign up for an account.\n\n\nYour first step is to go to the \nMicrosoft Account Developer Center\n and log on with your Microsoft account.  You\nshould use the same one as you use for Azure, but it is not required.\n\n\n\n\nJust to confuse us, there are two \nAdd an App\n buttons. Strangely, they are different. Click on the one next to\n\nMy applications\n.\n\n\n\n\nEnter an awesome name and click on \nCreate application\n.\n\n\n\n\nClick on \nAdd Platform\n, followed by \nWeb\n.  In the \nRedirect URIs\n, enter your app URL +\n\n/.auth/login/microsoftaccount/callback\n. Then click on \nSave\n.\n\n\n\n\nNow click on \nGenerate New Password\n under \nApplication Secrets\n.\n\n\n\n\nUnlike the other social providers, this is the only time you will get to see your client secret, so make a note of it\nor cut and paste it into a notepad.  Once you have it copied somewhere, click on \nOK\n, followed by \nSave\n.\n\n\nYou now have all the information you need to configure the Microsoft Account section within your App Server\nAuthentication / Authorization.  The Client ID you need to enter is the Application ID and the Client Secret is the\npassword you just copied somewhere.\n\n\n\n\nNote that you have to choose claims that you want to read.  The \nwl.basic\n and \nwl.emails\n will give you enough\ninformation to get started with this tutorial.\n\n\nClick on \nOK\n (at the bottom), followed by \nSave\n (at the top).  You can test the settings by pointing your browser\nto https://\nyoursite\n.azurewebsites.net/.auth/login/microsoftaccount.  You will see what should be a normal claims\nrequest page:\n\n\n\n\nClicking on \nYes\n should take you to the normal success page.\n\n\nTwitter Configuration\n\u00b6\n\n\nI hope you are seeing that all the OAuth providers take a very similar route to configuring their service.  The\nsemantics of the service are slightly different in each case.  Twitter is no different.  As you might expect, before\ncontinuing, sign up for \nTwitter\n.  Once you have signed up, the \nTwitter Developers Portal\n is your next stop.\nOnce there, you can click on \nCreate New App\n:\n\n\n\n\nMost of the fields are self-explanatory.  The \nCallback URL\n is the same thing that the other social providers have\ncalled the Redirect URL.  The appropriate value is your app URL + \n/.auth/login/twitter/callback\n.  There is a legal\nagreement at the bottom of the page, then you can click on \nCreate your Twitter application\n button.\n\n\n\n\nAll social authentication providers have some sort of legal agreement that governs their use.  In general, demo or\nPoC apps are fair use.  However, you should get a legal opinion before using a social authentication provider in a\nproduction app.\n\n\n\n\nOnce you have created the app, you will get a tabbed display with all the settings.  Click on the \nKeys and Access\nTokens\n tab:\n\n\n\n\nNote the values for the \nConsumer Key (API Key)\n and \nConsumer Secret (API Secret)\n.  They get entered into the\nAzure Portal.\n\n\n\n\nThere is a check box in the \nSettings\n tab that says \nAllow this application to be used to Sign in with Twitter\n.\nAt the time of writing, this is checked by default.  However, if you find you can not log in for some reason, then\nensure this checkbox is checked.\n\n\n\n\nBack in the Azure Portal, select your app service, then \nAll Settings\n, \nAuthentication / Authorization\n, and\nfinally \nTwitter\n (assuming you have already turned Authentication on).  You can now cut and paste the Consumer\nKey and Consumer Secret into the appropriate boxes, before clicking on \nOK\n (at the bottom) followed by \nSave\n\n(at the top).\n\n\nAs with the other providers, you should test the authentication flow by pointing your browser to\nhttps://\nyoursite\n.azurewebsites.net/.auth/login/twitter.\n\n\n\n\nClicking on \nAuthorize app\n should show you our normal successful authentication screen.\n\n\nThe social authentication providers should now all be configured to handle a web-based or server-flow authentication\nrequest.  There are times when configuring a client-flow authentication is different.  We will point those out when we\nget to them.\n\n\nAdding Authentication to a Mobile Client\n\u00b6\n\n\nNow that the backend is completely configured, we can move our attention to the mobile client.  We are going to be\nusing the same mobile client that we developed in the first chapter, but we are now going to add authentication to\nit.  Web views are one of those items that are platform dependent. Fortunately for us, Xamarin has already thought\nof this and provided a facility for running platform specific code called the \nDependencyService\n.\n\n\n\n\nIf you have already implemented authentication during the Enterprise Authentication section, this code is the\nsame.  You just have to alter the provider name.\n\n\nIf we run our application right now, clicking on the \"Enter the App\" button will result in an error.  You will be\nable to see the Unauthorized error in the debug window of Visual Studio.\n\n\n\n\nOur first step is to define an \nAbstractions\\ILoginProvider.cs\n interface within the  shared project:\n\n\nusing Microsoft.WindowsAzure.MobileServices;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ILoginProvider\n    {\n        Task LoginAsync(MobileServiceClient client);\n    }\n}\n\n\n\n\nNext, we are going to extend our \nAbstractions\\ICloudService.cs\n interface so that the main application can call\nthe login routine:\n\n\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n    }\n}\n\n\n\n\nOur code will call \nLoginAsync()\n in the \nICloudService\n, which will get the platform-specific version of the\nlogin provider and call \nLoginAsync()\n there, but with our defined mobile service client.  That is defined in the\n\nServices\\AzureCloudService.cs\n class:\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing Xamarin.Forms;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(Locations.AppServiceUrl);\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData => new AzureCloudTable<T>(client);\n\n        public Task LoginAsync()\n        {\n            var loginProvider = DependencyService.Get<ILoginProvider>();\n            return loginProvider.LoginAsync(client);\n        }\n    }\n}\n\n\n\n\nThe method looks up the platform dependent version of the login provider and executes the login method, passing\nalong the client (which we will need later).\n\n\nIn each platform-specific project, we are going to define a concrete implementation of the login provider that uses\na web view to hold the actual authentication flow.  Here is the droid \nServices\\DroidLoginProvider.cs\n (in the\nTaskList.Droid project):\n\n\nusing System.Threading.Tasks;\nusing Android.Content;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        Context context;\n\n        public void Init(Context context)\n        {\n            this.context = context;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(context, \"facebook\");\n        }\n    }\n}\n\n\n\n\n\n\nReplace \"facebook\" with \"google\", \"microsoftaccount\" or \"twitter\", depending on your identity provider.\n\n\n\n\nLet us take a closer look at this implementation.  The \nLoginAsync()\n method on the Azure Mobile Apps client object\ntakes the Android context (which is normally the main window) and a provider - we can pick any of \"facebook\",\n\"google\", \"microsoftaccount\", \"twitter\" or \"aad\" depending on what we have defined in the Azure App Service.  The\nclever piece is the \nXamarin.Forms.Dependency\n call at the top - that registers the class as a platform service\nso we can access it through the Xamarin dependency service.\n\n\nNote that we need an extra initialization routine for Android that must be called prior the login provider being\ncalled to pass along the main window of the app (also known as the context).  This is done in the \nMainActivity.cs\n\nfile \nafter\n the Xamarin Forms initialization call.  The dependency service is not set up until after the Xamarin\nForms library is initialized, so we will not be able to get the login provider reference before that point:\n\n\nprotected override void OnCreate(Bundle bundle)\n{\n    base.OnCreate(bundle);\n\n    Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n    global::Xamarin.Forms.Forms.Init(this, bundle);\n\n    ((DroidLoginProvider)DependencyService.Get<ILoginProvider>()).Init(this);\n\n    LoadApplication(new App());\n}\n\n\n\n\niOS is similar, but does not require the initialization step in the main startup class.  The login provider class\nis in \nServices\\iOSLoginProvider.cs\n (in the \nTaskList.iOS\n project):\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.iOS.Services;\nusing UIKit;\n\n[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]\nnamespace TaskList.iOS.Services\n{\n    public class iOSLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(RootView, \"facebook\");\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n    }\n}\n\n\n\n\nNote that we are using the same pattern here for registering the concrete implementation with the dependency service,\nso we can get it the same way. Finally, here is the UWP \nServices\\UWPLoginProvider.cs\n (in the TaskList.UWP project):\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.UWP.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(\"facebook\");\n        }\n    }\n}\n\n\n\n\nNow that we have all the platform-specific login routines registered, we can move on to adding the login routine to\nthe UI.  We have already got a button on the entry page to enter the app.  It makes sense to wire up that button so\nthat it logs us in as well. The Command for the login button is in the \nViewModels\\EntryPageViewModel.cs\n:\n\n\nasync Task ExecuteLoginCommand()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var cloudService = ServiceLocator.Instance.Resolve<ICloudService>();\n        await cloudService.LoginAsync();\n        Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n    }\n    catch (Exception ex)\n    {\n        Debug.WriteLine($\"[ExecuteLoginCommand] Error = {ex.Message}\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}\n\n\n\n\n\n\nThe \nServiceLocator\n class is my basic singleton handler.  It is available in the \nChapter2\n project.  It\nreturns the concrete version of the cloud service, just like the Singleton version we defined in Chapter1.\n\n\n\n\nWhen you run the application, clicking on the \"Enter the App\" button will now present you with an Authenticate window:\n\n\n![AAD Authenticate][img58]\n\n\nGoing through the authentication process will get you to the task list again.  If the authentication process fails,\nthen \nLoginAsync()\n will throw an error, which is caught at the ViewModel.  Right now, the \nEntryPageViewModel\n\ndoes nothing more than print a diagnostic message to the debug window of Visual Studio.\n\n\nClient-Flow for Social Providers\n\u00b6\n\n\nIn each of the social providers, the identity provider SDK (provided by Facebook, Google, or Twitter) will need to be\nintegrated.  In general, these SDKs are provided for a native platform (Objective-C or Swift for iOS, Java for Android),\nuse callbacks or delegates (as is common practice in native libraries) and are thus more complicated to integrate with\nyour mobile client than those that have a C#/.NET SDK delivered on NuGet.\n\n\nThe reward for doing so are a more integrated experience on mobile devices.  For example, if you integrate the Google\nPlay Services SDK in an Android app, the app will seamlessly authenticate itself with the connected Google account in\nthe background, avoiding the need for repeatedly authenticating the client.  It may ask for a fingerprint instead if\nthe app is not trusted.  If you integrate the Facebook SDK, then the app will automatically switch to the Facebook app\nand ask you to approve the authentication request there instead of authenticating the user through a web view.  Both\nof these provide a more integrated experience for the end user, so this work is well worth pursuing.\n\n\nAs an example, here is the client flow for Facebook.  I've implemented this using the \nXamarin.Facebook.iOS\n library,\nwhich can be downloaded and installed into the iOS project from NuGet.  The \nServices\\iOSLoginProvider.cs\n contains\nthe following:\n\n\n        #region Facebook Client Flow\n        private TaskCompletionSource<string> fbtcs;\n\n        public async Task<string> LoginFacebookAsync()\n        {\n            fbtcs = new TaskCompletionSource<string>();\n            var loginManager = new LoginManager();\n\n            loginManager.LogInWithReadPermissions(new[] { \"public_profile\" }, RootView, LoginTokenHandler);\n            return await fbtcs.Task;\n        }\n\n        private void LoginTokenHandler(LoginManagerLoginResult loginResult, NSError error)\n        {\n            if (loginResult.Token != null)\n            {\n                fbtcs.TrySetResult(loginResult.Token.TokenString);\n            }\n            else\n            {\n                fbtcs.TrySetException(new Exception(\"Facebook Client Flow Login Failed\"));\n            }\n        }\n        #endregion\n\n\n\n\nNote the use of a \nTaskCompletionSource<>()\n here.  This is used often to convert callback APIs into awaitable APIs.\nWe set off the async call with the callback, then await on the completion (which is signified by the\n\nTaskCompletionSource\n).  When the callback is called, it sets the value of the \nTaskCompletionSource\n (or causes\nan exception) and that causes the task to complete.\n\n\nThe \nLoginAsync()\n method can now be updated like this:\n\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            var accessToken = await LoginFacebookAsync();\n\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"facebook\", zumoPayload);\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n\n\n\n\nWith this version, clicking on the login button will seamlessly switch into the Facebook application and ask the\nuser to confirm the request, before switching back authenticated.",
            "title": "Social Authentication"
        },
        {
            "location": "/chapter2/social/#social-authentication",
            "text": "Azure App Service provides built-in support for Facebook, Google, Microsoft and Twitter.  Irrespective of whether\nyou intend to use server-flow or client-flow, you will need to configure the Azure App Service Authentication /\nAuthorization service.  The method is pretty similar in each case:   Obtain a Developer Account for the provider.  Create a new application, obtaining a Client ID and Secret.  Turn on Azure App Service Authentication.  Enter the Client ID and Secret into the specific provider setup.  Save the configuration.   Before you start any of this, create a new Azure Mobile Apps as we described in  Chapter 1 .  If you want\na site to deploy for the configuration, the  Backend  project in the  Chapter2  solution is pre-configured for\nauthorization. You just need to deploy it to Azure App Service.",
            "title": "Social Authentication"
        },
        {
            "location": "/chapter2/social/#facebook-configuration",
            "text": "I am going to assume you have a Facebook account already.  If you do not have a Facebook account, go to  Facebook \nand sign up.  All your friends are likely there already!  Now log in to the  Facebook Developers  web site.  Create\na new Facebook application:   Note : Facebook updates the look and feel of their developer site on a regular basis.  As a result, the screen shots\nI have provided here may be different.  If in doubt, follow the bullet descriptions to find your way.   If you are not already registered, click on the drop-down in the top-right corner and  Register as a Developer \nbefore continuing.    Click on the  My Apps  link in the top right corner of the screen.  Click on  Create a New App .  Fill in the form:      If required, verify your account according to the instructions.  This usually involves adding a credit card number\nor verifying your mobile phone number.    Click on the  Get Started  button next to  Facebook Login .      Enter your application URL +  /.auth/login/facebook/callback  in the  Valid OAuth redirect URIs .     Click on  Save Changes .  Click on the  Settings  ->  Basic  in the left hand side-bar.  Click on the  Show  button next to the App Secret   Now that you have the  App ID  and  App Secret , you can continue configuration of your app within the Azure Portal .   Open up your App Service by clicking on  All Resources  or  App Services  followed by the name of your app service.  In the  Settings  blade, click on  Authentication / Authorization  which is under  Features .  Turn  App Service Authentication  to  On .  In the  Action to take when request is not authenticated , select  Allow Request (no action) .    It is very tempting to choose  Log in with Facebook .  However, you need to avoid this.  Selecting this option\nwill mean that all requests need to be authenticated and you will not get the information about the identity on the\nback end.  Selecting  Allow Request  means your app is in charge of what gets authenticated and what does not\nrequire authentication.    Click on  Facebook  (which should show  Not Configured ).  Cut and Paste the  App ID  and  App Secret  into the boxes provided.  Select  public_profile  and  email  for Scopes.    Note that if you request anything but public_profile, user_friends, and email, your app will need further review by\nFacebook, which will take time.  This process is not worth it for test apps like this one.    Click on  OK  (at the bottom of the blade) to close the Facebook configuration blade.  Click on  Save  (at the top of the blade) to save your Authentication changes.   You can test your authentication process by browsing to https:// yoursite .azurewebsites.net/.auth/login/facebook;\nthis is the same endpoint that the Azure Mobile Apps Client SDK calls when it is time to integrate authentication\ninto the mobile client.   If you are not logged in to facebook already, you will be prompted for your facebook credentials first.  Finally,\nhere is your happy page - the page that signifies you have done everything right:    Minimal Permissions   Every single OAuth provider will ask you what sort of information you want to have access\nto.  These \"claims\" translate into permissions.  The more permissions you request, the less likely the user is going\nto accept them.  Be a good net citizen and only request the information you are actually going to use.",
            "title": "Facebook Configuration"
        },
        {
            "location": "/chapter2/social/#google-configuration",
            "text": "It should be no shock that you need a  Google Account  to get started.  If you do not have one already (or you\nwant a different account for your development activities), create a new account now.  Then log in to the Google Developer Portal .  Click on the  Create Project  link at the top:   Enter a nice name (like mine) and click on  Create .  The screen will show the progress and eventually the project\nwill be listed in the  All Projects  list.  It takes about 30 seconds to create a project.  Once you have your\nGoogle project, click on it to see all the wonderful things you can add to your project:   There is no \"Google Login\" that can guide you here.  The API you need to add is called  Google+  and is listed under\nthe  Social APIs .  Click on it, then click on  Enable  at the top of the screen.  Just because it is enabled does not mean you automatically get to use it.  Click on  Credentials  link in the\nleft-hand side bar.  You will also see a \"Go to Credentials\" button at the top of the screen, but it does not take\nyou to the same screen, so do not click it.  On the Crendetials screen, click on the  OAuth consent screen  tab:   Fill in the form and click on  Save .  This brings up the next step - creating credentials.  Click on the Create Credentials  button.  This pops up a drop-down menu.  You want the  OAuth Client ID .   The specific type of client ID you want is a  Web Application .  The server flow version of the application is\na web-based form authentication, which matches the  Web Application  version of the Client ID.  When you select  Web Application , you will get another form:   Enter the URL of your App Service in the  Authorized JavaScript origins  box, and the URL + /.auth/login/google/callback  into the  Authorized redirect URIs  box, then click on  Create .   Google is one of those providers that requires authentication redirect URIs to be secure - so ensure you use the\nhttps version of your URL.   At this point, Google will show you the Client ID and Client Secret for your app.  You can also get the Client ID and\nClient Secret from the interface by clicking on the  Credentials  link on the left-hand side bar.  The process from here is practically the same as Facebook.  Open your App Service within the Azure Portal, click on All Settings , then  Authentication / Authorization  and finally  Google  (assuming you have already turned\non the authentication service).  Cut and paste the Client ID and Client Secret into the boxes provided.  Click on OK  (at the bottom) followed by  Save  (at the top of the page).   You can define multiple providers at the same time.  The code in the client determines what authentication mechanism\ngets used.   You can test this just like Facebook.  Go to https:// yoursite /.auth/login/google with your browser.  You should get\nsomething like the following:   Confirming here should get us to the same happy screen we achieved with Facebook.  If you happen to mis-type the Authorized redirect URI, Google will tell you that the URI is wrong.  I inevitably swap\nhttp for https.  When this happens, it is an easy fix, but you have to wait a few minutes before the authentication\nsystem updates itself.",
            "title": "Google Configuration"
        },
        {
            "location": "/chapter2/social/#microsoft-account-configuration",
            "text": "The advantage of the Microsoft Account (or MSA, as it is known) is that you already have an account - you need one for\nAzure.  So this is the first time I am not going to explicitly tell you to sign up for an account.  Your first step is to go to the  Microsoft Account Developer Center  and log on with your Microsoft account.  You\nshould use the same one as you use for Azure, but it is not required.   Just to confuse us, there are two  Add an App  buttons. Strangely, they are different. Click on the one next to My applications .   Enter an awesome name and click on  Create application .   Click on  Add Platform , followed by  Web .  In the  Redirect URIs , enter your app URL + /.auth/login/microsoftaccount/callback . Then click on  Save .   Now click on  Generate New Password  under  Application Secrets .   Unlike the other social providers, this is the only time you will get to see your client secret, so make a note of it\nor cut and paste it into a notepad.  Once you have it copied somewhere, click on  OK , followed by  Save .  You now have all the information you need to configure the Microsoft Account section within your App Server\nAuthentication / Authorization.  The Client ID you need to enter is the Application ID and the Client Secret is the\npassword you just copied somewhere.   Note that you have to choose claims that you want to read.  The  wl.basic  and  wl.emails  will give you enough\ninformation to get started with this tutorial.  Click on  OK  (at the bottom), followed by  Save  (at the top).  You can test the settings by pointing your browser\nto https:// yoursite .azurewebsites.net/.auth/login/microsoftaccount.  You will see what should be a normal claims\nrequest page:   Clicking on  Yes  should take you to the normal success page.",
            "title": "Microsoft Account Configuration"
        },
        {
            "location": "/chapter2/social/#twitter-configuration",
            "text": "I hope you are seeing that all the OAuth providers take a very similar route to configuring their service.  The\nsemantics of the service are slightly different in each case.  Twitter is no different.  As you might expect, before\ncontinuing, sign up for  Twitter .  Once you have signed up, the  Twitter Developers Portal  is your next stop.\nOnce there, you can click on  Create New App :   Most of the fields are self-explanatory.  The  Callback URL  is the same thing that the other social providers have\ncalled the Redirect URL.  The appropriate value is your app URL +  /.auth/login/twitter/callback .  There is a legal\nagreement at the bottom of the page, then you can click on  Create your Twitter application  button.   All social authentication providers have some sort of legal agreement that governs their use.  In general, demo or\nPoC apps are fair use.  However, you should get a legal opinion before using a social authentication provider in a\nproduction app.   Once you have created the app, you will get a tabbed display with all the settings.  Click on the  Keys and Access\nTokens  tab:   Note the values for the  Consumer Key (API Key)  and  Consumer Secret (API Secret) .  They get entered into the\nAzure Portal.   There is a check box in the  Settings  tab that says  Allow this application to be used to Sign in with Twitter .\nAt the time of writing, this is checked by default.  However, if you find you can not log in for some reason, then\nensure this checkbox is checked.   Back in the Azure Portal, select your app service, then  All Settings ,  Authentication / Authorization , and\nfinally  Twitter  (assuming you have already turned Authentication on).  You can now cut and paste the Consumer\nKey and Consumer Secret into the appropriate boxes, before clicking on  OK  (at the bottom) followed by  Save \n(at the top).  As with the other providers, you should test the authentication flow by pointing your browser to\nhttps:// yoursite .azurewebsites.net/.auth/login/twitter.   Clicking on  Authorize app  should show you our normal successful authentication screen.  The social authentication providers should now all be configured to handle a web-based or server-flow authentication\nrequest.  There are times when configuring a client-flow authentication is different.  We will point those out when we\nget to them.",
            "title": "Twitter Configuration"
        },
        {
            "location": "/chapter2/social/#adding-authentication-to-a-mobile-client",
            "text": "Now that the backend is completely configured, we can move our attention to the mobile client.  We are going to be\nusing the same mobile client that we developed in the first chapter, but we are now going to add authentication to\nit.  Web views are one of those items that are platform dependent. Fortunately for us, Xamarin has already thought\nof this and provided a facility for running platform specific code called the  DependencyService .   If you have already implemented authentication during the Enterprise Authentication section, this code is the\nsame.  You just have to alter the provider name.  If we run our application right now, clicking on the \"Enter the App\" button will result in an error.  You will be\nable to see the Unauthorized error in the debug window of Visual Studio.   Our first step is to define an  Abstractions\\ILoginProvider.cs  interface within the  shared project:  using Microsoft.WindowsAzure.MobileServices;\nusing System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ILoginProvider\n    {\n        Task LoginAsync(MobileServiceClient client);\n    }\n}  Next, we are going to extend our  Abstractions\\ICloudService.cs  interface so that the main application can call\nthe login routine:  using System.Threading.Tasks;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n    }\n}  Our code will call  LoginAsync()  in the  ICloudService , which will get the platform-specific version of the\nlogin provider and call  LoginAsync()  there, but with our defined mobile service client.  That is defined in the Services\\AzureCloudService.cs  class:  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing Xamarin.Forms;\n\nnamespace TaskList.Services\n{\n    public class AzureCloudService : ICloudService\n    {\n        MobileServiceClient client;\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(Locations.AppServiceUrl);\n        }\n\n        public ICloudTable<T> GetTable<T>() where T : TableData => new AzureCloudTable<T>(client);\n\n        public Task LoginAsync()\n        {\n            var loginProvider = DependencyService.Get<ILoginProvider>();\n            return loginProvider.LoginAsync(client);\n        }\n    }\n}  The method looks up the platform dependent version of the login provider and executes the login method, passing\nalong the client (which we will need later).  In each platform-specific project, we are going to define a concrete implementation of the login provider that uses\na web view to hold the actual authentication flow.  Here is the droid  Services\\DroidLoginProvider.cs  (in the\nTaskList.Droid project):  using System.Threading.Tasks;\nusing Android.Content;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        Context context;\n\n        public void Init(Context context)\n        {\n            this.context = context;\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(context, \"facebook\");\n        }\n    }\n}   Replace \"facebook\" with \"google\", \"microsoftaccount\" or \"twitter\", depending on your identity provider.   Let us take a closer look at this implementation.  The  LoginAsync()  method on the Azure Mobile Apps client object\ntakes the Android context (which is normally the main window) and a provider - we can pick any of \"facebook\",\n\"google\", \"microsoftaccount\", \"twitter\" or \"aad\" depending on what we have defined in the Azure App Service.  The\nclever piece is the  Xamarin.Forms.Dependency  call at the top - that registers the class as a platform service\nso we can access it through the Xamarin dependency service.  Note that we need an extra initialization routine for Android that must be called prior the login provider being\ncalled to pass along the main window of the app (also known as the context).  This is done in the  MainActivity.cs \nfile  after  the Xamarin Forms initialization call.  The dependency service is not set up until after the Xamarin\nForms library is initialized, so we will not be able to get the login provider reference before that point:  protected override void OnCreate(Bundle bundle)\n{\n    base.OnCreate(bundle);\n\n    Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();\n\n    global::Xamarin.Forms.Forms.Init(this, bundle);\n\n    ((DroidLoginProvider)DependencyService.Get<ILoginProvider>()).Init(this);\n\n    LoadApplication(new App());\n}  iOS is similar, but does not require the initialization step in the main startup class.  The login provider class\nis in  Services\\iOSLoginProvider.cs  (in the  TaskList.iOS  project):  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.iOS.Services;\nusing UIKit;\n\n[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]\nnamespace TaskList.iOS.Services\n{\n    public class iOSLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(RootView, \"facebook\");\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n    }\n}  Note that we are using the same pattern here for registering the concrete implementation with the dependency service,\nso we can get it the same way. Finally, here is the UWP  Services\\UWPLoginProvider.cs  (in the TaskList.UWP project):  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\nusing TaskList.Abstractions;\nusing TaskList.UWP.Services;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            await client.LoginAsync(\"facebook\");\n        }\n    }\n}  Now that we have all the platform-specific login routines registered, we can move on to adding the login routine to\nthe UI.  We have already got a button on the entry page to enter the app.  It makes sense to wire up that button so\nthat it logs us in as well. The Command for the login button is in the  ViewModels\\EntryPageViewModel.cs :  async Task ExecuteLoginCommand()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var cloudService = ServiceLocator.Instance.Resolve<ICloudService>();\n        await cloudService.LoginAsync();\n        Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n    }\n    catch (Exception ex)\n    {\n        Debug.WriteLine($\"[ExecuteLoginCommand] Error = {ex.Message}\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}   The  ServiceLocator  class is my basic singleton handler.  It is available in the  Chapter2  project.  It\nreturns the concrete version of the cloud service, just like the Singleton version we defined in Chapter1.   When you run the application, clicking on the \"Enter the App\" button will now present you with an Authenticate window:  ![AAD Authenticate][img58]  Going through the authentication process will get you to the task list again.  If the authentication process fails,\nthen  LoginAsync()  will throw an error, which is caught at the ViewModel.  Right now, the  EntryPageViewModel \ndoes nothing more than print a diagnostic message to the debug window of Visual Studio.",
            "title": "Adding Authentication to a Mobile Client"
        },
        {
            "location": "/chapter2/social/#client-flow-for-social-providers",
            "text": "In each of the social providers, the identity provider SDK (provided by Facebook, Google, or Twitter) will need to be\nintegrated.  In general, these SDKs are provided for a native platform (Objective-C or Swift for iOS, Java for Android),\nuse callbacks or delegates (as is common practice in native libraries) and are thus more complicated to integrate with\nyour mobile client than those that have a C#/.NET SDK delivered on NuGet.  The reward for doing so are a more integrated experience on mobile devices.  For example, if you integrate the Google\nPlay Services SDK in an Android app, the app will seamlessly authenticate itself with the connected Google account in\nthe background, avoiding the need for repeatedly authenticating the client.  It may ask for a fingerprint instead if\nthe app is not trusted.  If you integrate the Facebook SDK, then the app will automatically switch to the Facebook app\nand ask you to approve the authentication request there instead of authenticating the user through a web view.  Both\nof these provide a more integrated experience for the end user, so this work is well worth pursuing.  As an example, here is the client flow for Facebook.  I've implemented this using the  Xamarin.Facebook.iOS  library,\nwhich can be downloaded and installed into the iOS project from NuGet.  The  Services\\iOSLoginProvider.cs  contains\nthe following:          #region Facebook Client Flow\n        private TaskCompletionSource<string> fbtcs;\n\n        public async Task<string> LoginFacebookAsync()\n        {\n            fbtcs = new TaskCompletionSource<string>();\n            var loginManager = new LoginManager();\n\n            loginManager.LogInWithReadPermissions(new[] { \"public_profile\" }, RootView, LoginTokenHandler);\n            return await fbtcs.Task;\n        }\n\n        private void LoginTokenHandler(LoginManagerLoginResult loginResult, NSError error)\n        {\n            if (loginResult.Token != null)\n            {\n                fbtcs.TrySetResult(loginResult.Token.TokenString);\n            }\n            else\n            {\n                fbtcs.TrySetException(new Exception(\"Facebook Client Flow Login Failed\"));\n            }\n        }\n        #endregion  Note the use of a  TaskCompletionSource<>()  here.  This is used often to convert callback APIs into awaitable APIs.\nWe set off the async call with the callback, then await on the completion (which is signified by the TaskCompletionSource ).  When the callback is called, it sets the value of the  TaskCompletionSource  (or causes\nan exception) and that causes the task to complete.  The  LoginAsync()  method can now be updated like this:          public async Task LoginAsync(MobileServiceClient client)\n        {\n            var accessToken = await LoginFacebookAsync();\n\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"facebook\", zumoPayload);\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;  With this version, clicking on the login button will seamlessly switch into the Facebook application and ask the\nuser to confirm the request, before switching back authenticated.",
            "title": "Client-Flow for Social Providers"
        },
        {
            "location": "/chapter2/debugging/",
            "text": "What is in a JWT\n\u00b6\n\n\nAt this point you will have the \"Authentication Success\" screen - perhaps several times.  If you bring up the\nDeveloper Tools for your browser, you can take a look at the token that is being minted for the authentication\nsession.  Take a look at the URL on the \"successful authentication\" page.\n\n\n\n\nThe authentication token is clearly marked (after you strip away the URL encoding).  You can use a\n[URL Decoder / Encoder][16] - just cut and paste the entire URL into the box and click on \nDecode\n.  Note that\nthe token is actually a JSON object.  You can now easily extract the \nauthenticationToken\n field from the JSON\nobject.\n\n\n\n\nTechnically, the authentication token is a \nJSON Web Token\n.  This is a mechanism for transferring claims\nbetween two systems securely.  The JWT is a cryptographically signed JSON object.  You can decode the JWT using\nthe \njwt.io tool\n.  Cut and paste the authentication token into the \nEncoded\n box and it will be decoded.\n\n\n\n\nNote that the contents of the JWT are revealed even without knowing the secret.  The client secret is generated\n(or entered as part of a configuration) at the identity provider and is used to cryptographically sign the token.\nYou will need the client secret to verify the signature of the token.  The client secret is copied from the identity\nprovider to the resource (in this case, the App Service).\n\n\nWe can see other items within the token.  The \nIssuer\n is the place that issued the token.  This is generally a URI.\nThe \nAudience\n is an identifier for who the token is for.  In this case, we have a token minted by the Azure App\nService for use accessing that same App Service, so the issuer and audience are both the URI.  If you look at an\nAuth0 token, you will see that the issuer is the Auth0 domain and the audience is the Client ID of the Auth0 tenant.\n\n\nEach token will also have a number of claims.  The most common claim is the \nSubject\n of the token.  This is generally\na security ID, but could be any unique user ID.\n\n\n\n\nAzure App Service sets the subject to a stable SID.  The stable SID is unique to the identity provider that is\nused for the authentication and guaranteed not to change, even if the user changes their email address or username\non the underlying identity provider.\n\n\n\n\nTechnically, the JWT can include any data and there are some identity providers that place just about everything\nabout the user in the JWT.  App Service keeps the amount of data small because the client will be sending the JWT\nwith every request. Imagine adding a few kilobytes to every single request that the client makes.  The bandwidth\nusage will add up quickly, and your app will be known as a bandwidth hog.\n\n\nHowever, there are some fields that are pretty universal.  Your JWT should always have the following fields:\n\n\n\n\nsub = Subject (the identifier for the token)\n\n\nexp = Expiry (when the token expires)\n\n\nnbf = Not Before (the earliest point in time the token is valid)\n\n\niss = Issuer (the site that issued the token)\n\n\naud = Audience (who is the token for)\n\n\n\n\nThe timestamps (exp and nbf) are all UNIX timestamps (i.e. the number of seconds since January 1, 1970).\n\n\nApp Service adds to this:\n\n\n\n\nstable_sid = Security Id of the user\n\n\nidp = the IdP that was used in the authentication request\n\n\nver = the Version of the token\n\n\n\n\nApp Service will be able to validate any token provided to it when presented in an X-ZUMO-AUTH header.  If you are\nusing Azure Active Directory, you can also use the more standard Bearer Authorization header.  If the token does\nnot match, then the X-ZUMO-AUTH header will be stripped from the request before the request is passed to your site.\n\n\nTesting Authentication without a Client\n\u00b6\n\n\nTesting authentication against your App Service without a client requires a REST client.  I use \nPostman\n,\nwhich is based on Google Chrome.  If you use Firefox, you might want to take a look at \nRESTClient\n.  Telerik\nalso distributes a web debugging proxy called \nFiddler\n that can do API testing.  To test the server, we will\nneed a token.  We can get one by testing authentication configuration by pointing the browser to \n/.auth/login/aad\n.\nThe return URL will contain a token in the query string and as \na secure cookie\n.\n\n\n\n\nYou can test any of the supported identity providers by replacing \naad\n with the authentication provider name:\nfacebook, google, microsoftaccount and twitter are possibilities here.\n\n\n\n\nWe can then do a request to \n/tables/todoitem\n to try and obtain the list of current tasks.  We will need to add\ntwo headers:\n\n\n\n\nZUMO-API-VERSION\n should contain a value of \n2.0.0\n.\n\n\nX-ZUMO-AUTH\n should contain the token you received.\n\n\n\n\nMy first request shows authentication failing:\n\n\n\n\nGo through one of the authentication flows and copy the authentication token.  In Postman, add a new header called\n\nX-ZUMO-AUTH\n and paste the authentication token in.\n\n\n\n\nNote that we have tested all this without touching the client.  Separating the backend operations from the client\noperations means we can be sure of where the inevitable bug that creeps in is located.  We have verified that we\ncan do each authentication flow on the server side and that the server is properly rejecting unauthenticated requests,\nplus it is properly returning data when authenticated requests are issued.\n\n\nDeveloping Locally\n\u00b6\n\n\nOne would normally be able to run the ASP.NET backend locally and get full functionality without authentication.\nHowever, authentication puts a stop to that because the redirect URLs, secrets and other authentication configuration\nsettings only work with a known endpoint.  To alleviate that, Azure Mobile Apps allows you to run a local server while\nusing an authentication endpoint in Azure App Service.  When the authentication transaction takes place, it is taking\nplace against the Azure App Service.   When it is not doing the OAuth transaction, however, it is operating against a\nlocal server.\n\n\nSetting this up requires a little bit of local machine configuration and a change to the configuration of your client.\n\n\nUpdate your Local Development Environment\n\u00b6\n\n\nThe first step in this process is to make your local IIS development environment look more like the Azure App Service,\nparticularly in reference to the authentication settings.  This means setting up a few app settings that should be\npulled from your App Service.\n\n\n\n\nLog on to the \nAzure Portal\n.\n\n\nSelect your App Service from the \nApp Services\n list.\n\n\nClick on \nTools\n, then \nKudu\n, then \nGo\n.\n\n\n\n\nKudu is the backend debug console for Azure App Service and there is a lot you can do here.  Of note in this instance\nis that you can gain access to the keys and audience for your App Service.\n\n\n\n\nClick on \nEnvironment\n in the top banner.\n\n\nClick on \nEnvironment variables\n.\n\n\nScroll down to the environment variables starting with \nWEBSITE_AUTH\n.\n\n\nMake a note of the \nWEBSITE_AUTH_SIGNING_KEY\n and \nWEBSITE_AUTH_ALLOWED_AUDIENCES\n values.\n\n\n\n\nAdd the following to your project Web.config \n<appSettings>\n section:\n\n\n  <appSettings>\n    <add key=\"PreserveLoginUrl\" value=\"true\" />\n    <add key=\"MS_SigningKey\" value=\"Overridden by portal settings\" />\n    <add key=\"EMA_RuntimeUrl\" value=\"Overridden by portal settings\" />\n    <add key=\"MS_NotificationHubName\" value=\"Overridden by portal settings\" />\n    <add key=\"SigningKey\" value=\"{Your WEBSITE_AUTH_SIGNING_KEY}\"/>\n    <add key=\"ValidAudience\" value=\"{Your WEBSITE_AUTH_ALLOWED_AUDIENCES}\"/>\n    <add key=\"ValidIssuer\" value=\"https://{Your WEBSITE_HOSTNAME}/\"/>\n  </appSettings>\n\n\n\n\n\n\nNOTE\n: Both the ValidAudience and ValidIssuer will have a slash on the end and be a https URL.\n\n\n\n\nThe last three keys are the keys you will need to add.  Make sure you do not have a \nHostName\n key as this is how\nthe startup file determines if you are running locally or remote. Talking of which, edit your\n\nApp_Start\\Startup.MobileApp.cs\n file to include the following:\n\n\n        public static void ConfigureMobileApp(IAppBuilder app)\n        {\n            HttpConfiguration config = new HttpConfiguration();\n\n            new MobileAppConfiguration()\n                .AddTablesWithEntityFramework()\n                .ApplyTo(config);\n\n            // Use Entity Framework Code First to create database tables based on your DbContext\n            Database.SetInitializer(new MobileServiceInitializer());\n\n            MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();\n\n            if (string.IsNullOrEmpty(settings.HostName))\n            {\n                app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions\n                {\n                    SigningKey = ConfigurationManager.AppSettings[\"SigningKey\"],\n                    ValidAudiences = new[] { ConfigurationManager.AppSettings[\"ValidAudience\"] },\n                    ValidIssuers = new[] { ConfigurationManager.AppSettings[\"ValidIssuer\"] },\n                    TokenHandler = config.GetAppServiceTokenHandler()\n                });\n            }\n\n            app.UseWebApi(config);\n        }\n\n\n\n\nThe \nUserAppServiceAuthentication()\n method sets up authentication checking.  This section is not required when running\nwithin App Service.\n\n\nIf you are running the server locally, you should either set up a local SQL Server instance and put the connection\nstring into the \nWeb.config\n file, or \nopen the firewall on your SQL Azure\n database so that your local development\nenvironment can connect to it, then place the connection string in the \nWeb.config\n.  You can get the connection string\nof the SQL Azure instance by looking at the Connection Strings in the \nApplication properties\n of your App Service.\n\n\nUpdate your Mobile Client\n\u00b6\n\n\nFor this demonstration, I have updated the \nTaskList.UWP\n application so that it is using the server-flow\nauthentication for Azure Active Directory.  This means updating the \nLoginAsync()\n method in the\n\nServices\\UWPLoginProvider.cs\n file to be the following:\n\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Server-Flow Version\n            await client.LoginAsync(\"aad\");\n        }\n\n\n\n\nThis is because the default local IIS instance is IIS Express.  IIS Express only listens for local connections.  If\nyou run a client from another device (for example, the Android emulator on a Hyper-V service or the iOS simulator\non a Mac), then that client would be connecting via a network connection.  You can still debug locally, but you need\nto \nconvert your environment to IIS\n first.\n\n\nIn the \nTaskList (Portable)\n project, update the \nHelpers\\Locations.cs\n file:\n\n\nnamespace TaskList.Helpers\n{\n    public static class Locations\n    {\n#if DEBUG\n        public static readonly string AppServiceUrl = \"http://localhost:17568/\";\n        public static readonly string AlternateLoginHost = \"https://the-book.azurewebsites.net\";\n#else\n        public static readonly string AppServiceUrl = \"https://the-book.azurewebsites.net\";\n        public static readonly string AlternateLoginHost = null;\n#endif\n    }\n}\n\n\n\n\nThe \nAppServiceUrl\n is always set to the location of your backend.  In this case, I right-clicked on the \nBackend\n\nproject and selected \nProperties\n then \nWeb\n.  The correct URL for local debugging is listed in the\n\nProject URL\n.  The \nAlternateLoginHost\n is set to the App Service when locally debugging or null if not. You can\nspecify the \nDEBUG\n constant in the \nBuild\n tab.\n\n\nIn the same project, update the \nServices\\AzureCloudService.cs\n constructor to the following:\n\n\n        public AzureCloudService()\n        {\n            client = new MobileServiceClient(Locations.AppServiceUrl);\n            if (Locations.AlternateLoginHost != null)\n                client.AlternateLoginHost = new Uri(Locations.AlternateLoginHost);\n        }\n\n\n\n\n\n\nIt's a good idea to separate the client and server into different solutions.  Although it doesn't hurt anything to\nhave them in the same solution (like we have), having the client and server separated allows you to attach a debugger\nseparately - which allows you to debug both sides of the connection at the same time.\n\n\n\n\nWith these settings, the client will contact the AlternateLoginHost listed for the authentication process and then\ncontact the local server for the rest of the transaction.\n\n\nRun the Local Server\n\u00b6\n\n\nRunning the local server and the client takes a larger machine.  You need to run two instances of Visual Studio: one\nfor the client and one for the server. This is really where you will appreciate multiple monitors (my personal favorite)\nor the snap action to the sides of the screens.\n\n\nEnsure you have your backend and clients in different solutions if you intend to run both client and server.  The\ndebugger in Visual Studio will stop one to run the other when they are in the same solution.",
            "title": "Debugging Authentication"
        },
        {
            "location": "/chapter2/debugging/#what-is-in-a-jwt",
            "text": "At this point you will have the \"Authentication Success\" screen - perhaps several times.  If you bring up the\nDeveloper Tools for your browser, you can take a look at the token that is being minted for the authentication\nsession.  Take a look at the URL on the \"successful authentication\" page.   The authentication token is clearly marked (after you strip away the URL encoding).  You can use a\n[URL Decoder / Encoder][16] - just cut and paste the entire URL into the box and click on  Decode .  Note that\nthe token is actually a JSON object.  You can now easily extract the  authenticationToken  field from the JSON\nobject.   Technically, the authentication token is a  JSON Web Token .  This is a mechanism for transferring claims\nbetween two systems securely.  The JWT is a cryptographically signed JSON object.  You can decode the JWT using\nthe  jwt.io tool .  Cut and paste the authentication token into the  Encoded  box and it will be decoded.   Note that the contents of the JWT are revealed even without knowing the secret.  The client secret is generated\n(or entered as part of a configuration) at the identity provider and is used to cryptographically sign the token.\nYou will need the client secret to verify the signature of the token.  The client secret is copied from the identity\nprovider to the resource (in this case, the App Service).  We can see other items within the token.  The  Issuer  is the place that issued the token.  This is generally a URI.\nThe  Audience  is an identifier for who the token is for.  In this case, we have a token minted by the Azure App\nService for use accessing that same App Service, so the issuer and audience are both the URI.  If you look at an\nAuth0 token, you will see that the issuer is the Auth0 domain and the audience is the Client ID of the Auth0 tenant.  Each token will also have a number of claims.  The most common claim is the  Subject  of the token.  This is generally\na security ID, but could be any unique user ID.   Azure App Service sets the subject to a stable SID.  The stable SID is unique to the identity provider that is\nused for the authentication and guaranteed not to change, even if the user changes their email address or username\non the underlying identity provider.   Technically, the JWT can include any data and there are some identity providers that place just about everything\nabout the user in the JWT.  App Service keeps the amount of data small because the client will be sending the JWT\nwith every request. Imagine adding a few kilobytes to every single request that the client makes.  The bandwidth\nusage will add up quickly, and your app will be known as a bandwidth hog.  However, there are some fields that are pretty universal.  Your JWT should always have the following fields:   sub = Subject (the identifier for the token)  exp = Expiry (when the token expires)  nbf = Not Before (the earliest point in time the token is valid)  iss = Issuer (the site that issued the token)  aud = Audience (who is the token for)   The timestamps (exp and nbf) are all UNIX timestamps (i.e. the number of seconds since January 1, 1970).  App Service adds to this:   stable_sid = Security Id of the user  idp = the IdP that was used in the authentication request  ver = the Version of the token   App Service will be able to validate any token provided to it when presented in an X-ZUMO-AUTH header.  If you are\nusing Azure Active Directory, you can also use the more standard Bearer Authorization header.  If the token does\nnot match, then the X-ZUMO-AUTH header will be stripped from the request before the request is passed to your site.",
            "title": "What is in a JWT"
        },
        {
            "location": "/chapter2/debugging/#testing-authentication-without-a-client",
            "text": "Testing authentication against your App Service without a client requires a REST client.  I use  Postman ,\nwhich is based on Google Chrome.  If you use Firefox, you might want to take a look at  RESTClient .  Telerik\nalso distributes a web debugging proxy called  Fiddler  that can do API testing.  To test the server, we will\nneed a token.  We can get one by testing authentication configuration by pointing the browser to  /.auth/login/aad .\nThe return URL will contain a token in the query string and as  a secure cookie .   You can test any of the supported identity providers by replacing  aad  with the authentication provider name:\nfacebook, google, microsoftaccount and twitter are possibilities here.   We can then do a request to  /tables/todoitem  to try and obtain the list of current tasks.  We will need to add\ntwo headers:   ZUMO-API-VERSION  should contain a value of  2.0.0 .  X-ZUMO-AUTH  should contain the token you received.   My first request shows authentication failing:   Go through one of the authentication flows and copy the authentication token.  In Postman, add a new header called X-ZUMO-AUTH  and paste the authentication token in.   Note that we have tested all this without touching the client.  Separating the backend operations from the client\noperations means we can be sure of where the inevitable bug that creeps in is located.  We have verified that we\ncan do each authentication flow on the server side and that the server is properly rejecting unauthenticated requests,\nplus it is properly returning data when authenticated requests are issued.",
            "title": "Testing Authentication without a Client"
        },
        {
            "location": "/chapter2/debugging/#developing-locally",
            "text": "One would normally be able to run the ASP.NET backend locally and get full functionality without authentication.\nHowever, authentication puts a stop to that because the redirect URLs, secrets and other authentication configuration\nsettings only work with a known endpoint.  To alleviate that, Azure Mobile Apps allows you to run a local server while\nusing an authentication endpoint in Azure App Service.  When the authentication transaction takes place, it is taking\nplace against the Azure App Service.   When it is not doing the OAuth transaction, however, it is operating against a\nlocal server.  Setting this up requires a little bit of local machine configuration and a change to the configuration of your client.",
            "title": "Developing Locally"
        },
        {
            "location": "/chapter2/debugging/#update-your-local-development-environment",
            "text": "The first step in this process is to make your local IIS development environment look more like the Azure App Service,\nparticularly in reference to the authentication settings.  This means setting up a few app settings that should be\npulled from your App Service.   Log on to the  Azure Portal .  Select your App Service from the  App Services  list.  Click on  Tools , then  Kudu , then  Go .   Kudu is the backend debug console for Azure App Service and there is a lot you can do here.  Of note in this instance\nis that you can gain access to the keys and audience for your App Service.   Click on  Environment  in the top banner.  Click on  Environment variables .  Scroll down to the environment variables starting with  WEBSITE_AUTH .  Make a note of the  WEBSITE_AUTH_SIGNING_KEY  and  WEBSITE_AUTH_ALLOWED_AUDIENCES  values.   Add the following to your project Web.config  <appSettings>  section:    <appSettings>\n    <add key=\"PreserveLoginUrl\" value=\"true\" />\n    <add key=\"MS_SigningKey\" value=\"Overridden by portal settings\" />\n    <add key=\"EMA_RuntimeUrl\" value=\"Overridden by portal settings\" />\n    <add key=\"MS_NotificationHubName\" value=\"Overridden by portal settings\" />\n    <add key=\"SigningKey\" value=\"{Your WEBSITE_AUTH_SIGNING_KEY}\"/>\n    <add key=\"ValidAudience\" value=\"{Your WEBSITE_AUTH_ALLOWED_AUDIENCES}\"/>\n    <add key=\"ValidIssuer\" value=\"https://{Your WEBSITE_HOSTNAME}/\"/>\n  </appSettings>   NOTE : Both the ValidAudience and ValidIssuer will have a slash on the end and be a https URL.   The last three keys are the keys you will need to add.  Make sure you do not have a  HostName  key as this is how\nthe startup file determines if you are running locally or remote. Talking of which, edit your App_Start\\Startup.MobileApp.cs  file to include the following:          public static void ConfigureMobileApp(IAppBuilder app)\n        {\n            HttpConfiguration config = new HttpConfiguration();\n\n            new MobileAppConfiguration()\n                .AddTablesWithEntityFramework()\n                .ApplyTo(config);\n\n            // Use Entity Framework Code First to create database tables based on your DbContext\n            Database.SetInitializer(new MobileServiceInitializer());\n\n            MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();\n\n            if (string.IsNullOrEmpty(settings.HostName))\n            {\n                app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions\n                {\n                    SigningKey = ConfigurationManager.AppSettings[\"SigningKey\"],\n                    ValidAudiences = new[] { ConfigurationManager.AppSettings[\"ValidAudience\"] },\n                    ValidIssuers = new[] { ConfigurationManager.AppSettings[\"ValidIssuer\"] },\n                    TokenHandler = config.GetAppServiceTokenHandler()\n                });\n            }\n\n            app.UseWebApi(config);\n        }  The  UserAppServiceAuthentication()  method sets up authentication checking.  This section is not required when running\nwithin App Service.  If you are running the server locally, you should either set up a local SQL Server instance and put the connection\nstring into the  Web.config  file, or  open the firewall on your SQL Azure  database so that your local development\nenvironment can connect to it, then place the connection string in the  Web.config .  You can get the connection string\nof the SQL Azure instance by looking at the Connection Strings in the  Application properties  of your App Service.",
            "title": "Update your Local Development Environment"
        },
        {
            "location": "/chapter2/debugging/#update-your-mobile-client",
            "text": "For this demonstration, I have updated the  TaskList.UWP  application so that it is using the server-flow\nauthentication for Azure Active Directory.  This means updating the  LoginAsync()  method in the Services\\UWPLoginProvider.cs  file to be the following:          public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Server-Flow Version\n            await client.LoginAsync(\"aad\");\n        }  This is because the default local IIS instance is IIS Express.  IIS Express only listens for local connections.  If\nyou run a client from another device (for example, the Android emulator on a Hyper-V service or the iOS simulator\non a Mac), then that client would be connecting via a network connection.  You can still debug locally, but you need\nto  convert your environment to IIS  first.  In the  TaskList (Portable)  project, update the  Helpers\\Locations.cs  file:  namespace TaskList.Helpers\n{\n    public static class Locations\n    {\n#if DEBUG\n        public static readonly string AppServiceUrl = \"http://localhost:17568/\";\n        public static readonly string AlternateLoginHost = \"https://the-book.azurewebsites.net\";\n#else\n        public static readonly string AppServiceUrl = \"https://the-book.azurewebsites.net\";\n        public static readonly string AlternateLoginHost = null;\n#endif\n    }\n}  The  AppServiceUrl  is always set to the location of your backend.  In this case, I right-clicked on the  Backend \nproject and selected  Properties  then  Web .  The correct URL for local debugging is listed in the Project URL .  The  AlternateLoginHost  is set to the App Service when locally debugging or null if not. You can\nspecify the  DEBUG  constant in the  Build  tab.  In the same project, update the  Services\\AzureCloudService.cs  constructor to the following:          public AzureCloudService()\n        {\n            client = new MobileServiceClient(Locations.AppServiceUrl);\n            if (Locations.AlternateLoginHost != null)\n                client.AlternateLoginHost = new Uri(Locations.AlternateLoginHost);\n        }   It's a good idea to separate the client and server into different solutions.  Although it doesn't hurt anything to\nhave them in the same solution (like we have), having the client and server separated allows you to attach a debugger\nseparately - which allows you to debug both sides of the connection at the same time.   With these settings, the client will contact the AlternateLoginHost listed for the authentication process and then\ncontact the local server for the rest of the transaction.",
            "title": "Update your Mobile Client"
        },
        {
            "location": "/chapter2/debugging/#run-the-local-server",
            "text": "Running the local server and the client takes a larger machine.  You need to run two instances of Visual Studio: one\nfor the client and one for the server. This is really where you will appreciate multiple monitors (my personal favorite)\nor the snap action to the sides of the screens.  Ensure you have your backend and clients in different solutions if you intend to run both client and server.  The\ndebugger in Visual Studio will stop one to run the other when they are in the same solution.",
            "title": "Run the Local Server"
        },
        {
            "location": "/chapter2/custom/",
            "text": "Custom authentication\n\u00b6\n\n\nFor some situations, the social or enterprise flows are not valid for the mobile client.  Perhaps you want the ability\nto provide a sign-up process with a username and password rather than using a social provider.  Perhaps you want to use\nan alternate provider that is not one of the supported five providers.  Whatever the reason, Azure App Service provides\nthe ability to handle all situations.  In this section, I will look at three methods for providing a unique set of\nusernames with no connection to the social or enterprise authentication.\n\n\nUsing an Identity Database.\n\u00b6\n\n\nProbably the most common request is to use a custom identity database.  In general, this is desirable because you\nalready have a database of usernames and password.  However, it's probably the least desirable option because of the\nsecurity concerns that come along with this technique.  The news is rife with password leakage for very large\norganizations.  The best way to ensure you do not disclose a users password is to not have it in the first place.\n\n\n\n\nI'm not going to cover the sign-up case here.  This would be an additional process and would use a regular Web API\nto insert data into the database after validation (and probably verification via email\nor text message).\n\n\n\n\nThe first thing we need to add to our project is a model for the user object.  I created the following in the \nModels\n\nfolder of the \nBackend\n project:\n\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace Backend.Models\n{\n    public class User\n    {\n        [Key]\n        public int Id { get; set; }\n\n        public string Username { get; set; }\n\n        public string Password { get; set; }\n    }\n}\n\n\n\n\nWe also need to modify the \nMobileServiceContext.cs\n file so that the database table is included in the Entity Framework\ncontext:\n\n\n    public class MobileServiceContext : DbContext\n    {\n        private const string connectionStringName = \"Name=MS_TableConnectionString\";\n\n        public MobileServiceContext() : base(connectionStringName)\n        {\n        }\n\n        public DbSet<TodoItem> TodoItems { get; set; }\n        public DbSet<User> Users { get; set; }\n\n        protected override void OnModelCreating(DbModelBuilder modelBuilder)\n        {\n            modelBuilder.Conventions.Add(\n                new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n                    \"ServiceTableColumn\", (property, attributes) => attributes.Single().ColumnType.ToString()));\n        }\n    }\n\n\n\n\nFinally, we probably want to put some seed data into the database when it is first created so that we can test it.\nAdjust the \nMobileServiceInitializer\n in the \nStartup.MobileApp.cs\n file:\n\n\n        protected override void Seed(MobileServiceContext context)\n        {\n            List<TodoItem> todoItems = new List<TodoItem>\n            {\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"First item\", Complete = false },\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"Second item\", Complete = false }\n            };\n\n            foreach (TodoItem todoItem in todoItems)\n            {\n                context.Set<TodoItem>().Add(todoItem);\n            }\n\n            List<User> users = new List<User>\n            {\n                new User { Id = 1, Username = \"adrian\", Password = \"supersecret\" }\n            };\n\n            foreach (User user in users)\n            {\n                context.Set<User>().Add(user);\n            }\n\n            base.Seed(context);\n        }\n\n\n\n\nNote that we are storing the passwords in plain text.  This is most definitely frowned upon.  We should be using some\nsort of encryption.  This code is most definitely just for demonstration purposes.  Continuing the code on the backend,\n we need to handle the request to authenticate from the client.  We will use a custom API controller for this; it is\n located in \nControllers\\CustomAuthController.cs\n:\n\n\nusing System;\nusing System.IdentityModel.Tokens;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Web.Http;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server.Login;\nusing Newtonsoft.Json;\n\nnamespace Backend.Controllers\n{\n    [Route(\".auth/login/custom\")]\n    public class CustomAuthController : ApiController\n    {\n        private MobileServiceContext db;\n        private string signingKey, audience, issuer;\n\n        public CustomAuthController()\n        {\n            db = new MobileServiceContext();\n            signingKey = Environment.GetEnvironmentVariable(\"WEBSITE_AUTH_SIGNING_KEY\");\n            var website = Environment.GetEnvironmentVariable(\"WEBSITE_HOSTNAME\");\n            audience = $\"https://{website}/\";\n            issuer = $\"https://{website}/\";\n        }\n\n        [HttpPost]\n        public IHttpActionResult Post([FromBody] User body)\n        {\n            if (body == null || body.Username == null || body.Password == null ||\n                body.Username.Length == 0 || body.Password.Length == 0)\n            {\n                return BadRequest(); ;\n            }\n\n            if (!IsValidUser(body))\n            {\n                return Unauthorized();\n            }\n\n            var claims = new Claim[]\n            {\n                new Claim(JwtRegisteredClaimNames.Sub, body.Username)\n            };\n\n            JwtSecurityToken token = AppServiceLoginHandler.CreateToken(\n                claims, signingKey, audience, issuer, TimeSpan.FromDays(30));\n            return Ok(new LoginResult()\n            {\n                AuthenticationToken = token.RawData,\n                User = new LoginResultUser { UserId = body.Username }\n            });\n        }\n\n        protected override void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                db.Dispose();\n            }\n            base.Dispose(disposing);\n        }\n\n        private bool IsValidUser(User user)\n        {\n            return db.Users.Count(u => u.Username.Equals(user.Username) && u.Password.Equals(user.Password)) > 0;\n        }\n    }\n\n    public class LoginResult\n    {\n        [JsonProperty(PropertyName = \"authenticationToken\")]\n        public string AuthenticationToken { get; set; }\n\n        [JsonProperty(PropertyName = \"user\")]\n        public LoginResultUser User { get; set; }\n    }\n\n    public class LoginResultUser\n    {\n        [JsonProperty(PropertyName = \"userId\")]\n        public string UserId { get; set; }\n    }\n}\n\n\n\n\nThere is a lot going on here:\n\n\n\n\nThe constructor reads the signing key and other information that we need for constructing the JWT.  Note that the\n  signing key is only available if you have the Authentication / Authorization is turned on.\n\n\nThe \nLoginResult\n and \nLoginResultUser\n provide the response to the client, when serialized by the JSON serializer.\n\n\nThe \nPost()\n method is where the work happens.  It verifies that you have a valid object, then checks that the\n  username and password match something in the user database.  It then constructs the JWT and returns the required\n  JSON object.\n\n\nThe \nIsValidUser()\n method actually validates the username and password provided in the request with the users in\n  the database.  This version is very simplistic.  I expect your version to at least include encryption of the password.\n\n\n\n\n\n\nNote that you must turn on Authentication / Authorization in your App Service.  Set the \nAction to take when request\nis not authenticated\n to \nAllow Request (no action)\n and do not configure any of the supported authentication providers.\n\n\n\n\nNext, we need to wire the custom authentication controller so that it appears in the same place as all the other\nauthenticators.  We are going to access it via the \n/.auth/login/custom\n endpoint.  The normal ASP.NET methods can be\napplied for this.  In this project, we can enable \nattribute routing\n:\n\n\npublic static void ConfigureMobileApp(IAppBuilder app)\n{\n    HttpConfiguration config = new HttpConfiguration();\n\n    new MobileAppConfiguration()\n        .AddTablesWithEntityFramework()\n        .ApplyTo(config);\n\n    // Map routes by attribute\n    config.MapHttpAttributeRoutes();\n\n    // Use Entity Framework Code First to create database tables based on your DbContext\n    Database.SetInitializer(new MobileServiceInitializer());\n\n    MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();\n\n    if (string.IsNullOrEmpty(settings.HostName))\n    {\n        app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions\n        {\n            SigningKey = ConfigurationManager.AppSettings[\"SigningKey\"],\n            ValidAudiences = new[] { ConfigurationManager.AppSettings[\"ValidAudience\"] },\n            ValidIssuers = new[] { ConfigurationManager.AppSettings[\"ValidIssuer\"] },\n            TokenHandler = config.GetAppServiceTokenHandler()\n        });\n    }\n\n    app.UseWebApi(config);\n}\n\n\n\n\nAt this point, we can deploy the backend to the App Service and send a suitably formed POST request to\nthe backend.  I use [Postman][19] for this purpose. The request:\n\n\n\n\nA successful POST will return the token and user ID in the response:\n\n\n\n\nAny other request (such as no body or a wrong username or password) should produce the right response.  If the body is\ncorrect, but the information is wrong, then a 401 Unauthorized response should be produced.  If the body is invalid, then\n400 Bad Request should be produced.\n\n\n\n\nNote that the format of the response is exactly the same as the token response we saw earlier when we were discussing\nthe contents of a JWT.\n\n\n\n\nWe can now turn our attention to the mobile client.  Custom Authentication is always implemented using a client-flow\n mechanism. To implement this, we are going to adjust the entry page so that the username and password fields are\n displayed.  The gathered username and password will then be passed to a new ICloudService \nLoginAsync()\n method.\n All of the UI work is done in the shared project.\n\n\nTo start, we need a copy of the \nUser.cs\n model from the backend project.  Unlike Data Transfer Objects, this model is\nthe same:\n\n\nnamespace TaskList.Models\n{\n    public class User\n    {\n        public string Username { get; set; }\n        public string Password { get; set; }\n    }\n}\n\n\n\n\nThe abstraction we use for the cloud service needs to be adjusted so that we can pass the user object into the login\nmethod.  This is the \nAbstractions\\ICloudService.cs\n interface:\n\n\nusing System.Threading.Tasks;\nusing TaskList.Models;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n\n        Task LoginAsync(User user);\n    }\n}\n\n\n\n\nNote that I am adding a new version of the \nLoginAsync()\n method.  The concrete version of this method no longer has\nto go through the dependency service since I can use shared code.  Here is the definition of our new \nLoginAsync()\n\nmethod in \nServices\\AzureCloudService.cs\n:\n\n\n        public Task LoginAsync(User user)\n        {\n            return client.LoginAsync(\"custom\", JObject.FromObject(user));\n        }\n\n\n\n\nFinally, we need to update the view-model \nViewModels\\EntryPageViewModel.cs\n so that we can store the username and\npassword in the model.  We will also update the call to the \nLoginAsync()\n method of the cloud service so it calls\nour new method:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class EntryPageViewModel : BaseViewModel\n    {\n        public EntryPageViewModel()\n        {\n            Title = \"Task List\";\n            User = new Models.User { Username = \"\", Password = \"\" };\n        }\n\n        Command loginCmd;\n        public Command LoginCommand => loginCmd ?? (loginCmd = new Command(async () => await ExecuteLoginCommand()));\n\n        public Models.User User { get; set; }\n\n        async Task ExecuteLoginCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                var cloudService = ServiceLocator.Instance.Resolve<ICloudService>();\n                await cloudService.LoginAsync(User);\n                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[ExecuteLoginCommand] Error = {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}\n\n\n\n\nThere are three new pieces here.  Firstly, we have the User property (for holding the username and password in our\nform).  Next, the constructor initializes the user object to an empty object.  Finally, the call to \nLoginAsync()\n\npasses the user object to the cloud service.\n\n\nWe also need some UI changes.  Specifically, we need a couple of fields for the username and password added to the\n\nPages\\EntryPage.xaml\n file:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage x:Class=\"TaskList.Pages.EntryPage\"\n             xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <StackLayout HorizontalOptions=\"Center\"\n                     Orientation=\"Vertical\"\n                     VerticalOptions=\"Center\">\n            <Label Text=\"Username?\" />\n            <Entry Text=\"{Binding User.Username}\" />\n            <Label Text=\"Password?\" />\n            <Entry IsPassword=\"True\" Text=\"{Binding User.Password}\" />\n\n            <Button BackgroundColor=\"Teal\"\n                    BorderRadius=\"10\"\n                    Command=\"{Binding LoginCommand}\"\n                    Text=\"Enter The App\"\n                    TextColor=\"White\" />\n        </StackLayout>\n    </ContentPage.Content>\n</ContentPage>\n\n\n\n\nThere is lots to complain about in this demonstration (including lack of encryption, storage of passwords, and a\ngenerally bad UI).  However, it serves to demonstrate the salient points for using a (perhaps pre-existing) identity\ndatabase for authentication of the users.\n\n\nUsing Azure Active Directory B2C\n\u00b6\n\n\nCustom authentication allows you to really customize the process, but I like to reduce the amount of code I write by\nusing services or libraries.   The whole sign-in and sign-up process is ripe for this.  The code needed for building\nthe sign-in / sign-up process is boiler-plate code.  It also introduces problems that I have to deal with going forward.\nI have to store passwords and profile information, which introduces a security concern.  I have to scale the database\nand ensure my app scales with it as my app gets popular.  Finally, I am being fairly inflexible and causing potential\nprivacy concerns with my users.\n\n\nThere are a couple of services that I can use to get around these concerns.  The first is an Azure service:\n\nAzure Active Directory B2C\n.  The B2C stands for Business to Consumer.  It is a mechanism by which you can add a\nsign-in and sign-up flow to your application.  The user can enter a username or password, or, at your option, add on\nsupport for one or more social providers.  In addition, there is support for branding the sign-in process, doing email\nverification of sign-ups and automatic password resets via email.  The Azure AD B2C sign-in / sign-up process is\nprimarily a server-flow proecss, so we will be able to add support in our app with just one line of code.\n\n\nThe Minimal Setup of Azure AD B2C\n\u00b6\n\n\nAzure AD is managed from the \nClassic Azure Portal\n, so start by logging in using your Azure\nSubscription credentials.\n\n\n\n\nClick on the big \n+ NEW\n button in the bottom left of the screen.\n\n\nSelect \nApp Services\n -> \nActive Directory\n -> \nDirectory\n -> \nCustom Create\n.\n\n\n\n\n\n\n\n\nChoose a name for the tenant, then choose a unique domain name (which will appear in the   \nonmicrosoft.com\n\n  domain) and country.  Ensure you check the \nThis is a B2C directory.\n\n\n\n\n\n\n\n\nClick on the tick to create the directory.  As noted, this process will take a couple of minutes to complete.\n\n\n\n\nThis creates a new tenant for you to manage.  If you go back to your \nAzure Portal\n and click on your name\n(top right corner), you will note that there is a new DIRECTORY entry for your B2C tenant.  This is where you will be\nmanaging your B2C tenant.\n\n\nIt's a good idea to pin the B2C settings blade to your dashboard or navigation pane so you can access it faster.\nTo do this:\n\n\n\n\nLog in to the \nAzure Portal\n.\n\n\nSwitch to your B2C tenant by clicking on your name, then selecting the new tenant in the drop-down.\n\n\nThe portal will probably ask you to confirm your ID and password.\n\n\nClick on \nBrowse>\n in the left-hand navigation bar.\n\n\nSearch for \nB2C\n.\n\n\nClick on the empty star next to \nAzure AD B2C\n.\n\n\n\n\n\n\nThis will make Azure AD B2C appear in your left hand navigation bar.  To place it on the dashboard, click on\n\nAzure AD B2C\n in the left hand navigation bar, then click on the pin at the top of the \nAZURE AD B2C SETTINGS\n\nblade.\n\n\nThe next job is to create an application registration within the B2C tenant:\n\n\n\n\nOpen the \nAzure AD B2C\n from your dashboard or the left hand navigation.\n\n\nIn the \nSettings\n blade, click on \nApplications\n.\n\n\n\n\n\n\n\n\nIn the \nNew application\n blade:\n\n\nEnter a unique name for the application.\n\n\nClick on \nYes\n under \nInclude web app / web API\n.\n\n\nIn the Reply URL, enter \nhttps://yoursite.azurewebsites.net/.auth/login/aad/callback\n.\n\n\nClick on \nGenerate key\n - a key will be generated (cut and paste it somewhere).\n\n\n\n\n\n\n\n\nClick on \nCreate\n.\n\n\n\n\nThere is no spinner or deployment here.  After approximately 5-10 seconds, the application registration will appear\nin the list.  Click on the application registration to see the \nApplication ID\n:\n\n\n\n\nYou will need the Application ID and App Key (which you copied earlier) later on.  The next step is to create a\nSign-in/Sign-up policy.  We'll create a policy for signing up with an email address and email confirmation, then\nsigning in with that email address:\n\n\n\n\nIn the \nSettings\n blade, click on \nSign-up or sign-in policies\n.\n\n\nClick on the \n+ Add\n button.\n\n\nGive the policy a name, like \nemailPolicy\n.\n\n\nClick on \nIdentity providers\n:\n\n\nClick on \nEmail signup / Local Account\n (a tick will appear next to the row).\n\n\nClick on \nOK\n.\n\n\nClick on \nSign-up attributes\n:\n\n\nClick on \nEmail Address\n and any other fields you want to gather.\n\n\nClick on \nOK\n.\n\n\nClick on \nApplication claims\n:\n\n\nClick on \nEmail Addresses\n and any other fields you want to provide to the application.\n\n\nClick on \nOK\n\n\nClick on \nCreate\n on the \nAdd policy\n blade.\n\n\nClick on the policy you just created.  It will be named something like \nB2C_1_emailPolicy\n. Make a note of the\n\nMetadata Endpoint for this policy\n.\n\n\n\n\n\n\nNow that your B2C tenant is configured, you can switch back to your original tenant (by clicking on your name in\nthe top-right corner and selecting the default directory).\n\n\nTo configure the App Service \nAuthentication / Authorization\n.  Open up the \nSettings\n blade, then\n\nAuthentication / Authorization\n.  Ensure the authentication service is turned on.  Click on\n\nAzure Active Directory\n. This time, we are going to select the \nAdvanced\n option.  The \nClient ID\n is\nthe application ID of your B2C application registration, and the \nIssuer Url\n is the \nMetadata Endpoint\n\nfor your sign-up policy:\n\n\n\n\nClick on \nOK\n to configure the authentication server flow, the \nSave\n to save the settings.  As before, you\ncan test your server flow by pointing your browser to \nhttps://yoursite.azurewebsites.net/.auth/login/aad\n:\n\n\n\n\nIf you have done everything right, you should be able to register an account, get the email verification code,\nand finally log in to get the happy login page.\n\n\n\n\nAll that is left to do is to configure your app for Azure Active Directory Server Flow.  We did that earlier when\ndiscussing the Enterprise Authentication flow for the mobile client.\n\n\nDrawbacks of Azure Active Directory B2C\n\u00b6\n\n\nAzure AD B2C is great for storing your users passwords and doing the sign-up and sign-in process for you.  There\nare a couple of reasons why you wouldn't want to use Azure Active Directory B2C.\n\n\nThe most obvious one is that this is built on Azure Active Directory.  That means you won't be able to, for example,\nintegrate the Facebook, Google and Twitter identity providers by utilizing their client libraries.  You also do\nnot get access to the underlying identity provider token, so you are restricted from accessing the Graph API for\nthe individual providers.  Finally, since the AAD B2C identity provider is configured with the AAD provider, you\ncan't use both a B2C provider and a regular AAD provider.\n\n\nIf you just want a sign-up / sign-in flow, then AAD B2C is probably the best way to go.  If, however, your plans\ninclude integration with other social identity providers, you should consider using the identity providers\ndirectly or via separate configuration with the Azure App Service Authentication / Authorization.\n\n\nUsing Third Party Tokens\n\u00b6\n\n\nThe final method of authenticating a user we are going to look at is a process by which you use a third party\nauthentication token.   For example, you may want to authenticate via \nGitHub\n or \nmiiCard\n or using\nan authentication provider like \nAuth0\n to get some single sign-in capabilities.\n\n\nAuthentication with third party tokens works remarkably similar to the custom authentication case.  Instead of\na username and password, you pass in the token from the other provider.\n\n\nTo look at this in example form, we are going to implement Auth0 as a provider. Your first stop should be the\n\nAuth0\n web site to sign up for a developer account. Once you have done that:\n\n\n\n\nClick on the \n+ NEW CLIENT\n button in the \nDashboard\n.\n\n\nGive your app a name, then click on \nNative\n and then \nCREATE\n.\n\n\n\n\n\n\n\n\nClick on the \nXamarin\n icon to get the Xamarin Quickstart.\n\n\nClick on \nSettings\n.\n\n\nEnter the callback URL in the \nAllowed Callback URLs\n.  The callback URL will be something like\n  \nhttps://_youraccount_.auth0.com/mobile\n and will be listed in the Quickstart page.\n\n\nScroll down to the bottom of the page and click on \nSAVE CHANGES\n.\n\n\nMake a note of the Client ID of the application.  You will need it later.\n\n\nClick on \nConnections\n.\n\n\nTurn on any connections that you want to use.  For this example, ensure you turn on the\n\nUsername-Password-Authentication\n and a couple of social providers.\n\n\n\n\nNow that the Auth0 service is configured, we can turn our attention to the mobile client.  The Xamarin.Auth0Client\nis a component, so right-click on the \nComponents\n node of a platform project and select \nGet More Components...\n.\nIn the dialog, find the \nAuth0 SDK\n, then click on \nAdd to App\n.\n\n\nFor our iOS application, we are going to integrate Auth0 into the \nServices\\iOSLoginProvider.cs\n:\n\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginAuth0Async();\n\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"auth0\", zumoPayload);\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n\n        public async Task<string> LoginAuth0Async()\n        {\n            var auth0 = new Auth0.SDK.Auth0Client(\n                \"shellmonger.auth0.com\",\n                \"lmFp5jXnwPpD9lQIYwgwwPmFeofuLpYq\");\n            var user = await auth0.LoginAsync(RootView, scope: \"openid email\");\n            return user.Auth0AccessToken;\n        }\n\n\n\n\nThe parameters for the constructor to the \nAuth0Client\n are your Auth0 domain and client ID.  You can retrieve these\nfrom the Auth0 management page for your app.  Note that I am requesting the email address.  This will become a part\nof my ZUMO token when I create it.\n\n\nSwitching our attention to our \nBackend\n project, we need a new custom authentication controller.  This is located\nin \nControllers\\Auth0Controller.cs\n:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.IdentityModel.Tokens;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Web.Http;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server.Login;\n\nnamespace Backend.Controllers\n{\n    [Route(\".auth/login/auth0\")]\n    public class Auth0Controller : ApiController\n    {\n        private JwtSecurityTokenHandler tokenHandler;\n        private string clientID, domain;\n        private string signingKey, audience, issuer;\n\n        public Auth0Controller()\n        {\n            // Information for the incoming Auth0 Token\n            domain = Environment.GetEnvironmentVariable(\"AUTH0_DOMAIN\");\n            clientID = Environment.GetEnvironmentVariable(\"AUTH0_CLIENTID\");\n\n            // Information for the outgoing ZUMO Token\n            signingKey = Environment.GetEnvironmentVariable(\"WEBSITE_AUTH_SIGNING_KEY\");\n            var website = Environment.GetEnvironmentVariable(\"WEBSITE_HOSTNAME\");\n            audience = $\"https://{website}/\";\n            issuer = $\"https://{website}/\";\n\n            // Token Handler\n            tokenHandler = new JwtSecurityTokenHandler();\n        }\n\n        [HttpPost]\n        public IHttpActionResult Post([FromBody] Auth0User body)\n        {\n            if (body == null || body.access_token == null || body.access_token.Length == 0)\n            {\n                return BadRequest();\n            }\n\n            try\n            {\n                var token = (JwtSecurityToken)tokenHandler.ReadToken(body.access_token);\n                if (!IsValidUser(token))\n                {\n                    return Unauthorized();\n                }\n\n                var subject = token.Claims.FirstOrDefault(c => c.Type.Equals(\"sub\"))?.Value;\n                var email = token.Claims.FirstOrDefault(c => c.Type.Equals(\"email\"))?.Value;\n                if (subject == null || email == null)\n                {\n                    return BadRequest();\n                }\n\n                var claims = new Claim[]\n                {\n                    new Claim(JwtRegisteredClaimNames.Sub, subject),\n                    new Claim(JwtRegisteredClaimNames.Email, email)\n                };\n\n                JwtSecurityToken zumoToken = AppServiceLoginHandler.CreateToken(\n                    claims, signingKey, audience, issuer, TimeSpan.FromDays(30));\n                return Ok(new LoginResult()\n                {\n                    AuthenticationToken = zumoToken.RawData,\n                    User = new LoginResultUser { UserId = email }\n                });\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"Auth0 JWT Exception = {ex.Message}\");\n                throw ex;\n            }\n        }\n\n        private bool IsValidUser(JwtSecurityToken token)\n        {\n            if (token == null)\n                return false;\n            var audience = token.Audiences.FirstOrDefault();\n            if (!audience.Equals(clientID))\n                return false;\n            if (!token.Issuer.Equals($\"https://{domain}/\"))\n                return false;\n            if (token.ValidTo.AddMinutes(5) < DateTime.Now)\n                return false;\n            return true;\n        }\n    }\n\n    public class Auth0User\n    {\n        public string access_token { get; set; }\n    }\n}\n\n\n\n\nNote that we are reading two new environment variables.  In the Azure App Service, you can read Application Settings\nby reading the environment variable of the same name.  We need to set the \nAUTH0_CLIENTID\n to the Client ID of\nour Auth0 application, and the \nAUTH0_DOMAIN\n to the domain of our account.  Both of these values need to match\nthe settings in the client.  These are not \"secure items\".  If using the client secret (to validate the token), then\nthat would be considered secure and should only appear on the server side.\n\n\nThe validation is that the token passed in is valid (i.e. it has the right audience, issuer and expiry times).  In\naddition, you should check the validity of the token signature.  You can do this by acquiring the token secret and\nusing \ntokenHandler.ValidateToken()\n instead of \ntokenHandler.ReadToken()\n.  My new token lasts for 30 days.  The\nZUMO token that is generated in custom authentication does not have to be the same length as the original token.\nYou can make it last for as long as you like.",
            "title": "Custom Authentication"
        },
        {
            "location": "/chapter2/custom/#custom-authentication",
            "text": "For some situations, the social or enterprise flows are not valid for the mobile client.  Perhaps you want the ability\nto provide a sign-up process with a username and password rather than using a social provider.  Perhaps you want to use\nan alternate provider that is not one of the supported five providers.  Whatever the reason, Azure App Service provides\nthe ability to handle all situations.  In this section, I will look at three methods for providing a unique set of\nusernames with no connection to the social or enterprise authentication.",
            "title": "Custom authentication"
        },
        {
            "location": "/chapter2/custom/#using-an-identity-database",
            "text": "Probably the most common request is to use a custom identity database.  In general, this is desirable because you\nalready have a database of usernames and password.  However, it's probably the least desirable option because of the\nsecurity concerns that come along with this technique.  The news is rife with password leakage for very large\norganizations.  The best way to ensure you do not disclose a users password is to not have it in the first place.   I'm not going to cover the sign-up case here.  This would be an additional process and would use a regular Web API\nto insert data into the database after validation (and probably verification via email\nor text message).   The first thing we need to add to our project is a model for the user object.  I created the following in the  Models \nfolder of the  Backend  project:  using System.ComponentModel.DataAnnotations;\n\nnamespace Backend.Models\n{\n    public class User\n    {\n        [Key]\n        public int Id { get; set; }\n\n        public string Username { get; set; }\n\n        public string Password { get; set; }\n    }\n}  We also need to modify the  MobileServiceContext.cs  file so that the database table is included in the Entity Framework\ncontext:      public class MobileServiceContext : DbContext\n    {\n        private const string connectionStringName = \"Name=MS_TableConnectionString\";\n\n        public MobileServiceContext() : base(connectionStringName)\n        {\n        }\n\n        public DbSet<TodoItem> TodoItems { get; set; }\n        public DbSet<User> Users { get; set; }\n\n        protected override void OnModelCreating(DbModelBuilder modelBuilder)\n        {\n            modelBuilder.Conventions.Add(\n                new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n                    \"ServiceTableColumn\", (property, attributes) => attributes.Single().ColumnType.ToString()));\n        }\n    }  Finally, we probably want to put some seed data into the database when it is first created so that we can test it.\nAdjust the  MobileServiceInitializer  in the  Startup.MobileApp.cs  file:          protected override void Seed(MobileServiceContext context)\n        {\n            List<TodoItem> todoItems = new List<TodoItem>\n            {\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"First item\", Complete = false },\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"Second item\", Complete = false }\n            };\n\n            foreach (TodoItem todoItem in todoItems)\n            {\n                context.Set<TodoItem>().Add(todoItem);\n            }\n\n            List<User> users = new List<User>\n            {\n                new User { Id = 1, Username = \"adrian\", Password = \"supersecret\" }\n            };\n\n            foreach (User user in users)\n            {\n                context.Set<User>().Add(user);\n            }\n\n            base.Seed(context);\n        }  Note that we are storing the passwords in plain text.  This is most definitely frowned upon.  We should be using some\nsort of encryption.  This code is most definitely just for demonstration purposes.  Continuing the code on the backend,\n we need to handle the request to authenticate from the client.  We will use a custom API controller for this; it is\n located in  Controllers\\CustomAuthController.cs :  using System;\nusing System.IdentityModel.Tokens;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Web.Http;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server.Login;\nusing Newtonsoft.Json;\n\nnamespace Backend.Controllers\n{\n    [Route(\".auth/login/custom\")]\n    public class CustomAuthController : ApiController\n    {\n        private MobileServiceContext db;\n        private string signingKey, audience, issuer;\n\n        public CustomAuthController()\n        {\n            db = new MobileServiceContext();\n            signingKey = Environment.GetEnvironmentVariable(\"WEBSITE_AUTH_SIGNING_KEY\");\n            var website = Environment.GetEnvironmentVariable(\"WEBSITE_HOSTNAME\");\n            audience = $\"https://{website}/\";\n            issuer = $\"https://{website}/\";\n        }\n\n        [HttpPost]\n        public IHttpActionResult Post([FromBody] User body)\n        {\n            if (body == null || body.Username == null || body.Password == null ||\n                body.Username.Length == 0 || body.Password.Length == 0)\n            {\n                return BadRequest(); ;\n            }\n\n            if (!IsValidUser(body))\n            {\n                return Unauthorized();\n            }\n\n            var claims = new Claim[]\n            {\n                new Claim(JwtRegisteredClaimNames.Sub, body.Username)\n            };\n\n            JwtSecurityToken token = AppServiceLoginHandler.CreateToken(\n                claims, signingKey, audience, issuer, TimeSpan.FromDays(30));\n            return Ok(new LoginResult()\n            {\n                AuthenticationToken = token.RawData,\n                User = new LoginResultUser { UserId = body.Username }\n            });\n        }\n\n        protected override void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                db.Dispose();\n            }\n            base.Dispose(disposing);\n        }\n\n        private bool IsValidUser(User user)\n        {\n            return db.Users.Count(u => u.Username.Equals(user.Username) && u.Password.Equals(user.Password)) > 0;\n        }\n    }\n\n    public class LoginResult\n    {\n        [JsonProperty(PropertyName = \"authenticationToken\")]\n        public string AuthenticationToken { get; set; }\n\n        [JsonProperty(PropertyName = \"user\")]\n        public LoginResultUser User { get; set; }\n    }\n\n    public class LoginResultUser\n    {\n        [JsonProperty(PropertyName = \"userId\")]\n        public string UserId { get; set; }\n    }\n}  There is a lot going on here:   The constructor reads the signing key and other information that we need for constructing the JWT.  Note that the\n  signing key is only available if you have the Authentication / Authorization is turned on.  The  LoginResult  and  LoginResultUser  provide the response to the client, when serialized by the JSON serializer.  The  Post()  method is where the work happens.  It verifies that you have a valid object, then checks that the\n  username and password match something in the user database.  It then constructs the JWT and returns the required\n  JSON object.  The  IsValidUser()  method actually validates the username and password provided in the request with the users in\n  the database.  This version is very simplistic.  I expect your version to at least include encryption of the password.    Note that you must turn on Authentication / Authorization in your App Service.  Set the  Action to take when request\nis not authenticated  to  Allow Request (no action)  and do not configure any of the supported authentication providers.   Next, we need to wire the custom authentication controller so that it appears in the same place as all the other\nauthenticators.  We are going to access it via the  /.auth/login/custom  endpoint.  The normal ASP.NET methods can be\napplied for this.  In this project, we can enable  attribute routing :  public static void ConfigureMobileApp(IAppBuilder app)\n{\n    HttpConfiguration config = new HttpConfiguration();\n\n    new MobileAppConfiguration()\n        .AddTablesWithEntityFramework()\n        .ApplyTo(config);\n\n    // Map routes by attribute\n    config.MapHttpAttributeRoutes();\n\n    // Use Entity Framework Code First to create database tables based on your DbContext\n    Database.SetInitializer(new MobileServiceInitializer());\n\n    MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();\n\n    if (string.IsNullOrEmpty(settings.HostName))\n    {\n        app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions\n        {\n            SigningKey = ConfigurationManager.AppSettings[\"SigningKey\"],\n            ValidAudiences = new[] { ConfigurationManager.AppSettings[\"ValidAudience\"] },\n            ValidIssuers = new[] { ConfigurationManager.AppSettings[\"ValidIssuer\"] },\n            TokenHandler = config.GetAppServiceTokenHandler()\n        });\n    }\n\n    app.UseWebApi(config);\n}  At this point, we can deploy the backend to the App Service and send a suitably formed POST request to\nthe backend.  I use [Postman][19] for this purpose. The request:   A successful POST will return the token and user ID in the response:   Any other request (such as no body or a wrong username or password) should produce the right response.  If the body is\ncorrect, but the information is wrong, then a 401 Unauthorized response should be produced.  If the body is invalid, then\n400 Bad Request should be produced.   Note that the format of the response is exactly the same as the token response we saw earlier when we were discussing\nthe contents of a JWT.   We can now turn our attention to the mobile client.  Custom Authentication is always implemented using a client-flow\n mechanism. To implement this, we are going to adjust the entry page so that the username and password fields are\n displayed.  The gathered username and password will then be passed to a new ICloudService  LoginAsync()  method.\n All of the UI work is done in the shared project.  To start, we need a copy of the  User.cs  model from the backend project.  Unlike Data Transfer Objects, this model is\nthe same:  namespace TaskList.Models\n{\n    public class User\n    {\n        public string Username { get; set; }\n        public string Password { get; set; }\n    }\n}  The abstraction we use for the cloud service needs to be adjusted so that we can pass the user object into the login\nmethod.  This is the  Abstractions\\ICloudService.cs  interface:  using System.Threading.Tasks;\nusing TaskList.Models;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n\n        Task LoginAsync(User user);\n    }\n}  Note that I am adding a new version of the  LoginAsync()  method.  The concrete version of this method no longer has\nto go through the dependency service since I can use shared code.  Here is the definition of our new  LoginAsync() \nmethod in  Services\\AzureCloudService.cs :          public Task LoginAsync(User user)\n        {\n            return client.LoginAsync(\"custom\", JObject.FromObject(user));\n        }  Finally, we need to update the view-model  ViewModels\\EntryPageViewModel.cs  so that we can store the username and\npassword in the model.  We will also update the call to the  LoginAsync()  method of the cloud service so it calls\nour new method:  using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.Models;\nusing Xamarin.Forms;\n\nnamespace TaskList.ViewModels\n{\n    public class EntryPageViewModel : BaseViewModel\n    {\n        public EntryPageViewModel()\n        {\n            Title = \"Task List\";\n            User = new Models.User { Username = \"\", Password = \"\" };\n        }\n\n        Command loginCmd;\n        public Command LoginCommand => loginCmd ?? (loginCmd = new Command(async () => await ExecuteLoginCommand()));\n\n        public Models.User User { get; set; }\n\n        async Task ExecuteLoginCommand()\n        {\n            if (IsBusy)\n                return;\n            IsBusy = true;\n\n            try\n            {\n                var cloudService = ServiceLocator.Instance.Resolve<ICloudService>();\n                await cloudService.LoginAsync(User);\n                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"[ExecuteLoginCommand] Error = {ex.Message}\");\n            }\n            finally\n            {\n                IsBusy = false;\n            }\n        }\n    }\n}  There are three new pieces here.  Firstly, we have the User property (for holding the username and password in our\nform).  Next, the constructor initializes the user object to an empty object.  Finally, the call to  LoginAsync() \npasses the user object to the cloud service.  We also need some UI changes.  Specifically, we need a couple of fields for the username and password added to the Pages\\EntryPage.xaml  file:  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage x:Class=\"TaskList.Pages.EntryPage\"\n             xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <StackLayout HorizontalOptions=\"Center\"\n                     Orientation=\"Vertical\"\n                     VerticalOptions=\"Center\">\n            <Label Text=\"Username?\" />\n            <Entry Text=\"{Binding User.Username}\" />\n            <Label Text=\"Password?\" />\n            <Entry IsPassword=\"True\" Text=\"{Binding User.Password}\" />\n\n            <Button BackgroundColor=\"Teal\"\n                    BorderRadius=\"10\"\n                    Command=\"{Binding LoginCommand}\"\n                    Text=\"Enter The App\"\n                    TextColor=\"White\" />\n        </StackLayout>\n    </ContentPage.Content>\n</ContentPage>  There is lots to complain about in this demonstration (including lack of encryption, storage of passwords, and a\ngenerally bad UI).  However, it serves to demonstrate the salient points for using a (perhaps pre-existing) identity\ndatabase for authentication of the users.",
            "title": "Using an Identity Database."
        },
        {
            "location": "/chapter2/custom/#using-azure-active-directory-b2c",
            "text": "Custom authentication allows you to really customize the process, but I like to reduce the amount of code I write by\nusing services or libraries.   The whole sign-in and sign-up process is ripe for this.  The code needed for building\nthe sign-in / sign-up process is boiler-plate code.  It also introduces problems that I have to deal with going forward.\nI have to store passwords and profile information, which introduces a security concern.  I have to scale the database\nand ensure my app scales with it as my app gets popular.  Finally, I am being fairly inflexible and causing potential\nprivacy concerns with my users.  There are a couple of services that I can use to get around these concerns.  The first is an Azure service: Azure Active Directory B2C .  The B2C stands for Business to Consumer.  It is a mechanism by which you can add a\nsign-in and sign-up flow to your application.  The user can enter a username or password, or, at your option, add on\nsupport for one or more social providers.  In addition, there is support for branding the sign-in process, doing email\nverification of sign-ups and automatic password resets via email.  The Azure AD B2C sign-in / sign-up process is\nprimarily a server-flow proecss, so we will be able to add support in our app with just one line of code.",
            "title": "Using Azure Active Directory B2C"
        },
        {
            "location": "/chapter2/custom/#the-minimal-setup-of-azure-ad-b2c",
            "text": "Azure AD is managed from the  Classic Azure Portal , so start by logging in using your Azure\nSubscription credentials.   Click on the big  + NEW  button in the bottom left of the screen.  Select  App Services  ->  Active Directory  ->  Directory  ->  Custom Create .     Choose a name for the tenant, then choose a unique domain name (which will appear in the    onmicrosoft.com \n  domain) and country.  Ensure you check the  This is a B2C directory.     Click on the tick to create the directory.  As noted, this process will take a couple of minutes to complete.   This creates a new tenant for you to manage.  If you go back to your  Azure Portal  and click on your name\n(top right corner), you will note that there is a new DIRECTORY entry for your B2C tenant.  This is where you will be\nmanaging your B2C tenant.  It's a good idea to pin the B2C settings blade to your dashboard or navigation pane so you can access it faster.\nTo do this:   Log in to the  Azure Portal .  Switch to your B2C tenant by clicking on your name, then selecting the new tenant in the drop-down.  The portal will probably ask you to confirm your ID and password.  Click on  Browse>  in the left-hand navigation bar.  Search for  B2C .  Click on the empty star next to  Azure AD B2C .    This will make Azure AD B2C appear in your left hand navigation bar.  To place it on the dashboard, click on Azure AD B2C  in the left hand navigation bar, then click on the pin at the top of the  AZURE AD B2C SETTINGS \nblade.  The next job is to create an application registration within the B2C tenant:   Open the  Azure AD B2C  from your dashboard or the left hand navigation.  In the  Settings  blade, click on  Applications .     In the  New application  blade:  Enter a unique name for the application.  Click on  Yes  under  Include web app / web API .  In the Reply URL, enter  https://yoursite.azurewebsites.net/.auth/login/aad/callback .  Click on  Generate key  - a key will be generated (cut and paste it somewhere).     Click on  Create .   There is no spinner or deployment here.  After approximately 5-10 seconds, the application registration will appear\nin the list.  Click on the application registration to see the  Application ID :   You will need the Application ID and App Key (which you copied earlier) later on.  The next step is to create a\nSign-in/Sign-up policy.  We'll create a policy for signing up with an email address and email confirmation, then\nsigning in with that email address:   In the  Settings  blade, click on  Sign-up or sign-in policies .  Click on the  + Add  button.  Give the policy a name, like  emailPolicy .  Click on  Identity providers :  Click on  Email signup / Local Account  (a tick will appear next to the row).  Click on  OK .  Click on  Sign-up attributes :  Click on  Email Address  and any other fields you want to gather.  Click on  OK .  Click on  Application claims :  Click on  Email Addresses  and any other fields you want to provide to the application.  Click on  OK  Click on  Create  on the  Add policy  blade.  Click on the policy you just created.  It will be named something like  B2C_1_emailPolicy . Make a note of the Metadata Endpoint for this policy .    Now that your B2C tenant is configured, you can switch back to your original tenant (by clicking on your name in\nthe top-right corner and selecting the default directory).  To configure the App Service  Authentication / Authorization .  Open up the  Settings  blade, then Authentication / Authorization .  Ensure the authentication service is turned on.  Click on Azure Active Directory . This time, we are going to select the  Advanced  option.  The  Client ID  is\nthe application ID of your B2C application registration, and the  Issuer Url  is the  Metadata Endpoint \nfor your sign-up policy:   Click on  OK  to configure the authentication server flow, the  Save  to save the settings.  As before, you\ncan test your server flow by pointing your browser to  https://yoursite.azurewebsites.net/.auth/login/aad :   If you have done everything right, you should be able to register an account, get the email verification code,\nand finally log in to get the happy login page.   All that is left to do is to configure your app for Azure Active Directory Server Flow.  We did that earlier when\ndiscussing the Enterprise Authentication flow for the mobile client.",
            "title": "The Minimal Setup of Azure AD B2C"
        },
        {
            "location": "/chapter2/custom/#drawbacks-of-azure-active-directory-b2c",
            "text": "Azure AD B2C is great for storing your users passwords and doing the sign-up and sign-in process for you.  There\nare a couple of reasons why you wouldn't want to use Azure Active Directory B2C.  The most obvious one is that this is built on Azure Active Directory.  That means you won't be able to, for example,\nintegrate the Facebook, Google and Twitter identity providers by utilizing their client libraries.  You also do\nnot get access to the underlying identity provider token, so you are restricted from accessing the Graph API for\nthe individual providers.  Finally, since the AAD B2C identity provider is configured with the AAD provider, you\ncan't use both a B2C provider and a regular AAD provider.  If you just want a sign-up / sign-in flow, then AAD B2C is probably the best way to go.  If, however, your plans\ninclude integration with other social identity providers, you should consider using the identity providers\ndirectly or via separate configuration with the Azure App Service Authentication / Authorization.",
            "title": "Drawbacks of Azure Active Directory B2C"
        },
        {
            "location": "/chapter2/custom/#using-third-party-tokens",
            "text": "The final method of authenticating a user we are going to look at is a process by which you use a third party\nauthentication token.   For example, you may want to authenticate via  GitHub  or  miiCard  or using\nan authentication provider like  Auth0  to get some single sign-in capabilities.  Authentication with third party tokens works remarkably similar to the custom authentication case.  Instead of\na username and password, you pass in the token from the other provider.  To look at this in example form, we are going to implement Auth0 as a provider. Your first stop should be the Auth0  web site to sign up for a developer account. Once you have done that:   Click on the  + NEW CLIENT  button in the  Dashboard .  Give your app a name, then click on  Native  and then  CREATE .     Click on the  Xamarin  icon to get the Xamarin Quickstart.  Click on  Settings .  Enter the callback URL in the  Allowed Callback URLs .  The callback URL will be something like\n   https://_youraccount_.auth0.com/mobile  and will be listed in the Quickstart page.  Scroll down to the bottom of the page and click on  SAVE CHANGES .  Make a note of the Client ID of the application.  You will need it later.  Click on  Connections .  Turn on any connections that you want to use.  For this example, ensure you turn on the Username-Password-Authentication  and a couple of social providers.   Now that the Auth0 service is configured, we can turn our attention to the mobile client.  The Xamarin.Auth0Client\nis a component, so right-click on the  Components  node of a platform project and select  Get More Components... .\nIn the dialog, find the  Auth0 SDK , then click on  Add to App .  For our iOS application, we are going to integrate Auth0 into the  Services\\iOSLoginProvider.cs :          public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Client Flow\n            var accessToken = await LoginAuth0Async();\n\n            var zumoPayload = new JObject();\n            zumoPayload[\"access_token\"] = accessToken;\n            await client.LoginAsync(\"auth0\", zumoPayload);\n        }\n\n        public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n\n        public async Task<string> LoginAuth0Async()\n        {\n            var auth0 = new Auth0.SDK.Auth0Client(\n                \"shellmonger.auth0.com\",\n                \"lmFp5jXnwPpD9lQIYwgwwPmFeofuLpYq\");\n            var user = await auth0.LoginAsync(RootView, scope: \"openid email\");\n            return user.Auth0AccessToken;\n        }  The parameters for the constructor to the  Auth0Client  are your Auth0 domain and client ID.  You can retrieve these\nfrom the Auth0 management page for your app.  Note that I am requesting the email address.  This will become a part\nof my ZUMO token when I create it.  Switching our attention to our  Backend  project, we need a new custom authentication controller.  This is located\nin  Controllers\\Auth0Controller.cs :  using System;\nusing System.Diagnostics;\nusing System.IdentityModel.Tokens;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Web.Http;\nusing Backend.Models;\nusing Microsoft.Azure.Mobile.Server.Login;\n\nnamespace Backend.Controllers\n{\n    [Route(\".auth/login/auth0\")]\n    public class Auth0Controller : ApiController\n    {\n        private JwtSecurityTokenHandler tokenHandler;\n        private string clientID, domain;\n        private string signingKey, audience, issuer;\n\n        public Auth0Controller()\n        {\n            // Information for the incoming Auth0 Token\n            domain = Environment.GetEnvironmentVariable(\"AUTH0_DOMAIN\");\n            clientID = Environment.GetEnvironmentVariable(\"AUTH0_CLIENTID\");\n\n            // Information for the outgoing ZUMO Token\n            signingKey = Environment.GetEnvironmentVariable(\"WEBSITE_AUTH_SIGNING_KEY\");\n            var website = Environment.GetEnvironmentVariable(\"WEBSITE_HOSTNAME\");\n            audience = $\"https://{website}/\";\n            issuer = $\"https://{website}/\";\n\n            // Token Handler\n            tokenHandler = new JwtSecurityTokenHandler();\n        }\n\n        [HttpPost]\n        public IHttpActionResult Post([FromBody] Auth0User body)\n        {\n            if (body == null || body.access_token == null || body.access_token.Length == 0)\n            {\n                return BadRequest();\n            }\n\n            try\n            {\n                var token = (JwtSecurityToken)tokenHandler.ReadToken(body.access_token);\n                if (!IsValidUser(token))\n                {\n                    return Unauthorized();\n                }\n\n                var subject = token.Claims.FirstOrDefault(c => c.Type.Equals(\"sub\"))?.Value;\n                var email = token.Claims.FirstOrDefault(c => c.Type.Equals(\"email\"))?.Value;\n                if (subject == null || email == null)\n                {\n                    return BadRequest();\n                }\n\n                var claims = new Claim[]\n                {\n                    new Claim(JwtRegisteredClaimNames.Sub, subject),\n                    new Claim(JwtRegisteredClaimNames.Email, email)\n                };\n\n                JwtSecurityToken zumoToken = AppServiceLoginHandler.CreateToken(\n                    claims, signingKey, audience, issuer, TimeSpan.FromDays(30));\n                return Ok(new LoginResult()\n                {\n                    AuthenticationToken = zumoToken.RawData,\n                    User = new LoginResultUser { UserId = email }\n                });\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"Auth0 JWT Exception = {ex.Message}\");\n                throw ex;\n            }\n        }\n\n        private bool IsValidUser(JwtSecurityToken token)\n        {\n            if (token == null)\n                return false;\n            var audience = token.Audiences.FirstOrDefault();\n            if (!audience.Equals(clientID))\n                return false;\n            if (!token.Issuer.Equals($\"https://{domain}/\"))\n                return false;\n            if (token.ValidTo.AddMinutes(5) < DateTime.Now)\n                return false;\n            return true;\n        }\n    }\n\n    public class Auth0User\n    {\n        public string access_token { get; set; }\n    }\n}  Note that we are reading two new environment variables.  In the Azure App Service, you can read Application Settings\nby reading the environment variable of the same name.  We need to set the  AUTH0_CLIENTID  to the Client ID of\nour Auth0 application, and the  AUTH0_DOMAIN  to the domain of our account.  Both of these values need to match\nthe settings in the client.  These are not \"secure items\".  If using the client secret (to validate the token), then\nthat would be considered secure and should only appear on the server side.  The validation is that the token passed in is valid (i.e. it has the right audience, issuer and expiry times).  In\naddition, you should check the validity of the token signature.  You can do this by acquiring the token secret and\nusing  tokenHandler.ValidateToken()  instead of  tokenHandler.ReadToken() .  My new token lasts for 30 days.  The\nZUMO token that is generated in custom authentication does not have to be the same length as the original token.\nYou can make it last for as long as you like.",
            "title": "Using Third Party Tokens"
        },
        {
            "location": "/chapter2/authorization/",
            "text": "Claims and Authorization\n\u00b6\n\n\nNow that we have covered all the techniques for authentication, it's time to look at authorization.  While authentication\nlooked at verifying that a user is who they say they are, authorization looks at if a user is allowed to do a specific\noperation.\n\n\nAuthorization is handled within the server-side project by the \n[Authorize]\n attribute.  Our Azure Mobile Apps backend\nis leveraging this to provide authorization based on whether a user is authenticated or not.  The Authorize attribute\ncan also check to see if a user is in a list of users or roles.  However, there is a problem with this.  The user id\nis not guessable and we have no roles.  To see what I mean, run the \nBackend\n project locally and set a break point\non the \nGetAllTodoItems()\n method in the \nTodoItemController\n, then run your server and your UWP application.\n\n\n\n\nOnce you have built and deployed the UWP application, it will appear in your normal Application list.  This allows\nyou to run the application and the server at the same time on the same machine.\n\n\n\n\nOnce you have authenticated, you will be able to set a break point to take a look at \nthis.User.Identity\n:\n\n\n\n\nNote that the \nName\n property is null.  This is the property that is used when you want to authorize individual users.\nExpand the \nClaims\n property and then click on \nResults View\n:\n\n\n\n\nThe only claims are the ones in the token, and none of them match the \nRoleClaimType\n, so we can't use roles either.\nClearly, we are going to have to do something else.\n\n\nObtaining User Claims\n\u00b6\n\n\nAt some point you are going to need to deal with something other than the claims that are in the token passed for\nauthentication.  Fortunately, the Authentication / Authorization feature has an endpoint for that at \n/.auth/me\n:\n\n\n\n\nOf course, the \n/.auth/me\n endpoint is not of any use if you cannot access it.  The most use of this information is\ngained during authorization on the server and we will cover this use later on.  However, there are reasons to pull\nthis information on the client as well.  For example, we may want to make the List View title be our name instead of\n\"Tasks\".\n\n\n\n\nYou can't use the /.auth/me endpoint when using custom authentication.\n\n\n\n\nSince identity provider claims can be anything, they are transferred as a list within a JSON object.  Before we can\ndecode the JSON object, we need to define the models.  This is done in the shared \nTaskList\n project.  I've defined\nthis in \nModels\\AppServiceIdentity.cs\n.\n\n\nusing System.Collections.Generic;\nusing Newtonsoft.Json;\n\nnamespace TaskList.Models\n{\n    public class AppServiceIdentity\n    {\n        [JsonProperty(PropertyName = \"id_token\")]\n        public string IdToken { get; set; }\n\n        [JsonProperty(PropertyName = \"provider_name\")]\n        public string ProviderName { get; set; }\n\n        [JsonProperty(PropertyName = \"user_id\")]\n        public string UserId { get; set; }\n\n        [JsonProperty(PropertyName = \"user_claims\")]\n        public List<UserClaim> UserClaims { get; set; }\n    }\n\n    public class UserClaim\n    {\n        [JsonProperty(PropertyName = \"typ\")]\n        public string Type { get; set; }\n\n        [JsonProperty(PropertyName = \"val\")]\n        public string Value { get; set; }\n    }\n}\n\n\n\n\nThis matches the JSON format from the \n/.auth/me\n call we did earlier.   This is going to be a part of the\nICloudService as follows:\n\n\nusing System.Threading.Tasks;\nusing TaskList.Models;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n\n        Task LoginAsync(User user);\n\n        Task<AppServiceIdentity> GetIdentityAsync();\n    }\n}\n\n\n\n\nFinally, we need to actually implement the concrete version in \nAzureCloudService.cs\n:\n\n\nList<AppServiceIdentity> identities = null;\n\npublic async Task<AppServiceIdentity> GetIdentityAsync()\n{\n    if (client.CurrentUser == null || client.CurrentUser?.MobileServiceAuthenticationToken == null)\n    {\n        throw new InvalidOperationException(\"Not Authenticated\");\n    }\n\n    if (identities == null)\n    {\n        identities = await client.InvokeApiAsync<List<AppServiceIdentity>>(\"/.auth/me\");\n    }\n\n    if (identities.Count > 0)\n        return identities[0];\n    return null;\n}\n\n\n\n\nNote that there is no reason to instantiate your own \nHttpClient()\n.  The Azure Mobile Apps SDK has a method for\ninvoking custom API calls (as we shall see later on).  However, if you prefix the path with a slash, it will execute\na HTTP GET for any API with any authentication that is currently in force.  We can leverage this to call the\n\n/.auth/me\n endpoint and decode the response in one line of code.  Adjust the \nExecuteRefreshCommand()\n method in\nthe \nViewModels\\TaskListViewModel.cs\n file to take advantage of this:\n\n\nasync Task ExecuteRefreshCommand()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var identity = await cloudService.GetIdentityAsync();\n        if (identity != null)\n        {\n            var name = identity.UserClaims.FirstOrDefault(c => c.Type.Equals(\"name\")).Value;\n            Title = $\"Tasks for {name}\";\n        }\n        var list = await Table.ReadAllItemsAsync();\n        Items.ReplaceRange(list);\n    }\n    catch (Exception ex)\n    {\n        await Application.Current.MainPage.DisplayAlert(\"Items Not Loaded\", ex.Message, \"OK\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}\n\n\n\n\nThe return value from the \nGetIdentityAsync()\n method is the first identity.  Normally, a user would only authenticate\nonce, so this is fairly safe.  The number of claims returned depends on the identity provider and could easily number\nin the hundreds.  Even the default configuration for Azure Active Directory returns 18 claims.  These are easily handled\nusing LINQ, however.  The \nType\n property holds the type.  This could be a short (common) name.  It could also be a\nschema name, which looks more like a URI.  The only way to know what claims are coming back for sure is to look at\nthe \n/.auth/me\n result with something like Postman.\n\n\n\n\nNote\n: If you are using Custom Authentication (e.g. username/password or a third-party token), then the \n/.auth/me\n\nendpoint is not available to you.  You can still produce a custom API in your backend to provide this information to\nyour client, but you are responsible for the code - it's custom, after all!\n\n\n\n\nAuthorization\n\u00b6\n\n\nNow that we have covered all the techniques for authentication, it's time to look at authorization.  While authentication\nlooked at verifying that a user is who they say they are, authorization looks at if a user is allowed to do a specific\noperation.\n\n\nAuthorization is handled within the server-side project by the \n[Authorize]\n attribute.  Our Azure Mobile Apps backend\nis leveraging this to provide authorization based on whether a user is authenticated or not.  The Authorize attribute\ncan also check to see if a user is in a list of users or roles.  However, there is a problem with this.  The user id\nis not guessable and we have no roles.  To see what I mean, run the \nBackend\n project and set a break point on the\n\nGetAllTodoItems()\n method in the \nTodoItemController\n, then run your server and your UWP application.\n\n\n\n\nOnce you have built and deployed the UWP application, it will appear in your normal Application list.  This allows\nyou to run the application and the server at the same time on the same machine.  Alternatively, you can attach a\nDebugger to your Azure App Service within Visual Studio's Cloud Explorer.\n\n\n\n\nOnce you have authenticated, you will be able to set a break point to take a look at \nthis.User.Identity\n:\n\n\n\n\nNote that the \nName\n property is null.  This is the property that is used when you want to authorize individual users.\nExpand the \nClaims\n property and then click on \nResults View\n:\n\n\n\n\nThe only claims are the ones in the token, and none of them match the \nRoleClaimType\n, so we can't use roles either.\nClearly, we are going to have to do something else.  Fortunately, we already know that we can get some information\nabout the identity provider claims from the \n/.auth/me\n endpoint.  To get the extra information, we need to query\nthe \nUser\n object:\n\n\nvar identity = await User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request);\n\n\n\n\nThere is one \nCredentials\n class for each supported authentication technique - Azure Active Directory, Facebook,\nGoogle, Microsoft Account and Twitter.  These are in the \nMicrosoft.Azure.Mobile.Server.Authentication\n namespace.\nThey all follow the same pattern as the model we created for the client - there are Provider, UserId and UserClaims\nproperties.  The token and any special information will be automatically decoded for you.  For instance, the TenantId\nis pulled out of the response for Azure AD.\n\n\n\n\nYou can use the AccessToken property to do Graph API lookups for most providers in a custom API. We'll get into\nthis more in a later Chapter.\n\n\n\n\nAdding Group Claims to the Request\n\u00b6\n\n\nThere are times when you want to add something else to the token that is returned from Azure AD. The most common\nrequirement is to add group information to the response so you can handle group-based authorization.\n\n\nTo add security groups to the Azure AD token:\n\n\n\n\nLog into the \nClassic Portal\n.\n\n\nClick on your directory (probably called \nDefault Directory\n) in the \nAll Items\n list.\n\n\nClick on \nAPPLICATIONS\n, then your WEB application.\n\n\nClick on \nMANAGE MANIFEST\n (at the bottom of the page), then \nDownload Manifest\n.\n\n\nClick on \nDownload manifest\n.\n\n\n\n\nThis will download a JSON file.  Edit the file with a text editor.  (I use Visual Studio Code).  At the top of the\nfile is this:\n\n\n  \"displayName\": \"webapp-for-the-book\",\n  \"errorUrl\": null,\n  \"groupMembershipClaims\": null,\n  \"homepage\": \"https://the-book.azurewebsites.net\",\n  \"identifierUris\": [\n    \"https://the-book.azurewebsites.net\"\n  ],\n  \"keyCredentials\": [],\n  \"knownClientApplications\": [],\n\n\n\n\nChange the \ngroupMembershipClaims\n to \"SecurityGroup\":\n\n\n  \"displayName\": \"webapp-for-the-book\",\n  \"errorUrl\": null,\n  \"groupMembershipClaims\": \"SecurityGroup\",\n  \"homepage\": \"https://the-book.azurewebsites.net\",\n  \"identifierUris\": [\n    \"https://the-book.azurewebsites.net\"\n  ],\n  \"keyCredentials\": [],\n  \"knownClientApplications\": [],\n\n\n\n\nSave the file.  You can now upload this again.  Go back to the WEB application, click on \nMANAGE MANIFEST\n, then\nclick on \nUpload Manifest\n.  Select the file and click on the tick.\n\n\n\n\nYou can now give the web application additional permissions:\n\n\n\n\nClick on the \nCONFIGURE\n tab.\n\n\nScroll to the bottom, click on \nDelegated Permissions\n.\n\n\nCheck the box for \nRead directory data\n.\n\n\n\n\n\n\n\n\nClick on \nSave\n.\n\n\n\n\nNow that you have configured the application to return groups as part of the claims, you should probably add a\ncouple of groups:\n\n\n\n\nClick on the back-arrow (at the top left) to return to the top level of your directory.\n\n\nClick on \nGROUPS\n.\n\n\nClick on \nADD GROUP\n.\n\n\nFill in the information, select \nSecurity\n as the group type, then click on the tick.\n\n\n\n\n\n\n\n\nClick on the new group, then click on \nPROPERTIES\n.\n\n\n\n\n\n\n\n\nMake a note of the \nOBJECT ID\n.  The claims for groups are listed by the Object ID, so you will need this to\n   refer to the group later.\n\n\n\n\nIt's a good idea to add a couple of groups for testing purposes.  If you are using the organization directory, you\nwill need to request the creation of a couple of groups for application roles.  The view of the groups will be shown\nwhen we get the identity of the user using \nUser.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request)\n:\n\n\n\n\nGroup Authorization\n\u00b6\n\n\nNow that we have group claims in the claims list for the \n/.auth/me\n endpoint, we can move forward to do authorization\nbased on these claims.  This can be done in a relatively basic manner by implementing a method to check the claims:\n\n\nasync Task<bool> IsAuthorizedAsync()\n{\n    var identity = await User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request);\n    var countofGroups = identity.UserClaims\n        .Where(c => c.Type.Equals(\"groups\") && c.Value.Equals(\"01f214a9-af1f-4bdd-938f-3f16749aef0e\"))\n        .Count();\n    return (countofGroups > 0);\n}\n\n\n\n\nThe \nUserClaims\n object is an \nIEnumerable\n that contains objects with a Type and a Value.  The Type for the group\nclaims is \ngroups\n.  Once we have this knowledge, we can use a LINQ query to obtain a count of the claims that match\nthe conditions we want to test.  The Value we use is the Object ID of the group.  This is available in the\n\nPROPERTIES\n tab of the group.\n\n\nWe can prevent a new record being added by adjusting the \nPostTodoItem()\n method:\n\n\npublic async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n{\n    if (!await IsAuthorizedAsync())\n    {\n        return Unauthorized();\n    }\n    TodoItem current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}\n\n\n\n\nUnfortunately, most of the table controller methods do not return an \nIHttpActionResult\n, so this has limited value.\nWhat would be better would be an \n[Authorize]\n attribute that tests the claims for us.  For instance, we should be\nable to do the following:\n\n\n[AuthorizeClaims(\"groups\", \"01f214a9-af1f-4bdd-938f-3f16749aef0e\")]\npublic async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n{\n    TodoItem current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}\n\n\n\n\nThe \n[AuthorizeClaims()]\n attribute does not exist, so we have to provide it ourselves:\n\n\nusing System.Linq;\nusing System.Net;\nusing System.Security.Principal;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.Filters;\nusing Microsoft.Azure.Mobile.Server.Authentication;\n\nnamespace Backend.Helpers\n{\n    public class AuthorizeClaimsAttribute : AuthorizationFilterAttribute\n    {\n        string Type { get; }\n        string Value { get; }\n\n        public AuthorizeClaimsAttribute(string type, string value)\n        {\n            Type = type;\n            Value = value;\n        }\n\n        public override async Task OnAuthorizationAsync(HttpActionContext actionContext, CancellationToken cancellationToken)\n        {\n            var request = actionContext.Request;\n            var user = actionContext.RequestContext.Principal;\n            if (user != null)\n            {\n                var identity = await user.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(request);\n                var countOfMatchingClaims = identity.UserClaims\n                    .Where(c => c.Type.Equals(Type) && c.Value.Equals(Value))\n                    .Count();\n                if (countOfMatchingClaims > 0) return;\n\n            }\n            throw new HttpResponseException(HttpStatusCode.Unauthorized);\n        }\n    }\n}\n\n\n\n\nThis is the same type of authorization filter attribute that the officially provided \nAuthorizeAttribute\n is based\non.  However, the AuthorizeAttribute is synchronous.  We require an asynchronous version of the attribute, so we\ncannot use a sub-class of the AuthorizeAttribute.  Aside from that note, this uses virtually the same code that we\nused in the \nIsAythorizedAsync()\n method we developped earlier.\n\n\nWe can now use this attribute for testing any claim.  For example, our claims has the identity provider as a claim.\nWe can use the following:\n\n\n[AuthorizeClaims(\"http://schemas.microsoft.com/identity/claims/identityprovider\", \"live.com\")]\n\n\n\n\n\n\nIf you want to test other claims that are not provided, you can enable the \nRead Directory Data\n permission in\nthe Azure Active Directory permissions and do a query against the Azure Active Directory.  You should think about\ncaching results or minting a new ZUMO token (just like we did in the custom authentication case) for\nperformance reasons.",
            "title": "Claims and Authorization"
        },
        {
            "location": "/chapter2/authorization/#claims-and-authorization",
            "text": "Now that we have covered all the techniques for authentication, it's time to look at authorization.  While authentication\nlooked at verifying that a user is who they say they are, authorization looks at if a user is allowed to do a specific\noperation.  Authorization is handled within the server-side project by the  [Authorize]  attribute.  Our Azure Mobile Apps backend\nis leveraging this to provide authorization based on whether a user is authenticated or not.  The Authorize attribute\ncan also check to see if a user is in a list of users or roles.  However, there is a problem with this.  The user id\nis not guessable and we have no roles.  To see what I mean, run the  Backend  project locally and set a break point\non the  GetAllTodoItems()  method in the  TodoItemController , then run your server and your UWP application.   Once you have built and deployed the UWP application, it will appear in your normal Application list.  This allows\nyou to run the application and the server at the same time on the same machine.   Once you have authenticated, you will be able to set a break point to take a look at  this.User.Identity :   Note that the  Name  property is null.  This is the property that is used when you want to authorize individual users.\nExpand the  Claims  property and then click on  Results View :   The only claims are the ones in the token, and none of them match the  RoleClaimType , so we can't use roles either.\nClearly, we are going to have to do something else.",
            "title": "Claims and Authorization"
        },
        {
            "location": "/chapter2/authorization/#obtaining-user-claims",
            "text": "At some point you are going to need to deal with something other than the claims that are in the token passed for\nauthentication.  Fortunately, the Authentication / Authorization feature has an endpoint for that at  /.auth/me :   Of course, the  /.auth/me  endpoint is not of any use if you cannot access it.  The most use of this information is\ngained during authorization on the server and we will cover this use later on.  However, there are reasons to pull\nthis information on the client as well.  For example, we may want to make the List View title be our name instead of\n\"Tasks\".   You can't use the /.auth/me endpoint when using custom authentication.   Since identity provider claims can be anything, they are transferred as a list within a JSON object.  Before we can\ndecode the JSON object, we need to define the models.  This is done in the shared  TaskList  project.  I've defined\nthis in  Models\\AppServiceIdentity.cs .  using System.Collections.Generic;\nusing Newtonsoft.Json;\n\nnamespace TaskList.Models\n{\n    public class AppServiceIdentity\n    {\n        [JsonProperty(PropertyName = \"id_token\")]\n        public string IdToken { get; set; }\n\n        [JsonProperty(PropertyName = \"provider_name\")]\n        public string ProviderName { get; set; }\n\n        [JsonProperty(PropertyName = \"user_id\")]\n        public string UserId { get; set; }\n\n        [JsonProperty(PropertyName = \"user_claims\")]\n        public List<UserClaim> UserClaims { get; set; }\n    }\n\n    public class UserClaim\n    {\n        [JsonProperty(PropertyName = \"typ\")]\n        public string Type { get; set; }\n\n        [JsonProperty(PropertyName = \"val\")]\n        public string Value { get; set; }\n    }\n}  This matches the JSON format from the  /.auth/me  call we did earlier.   This is going to be a part of the\nICloudService as follows:  using System.Threading.Tasks;\nusing TaskList.Models;\n\nnamespace TaskList.Abstractions\n{\n    public interface ICloudService\n    {\n        ICloudTable<T> GetTable<T>() where T : TableData;\n\n        Task LoginAsync();\n\n        Task LoginAsync(User user);\n\n        Task<AppServiceIdentity> GetIdentityAsync();\n    }\n}  Finally, we need to actually implement the concrete version in  AzureCloudService.cs :  List<AppServiceIdentity> identities = null;\n\npublic async Task<AppServiceIdentity> GetIdentityAsync()\n{\n    if (client.CurrentUser == null || client.CurrentUser?.MobileServiceAuthenticationToken == null)\n    {\n        throw new InvalidOperationException(\"Not Authenticated\");\n    }\n\n    if (identities == null)\n    {\n        identities = await client.InvokeApiAsync<List<AppServiceIdentity>>(\"/.auth/me\");\n    }\n\n    if (identities.Count > 0)\n        return identities[0];\n    return null;\n}  Note that there is no reason to instantiate your own  HttpClient() .  The Azure Mobile Apps SDK has a method for\ninvoking custom API calls (as we shall see later on).  However, if you prefix the path with a slash, it will execute\na HTTP GET for any API with any authentication that is currently in force.  We can leverage this to call the /.auth/me  endpoint and decode the response in one line of code.  Adjust the  ExecuteRefreshCommand()  method in\nthe  ViewModels\\TaskListViewModel.cs  file to take advantage of this:  async Task ExecuteRefreshCommand()\n{\n    if (IsBusy)\n        return;\n    IsBusy = true;\n\n    try\n    {\n        var identity = await cloudService.GetIdentityAsync();\n        if (identity != null)\n        {\n            var name = identity.UserClaims.FirstOrDefault(c => c.Type.Equals(\"name\")).Value;\n            Title = $\"Tasks for {name}\";\n        }\n        var list = await Table.ReadAllItemsAsync();\n        Items.ReplaceRange(list);\n    }\n    catch (Exception ex)\n    {\n        await Application.Current.MainPage.DisplayAlert(\"Items Not Loaded\", ex.Message, \"OK\");\n    }\n    finally\n    {\n        IsBusy = false;\n    }\n}  The return value from the  GetIdentityAsync()  method is the first identity.  Normally, a user would only authenticate\nonce, so this is fairly safe.  The number of claims returned depends on the identity provider and could easily number\nin the hundreds.  Even the default configuration for Azure Active Directory returns 18 claims.  These are easily handled\nusing LINQ, however.  The  Type  property holds the type.  This could be a short (common) name.  It could also be a\nschema name, which looks more like a URI.  The only way to know what claims are coming back for sure is to look at\nthe  /.auth/me  result with something like Postman.   Note : If you are using Custom Authentication (e.g. username/password or a third-party token), then the  /.auth/me \nendpoint is not available to you.  You can still produce a custom API in your backend to provide this information to\nyour client, but you are responsible for the code - it's custom, after all!",
            "title": "Obtaining User Claims"
        },
        {
            "location": "/chapter2/authorization/#authorization",
            "text": "Now that we have covered all the techniques for authentication, it's time to look at authorization.  While authentication\nlooked at verifying that a user is who they say they are, authorization looks at if a user is allowed to do a specific\noperation.  Authorization is handled within the server-side project by the  [Authorize]  attribute.  Our Azure Mobile Apps backend\nis leveraging this to provide authorization based on whether a user is authenticated or not.  The Authorize attribute\ncan also check to see if a user is in a list of users or roles.  However, there is a problem with this.  The user id\nis not guessable and we have no roles.  To see what I mean, run the  Backend  project and set a break point on the GetAllTodoItems()  method in the  TodoItemController , then run your server and your UWP application.   Once you have built and deployed the UWP application, it will appear in your normal Application list.  This allows\nyou to run the application and the server at the same time on the same machine.  Alternatively, you can attach a\nDebugger to your Azure App Service within Visual Studio's Cloud Explorer.   Once you have authenticated, you will be able to set a break point to take a look at  this.User.Identity :   Note that the  Name  property is null.  This is the property that is used when you want to authorize individual users.\nExpand the  Claims  property and then click on  Results View :   The only claims are the ones in the token, and none of them match the  RoleClaimType , so we can't use roles either.\nClearly, we are going to have to do something else.  Fortunately, we already know that we can get some information\nabout the identity provider claims from the  /.auth/me  endpoint.  To get the extra information, we need to query\nthe  User  object:  var identity = await User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request);  There is one  Credentials  class for each supported authentication technique - Azure Active Directory, Facebook,\nGoogle, Microsoft Account and Twitter.  These are in the  Microsoft.Azure.Mobile.Server.Authentication  namespace.\nThey all follow the same pattern as the model we created for the client - there are Provider, UserId and UserClaims\nproperties.  The token and any special information will be automatically decoded for you.  For instance, the TenantId\nis pulled out of the response for Azure AD.   You can use the AccessToken property to do Graph API lookups for most providers in a custom API. We'll get into\nthis more in a later Chapter.",
            "title": "Authorization"
        },
        {
            "location": "/chapter2/authorization/#adding-group-claims-to-the-request",
            "text": "There are times when you want to add something else to the token that is returned from Azure AD. The most common\nrequirement is to add group information to the response so you can handle group-based authorization.  To add security groups to the Azure AD token:   Log into the  Classic Portal .  Click on your directory (probably called  Default Directory ) in the  All Items  list.  Click on  APPLICATIONS , then your WEB application.  Click on  MANAGE MANIFEST  (at the bottom of the page), then  Download Manifest .  Click on  Download manifest .   This will download a JSON file.  Edit the file with a text editor.  (I use Visual Studio Code).  At the top of the\nfile is this:    \"displayName\": \"webapp-for-the-book\",\n  \"errorUrl\": null,\n  \"groupMembershipClaims\": null,\n  \"homepage\": \"https://the-book.azurewebsites.net\",\n  \"identifierUris\": [\n    \"https://the-book.azurewebsites.net\"\n  ],\n  \"keyCredentials\": [],\n  \"knownClientApplications\": [],  Change the  groupMembershipClaims  to \"SecurityGroup\":    \"displayName\": \"webapp-for-the-book\",\n  \"errorUrl\": null,\n  \"groupMembershipClaims\": \"SecurityGroup\",\n  \"homepage\": \"https://the-book.azurewebsites.net\",\n  \"identifierUris\": [\n    \"https://the-book.azurewebsites.net\"\n  ],\n  \"keyCredentials\": [],\n  \"knownClientApplications\": [],  Save the file.  You can now upload this again.  Go back to the WEB application, click on  MANAGE MANIFEST , then\nclick on  Upload Manifest .  Select the file and click on the tick.   You can now give the web application additional permissions:   Click on the  CONFIGURE  tab.  Scroll to the bottom, click on  Delegated Permissions .  Check the box for  Read directory data .     Click on  Save .   Now that you have configured the application to return groups as part of the claims, you should probably add a\ncouple of groups:   Click on the back-arrow (at the top left) to return to the top level of your directory.  Click on  GROUPS .  Click on  ADD GROUP .  Fill in the information, select  Security  as the group type, then click on the tick.     Click on the new group, then click on  PROPERTIES .     Make a note of the  OBJECT ID .  The claims for groups are listed by the Object ID, so you will need this to\n   refer to the group later.   It's a good idea to add a couple of groups for testing purposes.  If you are using the organization directory, you\nwill need to request the creation of a couple of groups for application roles.  The view of the groups will be shown\nwhen we get the identity of the user using  User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request) :",
            "title": "Adding Group Claims to the Request"
        },
        {
            "location": "/chapter2/authorization/#group-authorization",
            "text": "Now that we have group claims in the claims list for the  /.auth/me  endpoint, we can move forward to do authorization\nbased on these claims.  This can be done in a relatively basic manner by implementing a method to check the claims:  async Task<bool> IsAuthorizedAsync()\n{\n    var identity = await User.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(Request);\n    var countofGroups = identity.UserClaims\n        .Where(c => c.Type.Equals(\"groups\") && c.Value.Equals(\"01f214a9-af1f-4bdd-938f-3f16749aef0e\"))\n        .Count();\n    return (countofGroups > 0);\n}  The  UserClaims  object is an  IEnumerable  that contains objects with a Type and a Value.  The Type for the group\nclaims is  groups .  Once we have this knowledge, we can use a LINQ query to obtain a count of the claims that match\nthe conditions we want to test.  The Value we use is the Object ID of the group.  This is available in the PROPERTIES  tab of the group.  We can prevent a new record being added by adjusting the  PostTodoItem()  method:  public async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n{\n    if (!await IsAuthorizedAsync())\n    {\n        return Unauthorized();\n    }\n    TodoItem current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}  Unfortunately, most of the table controller methods do not return an  IHttpActionResult , so this has limited value.\nWhat would be better would be an  [Authorize]  attribute that tests the claims for us.  For instance, we should be\nable to do the following:  [AuthorizeClaims(\"groups\", \"01f214a9-af1f-4bdd-938f-3f16749aef0e\")]\npublic async Task<IHttpActionResult> PostTodoItem(TodoItem item)\n{\n    TodoItem current = await InsertAsync(item);\n    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n}  The  [AuthorizeClaims()]  attribute does not exist, so we have to provide it ourselves:  using System.Linq;\nusing System.Net;\nusing System.Security.Principal;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing System.Web.Http.Controllers;\nusing System.Web.Http.Filters;\nusing Microsoft.Azure.Mobile.Server.Authentication;\n\nnamespace Backend.Helpers\n{\n    public class AuthorizeClaimsAttribute : AuthorizationFilterAttribute\n    {\n        string Type { get; }\n        string Value { get; }\n\n        public AuthorizeClaimsAttribute(string type, string value)\n        {\n            Type = type;\n            Value = value;\n        }\n\n        public override async Task OnAuthorizationAsync(HttpActionContext actionContext, CancellationToken cancellationToken)\n        {\n            var request = actionContext.Request;\n            var user = actionContext.RequestContext.Principal;\n            if (user != null)\n            {\n                var identity = await user.GetAppServiceIdentityAsync<AzureActiveDirectoryCredentials>(request);\n                var countOfMatchingClaims = identity.UserClaims\n                    .Where(c => c.Type.Equals(Type) && c.Value.Equals(Value))\n                    .Count();\n                if (countOfMatchingClaims > 0) return;\n\n            }\n            throw new HttpResponseException(HttpStatusCode.Unauthorized);\n        }\n    }\n}  This is the same type of authorization filter attribute that the officially provided  AuthorizeAttribute  is based\non.  However, the AuthorizeAttribute is synchronous.  We require an asynchronous version of the attribute, so we\ncannot use a sub-class of the AuthorizeAttribute.  Aside from that note, this uses virtually the same code that we\nused in the  IsAythorizedAsync()  method we developped earlier.  We can now use this attribute for testing any claim.  For example, our claims has the identity provider as a claim.\nWe can use the following:  [AuthorizeClaims(\"http://schemas.microsoft.com/identity/claims/identityprovider\", \"live.com\")]   If you want to test other claims that are not provided, you can enable the  Read Directory Data  permission in\nthe Azure Active Directory permissions and do a query against the Azure Active Directory.  You should think about\ncaching results or minting a new ZUMO token (just like we did in the custom authentication case) for\nperformance reasons.",
            "title": "Group Authorization"
        },
        {
            "location": "/chapter2/realworld/",
            "text": "Caching Tokens\n\u00b6\n\n\nYou will notice that we have to log in with every start of the application.  The token that is generated has a lifetime\nthat is provided and controlled by the identity provider.  Some providers have a relatively short lifetime.  For example,\nAzure Active Directory tokens have a lifetime of 1 hour.  Others are incredibly long.  Facebook has an expiry time of\n60 days.\n\n\nIrrespective of the lifespan of the token, we will want to store it securely and re-use it when we can.  Xamarin has\nprovided a nice component, \nXamarin.Auth\n, that provides such as secure store in a cross-platform manner.  It starts\nwith an account store:\n\n\n// For iOS:\nvar accountStore = AccountStore.Create();\n// For Android:\nvar accountStore = AccountStore.Create(Context);\n\n\n\n\nWe can then store the token with the following:\n\n\naccountStore.Save(account, \"descriptor\");\n\n\n\n\nThe descriptor is a string that allows us to find the token again.  The account (which is an \nAccount\n object) is\nuniquely identified by a key composed of the account's Username property and the descriptor.  The Account class is\nprovided with Xamarin.Auth.  Storage is backed by the \nKeychain\n on iOS and the \nKeyStore\n on Android.\n\n\nTo get the token back, we use the following:\n\n\nvar accounts = accountStore.FindAccountsForService(\"descriptor\");\n\n\n\n\nWhen we receive the token back from the key store, we will want to check the expiry time to ensure the token has not\nexpired.  As a result, there is a little bit more code to caching code than one would expect.\n\n\nLet's start with the Android version in \nTaskList.Droid\n.  As with all the other login code, we are adjusting the\n\nLoginAsync()\n method in \nServices\\DroidLoginProvider.cs\n:\n\n\nusing System;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Android.App;\nusing Android.Content;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\nusing TaskList.Helpers;\nusing Xamarin.Auth;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        public Context RootView { get; private set; }\n\n        public AccountStore AccountStore { get; private set; }\n\n        public void Init(Context context)\n        {\n            RootView = context;\n            AccountStore = AccountStore.Create(context);\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Check if the token is available within the key store\n            var accounts = AccountStore.FindAccountsForService(\"tasklist\");\n            if (accounts != null)\n            {\n                foreach (var acct in accounts)\n                {\n                    string token;\n\n                    if (acct.Properties.TryGetValue(\"token\", out token))\n                    {\n                        if (!IsTokenExpired(token))\n                        {\n                            client.CurrentUser = new MobileServiceUser(acct.Username);\n                            client.CurrentUser.MobileServiceAuthenticationToken = token;\n                            return;\n                        }\n                    }\n                }\n            }\n\n            // Server Flow\n            await client.LoginAsync(RootView, \"aad\");\n\n            // Store the new token within the store\n            var account = new Account(client.CurrentUser.UserId);\n            account.Properties.Add(\"token\", client.CurrentUser.MobileServiceAuthenticationToken);\n            AccountStore.Save(account, \"tasklist\");\n        }\n\n        bool IsTokenExpired(string token)\n        {\n            // Get just the JWT part of the token (without the signature).\n            var jwt = token.Split(new Char[] { '.' })[1];\n\n            // Undo the URL encoding.\n            jwt = jwt.Replace('-', '+').Replace('_', '/');\n            switch (jwt.Length % 4)\n            {\n                case 0: break;\n                case 2: jwt += \"==\"; break;\n                case 3: jwt += \"=\"; break;\n                default:\n                    throw new ArgumentException(\"The token is not a valid Base64 string.\");\n            }\n\n            // Convert to a JSON String\n            var bytes = Convert.FromBase64String(jwt);\n            string jsonString = UTF8Encoding.UTF8.GetString(bytes, 0, bytes.Length);\n\n            // Parse as JSON object and get the exp field value,\n            // which is the expiration date as a JavaScript primative date.\n            JObject jsonObj = JObject.Parse(jsonString);\n            var exp = Convert.ToDouble(jsonObj[\"exp\"].ToString());\n\n            // Calculate the expiration by adding the exp value (in seconds) to the\n            // base date of 1/1/1970.\n            DateTime minTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);\n            var expire = minTime.AddSeconds(exp);\n            return (expire < DateTime.UtcNow);\n        }\n    }\n}\n\n\n\n\nThere are three new pieces to this code.  The first piece is to check to see if there is an existing token in the\nKeyStore.  If there is, we check the expiry time and then set up the Azure Mobile Apps client with the username and\ntoken from the KeyStore.  If there isn't, we do the normal authentication process.  If the authentication process is\nsuccessful, we reach the second piece, which is to store the token within the KeyStore.  If there is an existing entry,\nit will be overwritten.  Finally, there is a method called \nIsTokenExpired()\n whose only job is to check to see if a\ntoken is expired or not.  This same code can be used in the \nServices/iOSLoginProvider.cs\n.  The only difference is\nin the \nAccountStore.Create()\n call (as discussed earlier).\n\n\nI'm using an application specific service ID (or descriptor) for this purpose.  You could also use an identity\nprovider-based service ID which is especially useful if your mobile client supports multiple identity providers.\n\n\nXamarin.Auth only support iOS and Android.  We need to turn to an alternate library for token caching on Universal\nWindows.  The standard library has a package called \nPasswordVault\n that can be used identically to the\n\nKeyStore\n and \nKeychain\n libraries.  Here is the Universal Windows version of the same code in\n\nServices\\UWPLoginProvider.cs\n:\n\n\nusing System;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.UWP.Services;\nusing Windows.Security.Credentials;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public PasswordVault PasswordVault { get; private set; }\n\n        public UWPLoginProvider()\n        {\n            PasswordVault = new PasswordVault();\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Check if the token is available within the password vault\n            var acct = PasswordVault.FindAllByResource(\"tasklist\").FirstOrDefault();\n            if (acct != null)\n            {\n                var token = PasswordVault.Retrieve(\"tasklist\", acct.UserName).Password;\n                if (token != null && token.Length > 0 && !IsTokenExpired(token))\n                {\n                    client.CurrentUser = new MobileServiceUser(acct.UserName);\n                    client.CurrentUser.MobileServiceAuthenticationToken = token;\n                    return;\n                }\n            }\n\n            // Server-Flow Version\n            await client.LoginAsync(\"aad\");\n\n            // Store the token in the password vault\n            PasswordVault.Add(new PasswordCredential(\"tasklist\",\n                client.CurrentUser.UserId,\n                client.CurrentUser.MobileServiceAuthenticationToken));\n        }\n\n        bool IsTokenExpired(string token)\n        {\n            /* Copy code from DroidLoginProvider */\n        }\n    }\n}\n\n\n\n\nThe PasswordVault replaces the KeyStore (Android) and Keychain (iOS), but the concepts are the same.  All three\nmechanisms provide the basic functionality of storing client secrets securely.\n\n\nRefresh Tokens\n\u00b6\n\n\nOur token cache checks the token to see if it is expired and prompts the user if the token is no longer valid.  Since\nthe life of a token is inevitably short (maybe 1 hour), this will still mean that the user is prompted for new\ncredentials most of the time.  In addition, we have an issue when the app is running for a long time.  What happens\nif the user leaves the app running for 2 hours?  The token we received at the start of the session will be invalid\nhalfway through the session and we will have to restart the app in order to continue.  Both of these situations are\nundesirable from the point of view of the user.  Access tokens eventually expire and we need to explicitly deal with\nthis situation.\n\n\nThe first part of the solution is to request a \nRefresh Token\n.  This is something the identity provider issues when\nthe scope of the request includes an offline scope.  Only certain identity providers include the ability to request\nrefresh tokens.  For server-flow:\n\n\n\n\nGoogle: Append the \"access_type=offline\" to the request.\n\n\nMicrosoft Account: Select the wl.offline_access scope in the Azure management portal.\n\n\nAzure AD: Configure Azure AD to support access to the Graph API.\n\n\n\n\nFacebook and Twitter do not provider refresh tokens.  Once you have the refresh tokens, you can simply call the\nrefresh API in the Azure Mobile Apps SDK to refresh the token.\n\n\n\n\nRefresh Tokens are one area that require special consideration when using Custom Authentication.  Just like with\nthe /.auth/me endpoint, you are on your own when it comes to handling token expiry for custom authentication.\n\n\n\n\nConfiguring Refresh Tokens\n\u00b6\n\n\nYou can add the additional information to a Google request with the following code snippet:\n\n\nclient.LoginAsync(\"google\", new Dictionary<string, string>\n{\n    { \"access_type\", \"offline\" }\n});\n\n\n\n\nAzure Active Directory is perhaps the trickiest to configure.\n\n\n\n\nLog on to the \nClassic Portal\n.\n\n\nNavigate to your Azure Active Directory.\n\n\nGo to \nAPPLICATIONS\n and then your WEB application.\n\n\nGo to the \nCONFIGURE\n tab.\n\n\nScroll down to the \nKeys\n section.\n\n\n\n\n\n\n\n\nIn the \nSelect duration\n drop-down, select \n2 Years\n.\n\n\nClick on \nSAVE\n.  The key will be generated for you.  Copy the key (you will need it below).\n\n\nGo back to the \nAzure Portal\n.\n\n\nGo to \nApp Services\n, then your App Service.\n\n\nClick on \nTools\n, then \nResource explorer\n, then \nGo\n.\n\n\nIn the Resource Explorer, expand \nconfig\n and select \nauthsettings\n.\n\n\nClick on \nEdit\n.\n\n\nSet the clientSecret to the key you copied from above.\n\n\nSet the additionalLoginParams to \n[\"response_type=code id_token\"]\n.\n\n\n\n\n\n\n\n\nClick the \nRead/Write\n toggle button at the top of the page.\n\n\nClick the \nPUT\n button.\n\n\n\n\nThe next time the user logs into our web app side, there will be a one-time prompt to consent to graph API access.\nOnce granted, the App Service Authentication / Authorization service will start requesting and receiving refresh\ntokens.\n\n\nOnce you go through this process and re-authenticate, you will be able to see the refresh token in the output of\nthe \n/.auth/me\n endpoint:\n\n\n\n\nRefresh tokens have a different expiry time to the identity token.  The refresh token theoretically lives forever,\nbut there are \"non-use expiry\" times. This varies by identity provider.\n\n\n\n\nGoogle: 6 months\n\n\nMicrosoft Account: 24 hours\n\n\nAzure Active Directory: 90 days\n\n\n\n\nIn addition, there may be other reasons why a token can be invalidated.  For instance, Google provides 25 refresh\ntokens per user.  If the user requests more than the limit, the oldest token is invalidated.  You should refer\nto the OAuth documentation for the identity provider.\n\n\nUsing Refresh Tokens\n\u00b6\n\n\nThe Azure Mobile Apps Client SDK has a built in method for refreshing tokens for you.  It assumes that you are using\na supported identity provider (Azure Active Directory, Google or Microsoft Account), and have configured the identity\nprovider to generate the refresh token.  To refresh a token, use:\n\n\nclient.RefreshUserAsync();\n\n\n\n\n\n\nIf you get the error \"You do not have permission to view this directory or page\" when accessing the refresh\nendpoint, there are no refresh tokens for your user in the token store.  This could be because the user has\nyet to re-authenticate (causing a new refresh token to be generated), the provider is not set up to generate\nrefresh tokens or the provider does not support refresh tokens.\n\n\n\n\nWe can easily add this to the login process in the platform-specific provider.  Rather than provide the same logic\nover and over, we can extend the \nILoginProvider\n to do the base operations for us then implement the logic once\nin the \nAzureCloudService\n.  The \nAbstractions\\ILoginProvider.cs\n interface now looks like this:\n\n\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\n\nnamespace TaskList.Abstractions\n{\n    public interface ILoginProvider\n    {\n        MobileServiceUser RetrieveTokenFromSecureStore();\n\n        void StoreTokenInSecureStore(MobileServiceUser user);\n\n        Task<MobileServiceUser> LoginAsync(MobileServiceClient client);\n    }\n}\n\n\n\n\nSince the \nRefreshUserAsync()\n method is purely contained within the Azure Mobile Apps Client SDK and requires\nno changes between platforms, we don't need a special platform-specific version.  Each method of the interface\nis one of the primitives we have already discussed.  For example, the Android version in  \nServices\\DroidLoginProvider.cs\n\nnow looks like this:\n\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        #region ILoginProvider Interface\n        public MobileServiceUser RetrieveTokenFromSecureStore()\n        {\n            var accounts = AccountStore.FindAccountsForService(\"tasklist\");\n            if (accounts != null)\n            {\n                foreach (var acct in accounts)\n                {\n                    string token;\n\n                    if (acct.Properties.TryGetValue(\"token\", out token))\n                    {\n                        return new MobileServiceUser(acct.Username)\n                        {\n                            MobileServiceAuthenticationToken = token\n                        };\n                    }\n                }\n            }\n            return null;\n        }\n\n        public void StoreTokenInSecureStore(MobileServiceUser user)\n        {\n            var account = new Account(user.UserId);\n            account.Properties.Add(\"token\", user.MobileServiceAuthenticationToken);\n            AccountStore.Save(account, \"tasklist\");\n        }\n\n        public async Task<MobileServiceUser> LoginAsync(MobileServiceClient client)\n        {\n            // Server Flow\n            return await client.LoginAsync(RootView, \"aad\");\n        }\n        #endregion\n\n        public Context RootView { get; private set; }\n\n        public AccountStore AccountStore { get; private set; }\n\n        public void Init(Context context)\n        {\n            RootView = context;\n            AccountStore = AccountStore.Create(context);\n        }\n    }\n}\n\n\n\n\nThe iOS version is practically the same because we are using the common Xamarin.Auth portable library.  The\ndifference is in the methods outside of the ILoginProvider interface:\n\n\npublic UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n\npublic AccountStore AccountStore { get; private set; }\n\npublic iOSLoginProvider()\n{\n    AccountStore = AccountStore.Create();\n}\n\n\n\n\nFinally, the Universal Windows version (in \nServices\\UWPLoginProvider.cs\n) is significantly different in the\nsecure store implementation:\n\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public PasswordVault PasswordVault { get; private set; }\n\n        public UWPLoginProvider()\n        {\n            PasswordVault = new PasswordVault();\n        }\n\n        #region ILoginProvider Interface\n        public MobileServiceUser RetrieveTokenFromSecureStore()\n        {\n            try\n            {\n                // Check if the token is available within the password vault\n                var acct = PasswordVault.FindAllByResource(\"tasklist\").FirstOrDefault();\n                if (acct != null)\n                {\n                    var token = PasswordVault.Retrieve(\"tasklist\", acct.UserName).Password;\n                    if (token != null && token.Length > 0)\n                    {\n                        return new MobileServiceUser(acct.UserName)\n                        {\n                            MobileServiceAuthenticationToken = token\n                        };\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"Error retrieving existing token: {ex.Message}\");\n            }\n            return null;\n        }\n\n        public void StoreTokenInSecureStore(MobileServiceUser user)\n        {\n            PasswordVault.Add(new PasswordCredential(\"tasklist\", user.UserId, user.MobileServiceAuthenticationToken));\n        }\n\n        public async Task<MobileServiceUser> LoginAsync(MobileServiceClient client)\n        {\n            // Server-Flow Version\n            return await client.LoginAsync(\"aad\");\n        }\n        #endregion\n    }\n}\n\n\n\n\nWe can swap out the server-flow Azure Active Directory login method with any of the client-flow, server-flow or\ncustom flows that we have been discussing thus far across all three platform-specific implementations.\n\n\nThe common flow handles all the logic for us.  This is the \nLoginAsync()\n method in the \nServices\\AzureCloudService.cs\n\nclass:\n\n\npublic async Task<MobileServiceUser> LoginAsync()\n{\n    var loginProvider = DependencyService.Get<ILoginProvider>();\n\n    client.CurrentUser = loginProvider.RetrieveTokenFromSecureStore();\n    if (client.CurrentUser != null)\n    {\n        // User has previously been authenticated - try to Refresh the token\n        try\n        {\n            var refreshed = await client.RefreshUserAsync();\n            if (refreshed != null)\n            {\n                loginProvider.StoreTokenInSecureStore(refreshed);\n                return refreshed;\n            }\n        }\n        catch (Exception refreshException)\n        {\n            Debug.WriteLine($\"Could not refresh token: {refreshException.Message}\");\n        }\n    }\n\n    if (client.CurrentUser != null && !IsTokenExpired(client.CurrentUser.MobileServiceAuthenticationToken))\n    {\n        // User has previously been authenticated, no refresh is required\n        return client.CurrentUser;\n    }\n\n    // We need to ask for credentials at this point\n    await loginProvider.LoginAsync(client);\n    if (client.CurrentUser != null)\n    {\n        // We were able to successfully log in\n        loginProvider.StoreTokenInSecureStore(client.CurrentUser);\n    }\n    return client.CurrentUser;\n}\n\n\n\n\nFor full disclosure, I've also moved the \nIsTokenExpired()\n method from the platform-specific code to the\nshared project, and updated the \nICloudService.cs\n to match the new signature of \nLoginAsync()\n.  The process\nfollows the best practices:\n\n\n\n\nCheck for a stored token - if one exists, try to refresh it.\n\n\nIf the token (that potentially just got refreshed) is not expired, continue using it.\n\n\nIf not, ask the user for credentials.\n\n\nIf we get a valid token back, store it in the secure store for next time.\n\n\n\n\nThere is another place that we must consider refresh tokens.  During a HTTP request to our mobile backend, it is\npossible that the token has expired since our last request.  The request will return a 401 Unauthorized response\nin this case.  We need to trap that and perform a login request.  The login request will either refresh the\ntoken or prompt the user for new credentials.  We can then continue with the request as before.\n\n\nThe Azure Mobile Apps SDK contains a mechanism for hooking into the HTTP workflow using a \nDelegatingHandler\n. A\ndelegating handler is a base type for a HTTP handler that allows us to process the request and response from the\nHTTP client object before (and after) it finally get processed.  It's used for adding additional headers to the\nrequest or logging the request and response, for example.  We are going to use it to validate the response and\nre-submit the request (after login) if the request comes back as a 401 Unauthorized.\n\n\nWe start with the adjustment to the \nServices\\AzureCloudService.cs\n constructor:\n\n\npublic AzureCloudService()\n{\n    client = new MobileServiceClient(Locations.AppServiceUrl, new AuthenticationDelegatingHandler());\n\n    if (Locations.AlternateLoginHost != null)\n        client.AlternateLoginHost = new Uri(Locations.AlternateLoginHost);\n}\n\n\n\n\nThe \nAuthenticationDelegatingHandler()\n is the new piece here.  This is the delegating handler that we are going\nto implement to handle the re-try logic.  I've placed the code in \nHelpers\\AuthenticationDelegatingHandler.cs\n:\n\n\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Helpers\n{\n    class AuthenticationDelegatingHandler : DelegatingHandler\n    {\n        protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n        {\n            // Clone the request, in case we need to re-issue it\n            var clone = await CloneHttpRequestMessageAsync(request);\n            // Now do the request\n            var response = await base.SendAsync(request, cancellationToken);\n\n            if (response.StatusCode == HttpStatusCode.Unauthorized)\n            {\n                // The request resulted in a 401 Unauthorized.  We need to do a LoginAsync,\n                // which will do the Refresh if appropriate, or ask for credentials if not.\n                var user = await ServiceLocator.Instance.Resolve<ICloudService>().LoginAsync();\n\n                // Now, retry the request with the cloned request.  The only thing we have\n                // to do is replace the X-ZUMO-AUTH header with the new auth token.\n                clone.Headers.Remove(\"X-ZUMO-AUTH\");\n                clone.Headers.Add(\"X-ZUMO-AUTH\", user.MobileServiceAuthenticationToken);\n                response = await base.SendAsync(clone, cancellationToken);\n            }\n\n            return response;\n        }\n\n        /// <summary>\n        /// Clone a HttpRequestMessage\n        /// Credit: http://stackoverflow.com/questions/25044166/how-to-clone-a-httprequestmessage-when-the-original-request-has-content\n        /// </summary>\n        /// <param name=\"req\">The request</param>\n        /// <returns>A copy of the request</returns>\n        public static async Task<HttpRequestMessage> CloneHttpRequestMessageAsync(HttpRequestMessage req)\n        {\n            HttpRequestMessage clone = new HttpRequestMessage(req.Method, req.RequestUri);\n\n            // Copy the request's content (via a MemoryStream) into the cloned object\n            var ms = new MemoryStream();\n            if (req.Content != null)\n            {\n                await req.Content.CopyToAsync(ms).ConfigureAwait(false);\n                ms.Position = 0;\n                clone.Content = new StreamContent(ms);\n\n                // Copy the content headers\n                if (req.Content.Headers != null)\n                    foreach (var h in req.Content.Headers)\n                        clone.Content.Headers.Add(h.Key, h.Value);\n            }\n\n\n            clone.Version = req.Version;\n\n            foreach (KeyValuePair<string, object> prop in req.Properties)\n                clone.Properties.Add(prop);\n\n            foreach (KeyValuePair<string, IEnumerable<string>> header in req.Headers)\n                clone.Headers.TryAddWithoutValidation(header.Key, header.Value);\n\n            return clone;\n        }\n    }\n}\n\n\n\n\nThere is no in-built method for cloning a \nHttpRequestMessage\n object.  Fortunately \nStack Overflow\n provided\nan answer that seems to work.  Running this code will now pass every single non-login request through the delegating\nhandler.  If we get an Unauthorized at any point, the login flow (which includes an implicit refresh token) will\nbe triggered.\n\n\n\n\nThere are two HTTPClient objects created inside of the \nMobileServiceClient\n object. One is for all the non-login\nflows and it supports the delegating handlers.  However there is another one for login flows.  The one for login\nflows does not support delegating handlers.  This means you don't have to worry about cyclical references within the\ndelegating handler (where a login flow triggers another login flow).\n\n\n\n\nLogging out\n\u00b6\n\n\nThere is a dirty little secret within the Azure Mobile Apps Client SDK.  Calling \nLogoutAsync()\n does not actually\ninvalidate the token you are using.  It simply removes it from the \nMobileServiceClient\n context.  Don't believe\nme?  Here is \nthe code\n:\n\n\n        /// <summary>\n        /// Log a user out.\n        /// </summary>\n        public Task LogoutAsync()\n        {\n            this.CurrentUser = null;\n            return Task.FromResult(0);\n        }\n\n\n\n\nWhen you actually think about it, this makes sense.  You can get logged in via five different supported identity\nproviders via a web-flow.  In this case, you are logging your \nbrowser\n out of the identity provider.  Do you\nreally want to log out of Facebook when you log out of your app?\n\n\nSo, how do you log out?  You should:\n\n\n\n\nCall the identity provider logout method (if appropriate).  Many identity providers don't provide this.\n\n\nInvalidate the token on the mobile backend.\n\n\nRemove the token from the local secure cache store.\n\n\nFinally, call the \nLogoutAsync()\n method on the \nMobileServiceClient\n.\n\n\n\n\nInvalidating the token on the mobile backend.\n\u00b6\n\n\nCalling the \n/.auth/logout\n endpoint on the Azure App Service mobile backend will remove the entry\non the token store.  However, it does not (currently) invalidate the token.  The token, if submitted,\nwill still authorize the user.  Note, however, that the refresh token is stored in the token store.\nThe user submitting the token will be unable to refresh the token.  Once the ZUMO token has expired\n(which happens an hour after it was created), the logout is complete.\n\n\nWe need to do a HTTP client call for this purpose:\n\n\n// Invalidate the token on the mobile backend\nvar authUri = new Uri($\"{client.MobileAppUri}/.auth/logout\");\nusing (var httpClient = new HttpClient())\n{\n    httpClient.DefaultRequestHeaders.Add(\"X-ZUMO-AUTH\", client.CurrentUser.MobileServiceAuthenticationToken);\n    await httpClient.GetAsync(authUri);\n}\n\n\n\n\nRemoving the token from the local secure cache store.\n\u00b6\n\n\nFor this part of the process, I added a new method to the \nILoginProvider.cs\n interface:\n\n\nvoid RemoveTokenFromSecureStore();\n\n\n\n\nFor Android and iOS, the concrete implementation looks like this:\n\n\npublic void RemoveTokenFromSecureStore()\n{\n    var accounts = AccountStore.FindAccountsForService(\"tasklist\");\n    if (accounts != null)\n    {\n        foreach (var acct in accounts)\n        {\n            AccountStore.Delete(acct, \"tasklist\");\n        }\n    }\n}\n\n\n\n\nFor Universal Windows, the concrete implementation is a bit different:\n\n\npublic void RemoveTokenFromSecureStore()\n{\n    try\n    {\n        // Check if the token is available within the password vault\n        var acct = PasswordVault.FindAllByResource(\"tasklist\").FirstOrDefault();\n        if (acct != null)\n        {\n            PasswordVault.Remove(acct);\n        }\n    }\n    catch (Exception ex)\n    {\n        Debug.WriteLine($\"Error retrieving existing token: {ex.Message}\");\n    }\n}\n\n\n\n\nImplementing a LogoutAsync() method.\n\u00b6\n\n\nI've added the following to the \nICloudService\n interface:\n\n\nTask LogoutAsync();\n\n\n\n\nThis has a concrete implementation in \nServices\\AzureCloudService.cs\n:\n\n\npublic async Task LogoutAsync()\n{\n    if (client.CurrentUser == null || client.CurrentUser.MobileServiceAuthenticationToken == null)\n        return;\n\n    // Log out of the identity provider (if required)\n\n    // Invalidate the token on the mobile backend\n    var authUri = new Uri($\"{client.MobileAppUri}/.auth/logout\");\n    using (var httpClient = new HttpClient())\n    {\n        httpClient.DefaultRequestHeaders.Add(\"X-ZUMO-AUTH\", client.CurrentUser.MobileServiceAuthenticationToken);\n        await httpClient.GetAsync(authUri);\n    }\n\n    // Remove the token from the cache\n    DependencyService.Get<ILoginProvider>().RemoveTokenFromSecureStore();\n\n    // Remove the token from the MobileServiceClient\n    await client.LogoutAsync();\n}\n\n\n\n\nThis does three of the four providers.  If your identity provider supports an app-level logout, then you\nshould call that where indicated.  This is probably going to be platform-specific code, so you will want\nto add a method to the \nILoginProvider.cs\n interface and add a concrete implementation to each platform\nproject.\n\n\nI've also added a logout button to my \nPages\\TaskList.xaml\n (\nview code\n) and added the event handler\nfor the logout button to the \nViewModels\\EntryPageViewModel.cs\n (\nview code\n).",
            "title": "Tokens in Real Apps"
        },
        {
            "location": "/chapter2/realworld/#caching-tokens",
            "text": "You will notice that we have to log in with every start of the application.  The token that is generated has a lifetime\nthat is provided and controlled by the identity provider.  Some providers have a relatively short lifetime.  For example,\nAzure Active Directory tokens have a lifetime of 1 hour.  Others are incredibly long.  Facebook has an expiry time of\n60 days.  Irrespective of the lifespan of the token, we will want to store it securely and re-use it when we can.  Xamarin has\nprovided a nice component,  Xamarin.Auth , that provides such as secure store in a cross-platform manner.  It starts\nwith an account store:  // For iOS:\nvar accountStore = AccountStore.Create();\n// For Android:\nvar accountStore = AccountStore.Create(Context);  We can then store the token with the following:  accountStore.Save(account, \"descriptor\");  The descriptor is a string that allows us to find the token again.  The account (which is an  Account  object) is\nuniquely identified by a key composed of the account's Username property and the descriptor.  The Account class is\nprovided with Xamarin.Auth.  Storage is backed by the  Keychain  on iOS and the  KeyStore  on Android.  To get the token back, we use the following:  var accounts = accountStore.FindAccountsForService(\"descriptor\");  When we receive the token back from the key store, we will want to check the expiry time to ensure the token has not\nexpired.  As a result, there is a little bit more code to caching code than one would expect.  Let's start with the Android version in  TaskList.Droid .  As with all the other login code, we are adjusting the LoginAsync()  method in  Services\\DroidLoginProvider.cs :  using System;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Android.App;\nusing Android.Content;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Droid.Services;\nusing TaskList.Helpers;\nusing Xamarin.Auth;\n\n[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        public Context RootView { get; private set; }\n\n        public AccountStore AccountStore { get; private set; }\n\n        public void Init(Context context)\n        {\n            RootView = context;\n            AccountStore = AccountStore.Create(context);\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Check if the token is available within the key store\n            var accounts = AccountStore.FindAccountsForService(\"tasklist\");\n            if (accounts != null)\n            {\n                foreach (var acct in accounts)\n                {\n                    string token;\n\n                    if (acct.Properties.TryGetValue(\"token\", out token))\n                    {\n                        if (!IsTokenExpired(token))\n                        {\n                            client.CurrentUser = new MobileServiceUser(acct.Username);\n                            client.CurrentUser.MobileServiceAuthenticationToken = token;\n                            return;\n                        }\n                    }\n                }\n            }\n\n            // Server Flow\n            await client.LoginAsync(RootView, \"aad\");\n\n            // Store the new token within the store\n            var account = new Account(client.CurrentUser.UserId);\n            account.Properties.Add(\"token\", client.CurrentUser.MobileServiceAuthenticationToken);\n            AccountStore.Save(account, \"tasklist\");\n        }\n\n        bool IsTokenExpired(string token)\n        {\n            // Get just the JWT part of the token (without the signature).\n            var jwt = token.Split(new Char[] { '.' })[1];\n\n            // Undo the URL encoding.\n            jwt = jwt.Replace('-', '+').Replace('_', '/');\n            switch (jwt.Length % 4)\n            {\n                case 0: break;\n                case 2: jwt += \"==\"; break;\n                case 3: jwt += \"=\"; break;\n                default:\n                    throw new ArgumentException(\"The token is not a valid Base64 string.\");\n            }\n\n            // Convert to a JSON String\n            var bytes = Convert.FromBase64String(jwt);\n            string jsonString = UTF8Encoding.UTF8.GetString(bytes, 0, bytes.Length);\n\n            // Parse as JSON object and get the exp field value,\n            // which is the expiration date as a JavaScript primative date.\n            JObject jsonObj = JObject.Parse(jsonString);\n            var exp = Convert.ToDouble(jsonObj[\"exp\"].ToString());\n\n            // Calculate the expiration by adding the exp value (in seconds) to the\n            // base date of 1/1/1970.\n            DateTime minTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);\n            var expire = minTime.AddSeconds(exp);\n            return (expire < DateTime.UtcNow);\n        }\n    }\n}  There are three new pieces to this code.  The first piece is to check to see if there is an existing token in the\nKeyStore.  If there is, we check the expiry time and then set up the Azure Mobile Apps client with the username and\ntoken from the KeyStore.  If there isn't, we do the normal authentication process.  If the authentication process is\nsuccessful, we reach the second piece, which is to store the token within the KeyStore.  If there is an existing entry,\nit will be overwritten.  Finally, there is a method called  IsTokenExpired()  whose only job is to check to see if a\ntoken is expired or not.  This same code can be used in the  Services/iOSLoginProvider.cs .  The only difference is\nin the  AccountStore.Create()  call (as discussed earlier).  I'm using an application specific service ID (or descriptor) for this purpose.  You could also use an identity\nprovider-based service ID which is especially useful if your mobile client supports multiple identity providers.  Xamarin.Auth only support iOS and Android.  We need to turn to an alternate library for token caching on Universal\nWindows.  The standard library has a package called  PasswordVault  that can be used identically to the KeyStore  and  Keychain  libraries.  Here is the Universal Windows version of the same code in Services\\UWPLoginProvider.cs :  using System;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.IdentityModel.Clients.ActiveDirectory;\nusing Microsoft.WindowsAzure.MobileServices;\nusing Newtonsoft.Json.Linq;\nusing TaskList.Abstractions;\nusing TaskList.Helpers;\nusing TaskList.UWP.Services;\nusing Windows.Security.Credentials;\n\n[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public PasswordVault PasswordVault { get; private set; }\n\n        public UWPLoginProvider()\n        {\n            PasswordVault = new PasswordVault();\n        }\n\n        public async Task LoginAsync(MobileServiceClient client)\n        {\n            // Check if the token is available within the password vault\n            var acct = PasswordVault.FindAllByResource(\"tasklist\").FirstOrDefault();\n            if (acct != null)\n            {\n                var token = PasswordVault.Retrieve(\"tasklist\", acct.UserName).Password;\n                if (token != null && token.Length > 0 && !IsTokenExpired(token))\n                {\n                    client.CurrentUser = new MobileServiceUser(acct.UserName);\n                    client.CurrentUser.MobileServiceAuthenticationToken = token;\n                    return;\n                }\n            }\n\n            // Server-Flow Version\n            await client.LoginAsync(\"aad\");\n\n            // Store the token in the password vault\n            PasswordVault.Add(new PasswordCredential(\"tasklist\",\n                client.CurrentUser.UserId,\n                client.CurrentUser.MobileServiceAuthenticationToken));\n        }\n\n        bool IsTokenExpired(string token)\n        {\n            /* Copy code from DroidLoginProvider */\n        }\n    }\n}  The PasswordVault replaces the KeyStore (Android) and Keychain (iOS), but the concepts are the same.  All three\nmechanisms provide the basic functionality of storing client secrets securely.",
            "title": "Caching Tokens"
        },
        {
            "location": "/chapter2/realworld/#refresh-tokens",
            "text": "Our token cache checks the token to see if it is expired and prompts the user if the token is no longer valid.  Since\nthe life of a token is inevitably short (maybe 1 hour), this will still mean that the user is prompted for new\ncredentials most of the time.  In addition, we have an issue when the app is running for a long time.  What happens\nif the user leaves the app running for 2 hours?  The token we received at the start of the session will be invalid\nhalfway through the session and we will have to restart the app in order to continue.  Both of these situations are\nundesirable from the point of view of the user.  Access tokens eventually expire and we need to explicitly deal with\nthis situation.  The first part of the solution is to request a  Refresh Token .  This is something the identity provider issues when\nthe scope of the request includes an offline scope.  Only certain identity providers include the ability to request\nrefresh tokens.  For server-flow:   Google: Append the \"access_type=offline\" to the request.  Microsoft Account: Select the wl.offline_access scope in the Azure management portal.  Azure AD: Configure Azure AD to support access to the Graph API.   Facebook and Twitter do not provider refresh tokens.  Once you have the refresh tokens, you can simply call the\nrefresh API in the Azure Mobile Apps SDK to refresh the token.   Refresh Tokens are one area that require special consideration when using Custom Authentication.  Just like with\nthe /.auth/me endpoint, you are on your own when it comes to handling token expiry for custom authentication.",
            "title": "Refresh Tokens"
        },
        {
            "location": "/chapter2/realworld/#configuring-refresh-tokens",
            "text": "You can add the additional information to a Google request with the following code snippet:  client.LoginAsync(\"google\", new Dictionary<string, string>\n{\n    { \"access_type\", \"offline\" }\n});  Azure Active Directory is perhaps the trickiest to configure.   Log on to the  Classic Portal .  Navigate to your Azure Active Directory.  Go to  APPLICATIONS  and then your WEB application.  Go to the  CONFIGURE  tab.  Scroll down to the  Keys  section.     In the  Select duration  drop-down, select  2 Years .  Click on  SAVE .  The key will be generated for you.  Copy the key (you will need it below).  Go back to the  Azure Portal .  Go to  App Services , then your App Service.  Click on  Tools , then  Resource explorer , then  Go .  In the Resource Explorer, expand  config  and select  authsettings .  Click on  Edit .  Set the clientSecret to the key you copied from above.  Set the additionalLoginParams to  [\"response_type=code id_token\"] .     Click the  Read/Write  toggle button at the top of the page.  Click the  PUT  button.   The next time the user logs into our web app side, there will be a one-time prompt to consent to graph API access.\nOnce granted, the App Service Authentication / Authorization service will start requesting and receiving refresh\ntokens.  Once you go through this process and re-authenticate, you will be able to see the refresh token in the output of\nthe  /.auth/me  endpoint:   Refresh tokens have a different expiry time to the identity token.  The refresh token theoretically lives forever,\nbut there are \"non-use expiry\" times. This varies by identity provider.   Google: 6 months  Microsoft Account: 24 hours  Azure Active Directory: 90 days   In addition, there may be other reasons why a token can be invalidated.  For instance, Google provides 25 refresh\ntokens per user.  If the user requests more than the limit, the oldest token is invalidated.  You should refer\nto the OAuth documentation for the identity provider.",
            "title": "Configuring Refresh Tokens"
        },
        {
            "location": "/chapter2/realworld/#using-refresh-tokens",
            "text": "The Azure Mobile Apps Client SDK has a built in method for refreshing tokens for you.  It assumes that you are using\na supported identity provider (Azure Active Directory, Google or Microsoft Account), and have configured the identity\nprovider to generate the refresh token.  To refresh a token, use:  client.RefreshUserAsync();   If you get the error \"You do not have permission to view this directory or page\" when accessing the refresh\nendpoint, there are no refresh tokens for your user in the token store.  This could be because the user has\nyet to re-authenticate (causing a new refresh token to be generated), the provider is not set up to generate\nrefresh tokens or the provider does not support refresh tokens.   We can easily add this to the login process in the platform-specific provider.  Rather than provide the same logic\nover and over, we can extend the  ILoginProvider  to do the base operations for us then implement the logic once\nin the  AzureCloudService .  The  Abstractions\\ILoginProvider.cs  interface now looks like this:  using System.Threading.Tasks;\nusing Microsoft.WindowsAzure.MobileServices;\n\nnamespace TaskList.Abstractions\n{\n    public interface ILoginProvider\n    {\n        MobileServiceUser RetrieveTokenFromSecureStore();\n\n        void StoreTokenInSecureStore(MobileServiceUser user);\n\n        Task<MobileServiceUser> LoginAsync(MobileServiceClient client);\n    }\n}  Since the  RefreshUserAsync()  method is purely contained within the Azure Mobile Apps Client SDK and requires\nno changes between platforms, we don't need a special platform-specific version.  Each method of the interface\nis one of the primitives we have already discussed.  For example, the Android version in   Services\\DroidLoginProvider.cs \nnow looks like this:  [assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]\nnamespace TaskList.Droid.Services\n{\n    public class DroidLoginProvider : ILoginProvider\n    {\n        #region ILoginProvider Interface\n        public MobileServiceUser RetrieveTokenFromSecureStore()\n        {\n            var accounts = AccountStore.FindAccountsForService(\"tasklist\");\n            if (accounts != null)\n            {\n                foreach (var acct in accounts)\n                {\n                    string token;\n\n                    if (acct.Properties.TryGetValue(\"token\", out token))\n                    {\n                        return new MobileServiceUser(acct.Username)\n                        {\n                            MobileServiceAuthenticationToken = token\n                        };\n                    }\n                }\n            }\n            return null;\n        }\n\n        public void StoreTokenInSecureStore(MobileServiceUser user)\n        {\n            var account = new Account(user.UserId);\n            account.Properties.Add(\"token\", user.MobileServiceAuthenticationToken);\n            AccountStore.Save(account, \"tasklist\");\n        }\n\n        public async Task<MobileServiceUser> LoginAsync(MobileServiceClient client)\n        {\n            // Server Flow\n            return await client.LoginAsync(RootView, \"aad\");\n        }\n        #endregion\n\n        public Context RootView { get; private set; }\n\n        public AccountStore AccountStore { get; private set; }\n\n        public void Init(Context context)\n        {\n            RootView = context;\n            AccountStore = AccountStore.Create(context);\n        }\n    }\n}  The iOS version is practically the same because we are using the common Xamarin.Auth portable library.  The\ndifference is in the methods outside of the ILoginProvider interface:  public UIViewController RootView => UIApplication.SharedApplication.KeyWindow.RootViewController;\n\npublic AccountStore AccountStore { get; private set; }\n\npublic iOSLoginProvider()\n{\n    AccountStore = AccountStore.Create();\n}  Finally, the Universal Windows version (in  Services\\UWPLoginProvider.cs ) is significantly different in the\nsecure store implementation:  [assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]\nnamespace TaskList.UWP.Services\n{\n    public class UWPLoginProvider : ILoginProvider\n    {\n        public PasswordVault PasswordVault { get; private set; }\n\n        public UWPLoginProvider()\n        {\n            PasswordVault = new PasswordVault();\n        }\n\n        #region ILoginProvider Interface\n        public MobileServiceUser RetrieveTokenFromSecureStore()\n        {\n            try\n            {\n                // Check if the token is available within the password vault\n                var acct = PasswordVault.FindAllByResource(\"tasklist\").FirstOrDefault();\n                if (acct != null)\n                {\n                    var token = PasswordVault.Retrieve(\"tasklist\", acct.UserName).Password;\n                    if (token != null && token.Length > 0)\n                    {\n                        return new MobileServiceUser(acct.UserName)\n                        {\n                            MobileServiceAuthenticationToken = token\n                        };\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"Error retrieving existing token: {ex.Message}\");\n            }\n            return null;\n        }\n\n        public void StoreTokenInSecureStore(MobileServiceUser user)\n        {\n            PasswordVault.Add(new PasswordCredential(\"tasklist\", user.UserId, user.MobileServiceAuthenticationToken));\n        }\n\n        public async Task<MobileServiceUser> LoginAsync(MobileServiceClient client)\n        {\n            // Server-Flow Version\n            return await client.LoginAsync(\"aad\");\n        }\n        #endregion\n    }\n}  We can swap out the server-flow Azure Active Directory login method with any of the client-flow, server-flow or\ncustom flows that we have been discussing thus far across all three platform-specific implementations.  The common flow handles all the logic for us.  This is the  LoginAsync()  method in the  Services\\AzureCloudService.cs \nclass:  public async Task<MobileServiceUser> LoginAsync()\n{\n    var loginProvider = DependencyService.Get<ILoginProvider>();\n\n    client.CurrentUser = loginProvider.RetrieveTokenFromSecureStore();\n    if (client.CurrentUser != null)\n    {\n        // User has previously been authenticated - try to Refresh the token\n        try\n        {\n            var refreshed = await client.RefreshUserAsync();\n            if (refreshed != null)\n            {\n                loginProvider.StoreTokenInSecureStore(refreshed);\n                return refreshed;\n            }\n        }\n        catch (Exception refreshException)\n        {\n            Debug.WriteLine($\"Could not refresh token: {refreshException.Message}\");\n        }\n    }\n\n    if (client.CurrentUser != null && !IsTokenExpired(client.CurrentUser.MobileServiceAuthenticationToken))\n    {\n        // User has previously been authenticated, no refresh is required\n        return client.CurrentUser;\n    }\n\n    // We need to ask for credentials at this point\n    await loginProvider.LoginAsync(client);\n    if (client.CurrentUser != null)\n    {\n        // We were able to successfully log in\n        loginProvider.StoreTokenInSecureStore(client.CurrentUser);\n    }\n    return client.CurrentUser;\n}  For full disclosure, I've also moved the  IsTokenExpired()  method from the platform-specific code to the\nshared project, and updated the  ICloudService.cs  to match the new signature of  LoginAsync() .  The process\nfollows the best practices:   Check for a stored token - if one exists, try to refresh it.  If the token (that potentially just got refreshed) is not expired, continue using it.  If not, ask the user for credentials.  If we get a valid token back, store it in the secure store for next time.   There is another place that we must consider refresh tokens.  During a HTTP request to our mobile backend, it is\npossible that the token has expired since our last request.  The request will return a 401 Unauthorized response\nin this case.  We need to trap that and perform a login request.  The login request will either refresh the\ntoken or prompt the user for new credentials.  We can then continue with the request as before.  The Azure Mobile Apps SDK contains a mechanism for hooking into the HTTP workflow using a  DelegatingHandler . A\ndelegating handler is a base type for a HTTP handler that allows us to process the request and response from the\nHTTP client object before (and after) it finally get processed.  It's used for adding additional headers to the\nrequest or logging the request and response, for example.  We are going to use it to validate the response and\nre-submit the request (after login) if the request comes back as a 401 Unauthorized.  We start with the adjustment to the  Services\\AzureCloudService.cs  constructor:  public AzureCloudService()\n{\n    client = new MobileServiceClient(Locations.AppServiceUrl, new AuthenticationDelegatingHandler());\n\n    if (Locations.AlternateLoginHost != null)\n        client.AlternateLoginHost = new Uri(Locations.AlternateLoginHost);\n}  The  AuthenticationDelegatingHandler()  is the new piece here.  This is the delegating handler that we are going\nto implement to handle the re-try logic.  I've placed the code in  Helpers\\AuthenticationDelegatingHandler.cs :  using System.Collections.Generic;\nusing System.IO;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing TaskList.Abstractions;\n\nnamespace TaskList.Helpers\n{\n    class AuthenticationDelegatingHandler : DelegatingHandler\n    {\n        protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n        {\n            // Clone the request, in case we need to re-issue it\n            var clone = await CloneHttpRequestMessageAsync(request);\n            // Now do the request\n            var response = await base.SendAsync(request, cancellationToken);\n\n            if (response.StatusCode == HttpStatusCode.Unauthorized)\n            {\n                // The request resulted in a 401 Unauthorized.  We need to do a LoginAsync,\n                // which will do the Refresh if appropriate, or ask for credentials if not.\n                var user = await ServiceLocator.Instance.Resolve<ICloudService>().LoginAsync();\n\n                // Now, retry the request with the cloned request.  The only thing we have\n                // to do is replace the X-ZUMO-AUTH header with the new auth token.\n                clone.Headers.Remove(\"X-ZUMO-AUTH\");\n                clone.Headers.Add(\"X-ZUMO-AUTH\", user.MobileServiceAuthenticationToken);\n                response = await base.SendAsync(clone, cancellationToken);\n            }\n\n            return response;\n        }\n\n        /// <summary>\n        /// Clone a HttpRequestMessage\n        /// Credit: http://stackoverflow.com/questions/25044166/how-to-clone-a-httprequestmessage-when-the-original-request-has-content\n        /// </summary>\n        /// <param name=\"req\">The request</param>\n        /// <returns>A copy of the request</returns>\n        public static async Task<HttpRequestMessage> CloneHttpRequestMessageAsync(HttpRequestMessage req)\n        {\n            HttpRequestMessage clone = new HttpRequestMessage(req.Method, req.RequestUri);\n\n            // Copy the request's content (via a MemoryStream) into the cloned object\n            var ms = new MemoryStream();\n            if (req.Content != null)\n            {\n                await req.Content.CopyToAsync(ms).ConfigureAwait(false);\n                ms.Position = 0;\n                clone.Content = new StreamContent(ms);\n\n                // Copy the content headers\n                if (req.Content.Headers != null)\n                    foreach (var h in req.Content.Headers)\n                        clone.Content.Headers.Add(h.Key, h.Value);\n            }\n\n\n            clone.Version = req.Version;\n\n            foreach (KeyValuePair<string, object> prop in req.Properties)\n                clone.Properties.Add(prop);\n\n            foreach (KeyValuePair<string, IEnumerable<string>> header in req.Headers)\n                clone.Headers.TryAddWithoutValidation(header.Key, header.Value);\n\n            return clone;\n        }\n    }\n}  There is no in-built method for cloning a  HttpRequestMessage  object.  Fortunately  Stack Overflow  provided\nan answer that seems to work.  Running this code will now pass every single non-login request through the delegating\nhandler.  If we get an Unauthorized at any point, the login flow (which includes an implicit refresh token) will\nbe triggered.   There are two HTTPClient objects created inside of the  MobileServiceClient  object. One is for all the non-login\nflows and it supports the delegating handlers.  However there is another one for login flows.  The one for login\nflows does not support delegating handlers.  This means you don't have to worry about cyclical references within the\ndelegating handler (where a login flow triggers another login flow).",
            "title": "Using Refresh Tokens"
        },
        {
            "location": "/chapter2/realworld/#logging-out",
            "text": "There is a dirty little secret within the Azure Mobile Apps Client SDK.  Calling  LogoutAsync()  does not actually\ninvalidate the token you are using.  It simply removes it from the  MobileServiceClient  context.  Don't believe\nme?  Here is  the code :          /// <summary>\n        /// Log a user out.\n        /// </summary>\n        public Task LogoutAsync()\n        {\n            this.CurrentUser = null;\n            return Task.FromResult(0);\n        }  When you actually think about it, this makes sense.  You can get logged in via five different supported identity\nproviders via a web-flow.  In this case, you are logging your  browser  out of the identity provider.  Do you\nreally want to log out of Facebook when you log out of your app?  So, how do you log out?  You should:   Call the identity provider logout method (if appropriate).  Many identity providers don't provide this.  Invalidate the token on the mobile backend.  Remove the token from the local secure cache store.  Finally, call the  LogoutAsync()  method on the  MobileServiceClient .",
            "title": "Logging out"
        },
        {
            "location": "/chapter2/realworld/#invalidating-the-token-on-the-mobile-backend",
            "text": "Calling the  /.auth/logout  endpoint on the Azure App Service mobile backend will remove the entry\non the token store.  However, it does not (currently) invalidate the token.  The token, if submitted,\nwill still authorize the user.  Note, however, that the refresh token is stored in the token store.\nThe user submitting the token will be unable to refresh the token.  Once the ZUMO token has expired\n(which happens an hour after it was created), the logout is complete.  We need to do a HTTP client call for this purpose:  // Invalidate the token on the mobile backend\nvar authUri = new Uri($\"{client.MobileAppUri}/.auth/logout\");\nusing (var httpClient = new HttpClient())\n{\n    httpClient.DefaultRequestHeaders.Add(\"X-ZUMO-AUTH\", client.CurrentUser.MobileServiceAuthenticationToken);\n    await httpClient.GetAsync(authUri);\n}",
            "title": "Invalidating the token on the mobile backend."
        },
        {
            "location": "/chapter2/realworld/#removing-the-token-from-the-local-secure-cache-store",
            "text": "For this part of the process, I added a new method to the  ILoginProvider.cs  interface:  void RemoveTokenFromSecureStore();  For Android and iOS, the concrete implementation looks like this:  public void RemoveTokenFromSecureStore()\n{\n    var accounts = AccountStore.FindAccountsForService(\"tasklist\");\n    if (accounts != null)\n    {\n        foreach (var acct in accounts)\n        {\n            AccountStore.Delete(acct, \"tasklist\");\n        }\n    }\n}  For Universal Windows, the concrete implementation is a bit different:  public void RemoveTokenFromSecureStore()\n{\n    try\n    {\n        // Check if the token is available within the password vault\n        var acct = PasswordVault.FindAllByResource(\"tasklist\").FirstOrDefault();\n        if (acct != null)\n        {\n            PasswordVault.Remove(acct);\n        }\n    }\n    catch (Exception ex)\n    {\n        Debug.WriteLine($\"Error retrieving existing token: {ex.Message}\");\n    }\n}",
            "title": "Removing the token from the local secure cache store."
        },
        {
            "location": "/chapter2/realworld/#implementing-a-logoutasync-method",
            "text": "I've added the following to the  ICloudService  interface:  Task LogoutAsync();  This has a concrete implementation in  Services\\AzureCloudService.cs :  public async Task LogoutAsync()\n{\n    if (client.CurrentUser == null || client.CurrentUser.MobileServiceAuthenticationToken == null)\n        return;\n\n    // Log out of the identity provider (if required)\n\n    // Invalidate the token on the mobile backend\n    var authUri = new Uri($\"{client.MobileAppUri}/.auth/logout\");\n    using (var httpClient = new HttpClient())\n    {\n        httpClient.DefaultRequestHeaders.Add(\"X-ZUMO-AUTH\", client.CurrentUser.MobileServiceAuthenticationToken);\n        await httpClient.GetAsync(authUri);\n    }\n\n    // Remove the token from the cache\n    DependencyService.Get<ILoginProvider>().RemoveTokenFromSecureStore();\n\n    // Remove the token from the MobileServiceClient\n    await client.LogoutAsync();\n}  This does three of the four providers.  If your identity provider supports an app-level logout, then you\nshould call that where indicated.  This is probably going to be platform-specific code, so you will want\nto add a method to the  ILoginProvider.cs  interface and add a concrete implementation to each platform\nproject.  I've also added a logout button to my  Pages\\TaskList.xaml  ( view code ) and added the event handler\nfor the logout button to the  ViewModels\\EntryPageViewModel.cs  ( view code ).",
            "title": "Implementing a LogoutAsync() method."
        },
        {
            "location": "/chapter2/bestpractices/",
            "text": "Best Practices\n\u00b6\n\n\nWe've covered a lot of ground with authentication and authorization, so I wanted to cover some of the\nbest practices that I generally advise when thinking about this topic.\n\n\nDon't store passwords\n\u00b6\n\n\nI can't really advise on which identity provider is best for your mobile application.  However, I can\nclearly say that delegating the security of the identity database to someone who has that as their full\ntime job is an excellent idea.\n\n\nChoosing an identity provider is not easy.  Here are my choices:\n\n\n\n\nIf you need enterprise authentication, use \nAzure Active Directory\n.\n\n\nIf you need a specific social identity provider (for example, Facebook or Google), use that.\n\n\nIf you need multiple social identity providers, \nAuth0\n is an excellent choice.\n\n\nIf you need usernames and password, use \nAzure Active Directory B2C\n.\n\n\n\n\nStoring usernames and passwords in your own database is a bad idea and should be avoided.\n\n\nUse the client SDK provided by the Identity Provider\n\u00b6\n\n\nYour first step should be getting an access token from the identity provider itself.  You will see the\nmost integrated experience if you use their SDK.\n\n\n\n\nFor \nAzure Active Directory\n, that SDK is \nADAL\n.\n\n\nFor \nFacebook\n, check out \nXamarin.Facebook.iOS\n or \nXamarin.Facebook.Android\n.\n\n\nFor \nGoogle\n, check out \nGoogle APIs Core Client Library\n.\n\n\nFor \nAuth0\n, check out the \nAuth0 Xamarin Component\n.\n\n\nFor \nAzure Active Directory B2C\n, use \nADAL\n.\n\n\n\n\nSwap the Identity Provider access token for a ZUMO token.\n\u00b6\n\n\nNever use the token provided by the identity provider for anything other than requesting access to\nthe resource.  Use a short lived token (an hour is the standard) that is minted just for the purpose\nof providing that access.  If you are not using an identity provider that is explicitly supported\nby Azure App Service, use a custom authentication provider to mint your own token.\n\n\nEnforce Security at the Server\n\u00b6\n\n\nThere is no easy way to say this.  There are bad guys out there, and they are after your data.  You\nshould not assume that someone is using your client.  It could just be someone with a REST client.\nEnsure you enforce security on your server.  You can do this easily by using the \n[Authorize]\n\nattribute, the \n[AuthorizeClaims()]\n attribute we developed in the Authorization section or your\nown custom authorization attribute.\n\n\nMonitoring the server is just as important as enforcing security.  The Azure App Service Authentication\nservice outputs quite a bit of logging about who is logging in (and who is denied), so you can get some\ngood intelligence out of the logs when you mine them properly.\n\n\nSecurely Store Tokens\n\u00b6\n\n\nThe decisions we make are always a trade-off between convenience and security.  One such decision is\nif we should store tokens with the app.  On the one hand, it's convenient to allow the app to remember\nthe login and to not ask us to log in again with each app start.  On the other hand, that fact opens\nup a security hole that a determined hacker can exploit.  We can have convenience while still having\nsecurity by utilizing the secure stores that each platform provides to store secrets like the access\ntoken.\n\n\nUse https only\n\u00b6\n\n\nThis should go without saying.  Always use https communication.  Most security professionals start off\ntheir security career with learning \"Security at Rest & Security in Transit\".  In practical terms, storing\nsecrets (like tokens) securely and using HTTPS as a transport mechanism satisfies both claims.\n\n\nDon't stop with security there though.  HTTPS is just a medium through which secure communications can\ntake place.  There are a wide range of protocols and ciphers that can be used to encrypt the traffic.\nSome are  considered less secure and not to be used.  Azure App Service provides a default set of protocols\nand ciphers to support backwards compatibility with older browsers.  You can adjust the ciphers in use\nby your App Service.  For information on this, refer to the \nAzure Documentation\n.\n\n\nHandle Expiring Tokens\n\u00b6\n\n\nUnless you are using an identity provider that doesn't support refresh tokens (like Facebook or Twitter),\nyou should handle refresh tokens by silently calling the refresh action.  Tokens are going to expire.\nThis is a fact of the token specifications.  You need to deal with expiring tokens and act accordingly.\n\n\nIf you do need to use an identity provider that does not support refresh tokens, you are going to have\nto ask for credentials whenever the token expires.  You don't get out of determining the user experience\nwhen tokens expire just because you are using Facebook or Twitter.\n\n\nAuthenticating Your App\n\u00b6\n\n\nMy final word on authentication has to do with authenticating your app.  I get the same request every\nweek.  How do I implement an API key for my app?  When I probe a little, I get a few reasons for this\nrequest:\n\n\n\n\nI want to ensure my app is the only one accessing my backend because the data is important.\n\n\nI don't want my users to log in as it is inconvenient.\n\n\nI want to monetize my app, and I can't do that if anyone can copy it.\n\n\n\n\nAPI keys are used by multi-tenant systems to route requests for data to the appropriate data store.  For\nexample, the very popular \nParse Server\n used to have an API key because all clients connected to the\nsame \nparse.com\n service.  Once the \nParse Server\n was open-sourced, the API key went away.  It was no\nlonger needed to route the request.  In the same way, the Azure App Service has a unique name - the URL\nof the service, so it doesn't need an API key to route the information.\n\n\nAn API key does not prevent a rogue client from accessing your data.  If you did use an API key for security,\nyou can easily get the API key for the app by putting together a \"man in the middle proxy\".  One such proxy\nis \nTelerik Fiddler\n.  One of its features is \"Security Testing\" which amounts to a man-in-the-middle\ndecryption technique.  This \nworks with the Android emulator\n as well.  For iOS, you can use \nCharles\n.\n\n\nSo, how do you authenticate your app?  Step back a moment.  What are you monetizing or protecting?  It's\nlikely the data within the mobile backend.  Protect that data by authenticating your users.   If you absolutely\nmust monetize your app, then there are ways to do it, and we will discuss those later in the book.",
            "title": "Best Practices"
        },
        {
            "location": "/chapter2/bestpractices/#best-practices",
            "text": "We've covered a lot of ground with authentication and authorization, so I wanted to cover some of the\nbest practices that I generally advise when thinking about this topic.",
            "title": "Best Practices"
        },
        {
            "location": "/chapter2/bestpractices/#dont-store-passwords",
            "text": "I can't really advise on which identity provider is best for your mobile application.  However, I can\nclearly say that delegating the security of the identity database to someone who has that as their full\ntime job is an excellent idea.  Choosing an identity provider is not easy.  Here are my choices:   If you need enterprise authentication, use  Azure Active Directory .  If you need a specific social identity provider (for example, Facebook or Google), use that.  If you need multiple social identity providers,  Auth0  is an excellent choice.  If you need usernames and password, use  Azure Active Directory B2C .   Storing usernames and passwords in your own database is a bad idea and should be avoided.",
            "title": "Don't store passwords"
        },
        {
            "location": "/chapter2/bestpractices/#use-the-client-sdk-provided-by-the-identity-provider",
            "text": "Your first step should be getting an access token from the identity provider itself.  You will see the\nmost integrated experience if you use their SDK.   For  Azure Active Directory , that SDK is  ADAL .  For  Facebook , check out  Xamarin.Facebook.iOS  or  Xamarin.Facebook.Android .  For  Google , check out  Google APIs Core Client Library .  For  Auth0 , check out the  Auth0 Xamarin Component .  For  Azure Active Directory B2C , use  ADAL .",
            "title": "Use the client SDK provided by the Identity Provider"
        },
        {
            "location": "/chapter2/bestpractices/#swap-the-identity-provider-access-token-for-a-zumo-token",
            "text": "Never use the token provided by the identity provider for anything other than requesting access to\nthe resource.  Use a short lived token (an hour is the standard) that is minted just for the purpose\nof providing that access.  If you are not using an identity provider that is explicitly supported\nby Azure App Service, use a custom authentication provider to mint your own token.",
            "title": "Swap the Identity Provider access token for a ZUMO token."
        },
        {
            "location": "/chapter2/bestpractices/#enforce-security-at-the-server",
            "text": "There is no easy way to say this.  There are bad guys out there, and they are after your data.  You\nshould not assume that someone is using your client.  It could just be someone with a REST client.\nEnsure you enforce security on your server.  You can do this easily by using the  [Authorize] \nattribute, the  [AuthorizeClaims()]  attribute we developed in the Authorization section or your\nown custom authorization attribute.  Monitoring the server is just as important as enforcing security.  The Azure App Service Authentication\nservice outputs quite a bit of logging about who is logging in (and who is denied), so you can get some\ngood intelligence out of the logs when you mine them properly.",
            "title": "Enforce Security at the Server"
        },
        {
            "location": "/chapter2/bestpractices/#securely-store-tokens",
            "text": "The decisions we make are always a trade-off between convenience and security.  One such decision is\nif we should store tokens with the app.  On the one hand, it's convenient to allow the app to remember\nthe login and to not ask us to log in again with each app start.  On the other hand, that fact opens\nup a security hole that a determined hacker can exploit.  We can have convenience while still having\nsecurity by utilizing the secure stores that each platform provides to store secrets like the access\ntoken.",
            "title": "Securely Store Tokens"
        },
        {
            "location": "/chapter2/bestpractices/#use-https-only",
            "text": "This should go without saying.  Always use https communication.  Most security professionals start off\ntheir security career with learning \"Security at Rest & Security in Transit\".  In practical terms, storing\nsecrets (like tokens) securely and using HTTPS as a transport mechanism satisfies both claims.  Don't stop with security there though.  HTTPS is just a medium through which secure communications can\ntake place.  There are a wide range of protocols and ciphers that can be used to encrypt the traffic.\nSome are  considered less secure and not to be used.  Azure App Service provides a default set of protocols\nand ciphers to support backwards compatibility with older browsers.  You can adjust the ciphers in use\nby your App Service.  For information on this, refer to the  Azure Documentation .",
            "title": "Use https only"
        },
        {
            "location": "/chapter2/bestpractices/#handle-expiring-tokens",
            "text": "Unless you are using an identity provider that doesn't support refresh tokens (like Facebook or Twitter),\nyou should handle refresh tokens by silently calling the refresh action.  Tokens are going to expire.\nThis is a fact of the token specifications.  You need to deal with expiring tokens and act accordingly.  If you do need to use an identity provider that does not support refresh tokens, you are going to have\nto ask for credentials whenever the token expires.  You don't get out of determining the user experience\nwhen tokens expire just because you are using Facebook or Twitter.",
            "title": "Handle Expiring Tokens"
        },
        {
            "location": "/chapter2/bestpractices/#authenticating-your-app",
            "text": "My final word on authentication has to do with authenticating your app.  I get the same request every\nweek.  How do I implement an API key for my app?  When I probe a little, I get a few reasons for this\nrequest:   I want to ensure my app is the only one accessing my backend because the data is important.  I don't want my users to log in as it is inconvenient.  I want to monetize my app, and I can't do that if anyone can copy it.   API keys are used by multi-tenant systems to route requests for data to the appropriate data store.  For\nexample, the very popular  Parse Server  used to have an API key because all clients connected to the\nsame  parse.com  service.  Once the  Parse Server  was open-sourced, the API key went away.  It was no\nlonger needed to route the request.  In the same way, the Azure App Service has a unique name - the URL\nof the service, so it doesn't need an API key to route the information.  An API key does not prevent a rogue client from accessing your data.  If you did use an API key for security,\nyou can easily get the API key for the app by putting together a \"man in the middle proxy\".  One such proxy\nis  Telerik Fiddler .  One of its features is \"Security Testing\" which amounts to a man-in-the-middle\ndecryption technique.  This  works with the Android emulator  as well.  For iOS, you can use  Charles .  So, how do you authenticate your app?  Step back a moment.  What are you monetizing or protecting?  It's\nlikely the data within the mobile backend.  Protect that data by authenticating your users.   If you absolutely\nmust monetize your app, then there are ways to do it, and we will discuss those later in the book.",
            "title": "Authenticating Your App"
        },
        {
            "location": "/chapter3/dataconcepts/",
            "text": "Data Access Concepts\n\u00b6\n\n\nAt some point in the development of your application, you are going to want to store or retrieve data.  This could be\nas simple as a key-value store for storing personal settings, or as complex as a multi-table customer relationship\ndatabase.  The key ingredient to all these scenarios is structured data.  I say \nstructured\n here deliberately.  It\nis an important concept.  Most applications you write will require data in some sort of form that your application\nunderstands.\n\n\nIt's very tempting to use an unstructured data source (like NoSQL).  I'm a big fan of NoSQL stores since they free\nme up to concentrate on the mobile client without worrying about the data format. After all, you can store whatever\nentities you want in a NoSQL data source.  However, this is really just an example of sloppy programming.  Most\ndevelopers that use NoSQL are storing structured data in that NoSQL store to get around the problem that you actually\nhave to decide what data you want to store in the database.  For this reason, I prefer a SQL database.  It ensures\nthat I am thinking about the data format up front.  It also helps to ensure that a bad actor is not going to store\ndata I don't expect in my store.\n\n\nThis isn't to say that NoSQL doesn't have its place.  There are times when you need to store structured data where\nthe data format varies between each entity that you are storing.  This tends to be an outlier situation though.\n\n\nTables, Entities and Properties\n\u00b6\n\n\nWhen we talk about data, we tend to talk in terms of \nTables\n, \nEntities\n and \nProperties\n.  These have equivalents\nin the SQL world (tables, rows and fields).  A \nTable\n is a collection of \nEntities\n that share a common format.  That\nformat is described in terms of \nProperties\n.  Properties are basic types (like strings, numbers, booleans and dates).\n\n\nWe create a \nTable Controller\n to expose the tables to a mobile client.  A \nTable Controller\n is a REST endpoint\nthat implements an \nOData v3\n interface.  OData is a standard interface to table data that allows the client to\nperform CRUD (create, read, update and delete) operations on the data.  In addition, it provides for a standard\nway for querying the data.  More normally, the \nTable Controller\n is accessed through the Azure Mobile Apps Client\nSDK.  We saw an example of this in Chapter 1 when we first introduced the mobile client.\n\n\nAzure Mobile Apps also deals with tables in a manner that enables offline synchronization of the data.  That means\nit must be opinionated about the data format.  Specifically,\n\n\n\n\nThere are four system properties on each entity.\n\n\nThere are limitations on relationships between tables.\n\n\nComplex types need special handling.\n\n\n\n\nLet's take each of these in turn.  We implemented this \nModel\n within the mobile client in Chapter 1:\n\n\nusing TaskList.Abstractions;\n\nnamespace TaskList.Models\n{\n    public class TodoItem : TableData\n    {\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n    }\n}\n\n\n\n\nIt's a fairly basic model class.  Note the \nTableData\n base class.  I often say that Azure Mobile Apps implements\nan opinionated version of OData. What I mean by that is that the protocol expects certain system fields to be present\nduring the transfer.  The \nTableData\n class is a base class that implements that specification. It looks like this:\n\n\nusing System;\n\nnamespace TaskList.Abstractions\n{\n    public abstract class TableData\n    {\n        public string Id { get; set; }\n        public DateTimeOffset? UpdatedAt { get; set; }\n        public byte[] Version { get; set; }\n    }\n}\n\n\n\n\nThe server side version adds another field - the \nDeleted\n boolean.  This is described in the \nITableData\n interface\nthat is provided with the Azure Mobile Apps Server SDK.\n\n\n\n\nThe Azure Mobile Apps SDK uses \nDateTimeOffset\n instead of \nDateTime\n.  A DateTime object is time zone aware, and\ntime zone definitions change over time.  The DateTimeOffset does not know anything about time zones.  The DateTime\nrepresentation can change depending on where you are.  The DateTimeOffset will never change.  This makes it a better\nchoice for these things.  You will see dates stored in UTC in your database as a result of this.\n\n\n\n\nEach element of the TableData (and ITableData) has a purpose, nominally to deal with situations with Offline Sync.\n\n\nThe Id field\n\u00b6\n\n\nOne of the common questions is this:  Can I use an auto-incrementing integer as an Id field?  Let's take a look at\na simple situation.  You have two clients writing to the same table.  It might look something like this:\n\n\n\n\nDevice A inserts a new record in to the database, with ID 1.  Device B is also inserting and decides to do ID 1\nas well.  This causes an immediate conflict that must be resolved.  We could fix this by requiring that new inserts\ndo not insert an ID.  However, this can cause problems in offline cases, where you may be inserting many records\nand have to refer back to them during your offline state.\n\n\nThe compromise here is to use a globally unique ID.  The \nGUID\n is a well-known algorithm and easily generated in\noffline scenarios.  This is stored as a string during transfer.\n\n\nThe UpdatedAt field\n\u00b6\n\n\nOne of the concepts that is always top of mind is ensuring that we are a good mobile citizen.  This means that we\ncare about bandwidth utilization.  Reducing transfer size is good for your users.  They use less of their data\nallowance and save time by transferring less.  One of the key components to reduce bandwidth utilization is \nIncremental\nSync\n.  With each record, we record the date it was last updated.  This is generally done for us as a database\ntrigger, so we never have to worry about setting this value.  When we synchronize our table, only the records\nthat have been updated since the last synchronization are requested.\n\n\nThe Version field\n\u00b6\n\n\nThe version field is all about conflict detection.  Let's take two devices requesting the same table again:\n\n\n\n\nIn this diagram, Device A submits the first version of the entity.  Device B then updates the entity and posts\nit back.  This is accepted because Device B is sending the same version, so the server knows that this is an\nupdate to the latest version.  The server will send back a response with the updated version so that Device B\nknows that it has the latest version.\n\n\nLater on, Device A sends an update to the same entity.  It, however, still has version 1 of the entity.  The\nserver will reject that because of a version mismatch.\n\n\nThe Deleted field\n\u00b6\n\n\nWhen you are operating a service with an offline scope, you can't just delete entities.  If an entity is deleted\non Device A, it is then removed from the server.  The server does not know to send an update to that entity\nto Device B because it no longer exists.  For this reason, we never delete entities.  We use \nSoft Delete\n.\nSoft Delete is a feature whereby entities are marked as deleted by setting the Deleted flag to true.  When you\nquery the server, the deleted records are not shown unless you explicitly ask for them.  This is done as part\nof the offline sync process.\n\n\nThe Data Access Protocol\n\u00b6\n\n\nGiven any particular table, there are a few endpoints that are important.  Given our TodoItem table from Chapter 1:\n\n\n\n\n\n\n\n\nOperation\n\n\nEndpoint\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nGET\n\n\n/tables/todoitem\n\n\nQuery the table\n\n\n\n\n\n\nGET\n\n\n/tables/todoitem/\nid\n\n\nRetrieve a single entity\n\n\n\n\n\n\nPOST\n\n\n/tables/todoitem\n\n\nAdd a new entity\n\n\n\n\n\n\nPATCH\n\n\n/tables/todoitem/\nid\n\n\nUpdate an existing entity\n\n\n\n\n\n\nDELETE\n\n\n/tables/todoitem/\nid\n\n\nDeletes an existing entity\n\n\n\n\n\n\nPOST\n\n\n/tables/todoitem/\nid\n\n\nUndelete a previously deleted entity\n\n\n\n\n\n\n\n\nWe can take a look at each of these in turn with the Azure App Service.  These can be done with Postman easily.\n\n\n\n\nThe first request to a new Azure App Service will take some time, especially if the site has to set up the database.\n\n\n\n\nLet's start with a basic Query operation:\n\n\n\n\nWe always get an array of elements back.  These contain five system properties.  We didn't mention createdAt\nearlier - it's optional and will be maintained for you if you don't use it.  In addition, we have the fields\nthat were in our model.  If there are no elements in a table, we get an empty array.  If the table does not\nexist, we will get a \n404 Not Found\n error.\n\n\n\n\nAny operation can also return a \n401 Unauthorized\n if you are not allowed to do the operation with the current\nauthentication, \n400 Bad Request\n if you supplied bad data and \n500 Internal Server Error\n if the server crashed.\n\n\n\n\nWe can also do a GET for an Id:\n\n\n\n\nThe return is the entity serialized as an object.  If the Id does not exist, then a \n404 Not Found\n is\nreturned.\n\n\nAdding an item requires a POST:\n\n\n\n\nNote that you do not need to provide all the fields.  In particular, the system fields will be automatically\nfilled in for you.  Any fields with a default value will be similarly auto-created.  It is fairly easy to\ngenerate a \n400 Bad Request\n when updating or inserting data.  For example, if you submit a string when a number\nis expected or submit a malformed date, you can expect a \n400 Bad Request\n.  On success, the response has a\nLocation field in the headers:\n\n\n\n\nThis is the URI of the entity.  You can do a GET on this location to get the entity again.  Updating an entity\ninvolves sending the updated fields to the \nId\n endpoint with the changed properties:\n\n\n\n\nNote that you do not need to send the entire entity - just the properties that are changed.  The new entity is\nreturned on success.  As with the insert operation, data format errors will result in a \n400 Bad Request\n.  Note,\nhowever, that if you do not submit a \nversion\n field, no conflict handling is done and the server just accepts\nthe record.  We can fix this with server code later on by requiring a version field on updates.\n\n\nDeletion is fairly straight forward.  The main different is that it returns a \n204 No Content\n.\n\n\n\n\nThe table controller does not support soft delete out of the box.  If you have followed the sequence, the\nrecord we just deleted is gone.  You can verify this using a SQL Browser.  To enable soft delete, you need\nto adjust the domain manager in the TodoItemController:\n\n\nprotected override void Initialize(HttpControllerContext controllerContext)\n{\n    base.Initialize(controllerContext);\n    MobileServiceContext context = new MobileServiceContext();\n    DomainManager = new EntityDomainManager<TodoItem>(context, Request, enableSoftDelete: true);\n}\n\n\n\n\nAdding the \nenableSoftDelete\n parameter and setting it to true will enable the appropriate logic in the\ndomain manager.\n\n\n\n\nWe haven't introduced the \nDomain Manager\n yet.  Azure Mobile Apps doesn't really care what sort of data store\nyou are using on the backend.  It proxies all requests through a class that implements the \nIDomainManager\n\ninterface.  Azure Mobile Apps Server SDK supplies one such domain manager - the \nEntityDomainManager\n uses\nEntity Framework underneath for this purpose.\n\n\n\n\nGo through the same process of adding and deleting an entity.  You can see the entity by using the SQL Server Object\nExplorer in Visual Studio:\n\n\n\n\nGo to \nServer Explorer\n.\n\n\nExpand \nAzure\n and \nSQL Databases\n.\n\n\nSelect your database, then right-click and select \nOpen in SQL Server Object Explorer\n.\n\n\nYou will be prompted for your username and password.  Enter them, then click \nOK\n.\n\n\nYou may be prompted to update the firewall for SQL access.  Select \nMy Client IP\n, then \nOK\n.\n\n\nExpand your database node, then \nTables\n.\n\n\nRight-click on \ndbo.TodoItems\n and select \nView Data\n.\n\n\n\n\nI find the SQL Server Object Explorer to be relatively slow when it comes to database options.  However, it doesn't\nrequire any additional installs.  You can also use SQL Server Management Studio if you have it installed.  You will\nneed to \nupdate the firewall\n for access (something the SQL Server Object Explorer will do for you).\n\n\n\n\nNote the third record has the Deleted column set to true.  We will not see that record when we do a query.  We can\nsee the deleted records only if we use the parameter \n__includeDeleted=true\n:\n\n\n\n\nWe can now undelete that record by POSTing to the \nId\n endpoint:\n\n\n\n\nA success results in a \n201 Created\n response, with a failure resulting in a \n404 Not Found\n response (assuming the\nfailure is because the Id does not exist in the table).\n\n\nFiltering Data\n\u00b6\n\n\nIf you have followed along, we have three entities in our table now.  We can do searches by utilizing the OData\n\n$filter\n operator as a query:\n\n\n\n\nThe \n$filter\n parameter takes an \nOData filter\n and returns the list of entities that match the search.  The Azure\nMobile Apps SDK supports quite a bit of the OData v3 specification that is supported by the \nMicrosoft.Data.OData\n\npackage, but not everything.  There are features of the OData package that are explicitly disabled because they\ndo not work in an offline context.  OData was defined as a method of transferring data between client and server\nin an online context so we can expect some things to work differently.\n\n\nWe can also select specific fields by using the \n$select\n clause:\n\n\n\n\nPaging Results\n\u00b6\n\n\nAt some point, we are going to bump into an in-built limit of the server.  You can clearly see this by inserting\na lot of entities then querying the results.  Once the number of entities gets above 50, paging will occur.  You\ncan adjust the paging size on the server by adding an \n[EnableQuery()]\n attribute to the class.  For example, the\nfollowing will set the page size at 10:\n\n\nnamespace Chapter3.Controllers\n{\n    [EnableQuery(PageSize=10)]\n    public class TodoItemController : TableController<TodoItem>\n    {\n\n\n\n\nYou cannot make the page size infinite, so you should always implement paging controls in your mobile client.\n\n\nWe can always receive the number of records that would have been sent if paging had not been in place by including\n\n$inlinecount=allpages\n with the query.  The query response turns into an object with two properties - the \nresults\n\nproperty contains the array of results.  This is the same response as we received before.  There is now another\nproperty called \ncount\n that contains the count of the records:\n\n\n\n\nWe can implement paging by using \n$top\n and \n$skip\n parameters. The \n$top\n parameter tells the server how many\nentities you want to return.  The \n$skip\n parameter tells the server how many entities to skip before it starts\ncounting.\n\n\nFor example, let's say you wanted to receive individual entities.  You could request:\n\n\n\n\n/tables/todoitem?$top=1&$skip=0\n\n\n/tables/todoitem?$top=1&$skip=1\n\n\n/tables/todoitem?$top=1&$skip=2\n\n\n/tables/todoitem?$top=1&$skip=3\n\n\n\n\nAt this point, no entities would be returned and you would know you are at the end.\n\n\n\n\nAlthough it is tempting to suggest removing the limit on the number of entities that can be returned (so you\ncan receive all entities in one shot), it's better to implement paging.  The Azure App Service will run in a\nsmaller App Service Plan because it won't require as much memory.  You will be able to support more users and\nyour code will be more resilient to network issues that occur during transmission.\n\n\n\n\nOffline synchronization\n\u00b6\n\n\nOne of the many reasons that developers choose the Azure Mobile Apps SDK is that it natively supports offline\nsync.  Offline sync provides a number of benefits.  It improves app responsiveness by caching server data\nlocally on the device.  It allows the app to survive network issues including little or no connectivity, and it\nallows the developer to decide when to synchronize, thus allowing the deferral of large updates to when there\nis wifi available, for example.  The Azure Mobile Apps SDKs provide incremental sync (thereby ensuring the minimal\namount of mobile data is used), optimistic concurrency and conflict resolution.\n\n\nTo do this, Azure Mobile Apps provides a SQLite based backing store for data persistence on the mobile client.  You\ndon't have to use SQLite, but it's built in and there are very few reasons to not use it.  If you are using iOS,\nthe implementation is based on Core Data (which is itself based on SQLite).\n\n\nWhen you perform changes to an offline table, a \nSync Context\n is created along side the offline table. One of the\nelements of this sync context is an \nOperation Queue\n.  This is an ordered list of Create, Update and Delete\noperations against the offline table.  When you \nPUSH\n the Sync Context, the list of creates, updates and Deletes\nare sent one by one to the Azure App Service, which then executes them as if they were done online.  Nothing is\nsent to the Azure App Service until your call to \nPUSH\n.\n\n\nTo retrieve entities, your mobile client will perform a \nPULL\n against a query.  The query is based on the filter\nthat we reviewed earlier.  By default, all properties of all entities are pulled down.  An \nImplicit Push\n happens\nif there are entities in the operation queue at the time of a pull request.  If you specify a query name (which is\njust a text string) to the \nPullAsync()\n method, the mobile client will do an \nIncremental Sync\n.  In this case,\nthe latest \nUpdatedAt\n timestamp that the mobile client saw is recorded in the \nSync Context\n (and associated with\nthe query name).  This allows the pull operation to pick up where it left off.\n\n\n\n\nThe query name must be unique within a Sync Context for incremental sync to work.\n\n\n\n\nThe sync process implements \nOptimistic Concurrency\n.  With optimistic concurrency, the mobile client assumes that\nits change is valid.  Conflicts are handled only on push operations.  If the mobile client submits a record with\na \nversion\n field that does not match the server version field, the server will return a 409 or 412 response code.\n\n\n\n\nWhat's the difference between 409 and 412?  Most of the time, you will see 412 Precondition Failed.  This means\nthe ETag of the request did not match.  The ETag is a header that is equivalent to the version value.  409 Conflict\noccurs when you don't submit an ETag but do submit a version field in the update.\n\n\n\n\nIf no version field (or ETag header) is submitted, the client entity is used for the create or update irrespective\nof the value on the server.",
            "title": "Concepts"
        },
        {
            "location": "/chapter3/dataconcepts/#data-access-concepts",
            "text": "At some point in the development of your application, you are going to want to store or retrieve data.  This could be\nas simple as a key-value store for storing personal settings, or as complex as a multi-table customer relationship\ndatabase.  The key ingredient to all these scenarios is structured data.  I say  structured  here deliberately.  It\nis an important concept.  Most applications you write will require data in some sort of form that your application\nunderstands.  It's very tempting to use an unstructured data source (like NoSQL).  I'm a big fan of NoSQL stores since they free\nme up to concentrate on the mobile client without worrying about the data format. After all, you can store whatever\nentities you want in a NoSQL data source.  However, this is really just an example of sloppy programming.  Most\ndevelopers that use NoSQL are storing structured data in that NoSQL store to get around the problem that you actually\nhave to decide what data you want to store in the database.  For this reason, I prefer a SQL database.  It ensures\nthat I am thinking about the data format up front.  It also helps to ensure that a bad actor is not going to store\ndata I don't expect in my store.  This isn't to say that NoSQL doesn't have its place.  There are times when you need to store structured data where\nthe data format varies between each entity that you are storing.  This tends to be an outlier situation though.",
            "title": "Data Access Concepts"
        },
        {
            "location": "/chapter3/dataconcepts/#tables-entities-and-properties",
            "text": "When we talk about data, we tend to talk in terms of  Tables ,  Entities  and  Properties .  These have equivalents\nin the SQL world (tables, rows and fields).  A  Table  is a collection of  Entities  that share a common format.  That\nformat is described in terms of  Properties .  Properties are basic types (like strings, numbers, booleans and dates).  We create a  Table Controller  to expose the tables to a mobile client.  A  Table Controller  is a REST endpoint\nthat implements an  OData v3  interface.  OData is a standard interface to table data that allows the client to\nperform CRUD (create, read, update and delete) operations on the data.  In addition, it provides for a standard\nway for querying the data.  More normally, the  Table Controller  is accessed through the Azure Mobile Apps Client\nSDK.  We saw an example of this in Chapter 1 when we first introduced the mobile client.  Azure Mobile Apps also deals with tables in a manner that enables offline synchronization of the data.  That means\nit must be opinionated about the data format.  Specifically,   There are four system properties on each entity.  There are limitations on relationships between tables.  Complex types need special handling.   Let's take each of these in turn.  We implemented this  Model  within the mobile client in Chapter 1:  using TaskList.Abstractions;\n\nnamespace TaskList.Models\n{\n    public class TodoItem : TableData\n    {\n        public string Text { get; set; }\n\n        public bool Complete { get; set; }\n    }\n}  It's a fairly basic model class.  Note the  TableData  base class.  I often say that Azure Mobile Apps implements\nan opinionated version of OData. What I mean by that is that the protocol expects certain system fields to be present\nduring the transfer.  The  TableData  class is a base class that implements that specification. It looks like this:  using System;\n\nnamespace TaskList.Abstractions\n{\n    public abstract class TableData\n    {\n        public string Id { get; set; }\n        public DateTimeOffset? UpdatedAt { get; set; }\n        public byte[] Version { get; set; }\n    }\n}  The server side version adds another field - the  Deleted  boolean.  This is described in the  ITableData  interface\nthat is provided with the Azure Mobile Apps Server SDK.   The Azure Mobile Apps SDK uses  DateTimeOffset  instead of  DateTime .  A DateTime object is time zone aware, and\ntime zone definitions change over time.  The DateTimeOffset does not know anything about time zones.  The DateTime\nrepresentation can change depending on where you are.  The DateTimeOffset will never change.  This makes it a better\nchoice for these things.  You will see dates stored in UTC in your database as a result of this.   Each element of the TableData (and ITableData) has a purpose, nominally to deal with situations with Offline Sync.",
            "title": "Tables, Entities and Properties"
        },
        {
            "location": "/chapter3/dataconcepts/#the-id-field",
            "text": "One of the common questions is this:  Can I use an auto-incrementing integer as an Id field?  Let's take a look at\na simple situation.  You have two clients writing to the same table.  It might look something like this:   Device A inserts a new record in to the database, with ID 1.  Device B is also inserting and decides to do ID 1\nas well.  This causes an immediate conflict that must be resolved.  We could fix this by requiring that new inserts\ndo not insert an ID.  However, this can cause problems in offline cases, where you may be inserting many records\nand have to refer back to them during your offline state.  The compromise here is to use a globally unique ID.  The  GUID  is a well-known algorithm and easily generated in\noffline scenarios.  This is stored as a string during transfer.",
            "title": "The Id field"
        },
        {
            "location": "/chapter3/dataconcepts/#the-updatedat-field",
            "text": "One of the concepts that is always top of mind is ensuring that we are a good mobile citizen.  This means that we\ncare about bandwidth utilization.  Reducing transfer size is good for your users.  They use less of their data\nallowance and save time by transferring less.  One of the key components to reduce bandwidth utilization is  Incremental\nSync .  With each record, we record the date it was last updated.  This is generally done for us as a database\ntrigger, so we never have to worry about setting this value.  When we synchronize our table, only the records\nthat have been updated since the last synchronization are requested.",
            "title": "The UpdatedAt field"
        },
        {
            "location": "/chapter3/dataconcepts/#the-version-field",
            "text": "The version field is all about conflict detection.  Let's take two devices requesting the same table again:   In this diagram, Device A submits the first version of the entity.  Device B then updates the entity and posts\nit back.  This is accepted because Device B is sending the same version, so the server knows that this is an\nupdate to the latest version.  The server will send back a response with the updated version so that Device B\nknows that it has the latest version.  Later on, Device A sends an update to the same entity.  It, however, still has version 1 of the entity.  The\nserver will reject that because of a version mismatch.",
            "title": "The Version field"
        },
        {
            "location": "/chapter3/dataconcepts/#the-deleted-field",
            "text": "When you are operating a service with an offline scope, you can't just delete entities.  If an entity is deleted\non Device A, it is then removed from the server.  The server does not know to send an update to that entity\nto Device B because it no longer exists.  For this reason, we never delete entities.  We use  Soft Delete .\nSoft Delete is a feature whereby entities are marked as deleted by setting the Deleted flag to true.  When you\nquery the server, the deleted records are not shown unless you explicitly ask for them.  This is done as part\nof the offline sync process.",
            "title": "The Deleted field"
        },
        {
            "location": "/chapter3/dataconcepts/#the-data-access-protocol",
            "text": "Given any particular table, there are a few endpoints that are important.  Given our TodoItem table from Chapter 1:     Operation  Endpoint  Description      GET  /tables/todoitem  Query the table    GET  /tables/todoitem/ id  Retrieve a single entity    POST  /tables/todoitem  Add a new entity    PATCH  /tables/todoitem/ id  Update an existing entity    DELETE  /tables/todoitem/ id  Deletes an existing entity    POST  /tables/todoitem/ id  Undelete a previously deleted entity     We can take a look at each of these in turn with the Azure App Service.  These can be done with Postman easily.   The first request to a new Azure App Service will take some time, especially if the site has to set up the database.   Let's start with a basic Query operation:   We always get an array of elements back.  These contain five system properties.  We didn't mention createdAt\nearlier - it's optional and will be maintained for you if you don't use it.  In addition, we have the fields\nthat were in our model.  If there are no elements in a table, we get an empty array.  If the table does not\nexist, we will get a  404 Not Found  error.   Any operation can also return a  401 Unauthorized  if you are not allowed to do the operation with the current\nauthentication,  400 Bad Request  if you supplied bad data and  500 Internal Server Error  if the server crashed.   We can also do a GET for an Id:   The return is the entity serialized as an object.  If the Id does not exist, then a  404 Not Found  is\nreturned.  Adding an item requires a POST:   Note that you do not need to provide all the fields.  In particular, the system fields will be automatically\nfilled in for you.  Any fields with a default value will be similarly auto-created.  It is fairly easy to\ngenerate a  400 Bad Request  when updating or inserting data.  For example, if you submit a string when a number\nis expected or submit a malformed date, you can expect a  400 Bad Request .  On success, the response has a\nLocation field in the headers:   This is the URI of the entity.  You can do a GET on this location to get the entity again.  Updating an entity\ninvolves sending the updated fields to the  Id  endpoint with the changed properties:   Note that you do not need to send the entire entity - just the properties that are changed.  The new entity is\nreturned on success.  As with the insert operation, data format errors will result in a  400 Bad Request .  Note,\nhowever, that if you do not submit a  version  field, no conflict handling is done and the server just accepts\nthe record.  We can fix this with server code later on by requiring a version field on updates.  Deletion is fairly straight forward.  The main different is that it returns a  204 No Content .   The table controller does not support soft delete out of the box.  If you have followed the sequence, the\nrecord we just deleted is gone.  You can verify this using a SQL Browser.  To enable soft delete, you need\nto adjust the domain manager in the TodoItemController:  protected override void Initialize(HttpControllerContext controllerContext)\n{\n    base.Initialize(controllerContext);\n    MobileServiceContext context = new MobileServiceContext();\n    DomainManager = new EntityDomainManager<TodoItem>(context, Request, enableSoftDelete: true);\n}  Adding the  enableSoftDelete  parameter and setting it to true will enable the appropriate logic in the\ndomain manager.   We haven't introduced the  Domain Manager  yet.  Azure Mobile Apps doesn't really care what sort of data store\nyou are using on the backend.  It proxies all requests through a class that implements the  IDomainManager \ninterface.  Azure Mobile Apps Server SDK supplies one such domain manager - the  EntityDomainManager  uses\nEntity Framework underneath for this purpose.   Go through the same process of adding and deleting an entity.  You can see the entity by using the SQL Server Object\nExplorer in Visual Studio:   Go to  Server Explorer .  Expand  Azure  and  SQL Databases .  Select your database, then right-click and select  Open in SQL Server Object Explorer .  You will be prompted for your username and password.  Enter them, then click  OK .  You may be prompted to update the firewall for SQL access.  Select  My Client IP , then  OK .  Expand your database node, then  Tables .  Right-click on  dbo.TodoItems  and select  View Data .   I find the SQL Server Object Explorer to be relatively slow when it comes to database options.  However, it doesn't\nrequire any additional installs.  You can also use SQL Server Management Studio if you have it installed.  You will\nneed to  update the firewall  for access (something the SQL Server Object Explorer will do for you).   Note the third record has the Deleted column set to true.  We will not see that record when we do a query.  We can\nsee the deleted records only if we use the parameter  __includeDeleted=true :   We can now undelete that record by POSTing to the  Id  endpoint:   A success results in a  201 Created  response, with a failure resulting in a  404 Not Found  response (assuming the\nfailure is because the Id does not exist in the table).",
            "title": "The Data Access Protocol"
        },
        {
            "location": "/chapter3/dataconcepts/#filtering-data",
            "text": "If you have followed along, we have three entities in our table now.  We can do searches by utilizing the OData $filter  operator as a query:   The  $filter  parameter takes an  OData filter  and returns the list of entities that match the search.  The Azure\nMobile Apps SDK supports quite a bit of the OData v3 specification that is supported by the  Microsoft.Data.OData \npackage, but not everything.  There are features of the OData package that are explicitly disabled because they\ndo not work in an offline context.  OData was defined as a method of transferring data between client and server\nin an online context so we can expect some things to work differently.  We can also select specific fields by using the  $select  clause:",
            "title": "Filtering Data"
        },
        {
            "location": "/chapter3/dataconcepts/#paging-results",
            "text": "At some point, we are going to bump into an in-built limit of the server.  You can clearly see this by inserting\na lot of entities then querying the results.  Once the number of entities gets above 50, paging will occur.  You\ncan adjust the paging size on the server by adding an  [EnableQuery()]  attribute to the class.  For example, the\nfollowing will set the page size at 10:  namespace Chapter3.Controllers\n{\n    [EnableQuery(PageSize=10)]\n    public class TodoItemController : TableController<TodoItem>\n    {  You cannot make the page size infinite, so you should always implement paging controls in your mobile client.  We can always receive the number of records that would have been sent if paging had not been in place by including $inlinecount=allpages  with the query.  The query response turns into an object with two properties - the  results \nproperty contains the array of results.  This is the same response as we received before.  There is now another\nproperty called  count  that contains the count of the records:   We can implement paging by using  $top  and  $skip  parameters. The  $top  parameter tells the server how many\nentities you want to return.  The  $skip  parameter tells the server how many entities to skip before it starts\ncounting.  For example, let's say you wanted to receive individual entities.  You could request:   /tables/todoitem?$top=1&$skip=0  /tables/todoitem?$top=1&$skip=1  /tables/todoitem?$top=1&$skip=2  /tables/todoitem?$top=1&$skip=3   At this point, no entities would be returned and you would know you are at the end.   Although it is tempting to suggest removing the limit on the number of entities that can be returned (so you\ncan receive all entities in one shot), it's better to implement paging.  The Azure App Service will run in a\nsmaller App Service Plan because it won't require as much memory.  You will be able to support more users and\nyour code will be more resilient to network issues that occur during transmission.",
            "title": "Paging Results"
        },
        {
            "location": "/chapter3/dataconcepts/#offline-synchronization",
            "text": "One of the many reasons that developers choose the Azure Mobile Apps SDK is that it natively supports offline\nsync.  Offline sync provides a number of benefits.  It improves app responsiveness by caching server data\nlocally on the device.  It allows the app to survive network issues including little or no connectivity, and it\nallows the developer to decide when to synchronize, thus allowing the deferral of large updates to when there\nis wifi available, for example.  The Azure Mobile Apps SDKs provide incremental sync (thereby ensuring the minimal\namount of mobile data is used), optimistic concurrency and conflict resolution.  To do this, Azure Mobile Apps provides a SQLite based backing store for data persistence on the mobile client.  You\ndon't have to use SQLite, but it's built in and there are very few reasons to not use it.  If you are using iOS,\nthe implementation is based on Core Data (which is itself based on SQLite).  When you perform changes to an offline table, a  Sync Context  is created along side the offline table. One of the\nelements of this sync context is an  Operation Queue .  This is an ordered list of Create, Update and Delete\noperations against the offline table.  When you  PUSH  the Sync Context, the list of creates, updates and Deletes\nare sent one by one to the Azure App Service, which then executes them as if they were done online.  Nothing is\nsent to the Azure App Service until your call to  PUSH .  To retrieve entities, your mobile client will perform a  PULL  against a query.  The query is based on the filter\nthat we reviewed earlier.  By default, all properties of all entities are pulled down.  An  Implicit Push  happens\nif there are entities in the operation queue at the time of a pull request.  If you specify a query name (which is\njust a text string) to the  PullAsync()  method, the mobile client will do an  Incremental Sync .  In this case,\nthe latest  UpdatedAt  timestamp that the mobile client saw is recorded in the  Sync Context  (and associated with\nthe query name).  This allows the pull operation to pick up where it left off.   The query name must be unique within a Sync Context for incremental sync to work.   The sync process implements  Optimistic Concurrency .  With optimistic concurrency, the mobile client assumes that\nits change is valid.  Conflicts are handled only on push operations.  If the mobile client submits a record with\na  version  field that does not match the server version field, the server will return a 409 or 412 response code.   What's the difference between 409 and 412?  Most of the time, you will see 412 Precondition Failed.  This means\nthe ETag of the request did not match.  The ETag is a header that is equivalent to the version value.  409 Conflict\noccurs when you don't submit an ETag but do submit a version field in the update.   If no version field (or ETag header) is submitted, the client entity is used for the create or update irrespective\nof the value on the server.",
            "title": "Offline synchronization"
        },
        {
            "location": "/chapter3/server/",
            "text": "Implementing Table Controllers\n\u00b6\n\n\nThe central component for providing a table endpoint on the Azure App Service side of things occurs in your\nbackend project.  You must implement a Table Controller.  This is a specialized version of an ApiController\nthat has some similarities with an ODataController.  However, it has its own base class and the Azure Mobile\nApps SDK simplifies the process of making them.\n\n\nImplementing Code First Migrations\n\u00b6\n\n\nBefore we can get started with adding another table controller, we have to deal with modifications to our\ndatabase schema.  The default code for Azure Mobile Apps will deploy the configured schema \nonly if the\ndatabase is empty\n.  If the database is not empty, you have to do extra work.\n\n\nNothing causes more headaches in an Azure Mobile Apps backend than \ncode-first migrations\n.  A code-first\nmigration is simply a set of configuration commands that updates the database to support the new\ndatabase model.  If you try to publish this application, you will see an \nInvalidOperationException\n\nand your service will likely crash.  If you manage to trap the error, it will say \nThe model backing\nthe 'MobileServiceContext' context has changed since the database was created. Consider using Code First\nMigrations to update the database.\n  That's fairly specific and is common to all applications based\non Entity Framework that use code-first models.\n\n\n\n\nThere is an alternative here called \nDatabase First Models\n.  In this alternative, you create the\ndatabase first then create the models to match.  However, Azure Mobile Apps requires specific configuration\nof mobile tables that you will need to take care of.  See the section on using existing SQL tables later\non for details.\n\n\n\n\nThe first step is to enable migrations.  Go to \nView\n -> \nOther Windows\n -> \nPackage Manager Console\n.\nThis window will generally appear in the same place as your Output and Error List windows at the bottom\nof the screen.  Type \nenable-migrations\n in it:\n\n\n\n\nThis creates a \nMigrations\n folder to hold the code-first migrations.  An initial \nConfiguration.cs\n object\nwill be added as well.  We also need to apply an Initial migration.  We can do this with the command\n\nadd-migration Initial\n.\n\n\n\n\nThis will add a few files into the \nMigrations\n folder that represent the current state of affairs for\nthe database.\n\n\nCode First Migrations can be applied manually or automatically.  I personally prefer the automatic method.\nTo implement automated Code First Migrations, edit the \nApp_Start\\Startup.MobileApp.cs\n file:\n\n\npublic static void ConfigureMobileApp(IAppBuilder app)\n{\n    var httpConfig = new HttpConfiguration();\n    var mobileConfig = new MobileAppConfiguration();\n\n    mobileConfig\n        .AddTablesWithEntityFramework()\n        .ApplyTo(httpConfig);\n\n    // Automatic Code First Migrations\n    var migrator = new DbMigrator(new Migrations.Configuration());\n    migrator.Update();\n\n    app.UseWebApi(httpConfig);\n}\n\n\n\n\nWe have replaced the \nDbInitializer()\n (which was the method that created the database for us) with the\nautomatic database migrator code.\n\n\nThere is one issue that will cause some problems.  We are no longer using a database initializer.  This\nmeans that the special system columns will no longer be wired up to update their values automatically.\nWe can fix that by configuring the SqlGenerator in \nMigrations\\Configuration.cs\n:\n\n\npublic Configuration()\n{\n    AutomaticMigrationsEnabled = false;\n    SetSqlGenerator(\"System.Data.SqlClient\", new EntityTableSqlGenerator());\n}\n\n\n\n\nSince we are not using a database initializer, our seed data has also gone.  You may as well delete the\n\nMobileServiceInitializer\n class in the \nApp_Start\\Startup.MobileApp.cs\n as it isn't doing anything\nany more.  You can move the seed data to the \nMigrations\\Configuration.cs\n file though:\n\n\nnamespace Chapter3.Migrations\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Data.Entity.Migrations;\n    using DataObjects;\n    using Microsoft.Azure.Mobile.Server.Tables;\n\n    internal sealed class Configuration : DbMigrationsConfiguration<Chapter3.Models.MobileServiceContext>\n    {\n        public Configuration()\n        {\n            AutomaticMigrationsEnabled = false;\n            SetSqlGenerator(\"System.Data.SqlClient\", new EntityTableSqlGenerator());\n        }\n\n        protected override void Seed(Chapter3.Models.MobileServiceContext context)\n        {\n            List<TodoItem> todoItems = new List<TodoItem>\n            {\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"First item\", Complete = false },\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"Second item\", Complete = false }\n            };\n\n            foreach (TodoItem todoItem in todoItems)\n            {\n                context.Set<TodoItem>().Add(todoItem);\n            }\n\n            base.Seed(context);\n        }\n    }\n}\n\n\n\n\nThe contents of the \nSeed\n method are a cut-and-paste from the \nMobileServiceInitializer\n version.\n\n\nIf all goes well, you can clear your database (or delete it and re-create it), then publish this project\nand do a GET of the \n/tables/todoitem\n endpoint.  You should still see your data.  You should do a little\nmore investigation however.\n\n\n\n\nOpen the database in the \nSQL Server Object Explorer\n.\n\n\nExpand the \nTables\n node.\n\n\nRight-click on the \ndbo.__MigrationHistory\n table and select \nView Data\n.\n\n\n\n\n\n\nThere should be one row with a name that indicates it is the initial migration.\n\n\nThe final step is to apply the migration to the local system.  In the Package Manager Console, enter\nthe command \nupdate-database\n to apply the existing migration.\n\n\nAdding a SQL Table Controller\n\u00b6\n\n\nBefore we can use a table controller, we need to add one.  This has three steps:\n\n\n\n\nCreate a Data Transfer Object (DTO)\n\n\nCreate a Table Controller\n\n\nCreate a Code-First Migration\n\n\n\n\nCreating a Data Transfer Object\n\u00b6\n\n\nA Data Transfer Object (or DTO as it is commonly known) is the wire representation of the model for your\ntable.  It must inherit from a concrete implementation of \nITableData\n.  The Azure Mobile Apps SDK includes\n\nEntityData\n for this reason.  EntityData is a concrete implementation that works with Entity Framework.\n\n\n\n\nYou can't just assume EntityData will work with other data stores.  There are Entity Framework specific\nattributes decorating the properties for EntityData that will likely be different for other stores.\n\n\n\n\nThe default Azure Mobile Apps project that is supplied with the Azure SDK provides a folder for storing\nDTOs called \nDataObjects\n.  Let's create a DTO by right-clicking on the \nDataObjects\n folder, then\nusing \nAdd\n -> \nClass...\n:\n\n\nusing System;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Chapter3.DataObjects\n{\n    public class Example : EntityData\n    {\n        public string StringField { get; set; }\n        public int IntField { get; set; }\n        public double DoubleField { get; set; }\n        public DateTimeOffset DateTimeField { get; set; }\n    }\n}\n\n\n\n\n\n\nDon't call your model \nSomethingDTO\n.  This ends up as a \n/tables/somethingDTO\n endpoint and a \nSomethingDTO\n\ntable in your database.  Just call it \nSomething\n.  All the names will then line up properly.\n\n\n\n\nI've included several field types, including a complex type.  The basic requirement for a field is that it\nmust be serialized into a simple JSON type during transfer between the server and the mobile client.  Complex\ntypes (that is, any type that can be serialized to an object or array) will always require special handling\nand may not be able to be used at all.\n\n\nCreate a Table Controller\n\u00b6\n\n\nVisual Studio with the Azure SDK provides some help in creating a table controller.  Right-click on the\n\nControllers\n node and select \nAdd\n -> \nController...\n.\n\n\n\n\nThe Azure SDK provides scaffolding for a new table controller.  Select it and then click on \nAdd\n.\n\n\n\n\nThe dialog asks for the model (which is actually a DTO) and the data context (which is already created).\nOnce you select the model, the controller name is created for you.  You can change it if you like, but\nit's common practice to not do this.\n\n\nOnce the scaffolding is finished, you can look at your newly created table controller.  We do want to\ndo one change.  We want to enable soft delete so that our table controller supports offline sync\nscenarios properly.  To do this, go into the \nInitialize()\n method and change the constructor of the\n\nEntityDomainManager\n:\n\n\nprotected override void Initialize(HttpControllerContext controllerContext)\n{\n    base.Initialize(controllerContext);\n    MobileServiceContext context = new MobileServiceContext();\n    DomainManager = new EntityDomainManager<Example>(context, Request, enableSoftDelete: true);\n}\n\n\n\n\nCreating a Code-First Migration\n\u00b6\n\n\nYou must add a code first migration to update the database when it is published. Use the \nadd-migration\n\ncommand in the Package Manager Console.  The \nadd-migration\n command will request a name - it just has\nto be unique, but it's a good idea to make the name descriptive:\n\n\n\n\nYou should also use \nupdate-database\n to apply the change to the local database (if any):\n\n\n\n\nOnce this is done, you can publish the project.  Right-click on the project and select \nPublish...\n.  Once\nthe project is published, you should be able to send a query to the \n/tables/example\n endpoint using Postman\nand get an empty array.  You should also be able to insert, update and delete entities as you can with the\n\nTodoItem\n table.\n\n\nHandling Publish Failures\n\u00b6\n\n\nSometimes, the publish fails.  It seems that whenever I start with code-first migrations, my publish fails.\nI get a nice error screen, but no actual error.  At least half the time, the problem is not my code-first\nmigration, but something else.  For instance, one of the things I tend to do is update my NuGet packages.\nThis inevitably breaks something.\n\n\nFortunately, once the error message is known, it's generally trivial to correct the error.  You can turn\ncustom error messages off (and thus expose the original error message) by editing the Web.config file.\nLocate the \n<system.web>\n section and add the \n<customErrors mode=\"Off\"/>\n line:\n\n\n  <system.web>\n    <httpRuntime targetFramework=\"4.6\" />\n    <compilation debug=\"true\" targetFramework=\"4.6\" />\n    <customErrors mode=\"Off\" />\n  </system.web>\n\n\n\n\nThen republish your project and the response from the server is much more informative.\n\n\nTurning on Diagnostic Logs\n\u00b6\n\n\nYou can log all the SQL statements that Entity Framework executes on your behalf by adding a Database\nLog.  Edit the \nModels\\MobileServiceContext.cs\n file:\n\n\npublic class MobileServiceContext : DbContext\n{\n    private const string connectionStringName = \"Name=MS_TableConnectionString\";\n\n    public MobileServiceContext() : base(connectionStringName)\n    {\n        Database.Log = s => WriteLog(s);\n    }\n\n    public void WriteLog(string msg)\n    {\n        System.Diagnostics.Debug.WriteLine(msg);\n    }\n\n    protected override void OnModelCreating(DbModelBuilder modelBuilder)\n    {\n        modelBuilder.Conventions.Add(\n            new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n                \"ServiceTableColumn\", (property, attributes) => attributes.Single().ColumnType.ToString()));\n    }\n\n    public DbSet<DataObjects.TodoItem> TodoItems { get; set; }\n    public DbSet<DataObjects.Example> Examples { get; set; }\n}\n\n\n\n\nYou have to use a real method.  System.Diagnostics.Debug is removed from the context when DEBUG is not\ndefined, so you can't just use it directly.   Using an interim method works around that problem. Azure App\nService captures the output from the console and places it into the log viewer for you.\n\n\nTo turn on diagnostic logging:\n\n\n\n\nLog in to the \nAzure Portal\n.\n\n\nClick on \nApp Services\n then your App Service.\n\n\nFind \nDiagnostic Logs\n in the list of settings (you can use the search box).\n\n\nTurn on \nApplication Logging (Filesystem)\n with a level of \nVerbose\n.\n\n\nClick on \nSave\n.\n\n\n\n\nTo view the diagnostic logs in the portal, find \nLog Stream\n in the list of settings (again, you can\nuse the search box).  You can also get the diagnostic logs within Visual Studio.\n\n\n\n\nOpen the \nServer Explorer\n.\n\n\nExpand \nAzure\n, \nApp Service\n, your resource group.\n\n\nRight-click on the your App Service and select \nView Streaming Logs\n.\n\n\n\n\n\n\nUsing an existing SQL Table\n\u00b6",
            "title": "Implementing Table Controllers"
        },
        {
            "location": "/chapter3/server/#implementing-table-controllers",
            "text": "The central component for providing a table endpoint on the Azure App Service side of things occurs in your\nbackend project.  You must implement a Table Controller.  This is a specialized version of an ApiController\nthat has some similarities with an ODataController.  However, it has its own base class and the Azure Mobile\nApps SDK simplifies the process of making them.",
            "title": "Implementing Table Controllers"
        },
        {
            "location": "/chapter3/server/#implementing-code-first-migrations",
            "text": "Before we can get started with adding another table controller, we have to deal with modifications to our\ndatabase schema.  The default code for Azure Mobile Apps will deploy the configured schema  only if the\ndatabase is empty .  If the database is not empty, you have to do extra work.  Nothing causes more headaches in an Azure Mobile Apps backend than  code-first migrations .  A code-first\nmigration is simply a set of configuration commands that updates the database to support the new\ndatabase model.  If you try to publish this application, you will see an  InvalidOperationException \nand your service will likely crash.  If you manage to trap the error, it will say  The model backing\nthe 'MobileServiceContext' context has changed since the database was created. Consider using Code First\nMigrations to update the database.   That's fairly specific and is common to all applications based\non Entity Framework that use code-first models.   There is an alternative here called  Database First Models .  In this alternative, you create the\ndatabase first then create the models to match.  However, Azure Mobile Apps requires specific configuration\nof mobile tables that you will need to take care of.  See the section on using existing SQL tables later\non for details.   The first step is to enable migrations.  Go to  View  ->  Other Windows  ->  Package Manager Console .\nThis window will generally appear in the same place as your Output and Error List windows at the bottom\nof the screen.  Type  enable-migrations  in it:   This creates a  Migrations  folder to hold the code-first migrations.  An initial  Configuration.cs  object\nwill be added as well.  We also need to apply an Initial migration.  We can do this with the command add-migration Initial .   This will add a few files into the  Migrations  folder that represent the current state of affairs for\nthe database.  Code First Migrations can be applied manually or automatically.  I personally prefer the automatic method.\nTo implement automated Code First Migrations, edit the  App_Start\\Startup.MobileApp.cs  file:  public static void ConfigureMobileApp(IAppBuilder app)\n{\n    var httpConfig = new HttpConfiguration();\n    var mobileConfig = new MobileAppConfiguration();\n\n    mobileConfig\n        .AddTablesWithEntityFramework()\n        .ApplyTo(httpConfig);\n\n    // Automatic Code First Migrations\n    var migrator = new DbMigrator(new Migrations.Configuration());\n    migrator.Update();\n\n    app.UseWebApi(httpConfig);\n}  We have replaced the  DbInitializer()  (which was the method that created the database for us) with the\nautomatic database migrator code.  There is one issue that will cause some problems.  We are no longer using a database initializer.  This\nmeans that the special system columns will no longer be wired up to update their values automatically.\nWe can fix that by configuring the SqlGenerator in  Migrations\\Configuration.cs :  public Configuration()\n{\n    AutomaticMigrationsEnabled = false;\n    SetSqlGenerator(\"System.Data.SqlClient\", new EntityTableSqlGenerator());\n}  Since we are not using a database initializer, our seed data has also gone.  You may as well delete the MobileServiceInitializer  class in the  App_Start\\Startup.MobileApp.cs  as it isn't doing anything\nany more.  You can move the seed data to the  Migrations\\Configuration.cs  file though:  namespace Chapter3.Migrations\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Data.Entity.Migrations;\n    using DataObjects;\n    using Microsoft.Azure.Mobile.Server.Tables;\n\n    internal sealed class Configuration : DbMigrationsConfiguration<Chapter3.Models.MobileServiceContext>\n    {\n        public Configuration()\n        {\n            AutomaticMigrationsEnabled = false;\n            SetSqlGenerator(\"System.Data.SqlClient\", new EntityTableSqlGenerator());\n        }\n\n        protected override void Seed(Chapter3.Models.MobileServiceContext context)\n        {\n            List<TodoItem> todoItems = new List<TodoItem>\n            {\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"First item\", Complete = false },\n                new TodoItem { Id = Guid.NewGuid().ToString(), Text = \"Second item\", Complete = false }\n            };\n\n            foreach (TodoItem todoItem in todoItems)\n            {\n                context.Set<TodoItem>().Add(todoItem);\n            }\n\n            base.Seed(context);\n        }\n    }\n}  The contents of the  Seed  method are a cut-and-paste from the  MobileServiceInitializer  version.  If all goes well, you can clear your database (or delete it and re-create it), then publish this project\nand do a GET of the  /tables/todoitem  endpoint.  You should still see your data.  You should do a little\nmore investigation however.   Open the database in the  SQL Server Object Explorer .  Expand the  Tables  node.  Right-click on the  dbo.__MigrationHistory  table and select  View Data .    There should be one row with a name that indicates it is the initial migration.  The final step is to apply the migration to the local system.  In the Package Manager Console, enter\nthe command  update-database  to apply the existing migration.",
            "title": "Implementing Code First Migrations"
        },
        {
            "location": "/chapter3/server/#adding-a-sql-table-controller",
            "text": "Before we can use a table controller, we need to add one.  This has three steps:   Create a Data Transfer Object (DTO)  Create a Table Controller  Create a Code-First Migration",
            "title": "Adding a SQL Table Controller"
        },
        {
            "location": "/chapter3/server/#creating-a-data-transfer-object",
            "text": "A Data Transfer Object (or DTO as it is commonly known) is the wire representation of the model for your\ntable.  It must inherit from a concrete implementation of  ITableData .  The Azure Mobile Apps SDK includes EntityData  for this reason.  EntityData is a concrete implementation that works with Entity Framework.   You can't just assume EntityData will work with other data stores.  There are Entity Framework specific\nattributes decorating the properties for EntityData that will likely be different for other stores.   The default Azure Mobile Apps project that is supplied with the Azure SDK provides a folder for storing\nDTOs called  DataObjects .  Let's create a DTO by right-clicking on the  DataObjects  folder, then\nusing  Add  ->  Class... :  using System;\nusing Microsoft.Azure.Mobile.Server;\n\nnamespace Chapter3.DataObjects\n{\n    public class Example : EntityData\n    {\n        public string StringField { get; set; }\n        public int IntField { get; set; }\n        public double DoubleField { get; set; }\n        public DateTimeOffset DateTimeField { get; set; }\n    }\n}   Don't call your model  SomethingDTO .  This ends up as a  /tables/somethingDTO  endpoint and a  SomethingDTO \ntable in your database.  Just call it  Something .  All the names will then line up properly.   I've included several field types, including a complex type.  The basic requirement for a field is that it\nmust be serialized into a simple JSON type during transfer between the server and the mobile client.  Complex\ntypes (that is, any type that can be serialized to an object or array) will always require special handling\nand may not be able to be used at all.",
            "title": "Creating a Data Transfer Object"
        },
        {
            "location": "/chapter3/server/#create-a-table-controller",
            "text": "Visual Studio with the Azure SDK provides some help in creating a table controller.  Right-click on the Controllers  node and select  Add  ->  Controller... .   The Azure SDK provides scaffolding for a new table controller.  Select it and then click on  Add .   The dialog asks for the model (which is actually a DTO) and the data context (which is already created).\nOnce you select the model, the controller name is created for you.  You can change it if you like, but\nit's common practice to not do this.  Once the scaffolding is finished, you can look at your newly created table controller.  We do want to\ndo one change.  We want to enable soft delete so that our table controller supports offline sync\nscenarios properly.  To do this, go into the  Initialize()  method and change the constructor of the EntityDomainManager :  protected override void Initialize(HttpControllerContext controllerContext)\n{\n    base.Initialize(controllerContext);\n    MobileServiceContext context = new MobileServiceContext();\n    DomainManager = new EntityDomainManager<Example>(context, Request, enableSoftDelete: true);\n}",
            "title": "Create a Table Controller"
        },
        {
            "location": "/chapter3/server/#creating-a-code-first-migration",
            "text": "You must add a code first migration to update the database when it is published. Use the  add-migration \ncommand in the Package Manager Console.  The  add-migration  command will request a name - it just has\nto be unique, but it's a good idea to make the name descriptive:   You should also use  update-database  to apply the change to the local database (if any):   Once this is done, you can publish the project.  Right-click on the project and select  Publish... .  Once\nthe project is published, you should be able to send a query to the  /tables/example  endpoint using Postman\nand get an empty array.  You should also be able to insert, update and delete entities as you can with the TodoItem  table.",
            "title": "Creating a Code-First Migration"
        },
        {
            "location": "/chapter3/server/#handling-publish-failures",
            "text": "Sometimes, the publish fails.  It seems that whenever I start with code-first migrations, my publish fails.\nI get a nice error screen, but no actual error.  At least half the time, the problem is not my code-first\nmigration, but something else.  For instance, one of the things I tend to do is update my NuGet packages.\nThis inevitably breaks something.  Fortunately, once the error message is known, it's generally trivial to correct the error.  You can turn\ncustom error messages off (and thus expose the original error message) by editing the Web.config file.\nLocate the  <system.web>  section and add the  <customErrors mode=\"Off\"/>  line:    <system.web>\n    <httpRuntime targetFramework=\"4.6\" />\n    <compilation debug=\"true\" targetFramework=\"4.6\" />\n    <customErrors mode=\"Off\" />\n  </system.web>  Then republish your project and the response from the server is much more informative.",
            "title": "Handling Publish Failures"
        },
        {
            "location": "/chapter3/server/#turning-on-diagnostic-logs",
            "text": "You can log all the SQL statements that Entity Framework executes on your behalf by adding a Database\nLog.  Edit the  Models\\MobileServiceContext.cs  file:  public class MobileServiceContext : DbContext\n{\n    private const string connectionStringName = \"Name=MS_TableConnectionString\";\n\n    public MobileServiceContext() : base(connectionStringName)\n    {\n        Database.Log = s => WriteLog(s);\n    }\n\n    public void WriteLog(string msg)\n    {\n        System.Diagnostics.Debug.WriteLine(msg);\n    }\n\n    protected override void OnModelCreating(DbModelBuilder modelBuilder)\n    {\n        modelBuilder.Conventions.Add(\n            new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n                \"ServiceTableColumn\", (property, attributes) => attributes.Single().ColumnType.ToString()));\n    }\n\n    public DbSet<DataObjects.TodoItem> TodoItems { get; set; }\n    public DbSet<DataObjects.Example> Examples { get; set; }\n}  You have to use a real method.  System.Diagnostics.Debug is removed from the context when DEBUG is not\ndefined, so you can't just use it directly.   Using an interim method works around that problem. Azure App\nService captures the output from the console and places it into the log viewer for you.  To turn on diagnostic logging:   Log in to the  Azure Portal .  Click on  App Services  then your App Service.  Find  Diagnostic Logs  in the list of settings (you can use the search box).  Turn on  Application Logging (Filesystem)  with a level of  Verbose .  Click on  Save .   To view the diagnostic logs in the portal, find  Log Stream  in the list of settings (again, you can\nuse the search box).  You can also get the diagnostic logs within Visual Studio.   Open the  Server Explorer .  Expand  Azure ,  App Service , your resource group.  Right-click on the your App Service and select  View Streaming Logs .",
            "title": "Turning on Diagnostic Logs"
        },
        {
            "location": "/chapter3/server/#using-an-existing-sql-table",
            "text": "",
            "title": "Using an existing SQL Table"
        },
        {
            "location": "/data/",
            "text": "Data Access and Offline Sync\n\u00b6\n\n\nAdding a SQL Table Controller\n\u00b6\n\n\nUsing an Existing SQL Table\n\u00b6\n\n\nUsing Code Behind\n\u00b6\n\n\nWhy use Code Behind?\n\u00b6\n\n\nImplementing Code Behind\n\u00b6\n\n\nCode Behind Recipes\n\u00b6\n\n\nWorking with Data in your Client\n\u00b6\n\n\nImplementing an Online Table\n\u00b6\n\n\nImplementing an Offline Table\n\u00b6\n\n\nUsing a Non-SQL Data Source\n\u00b6\n\n\nThe ASP.NET Domain Manager\n\u00b6\n\n\nImplementing a DocumentDB Domain Manager\n\u00b6\n\n\nImplementing an Azure Table Storage Domain Manager\n\u00b6",
            "title": "Data"
        },
        {
            "location": "/data/#data-access-and-offline-sync",
            "text": "",
            "title": "Data Access and Offline Sync"
        },
        {
            "location": "/data/#adding-a-sql-table-controller",
            "text": "",
            "title": "Adding a SQL Table Controller"
        },
        {
            "location": "/data/#using-an-existing-sql-table",
            "text": "",
            "title": "Using an Existing SQL Table"
        },
        {
            "location": "/data/#using-code-behind",
            "text": "",
            "title": "Using Code Behind"
        },
        {
            "location": "/data/#why-use-code-behind",
            "text": "",
            "title": "Why use Code Behind?"
        },
        {
            "location": "/data/#implementing-code-behind",
            "text": "",
            "title": "Implementing Code Behind"
        },
        {
            "location": "/data/#code-behind-recipes",
            "text": "",
            "title": "Code Behind Recipes"
        },
        {
            "location": "/data/#working-with-data-in-your-client",
            "text": "",
            "title": "Working with Data in your Client"
        },
        {
            "location": "/data/#implementing-an-online-table",
            "text": "",
            "title": "Implementing an Online Table"
        },
        {
            "location": "/data/#implementing-an-offline-table",
            "text": "",
            "title": "Implementing an Offline Table"
        },
        {
            "location": "/data/#using-a-non-sql-data-source",
            "text": "",
            "title": "Using a Non-SQL Data Source"
        },
        {
            "location": "/data/#the-aspnet-domain-manager",
            "text": "",
            "title": "The ASP.NET Domain Manager"
        },
        {
            "location": "/data/#implementing-a-documentdb-domain-manager",
            "text": "",
            "title": "Implementing a DocumentDB Domain Manager"
        },
        {
            "location": "/data/#implementing-an-azure-table-storage-domain-manager",
            "text": "",
            "title": "Implementing an Azure Table Storage Domain Manager"
        },
        {
            "location": "/files/",
            "text": "File Management\n\u00b6\n\n\nAzure Storage Concepts\n\u00b6\n\n\nBlobs, Table, Queues and files\n\u00b6\n\n\nThe SAS Tokens\n\u00b6\n\n\nFile Sync with Azure Mobile Apps\n\u00b6\n\n\nDealing with Files\n\u00b6\n\n\nUploading a File to Blob Storage\n\u00b6\n\n\nDownload a File from Blob Storage\n\u00b6\n\n\nFile Sync with Azure Mobile Apps\n\u00b6\n\n\nConfiguring the Mobile Backend\n\u00b6\n\n\nDeveloping the Mobile Client\n\u00b6",
            "title": "File Management"
        },
        {
            "location": "/files/#file-management",
            "text": "",
            "title": "File Management"
        },
        {
            "location": "/files/#azure-storage-concepts",
            "text": "",
            "title": "Azure Storage Concepts"
        },
        {
            "location": "/files/#blobs-table-queues-and-files",
            "text": "",
            "title": "Blobs, Table, Queues and files"
        },
        {
            "location": "/files/#the-sas-tokens",
            "text": "",
            "title": "The SAS Tokens"
        },
        {
            "location": "/files/#file-sync-with-azure-mobile-apps",
            "text": "",
            "title": "File Sync with Azure Mobile Apps"
        },
        {
            "location": "/files/#dealing-with-files",
            "text": "",
            "title": "Dealing with Files"
        },
        {
            "location": "/files/#uploading-a-file-to-blob-storage",
            "text": "",
            "title": "Uploading a File to Blob Storage"
        },
        {
            "location": "/files/#download-a-file-from-blob-storage",
            "text": "",
            "title": "Download a File from Blob Storage"
        },
        {
            "location": "/files/#file-sync-with-azure-mobile-apps_1",
            "text": "",
            "title": "File Sync with Azure Mobile Apps"
        },
        {
            "location": "/files/#configuring-the-mobile-backend",
            "text": "",
            "title": "Configuring the Mobile Backend"
        },
        {
            "location": "/files/#developing-the-mobile-client",
            "text": "",
            "title": "Developing the Mobile Client"
        },
        {
            "location": "/push/",
            "text": "Push Notifications\n\u00b6\n\n\nPush Notification Concepts\n\u00b6\n\n\nHow Push Notifications Works\n\u00b6\n\n\nWorking with Notification Hubs\n\u00b6\n\n\nTesting Push Notifications\n\u00b6\n\n\nPush Notifications for Android\n\u00b6\n\n\nConfiguring the Notification Hub\n\u00b6\n\n\nRegistering for Push Notifications\n\u00b6\n\n\nHandling Push Notifications\n\u00b6\n\n\nPush Notifications for iOS\n\u00b6\n\n\nConfiguring the Notification Hub\n\u00b6\n\n\nRegistering for Push Notifications\n\u00b6\n\n\nHandling Push Notifications\n\u00b6\n\n\nPush Notifications for Universal Windows\n\u00b6\n\n\nConfiguring the Notification Hub\n\u00b6\n\n\nRegistering for Push Notifications\n\u00b6\n\n\nHandling Push Notifications\n\u00b6\n\n\nPush Notification Recipes\n\u00b6\n\n\nCross-Platform Templates\n\u00b6\n\n\nPushing to Tags\n\u00b6",
            "title": "Push Notifications"
        },
        {
            "location": "/push/#push-notifications",
            "text": "",
            "title": "Push Notifications"
        },
        {
            "location": "/push/#push-notification-concepts",
            "text": "",
            "title": "Push Notification Concepts"
        },
        {
            "location": "/push/#how-push-notifications-works",
            "text": "",
            "title": "How Push Notifications Works"
        },
        {
            "location": "/push/#working-with-notification-hubs",
            "text": "",
            "title": "Working with Notification Hubs"
        },
        {
            "location": "/push/#testing-push-notifications",
            "text": "",
            "title": "Testing Push Notifications"
        },
        {
            "location": "/push/#push-notifications-for-android",
            "text": "",
            "title": "Push Notifications for Android"
        },
        {
            "location": "/push/#configuring-the-notification-hub",
            "text": "",
            "title": "Configuring the Notification Hub"
        },
        {
            "location": "/push/#registering-for-push-notifications",
            "text": "",
            "title": "Registering for Push Notifications"
        },
        {
            "location": "/push/#handling-push-notifications",
            "text": "",
            "title": "Handling Push Notifications"
        },
        {
            "location": "/push/#push-notifications-for-ios",
            "text": "",
            "title": "Push Notifications for iOS"
        },
        {
            "location": "/push/#configuring-the-notification-hub_1",
            "text": "",
            "title": "Configuring the Notification Hub"
        },
        {
            "location": "/push/#registering-for-push-notifications_1",
            "text": "",
            "title": "Registering for Push Notifications"
        },
        {
            "location": "/push/#handling-push-notifications_1",
            "text": "",
            "title": "Handling Push Notifications"
        },
        {
            "location": "/push/#push-notifications-for-universal-windows",
            "text": "",
            "title": "Push Notifications for Universal Windows"
        },
        {
            "location": "/push/#configuring-the-notification-hub_2",
            "text": "",
            "title": "Configuring the Notification Hub"
        },
        {
            "location": "/push/#registering-for-push-notifications_2",
            "text": "",
            "title": "Registering for Push Notifications"
        },
        {
            "location": "/push/#handling-push-notifications_2",
            "text": "",
            "title": "Handling Push Notifications"
        },
        {
            "location": "/push/#push-notification-recipes",
            "text": "",
            "title": "Push Notification Recipes"
        },
        {
            "location": "/push/#cross-platform-templates",
            "text": "",
            "title": "Cross-Platform Templates"
        },
        {
            "location": "/push/#pushing-to-tags",
            "text": "",
            "title": "Pushing to Tags"
        },
        {
            "location": "/custom/",
            "text": "Server Side\n\u00b6\n\n\nWorking with Server Side\n\u00b6\n\n\nCustom APIs\n\u00b6\n\n\nFunctions\n\u00b6\n\n\nServer Side Recipes\n\u00b6",
            "title": "Server Side Code"
        },
        {
            "location": "/custom/#server-side",
            "text": "",
            "title": "Server Side"
        },
        {
            "location": "/custom/#working-with-server-side",
            "text": "",
            "title": "Working with Server Side"
        },
        {
            "location": "/custom/#custom-apis",
            "text": "",
            "title": "Custom APIs"
        },
        {
            "location": "/custom/#functions",
            "text": "",
            "title": "Functions"
        },
        {
            "location": "/custom/#server-side-recipes",
            "text": "",
            "title": "Server Side Recipes"
        },
        {
            "location": "/media/",
            "text": "Using Media Services\n\u00b6\n\n\nWhat can Media Services do?\n\u00b6\n\n\nUploading Videos from Mobile\n\u00b6\n\n\nAutomatically Processing Videos\n\u00b6\n\n\nStreaming Videos to Mobile\n\u00b6\n\n\nCase Study: Video Learning App\n\u00b6",
            "title": "Media Services"
        },
        {
            "location": "/media/#using-media-services",
            "text": "",
            "title": "Using Media Services"
        },
        {
            "location": "/media/#what-can-media-services-do",
            "text": "",
            "title": "What can Media Services do?"
        },
        {
            "location": "/media/#uploading-videos-from-mobile",
            "text": "",
            "title": "Uploading Videos from Mobile"
        },
        {
            "location": "/media/#automatically-processing-videos",
            "text": "",
            "title": "Automatically Processing Videos"
        },
        {
            "location": "/media/#streaming-videos-to-mobile",
            "text": "",
            "title": "Streaming Videos to Mobile"
        },
        {
            "location": "/media/#case-study-video-learning-app",
            "text": "",
            "title": "Case Study: Video Learning App"
        },
        {
            "location": "/search/",
            "text": "Integrating Mobile Search\n\u00b6\n\n\nDiscovering Search capabilities\n\u00b6\n\n\nConfiguring Azure Search\n\u00b6\n\n\nUsing Azure Search\n\u00b6",
            "title": "Leveraging Search"
        },
        {
            "location": "/search/#integrating-mobile-search",
            "text": "",
            "title": "Integrating Mobile Search"
        },
        {
            "location": "/search/#discovering-search-capabilities",
            "text": "",
            "title": "Discovering Search capabilities"
        },
        {
            "location": "/search/#configuring-azure-search",
            "text": "",
            "title": "Configuring Azure Search"
        },
        {
            "location": "/search/#using-azure-search",
            "text": "",
            "title": "Using Azure Search"
        },
        {
            "location": "/combined/",
            "text": "Web and Mobile Apps\n\u00b6\n\n\nServer Side Development\n\u00b6\n\n\nSharing the Database Between Web and Mobile Apps\n\u00b6\n\n\nAuthentication for Web and Mobile Apps\n\u00b6\n\n\nClient Side Development\n\u00b6\n\n\nAccessing Mobile Data from a Single Page Application\n\u00b6\n\n\nAuthentication for Single Page Applications\n\u00b6\n\n\nRecipes for Single Page Applications\n\u00b6\n\n\nAngular 1.x\n\u00b6\n\n\nAngular 2.x\n\u00b6\n\n\nEmber 1.x\n\u00b6\n\n\nReact\n\u00b6",
            "title": "Web and Mobile Apps"
        },
        {
            "location": "/combined/#web-and-mobile-apps",
            "text": "",
            "title": "Web and Mobile Apps"
        },
        {
            "location": "/combined/#server-side-development",
            "text": "",
            "title": "Server Side Development"
        },
        {
            "location": "/combined/#sharing-the-database-between-web-and-mobile-apps",
            "text": "",
            "title": "Sharing the Database Between Web and Mobile Apps"
        },
        {
            "location": "/combined/#authentication-for-web-and-mobile-apps",
            "text": "",
            "title": "Authentication for Web and Mobile Apps"
        },
        {
            "location": "/combined/#client-side-development",
            "text": "",
            "title": "Client Side Development"
        },
        {
            "location": "/combined/#accessing-mobile-data-from-a-single-page-application",
            "text": "",
            "title": "Accessing Mobile Data from a Single Page Application"
        },
        {
            "location": "/combined/#authentication-for-single-page-applications",
            "text": "",
            "title": "Authentication for Single Page Applications"
        },
        {
            "location": "/combined/#recipes-for-single-page-applications",
            "text": "",
            "title": "Recipes for Single Page Applications"
        },
        {
            "location": "/combined/#angular-1x",
            "text": "",
            "title": "Angular 1.x"
        },
        {
            "location": "/combined/#angular-2x",
            "text": "",
            "title": "Angular 2.x"
        },
        {
            "location": "/combined/#ember-1x",
            "text": "",
            "title": "Ember 1.x"
        },
        {
            "location": "/combined/#react",
            "text": "",
            "title": "React"
        },
        {
            "location": "/developing/",
            "text": "The Development Environment\n\u00b6\n\n\nWorking with Azure mobile Apps Locally\n\u00b6\n\n\nHandling Authentication\n\u00b6\n\n\nHandling Push Notifications\n\u00b6\n\n\nDebugging your Cloud Mobile Backend\n\u00b6\n\n\nDiagnostic Logging\n\u00b6\n\n\nUsing the Visual Studio Debugger\n\u00b6",
            "title": "The Development Environment"
        },
        {
            "location": "/developing/#the-development-environment",
            "text": "",
            "title": "The Development Environment"
        },
        {
            "location": "/developing/#working-with-azure-mobile-apps-locally",
            "text": "",
            "title": "Working with Azure mobile Apps Locally"
        },
        {
            "location": "/developing/#handling-authentication",
            "text": "",
            "title": "Handling Authentication"
        },
        {
            "location": "/developing/#handling-push-notifications",
            "text": "",
            "title": "Handling Push Notifications"
        },
        {
            "location": "/developing/#debugging-your-cloud-mobile-backend",
            "text": "",
            "title": "Debugging your Cloud Mobile Backend"
        },
        {
            "location": "/developing/#diagnostic-logging",
            "text": "",
            "title": "Diagnostic Logging"
        },
        {
            "location": "/developing/#using-the-visual-studio-debugger",
            "text": "",
            "title": "Using the Visual Studio Debugger"
        },
        {
            "location": "/testing/",
            "text": "Testing your Mobile Application\n\u00b6\n\n\nTesting your Mobile Client\n\u00b6\n\n\nIntroduction to Mobile Client Testing\n\u00b6\n\n\nIntroduction to Xamarin Test Cloud\n\u00b6\n\n\nUsing Mock Data Services\n\u00b6\n\n\nUnit Testing\n\u00b6\n\n\nTesting your Mobile Backend\n\u00b6\n\n\nIntroduction to Mobile Backend Testing\n\u00b6\n\n\nUnit Testing\n\u00b6\n\n\nLoad Testing\n\u00b6\n\n\nEnd to End Testing\n\u00b6",
            "title": "Testing your Application"
        },
        {
            "location": "/testing/#testing-your-mobile-application",
            "text": "",
            "title": "Testing your Mobile Application"
        },
        {
            "location": "/testing/#testing-your-mobile-client",
            "text": "",
            "title": "Testing your Mobile Client"
        },
        {
            "location": "/testing/#introduction-to-mobile-client-testing",
            "text": "",
            "title": "Introduction to Mobile Client Testing"
        },
        {
            "location": "/testing/#introduction-to-xamarin-test-cloud",
            "text": "",
            "title": "Introduction to Xamarin Test Cloud"
        },
        {
            "location": "/testing/#using-mock-data-services",
            "text": "",
            "title": "Using Mock Data Services"
        },
        {
            "location": "/testing/#unit-testing",
            "text": "",
            "title": "Unit Testing"
        },
        {
            "location": "/testing/#testing-your-mobile-backend",
            "text": "",
            "title": "Testing your Mobile Backend"
        },
        {
            "location": "/testing/#introduction-to-mobile-backend-testing",
            "text": "",
            "title": "Introduction to Mobile Backend Testing"
        },
        {
            "location": "/testing/#unit-testing_1",
            "text": "",
            "title": "Unit Testing"
        },
        {
            "location": "/testing/#load-testing",
            "text": "",
            "title": "Load Testing"
        },
        {
            "location": "/testing/#end-to-end-testing",
            "text": "",
            "title": "End to End Testing"
        },
        {
            "location": "/troubleshooting/",
            "text": "Troubleshooting\n\u00b6\n\n\nTroubleshooting the Mobile Backend\n\u00b6\n\n\nIntroduction to Azure Application Insights\n\u00b6\n\n\nTroubleshooting the Mobile Client\n\u00b6\n\n\nIntroduction to HockeyApp\n\u00b6\n\n\nIntroduction to Xamarin Insights\n\u00b6",
            "title": "Troubleshooting"
        },
        {
            "location": "/troubleshooting/#troubleshooting",
            "text": "",
            "title": "Troubleshooting"
        },
        {
            "location": "/troubleshooting/#troubleshooting-the-mobile-backend",
            "text": "",
            "title": "Troubleshooting the Mobile Backend"
        },
        {
            "location": "/troubleshooting/#introduction-to-azure-application-insights",
            "text": "",
            "title": "Introduction to Azure Application Insights"
        },
        {
            "location": "/troubleshooting/#troubleshooting-the-mobile-client",
            "text": "",
            "title": "Troubleshooting the Mobile Client"
        },
        {
            "location": "/troubleshooting/#introduction-to-hockeyapp",
            "text": "",
            "title": "Introduction to HockeyApp"
        },
        {
            "location": "/troubleshooting/#introduction-to-xamarin-insights",
            "text": "",
            "title": "Introduction to Xamarin Insights"
        },
        {
            "location": "/production/",
            "text": "Going to Production\n\u00b6\n\n\nDeploying Beta Editions of your Application\n\u00b6\n\n\nUsing Slots for the Mobile Backend\n\u00b6\n\n\nUsing HockeyApp for the Mobile Client\n\u00b6\n\n\nScaling your Backend\n\u00b6\n\n\nMonitoring your Production Application\n\u00b6\n\n\nApplication Insights vs. Xamarin Insights\n\u00b6\n\n\nConfiguration as Code (DevOps)\n\u00b6\n\n\nIntroduction to Azure Resource Manager\n\u00b6\n\n\nDeploying your site with Azure Resource Manager\n\u00b6",
            "title": "Going to Production"
        },
        {
            "location": "/production/#going-to-production",
            "text": "",
            "title": "Going to Production"
        },
        {
            "location": "/production/#deploying-beta-editions-of-your-application",
            "text": "",
            "title": "Deploying Beta Editions of your Application"
        },
        {
            "location": "/production/#using-slots-for-the-mobile-backend",
            "text": "",
            "title": "Using Slots for the Mobile Backend"
        },
        {
            "location": "/production/#using-hockeyapp-for-the-mobile-client",
            "text": "",
            "title": "Using HockeyApp for the Mobile Client"
        },
        {
            "location": "/production/#scaling-your-backend",
            "text": "",
            "title": "Scaling your Backend"
        },
        {
            "location": "/production/#monitoring-your-production-application",
            "text": "",
            "title": "Monitoring your Production Application"
        },
        {
            "location": "/production/#application-insights-vs-xamarin-insights",
            "text": "",
            "title": "Application Insights vs. Xamarin Insights"
        },
        {
            "location": "/production/#configuration-as-code-devops",
            "text": "",
            "title": "Configuration as Code (DevOps)"
        },
        {
            "location": "/production/#introduction-to-azure-resource-manager",
            "text": "",
            "title": "Introduction to Azure Resource Manager"
        },
        {
            "location": "/production/#deploying-your-site-with-azure-resource-manager",
            "text": "",
            "title": "Deploying your site with Azure Resource Manager"
        },
        {
            "location": "/xamarin_tips/",
            "text": "Xamarin Forms Tips\n\u00b6\n\n\nOver the many months I have spent coding Xamarin Forms, a number of people\nfrom the community and the Xamarin team have given me little tips to improve\nmy Xamarin Forms code.  I hope you find them as useful as I did.\n\n\nImprove your ListView performance\n\u00b6\n\n\nIt should be no surprise that performance matters.  Little things like smooth\nscrolling and fast load times are a must.  A lot of improvement can be gained\nby the techniques we have shown in this book since most of the perceived delays\nare caused by the back end loading times.\n\n\nEventually, a lot of apps generate a list.  The normal way for implementing\nthis is with a \nListView\n that has an \nObservableCollection\n  You load your\ndata into the ObservableCollection and then update that whenever the data\nchanges.  That, in turn, updates the ListView.\n\n\nThere are two problems that are inherent here.  The first is in the ObservableCollection\nand the second is in the ListView.  Let's tackle the ObservableCollection first.\n\n\nThe problem with the ObservableCollection is that it's very hard to update.\nWhat normally ends up happening is code like this:\n\n\n// Earlier in the code\nvar listContents = new ObservableCollection<Model>();\n\n// When updating the code\nvar items = await table.ReadAllItemsAsync();\nlistContents.Clear();\nfor (var item in items) {\n    listContents.Add(item);\n}\n\n\n\n\nThe point of the ObservableCollection is that it emits an event whenever the\nlist changes.  In the case where the table has thousands of entries, thousands\nof events will cause thousands of redraws, causing a major slow down in your\ncode that you probably won't know until you have a large enough data set to\nnote the problem.\n\n\nFortunately, one of the top Xamarin Evangelists, \nJames Montemagno\n, has\ncreated a set of helper classes that assist with this sort of problem.  The\nsolution to this problem is to use the \nObservableRangeCollection\n, like\nthis:\n\n\n// Earlier in the code\nvar listContents = new ObservableRangeCollection<Model>();\n\n// When updating the code\nvar items = await table.ReadAllItemsAsync();\nlistContents.ReplaceRange(items);\n\n\n\n\nWith this code, Xamarin Forms gets notified once instead of thousands of times.\nThere are actually several versions of this same behavior in the NuGet repository.\n\n\nAs to the second problem.  A \nListView\n with thousands of items will not be\nshowing all the items at once.  A ListView will update all the items that have\nbeen updated, irrespective of whether they are visible or not.  The answer is\nto use a caching strategy.  There are two potential caching strategies.  with\n\nRetainElement\n, the ListView will generate a cell for each item in the list.\nThis is the default, but it's really only good for certain situations (most\nnotably when the cell has a large number of bindings).  For almost all situations,\nthe \nRecycleElement\n caching strategy should be used.  In this caching strategy,\nthe ListView will minimize the memory foot print and execution speed by only\nupdating cells when they are in the viewable area.  This is good pretty much\nall the time, but explicitly when the cell has a small number of bindings or\nwhen each cell in the list has the same template.  All data about the cell must\ncome from the binding context when using the \nRecycleElement\n caching strategy.\n\n\nYou can set the caching strategy right in the XAML:\n\n\n<ListView CachingStrategy=\"RecycleElement\" ...>\n\n\n\n\nAlternatively, if you are creating a ListView in code, you can specify the\ncaching strategy in the constructor:\n\n\nvar listView = new ListView(ListViewCachingStrategy.RecycleElement);\n\n\n\n\nThere are more techniques for improving ListView performance in the\n\nXamarin documentation\n\n\nBuilding a Floating Action Button\n\u00b6\n\n\nOne of the things that I wanted to do to my apps was to give them a little more in the\nway of normal UI design.  My original design (which I introduced back in [Chapter ][ch1])\nhad teal buttons at the bottom of the page.  These buttons scrolled off the page when\nthere were more items on the page than could reasonably be fit on the page.  To fix this,\nI wanted to create a button that was always relative to the viewport.\n\n\nThere are two steps to this.  Firstly, you need to convert the layout to a \nRelativeLayout\n.\nFor instance, my new \nListView.xaml\n file:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage x:Class=\"TaskList.Pages.TaskList\"\n             xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <RelativeLayout>\n            <StackLayout RelativeLayout.HeightConstraint=\"{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=1}\"\n                         RelativeLayout.WidthConstraint=\"{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=1}\">\n\n\n\n\nThe original \nStackLayout\n layout renderer is placed inside the newly added \nRelativeLayout\n.\nThe height and width constraints tell the StackLayout to consume the whole screen.\n\n\nAt the bottom of the page, I can add my button:\n\n\n            </StackLayout>\n\n            <!--  The Floating Button  -->\n            <Button BackgroundColor=\"Teal\"\n                    Command=\"{Binding AddNewItemCommand}\"\n                    RelativeLayout.XConstraint=\"{ConstraintExpression Type=RelativeToParent,\n                                                                      Property=Width,\n                                                                      Factor=1,\n                                                                      Constant=-60}\"\n                    RelativeLayout.YConstraint=\"{ConstraintExpression Type=RelativeToParent,\n                                                                      Property=Height,\n                                                                      Factor=1,\n                                                                      Constant=-60}\"\n                    Text=\"+\"\n                    TextColor=\"White\" />\n        </RelativeLayout>\n    </ContentPage.Content>\n</ContentPage>\n\n\n\n\nThe \nStackLayout\n is the end of the StackLayout I introduced in the previous listing.  Now\nI can add a button (or any other View type control, including a custom control that I may\nhave downloaded from NuGet or the Xamarin Plugins site) as well.  The button will float\nabove the other content since it is added later.  The constraints in this case provide\nthe location of the button.\n\n\nThere is more work to do.  For instance, you cannot click on the thing behind the button -\nthe button always receives the click, which will (in this case) initiate the addition of\na new item.  A custom control will allow you to provide iconography for the button, handle\nsituations where you want to scroll behind and provide for the circular styling of the button\nwhich seems to be in-vogue right now.\n\n\nIf you want to place commands that are not normally used, you may want to consider the ToolbarItem\narea of the ContentPage.  Here is a snippet:\n\n\n    <ContentPage.ToolbarItems>\n        <ToolbarItem Name=\"Refresh\"\n                     Command=\"{Binding RefreshCommand}\"\n                     Icon=\"refresh.png\"\n                     Order=\"Primary\"\n                     Priority=\"0\" />\n    </ContentPage.ToolbarItems>\n\n\n\n\nOn Universal Windows (where this is actually important due to a lack of \"pull-to-refresh\" logic), you\nwill see the familiar triple-dot on the app bar - clicking on the triple dot gives you access to\nthe refresh command.\n\n\nInstalling NuGet Packages in Multiple Projects\n\u00b6\n\n\nOne of the common requirements we have in Xamarin Forms is to install NuGet packages\nin all the Xamarin Forms projects.  To do this, right-click on the solution and select\n\nManage NuGet Packages for Solution...\n.  When you install a package here, you can\nselect which projects it should be applied to, allowing you to install a package once\nacross all the dependent projects.\n\n\nAuto-Deploy Universal Windows Apps\n\u00b6\n\n\nOne of the more annoying things is that you have to \nDeploy\n the Universal Windows app.\nThis gets in the way of the build process.  I like to build then run.  Having the extra\nDeploy step in there might not seem like much until you find yourself deploying several\ntimes an hour.\n\n\nFortunately, there is a simple fix for this.  Set up the \nConfiguration Manager\n to\nautomatically deploy the right libraries on every successful build.  To do this:\n\n\n\n\nIn Visual Studio, select \nBuild\n -> \nConfiguration Manager...\n\n\nCheck the boxes you can under \nDeploy\n\n\n\n\n\n\n\n\nClick on \nClose\n\n\n\n\nThis setting is saved within the solution, so you only need to do it once per project.",
            "title": "Xamarin Forms Tips"
        },
        {
            "location": "/xamarin_tips/#xamarin-forms-tips",
            "text": "Over the many months I have spent coding Xamarin Forms, a number of people\nfrom the community and the Xamarin team have given me little tips to improve\nmy Xamarin Forms code.  I hope you find them as useful as I did.",
            "title": "Xamarin Forms Tips"
        },
        {
            "location": "/xamarin_tips/#improve-your-listview-performance",
            "text": "It should be no surprise that performance matters.  Little things like smooth\nscrolling and fast load times are a must.  A lot of improvement can be gained\nby the techniques we have shown in this book since most of the perceived delays\nare caused by the back end loading times.  Eventually, a lot of apps generate a list.  The normal way for implementing\nthis is with a  ListView  that has an  ObservableCollection   You load your\ndata into the ObservableCollection and then update that whenever the data\nchanges.  That, in turn, updates the ListView.  There are two problems that are inherent here.  The first is in the ObservableCollection\nand the second is in the ListView.  Let's tackle the ObservableCollection first.  The problem with the ObservableCollection is that it's very hard to update.\nWhat normally ends up happening is code like this:  // Earlier in the code\nvar listContents = new ObservableCollection<Model>();\n\n// When updating the code\nvar items = await table.ReadAllItemsAsync();\nlistContents.Clear();\nfor (var item in items) {\n    listContents.Add(item);\n}  The point of the ObservableCollection is that it emits an event whenever the\nlist changes.  In the case where the table has thousands of entries, thousands\nof events will cause thousands of redraws, causing a major slow down in your\ncode that you probably won't know until you have a large enough data set to\nnote the problem.  Fortunately, one of the top Xamarin Evangelists,  James Montemagno , has\ncreated a set of helper classes that assist with this sort of problem.  The\nsolution to this problem is to use the  ObservableRangeCollection , like\nthis:  // Earlier in the code\nvar listContents = new ObservableRangeCollection<Model>();\n\n// When updating the code\nvar items = await table.ReadAllItemsAsync();\nlistContents.ReplaceRange(items);  With this code, Xamarin Forms gets notified once instead of thousands of times.\nThere are actually several versions of this same behavior in the NuGet repository.  As to the second problem.  A  ListView  with thousands of items will not be\nshowing all the items at once.  A ListView will update all the items that have\nbeen updated, irrespective of whether they are visible or not.  The answer is\nto use a caching strategy.  There are two potential caching strategies.  with RetainElement , the ListView will generate a cell for each item in the list.\nThis is the default, but it's really only good for certain situations (most\nnotably when the cell has a large number of bindings).  For almost all situations,\nthe  RecycleElement  caching strategy should be used.  In this caching strategy,\nthe ListView will minimize the memory foot print and execution speed by only\nupdating cells when they are in the viewable area.  This is good pretty much\nall the time, but explicitly when the cell has a small number of bindings or\nwhen each cell in the list has the same template.  All data about the cell must\ncome from the binding context when using the  RecycleElement  caching strategy.  You can set the caching strategy right in the XAML:  <ListView CachingStrategy=\"RecycleElement\" ...>  Alternatively, if you are creating a ListView in code, you can specify the\ncaching strategy in the constructor:  var listView = new ListView(ListViewCachingStrategy.RecycleElement);  There are more techniques for improving ListView performance in the Xamarin documentation",
            "title": "Improve your ListView performance"
        },
        {
            "location": "/xamarin_tips/#building-a-floating-action-button",
            "text": "One of the things that I wanted to do to my apps was to give them a little more in the\nway of normal UI design.  My original design (which I introduced back in [Chapter ][ch1])\nhad teal buttons at the bottom of the page.  These buttons scrolled off the page when\nthere were more items on the page than could reasonably be fit on the page.  To fix this,\nI wanted to create a button that was always relative to the viewport.  There are two steps to this.  Firstly, you need to convert the layout to a  RelativeLayout .\nFor instance, my new  ListView.xaml  file:  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ContentPage x:Class=\"TaskList.Pages.TaskList\"\n             xmlns=\"http://xamarin.com/schemas/2014/forms\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n             Title=\"{Binding Title}\">\n    <ContentPage.Content>\n        <RelativeLayout>\n            <StackLayout RelativeLayout.HeightConstraint=\"{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=1}\"\n                         RelativeLayout.WidthConstraint=\"{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=1}\">  The original  StackLayout  layout renderer is placed inside the newly added  RelativeLayout .\nThe height and width constraints tell the StackLayout to consume the whole screen.  At the bottom of the page, I can add my button:              </StackLayout>\n\n            <!--  The Floating Button  -->\n            <Button BackgroundColor=\"Teal\"\n                    Command=\"{Binding AddNewItemCommand}\"\n                    RelativeLayout.XConstraint=\"{ConstraintExpression Type=RelativeToParent,\n                                                                      Property=Width,\n                                                                      Factor=1,\n                                                                      Constant=-60}\"\n                    RelativeLayout.YConstraint=\"{ConstraintExpression Type=RelativeToParent,\n                                                                      Property=Height,\n                                                                      Factor=1,\n                                                                      Constant=-60}\"\n                    Text=\"+\"\n                    TextColor=\"White\" />\n        </RelativeLayout>\n    </ContentPage.Content>\n</ContentPage>  The  StackLayout  is the end of the StackLayout I introduced in the previous listing.  Now\nI can add a button (or any other View type control, including a custom control that I may\nhave downloaded from NuGet or the Xamarin Plugins site) as well.  The button will float\nabove the other content since it is added later.  The constraints in this case provide\nthe location of the button.  There is more work to do.  For instance, you cannot click on the thing behind the button -\nthe button always receives the click, which will (in this case) initiate the addition of\na new item.  A custom control will allow you to provide iconography for the button, handle\nsituations where you want to scroll behind and provide for the circular styling of the button\nwhich seems to be in-vogue right now.  If you want to place commands that are not normally used, you may want to consider the ToolbarItem\narea of the ContentPage.  Here is a snippet:      <ContentPage.ToolbarItems>\n        <ToolbarItem Name=\"Refresh\"\n                     Command=\"{Binding RefreshCommand}\"\n                     Icon=\"refresh.png\"\n                     Order=\"Primary\"\n                     Priority=\"0\" />\n    </ContentPage.ToolbarItems>  On Universal Windows (where this is actually important due to a lack of \"pull-to-refresh\" logic), you\nwill see the familiar triple-dot on the app bar - clicking on the triple dot gives you access to\nthe refresh command.",
            "title": "Building a Floating Action Button"
        },
        {
            "location": "/xamarin_tips/#installing-nuget-packages-in-multiple-projects",
            "text": "One of the common requirements we have in Xamarin Forms is to install NuGet packages\nin all the Xamarin Forms projects.  To do this, right-click on the solution and select Manage NuGet Packages for Solution... .  When you install a package here, you can\nselect which projects it should be applied to, allowing you to install a package once\nacross all the dependent projects.",
            "title": "Installing NuGet Packages in Multiple Projects"
        },
        {
            "location": "/xamarin_tips/#auto-deploy-universal-windows-apps",
            "text": "One of the more annoying things is that you have to  Deploy  the Universal Windows app.\nThis gets in the way of the build process.  I like to build then run.  Having the extra\nDeploy step in there might not seem like much until you find yourself deploying several\ntimes an hour.  Fortunately, there is a simple fix for this.  Set up the  Configuration Manager  to\nautomatically deploy the right libraries on every successful build.  To do this:   In Visual Studio, select  Build  ->  Configuration Manager...  Check the boxes you can under  Deploy     Click on  Close   This setting is saved within the solution, so you only need to do it once per project.",
            "title": "Auto-Deploy Universal Windows Apps"
        },
        {
            "location": "/android_appendix/",
            "text": "Android Developer Notes\n\u00b6\n\n\nThis chapter contains random notes that I discovered while developing mobile apps\nwith Xamarin Forms on the Android platform.  I hope they are useful to you.\n\n\nHandling Callbacks with an Android SDK\n\u00b6\n\n\nDissecting the Google Plus Login Process\n\u00b6",
            "title": "Android Developer Notes"
        },
        {
            "location": "/android_appendix/#android-developer-notes",
            "text": "This chapter contains random notes that I discovered while developing mobile apps\nwith Xamarin Forms on the Android platform.  I hope they are useful to you.",
            "title": "Android Developer Notes"
        },
        {
            "location": "/android_appendix/#handling-callbacks-with-an-android-sdk",
            "text": "",
            "title": "Handling Callbacks with an Android SDK"
        },
        {
            "location": "/android_appendix/#dissecting-the-google-plus-login-process",
            "text": "",
            "title": "Dissecting the Google Plus Login Process"
        },
        {
            "location": "/references/",
            "text": "References\n\u00b6\n\n\nFurther Reading\n\u00b6\n\n\nAPI References\n\u00b6\n\n\nSamples\n\u00b6\n\n\nHow to get Help\n\u00b6",
            "title": "References"
        },
        {
            "location": "/references/#references",
            "text": "",
            "title": "References"
        },
        {
            "location": "/references/#further-reading",
            "text": "",
            "title": "Further Reading"
        },
        {
            "location": "/references/#api-references",
            "text": "",
            "title": "API References"
        },
        {
            "location": "/references/#samples",
            "text": "",
            "title": "Samples"
        },
        {
            "location": "/references/#how-to-get-help",
            "text": "",
            "title": "How to get Help"
        },
        {
            "location": "/credits/",
            "text": "Credits\n\u00b6\n\n\nI got a lot of assistance during the writing of this book.  The following people assisted (in no\nparticular order):\n\n\n\n\nChris Gillum\n\n\nChris Risner\n\n\nJames Montemagno\n\n\nMike James\n\n\nPierce Boggan\n\n\nSteve Lee",
            "title": "Credits"
        },
        {
            "location": "/credits/#credits",
            "text": "I got a lot of assistance during the writing of this book.  The following people assisted (in no\nparticular order):   Chris Gillum  Chris Risner  James Montemagno  Mike James  Pierce Boggan  Steve Lee",
            "title": "Credits"
        }
    ]
}