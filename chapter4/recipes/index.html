<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="no-js ie6"><![endif]-->
<!--[if IE 7 ]><html class="no-js ie7"><![endif]-->
<!--[if IE 8 ]><html class="no-js ie8"><![endif]-->
<!--[if IE 9 ]><html class="no-js ie9"><![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html class="no-js"> <!--<![endif]-->
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    
      
        <title>Recipes - Develop Cloud Connected Mobile Apps with Xamarin and Microsoft Azure</title>
      
      
      
        <link rel="canonical" href="https://adrianhall.github.io/develop-mobile-apps-with-csharp-and-azure/chapter4/recipes/">
      
      
        <meta name="author" content="Adrian Hall">
      
    
    <meta property="og:url" content="https://adrianhall.github.io/develop-mobile-apps-with-csharp-and-azure/chapter4/recipes/">
    <meta property="og:title" content="Develop Cloud Connected Mobile Apps with Xamarin and Microsoft Azure">
    <meta property="og:image" content="https://adrianhall.github.io/develop-mobile-apps-with-csharp-and-azure/chapter4/recipes//../../">
    <meta name="apple-mobile-web-app-title" content="Develop Cloud Connected Mobile Apps with Xamarin and Microsoft Azure">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    
    <link rel="shortcut icon" type="image/x-icon" href="../../assets/images/favicon-e565ddfa3b.ico">
    <link rel="icon" type="image/x-icon" href="../../assets/images/favicon-e565ddfa3b.ico">
    <style>
      @font-face {
      	font-family: 'Icon';
      	src: url('../../assets/fonts/icon.eot?52m981');
      	src: url('../../assets/fonts/icon.eot?#iefix52m981')
               format('embedded-opentype'),
      		   url('../../assets/fonts/icon.woff?52m981')
               format('woff'),
      		   url('../../assets/fonts/icon.ttf?52m981')
               format('truetype'),
      		   url('../../assets/fonts/icon.svg?52m981#icon')
               format('svg');
      	font-weight: normal;
      	font-style: normal;
      }
    </style>
    <link rel="stylesheet" href="../../assets/stylesheets/application-a422ff04cc.css">
    
    
      
      
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,700|Ubuntu+Mono">
      <style>
        body, input {
          font-family: 'Ubuntu', Helvetica, Arial, sans-serif;
        }
        pre, code {
          font-family: 'Ubuntu Mono', 'Courier New', 'Courier', monospace;
        }
      </style>
    
    
      <link rel="stylesheet" href="../../css/extra.css">
    
      <link rel="stylesheet" href="../../css/vs.css">
    
    <script src="../../assets/javascripts/modernizr-4ab42b99fd.js"></script>
    
  </head>
  
  
  
  <body class=" ">
    
      
      
    
    <div class="backdrop">
      <div class="backdrop-paper"></div>
    </div>
    <input class="toggle" type="checkbox" id="toggle-drawer">
    <input class="toggle" type="checkbox" id="toggle-search">
    <label class="toggle-button overlay" for="toggle-drawer"></label>
    <header class="header">
      <nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        
          <span class="path">
            
              
                Chapter 4 - Server Side Code <i class="icon icon-link"></i>
              
            
          </span>
        
        Recipes
      </div>
    </div>
    
      
      <div class="button button-twitter" role="button" aria-label="Twitter">
        <a href="https://twitter.com/FizzyInTheHall" title="@FizzyInTheHall on Twitter" target="_blank" class="toggle-button icon icon-twitter"></a>
      </div>
    
    
      
      <div class="button button-github" role="button" aria-label="GitHub">
        <a href="https://github.com/adrianhall" title="@adrianhall on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
      </div>
    
    <div class="button button-search" role="button" aria-label="Search">
      <label class="toggle-button icon icon-search" title="Search" for="toggle-search"></label>
    </div>
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
    </header>
    <main class="main">
      
      <div class="drawer">
        <nav aria-label="Navigation">
  
  <a href="https://github.com/adrianhall/develop-mobile-apps-with-csharp-and-azure" class="project">
    <div class="banner">
      
      <div class="name">
        <strong>
          Develop Cloud Connected Mobile Apps with Xamarin and Microsoft Azure
          <span class="version">
            
          </span>
        </strong>
        
          <br>
          adrianhall/develop-mobile-apps-with-csharp-and-azure
        
      </div>
    </div>
  </a>
  <div class="scrollable">
    <div class="wrapper">
      
        <ul class="repo">
          <li class="repo-download">
            
            <a href="https://github.com/adrianhall/develop-mobile-apps-with-csharp-and-azure/archive/master.zip" target="_blank" title="Download" data-action="download">
              <i class="icon icon-download"></i> Download
            </a>
          </li>
          <li class="repo-stars">
            <a href="https://github.com/adrianhall/develop-mobile-apps-with-csharp-and-azure/stargazers" target="_blank" title="Stargazers" data-action="star">
              <i class="icon icon-star"></i> Stars
              <span class="count">&ndash;</span>
            </a>
          </li>
        </ul>
        <hr>
      
      <div class="toc">
        <ul>
          
            
  <li>
    <a class="" title="Getting Started" href="../..">
      Getting Started
    </a>
    
  </li>

          
            
  <li>
    <span class="section">Chapter 1 - Introduction</span>
    <ul>
      
        
  <li>
    <a class="" title="Your First App - PC Edition" href="../../chapter1/firstapp_pc/">
      Your First App - PC Edition
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Your First App - Mac Edition" href="../../chapter1/firstapp_mac/">
      Your First App - Mac Edition
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">Chapter 2 - Authentication</span>
    <ul>
      
        
  <li>
    <a class="" title="Concepts" href="../../chapter2/authconcepts/">
      Concepts
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Authentication in the Backend" href="../../chapter2/backend/">
      Authentication in the Backend
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Enterprise Authentication" href="../../chapter2/enterprise/">
      Enterprise Authentication
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Social Authentication" href="../../chapter2/social/">
      Social Authentication
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Debugging Authentication" href="../../chapter2/debugging/">
      Debugging Authentication
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Custom Authentication" href="../../chapter2/custom/">
      Custom Authentication
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Claims and Authorization" href="../../chapter2/authorization/">
      Claims and Authorization
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Tokens in Real Apps" href="../../chapter2/realworld/">
      Tokens in Real Apps
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Best Practices" href="../../chapter2/bestpractices/">
      Best Practices
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">Chapter 3 - Data Access and Offline Sync</span>
    <ul>
      
        
  <li>
    <a class="" title="Concepts" href="../../chapter3/dataconcepts/">
      Concepts
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Implementing Table Controllers" href="../../chapter3/server/">
      Implementing Table Controllers
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Data Projection and Queries" href="../../chapter3/projection/">
      Data Projection and Queries
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="The Mobile Client" href="../../chapter3/client/">
      The Mobile Client
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Relationships" href="../../chapter3/relationships/">
      Relationships
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="The Domain Manager" href="../../chapter3/domainmgr/">
      The Domain Manager
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">Chapter 4 - Server Side Code</span>
    <ul>
      
        
  <li>
    <a class="" title="Options for Server Code" href="../options/">
      Options for Server Code
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Custom HTTP Endpoints" href="../custom/">
      Custom HTTP Endpoints
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="WebJobs" href="../webjobs/">
      WebJobs
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Functions" href="../functions/">
      Functions
    </a>
    
  </li>

      
        
  <li>
    <a class="current" title="Recipes" href="./">
      Recipes
    </a>
    
      
      
        <ul>
          
            <li class="anchor">
              <a title="Storage Related Operations" href="#storage-related-operations">
                Storage Related Operations
              </a>
            </li>
          
            <li class="anchor">
              <a title="Uploading a File" href="#uploading-a-file">
                Uploading a File
              </a>
            </li>
          
            <li class="anchor">
              <a title="Downloading a File" href="#downloading-a-file">
                Downloading a File
              </a>
            </li>
          
            <li class="anchor">
              <a title="Table Controllers and Webhooks" href="#table-controllers-and-webhooks">
                Table Controllers and Webhooks
              </a>
            </li>
          
        </ul>
      
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">Chapter 5 - Push Notifications</span>
    <ul>
      
        
  <li>
    <a class="" title="Concepts" href="../../chapter5/concepts/">
      Concepts
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Android Push" href="../../chapter5/android/">
      Android Push
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="iOS Push" href="../../chapter5/ios/">
      iOS Push
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Windows Push" href="../../chapter5/windows/">
      Windows Push
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Push Recipes" href="../../chapter5/recipes/">
      Push Recipes
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">Chapter 6 - Combining Web and Mobile Apps</span>
    <ul>
      
        
  <li>
    <a class="" title="MVC Applications" href="../../chapter6/mvc/">
      MVC Applications
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="SPA Applications" href="../../chapter6/spa/">
      SPA Applications
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">Chapter 7 - Other Useful Services</span>
    <ul>
      
        
  <li>
    <a class="" title="Azure Search" href="../../chapter7/search/">
      Azure Search
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Media Services" href="../../chapter7/media/">
      Media Services
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Real-time Notifications" href="../../chapter7/realtime/">
      Real-time Notifications
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">Chapter 8 - Developing An App</span>
    <ul>
      
        
  <li>
    <a class="" title="The Development Environment" href="../../chapter8/developing/">
      The Development Environment
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Testing your Application" href="../../chapter8/testing/">
      Testing your Application
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">Chapter 9 - Going to Production</span>
    <ul>
      
        
  <li>
    <a class="" title="Repeatable Deployments" href="../../chapter9/arm/">
      Repeatable Deployments
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Safe Deployments" href="../../chapter9/appsvc/">
      Safe Deployments
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Monitoring" href="../../chapter9/monitoring/">
      Monitoring
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Troubleshooting" href="../../chapter9/troubleshooting/">
      Troubleshooting
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <a class="" title="Xamarin Forms Tips" href="../../xamarin_tips/">
      Xamarin Forms Tips
    </a>
    
  </li>

          
            
  <li>
    <a class="" title="Android Developer Notes" href="../../android_appendix/">
      Android Developer Notes
    </a>
    
  </li>

          
            
  <li>
    <a class="" title="References" href="../../references/">
      References
    </a>
    
  </li>

          
            
  <li>
    <a class="" title="Credits" href="../../credits/">
      Credits
    </a>
    
  </li>

          
        </ul>
        
          <hr>
          <span class="section">The author</span>
          <ul>
            
              
              <li>
                <a href="https://twitter.com/FizzyInTheHall" target="_blank" title="@FizzyInTheHall on Twitter">
                  @FizzyInTheHall on Twitter
                </a>
              </li>
            
            
              
              <li>
                <a href="https://github.com/adrianhall" target="_blank" title="@adrianhall on GitHub">
                  @adrianhall on GitHub
                </a>
              </li>
            
          </ul>
        
      </div>
    </div>
  </div>
</nav>
      </div>
      <article class="article">
        <div class="wrapper">
          
            <h1>Recipes</h1>
          
          <p>Now that we have explored the syntax and methodologies of invoking server-side code, we can look at some very common
use cases for custom code.</p>
<h2 id="storage-related-operations">Storage Related Operations<a class="headerlink" href="#storage-related-operations" title="Permanent link">&para;</a></h2>
<p>When dealing with cloud concepts, there are multiple operating levels one can think about.  At the bottom layer
is <em>Infrastructure as a Service</em>.  Most people think of this as the Virtual Machine layer, but it also incorporates
basic networking and storage concepts.  As you move to higher level services, you gain a lot of efficiencies by
adding software components, you lose a lot of the potential management headaches, but you also lose flexibility
in what you can do to the platform.  At the top of the stack is <em>Software as a Service</em>.  You may be running
a helpdesk, for example, but you are completely isolated from what operating system is being run, what web services
are being run, APIs that can be accessed and language that is used.</p>
<p>Azure Mobile Apps is an opinionated combination of a client and server SDK running on top of a standard ASP.NET
based web service and is normally thought of as being a <em>Platform as a Service</em>.  You get to choose what database
to use, what tables to expose, and what programming language to use.  You don't get to determine when the operating
system is patched or what patches are applied.  It's a middle of the road between SaaS and IaaS.</p>
<p>That isn't to say we can't dip down sometimes to deal with lower level cloud services, nor to access higher level
SaaS APIs.  One of those times is when dealing with files.  Storage is conceptually easy - you have an amount of
disk and you can store files on it.  However, the management of that storage is complicated.  Placing that storage
at the service of a scalable web application is similarly complicated.  What we intend to do is develop a set of
skills that make developing storage based mobile applications easy.</p>
<h3 id="blobs-table-queues-and-files">Blobs, Table, Queues and files<a class="headerlink" href="#blobs-table-queues-and-files" title="Permanent link">&para;</a></h3>
<p>At the top of my list of "storage made complicated" is the cloud storage concepts.  In the old days, we stored files
on a file system and we didn't really have to worry about differing types of storage, redundancy and capabilities.
Cloud storage tends to come in multiple flavors:</p>
<ul>
<li>
<p>The base storage type is <strong>Blob Storage</strong>.  Put simply, you have containers (roughly analogous to directories) and
blobs (roughly analogous to files).  It's the cheapest form of storage and is used for many things, including the underlying
storage for virtual machine disks.  Blob storage has many advantages.  From a mobile perspective, developers will
appreciate the upload/download restart capabilities within the SDK.</p>
</li>
<li>
<p>We've already introduced <strong>Table Storage</strong> in <a href="../../chapter3/domainmgr/">the last chapter</a>.  It is more analogous to a NoSQL store for storing
key / attribute values.  It has a schemaless design, so you can store basic JSON objects.  However, it has limited
query capabilities, as we discussed in the last chapter.  That makes it unsuited to large scale query-driven applications.</p>
</li>
<li>
<p>You may think you want <strong>Files Storage</strong>.  This provides an SMB interface to the storage layer.  You would use Files
Storage if you want to browse files from your PC or Mac as you can mount the file system directly from Azure Storage.</p>
</li>
<li>
<p>Finally, <strong>Queue Storage</strong> provides cloud messaging between application components.  We'll get onto Azure Functions
later on, during our look at Custom API.  Queue Storage will definitely be coming into play then.  Think of Queue
Storage as the glue that ties work flow components together.</p>
</li>
</ul>
<p>The real question is when should you use File Storage and when should you use Blob Storage.  For more applications,
Blob Storage is going to save you money over File Storage, so it's pretty much always the better choice.  You should
only be thinking of File Storage if you have other components of your system that need to access the data you upload
that can only access that data via an SMB interface.</p>
<p>If you need to explore the data that you upload or download, you can use the <a href="https://azurestorageexplorer.codeplex.com/">Azure Storage Explorer</a> as a standalone
application or you can use the Cloud Explorer in <a href="https://msdn.microsoft.com/library/azure/dd135715.aspx">Visual Studio</a>.</p>
<h3 id="creating-and-linking-a-storage-account"><a name="create-storage-acct"></a>Creating and Linking a Storage Account<a class="headerlink" href="#creating-and-linking-a-storage-account" title="Permanent link">&para;</a></h3>
<p>Before we can use storage, we need to set up a storage account and connect it to our environment.  This involves:</p>
<ol>
<li>Create a Resource Group</li>
<li>Create an Azure App Service</li>
<li>Set up authentication on the Azure App Service</li>
<li>Create a Storage Account</li>
<li>Link the Storage Account to the Azure App Service.</li>
</ol>
<p>We've already covered the first three items in previous chapters.  We've also created a storage account and linked it
to the mobile backend during our look at the <a href="../../chapter3/domainmgr/">Storage Domain Manager</a>.  To create a Storage Account:</p>
<ul>
<li>Log on to the <a href="https://portal.azure.com">Azure portal</a>.</li>
<li>Click the big <strong>+ NEW</strong> button in the top left corner.</li>
<li>Click <strong>Data + Storage</strong>, then <strong>Storage account</strong>.</li>
<li>Fill in the form:<ul>
<li>The name can only contain letters and numbers and must be unique.  A GUID without the dashes is a good choice.</li>
<li>The <strong>Deployment model</strong> should be set to <strong>Resource manager</strong>.</li>
<li>The <strong>Account kind</strong> should be set to <strong>General purpose</strong>.</li>
<li>The <strong>Performance</strong> should be set to <strong>Standard</strong> for this example.</li>
<li>The <strong>Replication</strong> should be set to <strong>Locally-redundant storage (LRS)</strong>.</li>
<li>Set the <strong>Resource group</strong> to your existing resource group.</li>
<li>Set the <strong>Location</strong> to the same location as your App Service.</li>
</ul>
</li>
<li>Click <strong>Create</strong>.</li>
</ul>
<p>Just like SQL Azure, Azure Storage has some great scalability and redundancy features if your backend takes advantage of them.
For example, you have the option of <strong>Premium Storage</strong> - this provides all-SSD storage that has a large IOPS performance
number.  You can also decide how redundant you want the storage.  Azure always keeps 3 copies of your data.  You can choose
to increase the number of copies and decide whether the additional copies will be in the same datacenter, another datacenter
in the same region or another region.  We have selected the slowest performance and least redundant options here to keep the
cost down on your service.</p>
<div class="admonition warn">
<p class="admonition-title">Warn</p>
<p>There is no "free" option for Azure Storage.  You pay by the kilobyte depending on the performance and redundancy selected.</p>
</div>
<p>Once the Azure Storage account is deployed, you can link the storage account to your App Service:</p>
<ul>
<li>Open your App Service in the <a href="https://portal.azure.com">Azure portal</a>.</li>
<li>Click  <strong>Data Connections</strong> under the <strong>MOBILE</strong> section in the settings menu.</li>
<li>Click <strong>+ ADD</strong></li>
<li>In the <strong>Add data connection</strong> blade:<ul>
<li>Set the Type to <strong>Storage</strong>.</li>
<li>Click the <strong>Storage</strong> link.</li>
<li>In the <strong>Storage Account</strong> selector, click the storage account you just created.</li>
<li>Click the <strong>Connection string</strong>.</li>
<li>In the <strong>Connection string</strong> selector, make a note of the <strong>Name</strong> field.</li>
<li>Click <strong>OK</strong>.</li>
<li>Click <strong>OK</strong> to close the <strong>Add data connection</strong> blade.</li>
</ul>
</li>
</ul>
<p>Click on the <strong>Application Settings</strong> menu option, then scroll down to the <strong>Connection Strings</strong> section.  Note that the portal
has created the connection string as an App Setting for you with the right value:</p>
<pre><code class="bash">DefaultEndpointsProtocol=https;AccountName=thebook;AccountKey=&lt;key1&gt;
</code></pre>

<p>By default, the connection string is called <code>MS_AzureStorageAccountConnectionString</code> and we will use that throughout our
examples.</p>
<p>The key is the access key for the storage.  When a storage account is created, two keys are also created.  The keys are used for
secure access to the storage area.  You should never distribute the storage keys nor check them into source control.  If you feel
they have been compromised, you should regenerate them.  There are two keys for this purpose.  The process of regeneration is:</p>
<ol>
<li>Regenerate KEY2</li>
<li>Place the regenerated KEY2 in the connection string and restart your App Service.</li>
<li>Regenerate key1</li>
<li>Place the regenerated KEY1 in the connection string and restart your App Service.</li>
</ol>
<p>In this way, your App Service will always be using KEY1 except during regeneration.  You can avoid the restart of your App Service
by providing a management interface that sets the Account Key for the App Service.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>For local development, there is the <a href="https://github.com/jamesmontemagno/MediaPlugin">Azure Storage Emulator</a>.  The connection string when using the Azure Storage
Emulator is <code>UseDevelopmentStorage=true</code>.</p>
</div>
<p>It's normal to add the storage connection string to the <code>Web.config</code> file with the following:</p>
<pre><code class="xml">&lt;connectionStrings&gt;
    &lt;add name=&quot;MS_AzureStorageAccountConnectionString&quot; connectionString=&quot;UseDevelopmentStorage=true&quot; /&gt;
&lt;/connectionStrings&gt;
</code></pre>

<p>This will be overwritten by the connection string in the App Service Application Settings.  Effectively, you will be using the
Azure Storage Emulator during local development and Azure Storage when you deploy to Azure App Service.</p>
<h3 id="the-shared-access-signature-sas">The Shared Access Signature (SAS)<a class="headerlink" href="#the-shared-access-signature-sas" title="Permanent link">&para;</a></h3>
<p>The storage account key is kind of like the root or Administrator password.  You should always protect it, never send it to a
third party and regenerate it on a regular basis.  You avoid storing the storage account key in source code by linking the
storage account to the App Service.  The key is stored in the connection string instead.  You should never ship an account
key to your mobile account.</p>
<p>The Azure Storage SDK already has many of the features that you want in handling file upload and download.  Azure Storage is
optimized for streaming, for example.  You can upload or download blobs in blocks, allowing you to restart the transfer and
provide feedback to the user on progress, for example.   You will inevitably be drawn to having your mobile client interact
with Azure Storage directly rather than having an intermediary web service for this reason.</p>
<p>If you want to interact with Azure Storage directly and you shouldn't give out the account key, how do you deal with the
security of the service?  The answer is with a Shared Access Signature, or SAS.  The <strong>Service SAS</strong> delegates access
to just a single resource in one of the storage services (Blob, Table, Queue or File service).</p>
<div class="admonition info">
<p class="admonition-title">Info</p>
<p>There is also an <a href="https://blog.xamarin.com/new-ios-10-privacy-permission-settings/">Account SAS</a> which delegates access to resources in more than one service.  You generally don't
want this in application development.</p>
</div>
<p>A service SAS is a URI that is used when accessing the resource.  It consists of the URI to the resource followed by a
SAS token.  The SAS token is an cryptographically signed opaque token that the storage service decodes.  Minimally, it
provides an expiry time and the permissions being granted to the SAS.</p>
<div class="admonition warn">
<p class="admonition-title">Warn</p>
<p>A SAS token <strong>ALWAYS</strong> expires.  There is no way to produce a permanent SAS token.  If you think you need one,
think again.  In mobile development, you <strong>NEVER</strong> want a non-expiring token.</p>
</div>
<p>Accessing Azure Storage is always done with a specific <a href="https://msdn.microsoft.com/en-us/library/azure/dd894041.aspx">version of the REST API</a> and that follows through to the SDK.  You
should always request a SAS token for the appropriate API you are going to be using.   We'll cover the various
methods of obtaining a SAS later in the chapter.</p>
<h2 id="uploading-a-file">Uploading a File<a class="headerlink" href="#uploading-a-file" title="Permanent link">&para;</a></h2>
<p>The most normal tasks for dealing with files are the upload and download of files to blob storage.  There is
a natural and consistent process to this which makes this recipe very repeatable.  First, deal with the things
you need before you start:</p>
<ol>
<li>Create an Azure Storage Account and link it to your Azure App Service.</li>
<li>Decide how you want your files organized.</li>
<li>Create a WebAPI to generate a SAS token for your upload or download.
Blob storage is organized in a typical directory structure.  Each directory is called a container, and each file
is a blob.  In the examples for this section, I am going to store each uploaded file in a container based on the
authenticated user.  My WebAPI will create the appropriate container and then return an appropriate SAS token.</li>
</ol>
<p>We can set up our custom API as follows:</p>
<pre><code class="csharp">namespace Backend.Controllers
{
    [Authorize]
    [MobileappController]
    public class GetStorageTokenController : ApiController
    {
        private const string connString = &quot;CUSTOMCONNSTR_MS_AzureStorageAccountConnectionString&quot;;

        public GetStorageTokenController()
        {
            ConnectionString = Environment.GetEnvironmentVariable(connString);
            StorageAccount = CloudStorageAccount.Parse(ConnectionString);
            BlobClient = StorageAccount.CreateCloudBlobClient();
        }

        public string ConnectionString { get; }

        public CloudStorageAccount StorageAccount { get; }

        public CloudBlobClient BlobClient { get; }
    }
}
</code></pre>

<p>The <code>ConnectionString</code> property is the pointer to where the Azure Storage account is located and how to
access it.  the <code>StorageAccount</code> is a reference to that Azure Storage account.  Finally, the <code>BlobClient</code>
is an object used for accessing blob storage.  We can access any WebAPI methods in this class by using
the endpoint <code>/api/GetStorageToken</code> within our mobile client or using Postman.</p>
<p>Azure Storage doesn't have a true heirarchial container system.  It does have containers and directories
to organize things though, so we are going to use that:</p>
<pre><code class="csharp">    private const string containerName = &quot;userdata&quot;;

    [HttpGet]
    public async Task&lt;StorageTokenViewModel&gt; GetAsync()
    {
        // The userId is the SID without the sid: prefix
        var claimsPrincipal = User as ClaimsPrincipal;
        var userId = claimsPrincipal
            .FindFirst(ClaimTypes.NameIdentifier)
            .Value.Substring(4);

        // Errors creating the storage container result in a 500 Internal Server Error
        var container = BlobClient.GetContainerReference(containerName);
        await container.CreateIfNotExistsAsync();

        // Get the user directory within the container
        var directory = container.GetDirectoryReference(userId);
        var blobName = Guid.NewGuid().ToString(&quot;N&quot;);
        var blob = directory.GetBlockBlobReference(blobName);

        // Create a policy for accessing the defined blob
        var blobPolicy = new SharedAccessBlobPolicy
        {
            SharedAccessStartTime = DateTime.UtcNow.AddMinutes(-5),
            SharedAccessExpiryTime = DateTime.UtcNow.AddMinutes(60),
            Permissions = SharedAccessBlobPermissions.Read
                        | SharedAccessBlobPermissions.Write
                        | SharedAccessBlobPermissions.Create
        };

        return new StorageTokenViewModel
        {
            Name = blobName,
            Uri = blob.Uri,
            SasToken = blob.GetSharedAccessSignature(blobPolicy)
        };
    }
</code></pre>

<p>The main piece of work in this API is generating the policy that is then signed and returned to
the user as the SAS Token.  The mobile device has permission to read, write and create the blob
that we have defined for the next 60 minutes.  I've provided a policy that starts in the past in
case there is a little amount of clock-skew between the mobile device and the backend.</p>
<div class="admonition warn">
<p class="admonition-title">Warn</p>
<p>Container names must be a valid DNS name.  The most notable requirement here is between 3
and 64 lower-case letters.  Container names are case-sensitive.  Check <a href="https://msdn.microsoft.com/library/azure/dd135715.aspx">the documentation</a>
for full details on naming requirements.</p>
</div>
<p>The <code>StorageTokenViewModel</code> is used for serialization purposes:</p>
<pre><code class="csharp">public class StorageTokenViewModel
{
    public string Name { get; set; }
    public Uri Uri { get; set; }
    public string SasToken { get; set; }
}
</code></pre>

<p>We can test this API using Postman.  First, generate an authentication token.  Then use Postman to
do a GET of the <code>/api/GetStorageToken</code> endpoint:</p>
<p><img alt="" src="../img/getstoragetoken-1.PNG" /></p>
<p>There are two pieces of information we need here.  Firstly, the <code>uri</code> property provides the URI that we are going to
use to upload the file.  Secondly, the <code>sasToken</code> is appended to the <code>uri</code> when uploading to provide a link to the
policy.  Note that the token start and expiry time are encoded and readable in the sasToken.</p>
<p>In real world applications, this is likely not the right method.  We might want to organize the files based on information
that the mobile client provides us, for example.  We may also want to upload to a specific upload area and then download
from another location, allowing processing of the files in between.  You may also want to append the uploaded file extension
to the file before uploading.  There is no "one size fits all" token policy.  You must decide on the conditions under which
you will allow upload and download capabilities and then provide the appropriate logic to generate the SAS token.</p>
<h3 id="the-mobile-client">The Mobile Client<a class="headerlink" href="#the-mobile-client" title="Permanent link">&para;</a></h3>
<p>Once we have the logic to generate a SAS token, we can turn our attention to the mobile clients.  We need to do three
things for uploading a file to the service:</p>
<ol>
<li>Get a reference to the file (as a Stream object).</li>
<li>Generate a SAS token using the custom API.</li>
<li>Use the Azure Storage SDK to upload directly to the Azure Storage Account.</li>
</ol>
<p>You should not upload to a custom API in your mobile backend.  This needlessly ties up your mobile backend, causing your
mobile backend to be less efficient at scaling.  Your mobile backend will not have all the facilities that the
Azure Storage endpoint has provided either.  Azure Storage provides upload and download restarts and progress bar
capabilities.</p>
<p>Obtaining a reference to the file that you wish to upload is normally a per-platform API.  Obtaining a reference to a photo or video
involves interacting with platform-specific APIs to provide access to camera and built-in photo storage capabilities on the
phone. To support such a per-platform capability, we need to add an interface for the API to the <code>Abstractions\IPlatform.cs</code> file:</p>
<pre><code class="csharp">Task&lt;Stream&gt; GetUploadFileAsync();
</code></pre>

<p>This API will interact with whatever photo sharing API is available on the device, open the requested file and return a standard
<code>Stream</code> object.  Loading a media file is made much simpler using the cross-platform <a href="https://github.com/jamesmontemagno/MediaPlugin">Xamarin Media plugin</a>.  This plugin allows
the user to take photos or video, or pick  the media file from a gallery.  It's available on NuGet, so add the <code>Xam.Plugin.Media</code>
plugin to each of the platform-specific projects.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>I still like separating out code that deals with the hardware of a mobile device into the platform-specific code.  You don't
need to do such separation on this project.  I find that I inevitably have one thing or another that requires a platform-specific
tweak, so starting with a platform-specific API is better.</p>
</div>
<p>The Xamarin Media plugin is used like this:</p>
<pre><code class="csharp">await CrossMedia.Current.Initialize();

var file = await CrossMedia.Current.PickPhotoAsync();
var stream = file.GetStream();
</code></pre>

<p>There are methods within the plugin to determine if a camera is available.  Different platforms require different permissions:</p>
<h3 id="android">Android<a class="headerlink" href="#android" title="Permanent link">&para;</a></h3>
<p>Android requires the  <code>WRITE_EXTERNAL_STORAGE</code>, <code>READ_EXTERNAL_STORAGE</code> and <code>CAMERA</code> permissions. If the mobile device is
running Android M or later, the plugin will automatically prompt the user for runtime permissions.  You can set these permissions
within Visual Studio:</p>
<ul>
<li>Double-click the <strong>Properties</strong> node within the Android project.</li>
<li>Select <strong>Android Manifest</strong>.</li>
<li>In the <strong>Required permissions</strong> list, check the box next to the required permissions by double-clicking the permission.</li>
<li>Save the Properties (you may have to right-click on the TaskList.Droid tab and click on <strong>Save Selected Items</strong>).</li>
</ul>
<h3 id="ios">iOS<a class="headerlink" href="#ios" title="Permanent link">&para;</a></h3>
<p>Apple iOS requires the <strong>NSCameraUsageDescription</strong> and <strong>NSPhotoLibraryUsageDescription</strong> keys.  The string provided will be
displayed to the user when they are prompted to provide permission.  You can set these keys within Visual Studio:</p>
<ul>
<li>Right-click on the <strong>Info.plist</strong> file and select <strong>Open with...</strong></li>
<li>Choose the <strong>XML (Text) Editor</strong> then click <strong>OK</strong>.</li>
<li>Within the <code>&lt;dict&gt;</code> node, add the following lines:</li>
</ul>
<pre><code class="xml">&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;
&lt;string&gt;This app needs access to the camera to take photos.&lt;/string&gt;
&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;
&lt;string&gt;This app needs access to photos.&lt;/string&gt;
</code></pre>

<ul>
<li>Save and close the file.</li>
</ul>
<p>You can choose whatever string you want to display to the user.  For more information on iOS 10 privacy permissions, review
the <a href="https://blog.xamarin.com/new-ios-10-privacy-permission-settings/">Xamarin Blog</a>.</p>
<h3 id="universal-windows">Universal Windows<a class="headerlink" href="#universal-windows" title="Permanent link">&para;</a></h3>
<p>Universal Windows may require the <strong>Pictures Library</strong> capability:</p>
<ul>
<li>In the <strong>TaskList.UWP (Universal Windows)</strong> project, open <strong>Package.appxmanifest</strong>.</li>
<li>Select the <strong>Capabilities</strong> tab.</li>
<li>Check the box next to <strong>Pictures Library</strong>.</li>
<li>Save the manifest.</li>
</ul>
<h3 id="implementing-the-file-reader">Implementing the File Reader<a class="headerlink" href="#implementing-the-file-reader" title="Permanent link">&para;</a></h3>
<p>The same code can be used in all three platform-specific projects, in the <code>*Platform.cs</code> file:</p>
<pre><code class="csharp">    /// &lt;summary&gt;
    /// Picks a photo for uploading
    /// &lt;/summary&gt;
    /// &lt;returns&gt;A Stream for the photo&lt;/returns&gt;
    public async Task&lt;Stream&gt; GetUploadFileAsync()
    {
        var mediaPlugin = CrossMedia.Current;
        var mainPage = Xamarin.Forms.Application.Current.MainPage;

        await mediaPlugin.Initialize();

        if (mediaPlugin.IsPickPhotoSupported)
        {
            var mediaFile = await mediaPlugin.PickPhotoAsync();
            return mediaFile.GetStream();
        }
        else
        {
            await mainPage.DisplayAlert(&quot;Media Service Unavailable&quot;, &quot;Cannot pick photo&quot;, &quot;OK&quot;);
            return null;
        }
    }
</code></pre>

<h3 id="uploading-a-file_1">Uploading a File<a class="headerlink" href="#uploading-a-file_1" title="Permanent link">&para;</a></h3>
<p>We can now put the individual pieces together to actually do an upload.  In this example, we are going to use the photo picker to
pick a photo and then upload it, displaying a progress bar as it happens.  We start with the XAML code in <code>Pages\TaskList.xaml</code>.  We
need a button in the toolbar to initiate the file upload:</p>
<pre><code class="xml">    &lt;ContentPage.ToolbarItems&gt;
        &lt;ToolbarItem Name=&quot;Refresh&quot;
                     Command=&quot;{Binding RefreshCommand}&quot;
                     Icon=&quot;refresh.png&quot;
                     Order=&quot;Primary&quot;
                     Priority=&quot;0&quot; /&gt;
        &lt;ToolbarItem Name=&quot;Add Task&quot;
                     Command=&quot;{Binding AddNewItemCommand}&quot;
                     Icon=&quot;add.png&quot;
                     Order=&quot;Primary&quot;
                     Priority=&quot;0&quot; /&gt;
        &lt;ToolbarItem Name=&quot;Add File&quot;
                     Command=&quot;{Binding AddNewFileCommand}&quot;
                     Icon=&quot;addfile.png&quot;
                     Order=&quot;Primary&quot;
                     Priority=&quot;0&quot; /&gt;
    &lt;/ContentPage.ToolbarItems&gt;
</code></pre>

<p>Obtain a suitable "Add File" icon from the Internet and resize the image appropriately for the task.  You will need five images total:</p>
<ul>
<li>TaskList.Droid\Resources\drawable\addfile.png should be 128x128 pixels</li>
<li>TaskList.iOS\Resources\addfile.png should be 25x25 pixels</li>
<li>TaskList.iOS\Resources\addfile@2x.png should be 50x50 pixels</li>
<li>TaskList.iOS\Resources\addfile@3x.png should be 75x75 pixels</li>
<li>TaskList.UWP\addfile.png should be 128x128 pixels</li>
</ul>
<p>All images should have a transparent background.</p>
<p>The storage token is retrieved from the backend via the cloud service.  Add the following to <code>Abstractions\ICloudService.cs</code>:</p>
<pre><code class="csharp">    // Custom APIs
    Task&lt;StorageTokenViewModel&gt; GetSasTokenAsync();
</code></pre>

<p>This has a concrete implementation in <code>Services\AzureCloudService.cs</code>:</p>
<pre><code class="csharp">    public async Task&lt;StorageTokenViewModel&gt; GetSasTokenAsync()
    {
        var parameters = new Dictionary&lt;string, string&gt;();
        var storageToken = await Client.InvokeApiAsync&lt;StorageTokenViewModel&gt;(&quot;GetStorageToken&quot;, HttpMethod.Get, parameters);
        return storageToken;
    }
</code></pre>

<p>The <code>StorageTokenViewModel</code> is identical to the class in the <code>GetStorageTokenController.cs</code> controller in the Backend.  I've placed the class
definition in the <code>Models</code> namespace for the client.  We could share this model between the backend and front end, but the case of sharing
models is so rare I tend not to share the code.</p>
<p>In the <code>TaskListViewModel.cs</code>, we can define a command that is called when the Add File button is clicked:</p>
<pre><code class="csharp">    /// &lt;summary&gt;
    /// Reference to the Platform Provider
    /// &lt;/summary&gt;
    public IPlatform PlatformProvider =&gt; DependencyService.Get&lt;IPlatform&gt;();

    /// &lt;summary&gt;
    /// Bindable property for the AddNewFile Command
    /// &lt;/summary&gt;
    public ICommand AddNewFileCommand { get; }

    /// &lt;summary&gt;
    /// User clicked on the Add New File button
    /// &lt;/summary&gt;
    private async Task AddNewFileAsync()
    {
        if (IsBusy)
        {
            return;
        }
        IsBusy = true;

        try
        {
            // Get a stream for the file
            var mediaStream = await PlatformProvider.GetUploadFileAsync();
            if (mediaStream == null)
            {
                IsBusy = false;
                return;
            }

            // Get the SAS token from the backend
            var storageToken = await CloudService.GetSasTokenAsync();

            // Use the SAS token to upload the file
            var storageUri = new Uri($&quot;{storageToken.Uri}{storageToken.SasToken}&quot;);
            var blobStorage = new CloudBlockBlob(storageUri);
            await blobStorage.UploadFromStreamAsync(mediaStream);
        }
        catch (Exception ex)
        {
            await Application.Current.MainPage.DisplayAlert(&quot;Error Uploading File&quot;, ex.Message, &quot;OK&quot;);
        }
        finally
        {
            IsBusy = false;
        }
    }
</code></pre>

<div class="admonition warn">
<p class="admonition-title">Warn</p>
<p>Azure Storage SDK support for PCL projects is only available in -preview editions.  When installing the SDK, ensure you check the
"Include prerelease" box in the NuGet package manager.  The latest version with PCL (.NETPortable) support is v7.0.2-preview.</p>
</div>
<p>You can look at the uploaded files in the Azure portal:</p>
<ol>
<li>Log in to the <a href="https://portal.azure.com">Azure portal</a>.</li>
<li>Click <strong>All resources</strong>, then your storage account.</li>
<li>Under <strong>SERVICES</strong>, click <strong>Blobs</strong>.</li>
<li>Click your storage container (in this example, that's called <strong>userdata</strong>)</li>
</ol>
<p><img alt="" src="../img/storageinportal.PNG" /></p>
<p>You will see a folder for each user account.  The folder is named for the SID of the account - not the username.  It's a good idea to
store the user SID with other data about the user in a table within your database.   This allows you to associate a real user with their
SID since a user will never know what their SID is.</p>
<h3 id="implementing-a-progress-bar">Implementing a Progress bar<a class="headerlink" href="#implementing-a-progress-bar" title="Permanent link">&para;</a></h3>
<p>It's common to want to see the progress of the upload while it is happening.  For that, we need a progress bar.  First, let's add a hidden
progress bar to our <code>TaskList.xaml</code> page:</p>
<pre><code class="xml">    &lt;ActivityIndicator HorizontalOptions=&quot;FillAndExpand&quot;
                        IsRunning=&quot;{Binding IsBusy}&quot;
                        IsVisible=&quot;{Binding IsBusy}&quot;
                        VerticalOptions=&quot;Start&quot; /&gt;
    &lt;ProgressBar x:Name=&quot;fileUploadProgress&quot;
                    HeightRequest=&quot;3&quot;
                    HorizontalOptions=&quot;FillAndExpand&quot;
                    IsVisible=&quot;{Binding IsUploadingFile}&quot;
                    Progress=&quot;{Binding FileProgress}&quot; /&gt;
</code></pre>

<p>This comes with two new bindable properties.  <code>IsUploadingFile</code> is a <code>bool</code> and <code>FileProgress</code> is a <code>Double</code>.  <code>FileProgress</code> takes a value between
0 and 1 to indicate how far along the progress bar should be.  This code should be in the <code>TaskListViewModel.cs</code> file:</p>
<pre><code class="csharp">    private bool isUploadingFile;
    public bool IsUploadingFile
    {
        get { return isUploadingFile; }
        set { SetProperty(ref isUploadingFile, value, &quot;IsUploadingFile&quot;); }
    }

    private Double fileProgress = 0.0;
    public Double FileProgress
    {
        get { return fileProgress;  }
        set { SetProperty(ref fileProgress, value, &quot;FileProgress&quot;); }
    }
</code></pre>

<p>Finally, we have to change the upload so that it happens a chunk at a time.  In the <code>AddNewFileAsync()</code> method, we can replace the upload code with this:</p>
<pre><code class="csharp">    /// &lt;summary&gt;
    /// User clicked on the Add New File button
    /// &lt;/summary&gt;
    private async Task AddNewFileAsync()
    {
        if (IsBusy)
        {
            return;
        }
        IsBusy = true;

        try
        {
            // Get a stream for the file
            var mediaStream = await PlatformProvider.GetUploadFileAsync();
            if (mediaStream == null)
            {
                IsBusy = false;
                return;
            }

            // Get the SAS token from the backend
            var storageToken = await CloudService.GetSasTokenAsync();

            // Use the SAS token to get a reference to the blob storage
            var storageUri = new Uri($&quot;{storageToken.Uri}{storageToken.SasToken}&quot;);
            var blobStorage = new CloudBlockBlob(storageUri);

            // Get the length of the stream
            var mediaLength = mediaStream.Length;

            // Initialize the blocks
            int bytesInBlock = 1024;                // The number of bytes in a single block
            var buffer = new byte[bytesInBlock];    // The buffer to hold the data during transfer
            int totalBytesRead = 0;                 // The number of bytes read from the stream.
            int bytesRead = 0;                      // The number of bytes read per block.
            int blocksWritten = 0;                  // The # Blocks Written

            IsUploadingFile = true;
            FileProgress = 0.00;

            // Loop through until we have processed the whole file
            do
            {
                // Read a block from the media stream
                bytesRead = mediaStream.Read(buffer, 0, bytesInBlock);

                if (bytesRead &gt; 0)
                {
                    // Move the buffer into a memory stream
                    using (var memoryStream = new MemoryStream(buffer, 0, bytesRead))
                    {
                        string blockId = GetBlockId(blocksWritten);
                        await blobStorage.PutBlockAsync(blockId, memoryStream, null);
                    }

                    // Update the internal counters
                    totalBytesRead += bytesRead;
                    blocksWritten++;

                    // Update the progress bar
                    FileProgress = totalBytesRead / mediaLength;
                }

            } while (bytesRead &gt; 0);
        }
        catch (Exception ex)
        {
            await Application.Current.MainPage.DisplayAlert(&quot;Error Uploading File&quot;, ex.Message, &quot;OK&quot;);
        }
        finally
        {
            IsBusy = false;
            IsUploadingFile = false;
            FileProgress = 0.0;
        }
    }

    /// &lt;summary&gt;
    /// Convert the Block ID to the string we need
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;block&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    private string GetBlockId(int block)
    {
        char[] tempID = new char[6];
        string iStr = block.ToString();

        for (int j = tempID.Length - 1; j &gt; (tempID.Length - iStr.Length - 1); j--)
        {
            tempID[j] = iStr[tempID.Length - j - 1];
        }
        byte[] blockIDBeforeEncoding = Encoding.UTF8.GetBytes(tempID);
        return Convert.ToBase64String(blockIDBeforeEncoding);
    }
</code></pre>

<p>The main work is done in the inner loop.  We split the media stream into 1024 byte blocks.  Each block is copied into a temporary buffer
then transferred to cloud storage.  After each block is delivered, the <code>FileProgress</code> counter is updated which updates the progress bar.</p>
<p>One of the secrets for doing block-based streaming uploads is the <code>GetBlockId()</code> method.  This properly formats the block ID (based on
a rather convoluted method that ends up being Base-64 encoded).  If you do not get this right, you will instead get a rather cryptic
message about the query parameter for the HTTP request being wrong.</p>
<h2 id="downloading-a-file">Downloading a File<a class="headerlink" href="#downloading-a-file" title="Permanent link">&para;</a></h2>
<p>You can similarly download a file from blob storage.  The basics (such as the SAS token generator) are exactly
the same as before.  To do the basic form:</p>
<pre><code class="csharp">    // Get the SAS token from the backend
    var storageToken = await CloudService.GetSasTokenAsync(filename);

    // Use the SAS token to get a reference to the blob storage
    var storageUri = new Uri($&quot;{storageToken.Uri}{storageToken.SasToken}&quot;);
    var blobStorage = new CloudBlockBlob(storageUri);

    // Get a stream for the blob file
    var mediaStream = await blobStorage.OpenReadAsync();
    // Do something with the mediaStream - like move it to storage
    await PlatformProvider.StoreFileAsync(mediaStream);
    // At the end, close the stream properly
    mediaStream.Dispose();
</code></pre>

<p>Similarly, you can also produce a progress bar:</p>
<pre><code class="csharp">    // Get the SAS token from the backend
    var storageToken = await CloudService.GetSasTokenAsync(filename);

    // Use the SAS token to get a reference to the blob storage
    var storageUri = new Uri($&quot;{storageToken.Uri}{storageToken.SasToken}&quot;);
    var blobStorage = new CloudBlockBlob(storageUri);
    var mediaStream = await blobStorage.OpenReadAsync();

    var mediaLength = mediaStream.Length;
    byte[] buffer = new byte[1024];
    var bytesRead = 0, totalBytesRead = 0;

    // Do what you need to for opening your output file
    do {
        bytesRead = mediaStream.ReadAsync(buffer, 0, 1024);
        if (bytesRead &gt; 0) {
            // Do something with the buffer

            totalBytesRead += bytesRead;
            FileProgress = totalBytesRead / mediaLength;
        }
    } while (bytesRead &gt; 0);

    // Potentially close your output file as well
    mediaStream.Dispose();
</code></pre>

<p>When downloading, you will need to update the <code>GetStorageTokenController</code> method to provide access to files.  One possibility is to
provide read/write access to the entire container, allowing the mobile device to get a directory listing for browsing.</p>
<h2 id="table-controllers-and-webhooks">Table Controllers and Webhooks<a class="headerlink" href="#table-controllers-and-webhooks" title="Permanent link">&para;</a></h2>
<p>I love writing asynchronous applications.  One of the four features I mentioned with Table Controllers is the
Webhook.  In essence, if someone inserts, updates or deletes a record, you may want to do something asynchronously.
For example, you may want to do sentiment analysis on the record that was just uploaded, or perhaps execute some
custom code to simulate an offline custom API.</p>
<p>A Webhook is a callback mechanism whereby the controller will do an HTTP POST when something happens.  It's an
event processing system over HTTP.  In this sample, we are going to generate a simple Webhook function that
logs the inserted record, then adjust our table controller to call the Webhook when an insert happens.</p>
<p>Let's first of all create a Function that handles the request.  Create a Function App, and then create a new
function based on the <strong>Generic Webhook - C#</strong> template.  Call this function <code>InsertTodoItemWebhook</code>.  You
can call this whatever you want, but the URI of your Webhook is based on the name of your function.</p>
<p>Replace the body of the function with the following:</p>
<pre><code class="csharp">#r &quot;Newtonsoft.Json&quot;

using System;
using System.Net;
using Newtonsoft.Json;

public static async Task&lt;object&gt; Run(HttpRequestMessage req, TraceWriter log)
{
    string jsonContent = await req.Content.ReadAsStringAsync();
    dynamic data = JsonConvert.DeserializeObject(jsonContent);

    log.Info($&quot;Created New Todo ({data.Text}, {data.Complete})&quot;);

    return req.CreateResponse(HttpStatusCode.OK);
}
</code></pre>

<p>Note the <strong>Function Url</strong> at the top of the page.  You will need to copy and paste this later on.  You can
test the Function in isolation by putting the following in the <strong>Request body</strong> panel:</p>
<pre><code class="text">{
    &quot;Text&quot;: &quot;test&quot;,
    &quot;Complete&quot;: true
}
</code></pre>

<p>When you click the <strong>Run</strong> button, the log should show the Info line and the Output should show a <strong>200 OK</strong></p>
<p><img alt="" src="../img/run-webhook.PNG" /></p>
<p>You can now turn your attention to the mobile backend.  I use a <code>Webhook.cs</code> helper:</p>
<pre><code class="csharp">using System;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;

namespace Backend.Helpers
{
    public static class Webhook
    {
        public static async Task&lt;HttpStatusCode&gt; SendAsync&lt;T&gt;(Uri uri, T data)
        {
            var httpClient = new HttpClient();
            httpClient.BaseAddress = uri;
            var response = await httpClient.PostAsJsonAsync&lt;T&gt;(&quot;&quot;, data);
            return response.StatusCode;
        }
    }
}
</code></pre>

<p>This allows me to call the Webhook in my <code>TodoItemController.cs</code> method like this:</p>
<pre><code class="csharp">    public async Task&lt;IHttpActionResult&gt; PostTodoItem(TodoItem item)
    {
        TodoItem current = await InsertAsync(item);
#pragma warning disable CS4014
        Webhook.SendAsync&lt;TodoItem&gt;(new Uri(webhookUri), current);
#pragma warning restore CS4014
        return CreatedAtRoute(&quot;Tables&quot;, new { id = current.Id }, current);
    }
</code></pre>

<p>You will see the Webhook is called when the value is inserted.  We don't await the <code>SendAsync&lt;TodoItem&gt;()</code>
call because we don't want the process to be held up while the webhook is running.  You will notice that
the response is sometimes returned to the user before the webhook is executed.</p>
<!-- Images -->

<!-- Links -->
          <aside class="copyright" role="note">
            
            Documentation built with
            <a href="http://www.mkdocs.org" target="_blank">MkDocs</a>
            using the
            <a href="http://squidfunk.github.io/mkdocs-material/" target="_blank">
              Material
            </a>
            theme.
          </aside>
          
            <footer class="footer">
              
  <nav class="pagination" aria-label="Footer">
    <div class="previous">
      
        <a href="../functions/" title="Functions">
          <span class="direction">
            Previous
          </span>
          <div class="page">
            <div class="button button-previous" role="button" aria-label="Previous">
              <i class="icon icon-back"></i>
            </div>
            <div class="stretch">
              <div class="title">
                Functions
              </div>
            </div>
          </div>
        </a>
      
    </div>
    <div class="next">
      
        <a href="../../chapter5/concepts/" title="Concepts">
          <span class="direction">
            Next
          </span>
          <div class="page">
            <div class="stretch">
              <div class="title">
                Concepts
              </div>
            </div>
            <div class="button button-next" role="button" aria-label="Next">
              <i class="icon icon-forward"></i>
            </div>
          </div>
        </a>
      
    </div>
  </nav>

            </footer>
          
        </div>
      </article>
      <div class="results" role="status" aria-live="polite">
        <div class="scrollable">
          <div class="wrapper">
            <div class="meta"></div>
            <div class="list"></div>
          </div>
        </div>
      </div>
    </main>
    <script>
      var base_url = '../..';
      var repo_id  = 'adrianhall/develop-mobile-apps-with-csharp-and-azure';
    </script>
    <script src="../../assets/javascripts/application-997097ee0c.js"></script>
    
      <script src="../../js/highlight.pack.js"></script>
    
    
  </body>
</html>