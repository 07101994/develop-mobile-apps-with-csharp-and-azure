<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <title>Chapter 2 - Authentication - Develop Cloud Connected Mobile Apps with Xamarin and Microsoft Azure</title>
  

  <link rel="shortcut icon" href="../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">
  <link href="../extra.css" rel="stylesheet">

  
  <script>
    // Current page data
    var mkdocs_page_name = "Chapter 2 - Authentication";
    var mkdocs_page_input_path = "2_authentication.md";
    var mkdocs_page_url = "/2_authentication/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script>
  <script src="../js/theme.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Develop Cloud Connected Mobile Apps with Xamarin and Microsoft Azure</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="..">Getting Started</a>
        
    </li>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>Chapter 1 - Introduction</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../chapter1/firstapp_pc/">Your First App - PC Edition</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../chapter1/firstapp_mac/">Your First App - Mac Edition</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="./">Chapter 2 - Authentication</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#authentication">Authentication</a></li>
                
                    <li><a class="toctree-l4" href="#concepts">Concepts</a></li>
                
                    <li><a class="toctree-l4" href="#adding-authentication-to-a-mobile-backend">Adding Authentication to a Mobile Backend</a></li>
                
                    <li><a class="toctree-l4" href="#configuring-an-authentication-provider">Configuring an Authentication Provider</a></li>
                
                    <li><a class="toctree-l4" href="#azure-active-directory-server-flow-setup">Azure Active Directory: Server-Flow setup</a></li>
                
            
                <li class="toctree-l3"><a href="#adding-authentication-to-a-mobile-client">Adding Authentication to a Mobile Client</a></li>
                
                    <li><a class="toctree-l4" href="#azure-active-directory-client-flow-setup">Azure Active Directory: Client-Flow Setup</a></li>
                
            
                <li class="toctree-l3"><a href="#social-authentication">Social Authentication</a></li>
                
                    <li><a class="toctree-l4" href="#facebook-authentication">Facebook Authentication</a></li>
                
                    <li><a class="toctree-l4" href="#google-authentication">Google Authentication</a></li>
                
                    <li><a class="toctree-l4" href="#microsoft-account-authentication">Microsoft Account Authentication</a></li>
                
                    <li><a class="toctree-l4" href="#twitter-authentication">Twitter Authentication</a></li>
                
            
                <li class="toctree-l3"><a href="#testing-authentication-without-a-client">Testing Authentication without a Client</a></li>
                
            
                <li class="toctree-l3"><a href="#developing-locally">Developing Locally</a></li>
                
                    <li><a class="toctree-l4" href="#update-your-local-development-environment">Update your Local Development Environment</a></li>
                
                    <li><a class="toctree-l4" href="#update-your-mobile-client">Update your Mobile Client</a></li>
                
                    <li><a class="toctree-l4" href="#run-the-local-server">Run the Local Server</a></li>
                
            
                <li class="toctree-l3"><a href="#custom-authentication">Custom authentication</a></li>
                
                    <li><a class="toctree-l4" href="#using-an-identity-database">Using an Identity Database.</a></li>
                
            
                <li class="toctree-l3"><a href="#using-azure-active-directory-b2c">Using Azure Active Directory B2C</a></li>
                
                    <li><a class="toctree-l4" href="#the-minimal-setup-of-azure-ad-b2c">The Minimal Setup of Azure AD B2C</a></li>
                
                    <li><a class="toctree-l4" href="#drawbacks-of-azure-active-directory-b2c">Drawbacks of Azure Active Directory B2C</a></li>
                
            
                <li class="toctree-l3"><a href="#using-third-party-tokens">Using Third Party Tokens</a></li>
                
            
                <li class="toctree-l3"><a href="#claims-and-authorization">Claims and Authorization</a></li>
                
            
                <li class="toctree-l3"><a href="#obtaining-user-claims">Obtaining User Claims</a></li>
                
            
                <li class="toctree-l3"><a href="#authorization">Authorization</a></li>
                
            
                <li class="toctree-l3"><a href="#group-authorization">Group Authorization</a></li>
                
            
                <li class="toctree-l3"><a href="#caching-tokens">Caching Tokens</a></li>
                
            
                <li class="toctree-l3"><a href="#refresh-tokens">Refresh Tokens</a></li>
                
                    <li><a class="toctree-l4" href="#configuring-refresh-tokens">Configuring Refresh Tokens</a></li>
                
                    <li><a class="toctree-l4" href="#using-refresh-tokens">Using Refresh Tokens</a></li>
                
            
                <li class="toctree-l3"><a href="#logging-out">Logging out</a></li>
                
            
                <li class="toctree-l3"><a href="#best-practices">Best Practices</a></li>
                
            
            </ul>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../data/">Data Access and Offline Sync</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../authdata/">Authenticated Data Access</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../files/">File Management</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../push/">Push Notifications</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../custom/">Server Side Code</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../media/">Media Services</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../search/">Leveraging Search</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../combined/">Web and Mobile Apps</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../developing/">The Development Environment</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../testing/">Testing your Application</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../troubleshooting/">Troubleshooting</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../production/">Going to Production</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../xamarin_tips/">Xamarin Forms Tips</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../android_appendix/">Android Developer Notes</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../references/">References</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../credits/">Credits</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Develop Cloud Connected Mobile Apps with Xamarin and Microsoft Azure</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Chapter 2 - Authentication</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="authentication">Authentication</h1>
<p>One of the very first things you will want to do is to provide users with a unique experience.  For our example task list application, this could be as simple as providing a task list for the user who is logged in.  In more complex applications, this is the gateway to role-based access controls, group rules, and sharing with your friends.  In all these cases, properly identifying the user using the phone is the starting point.</p>
<h2 id="concepts">Concepts</h2>
<p>Authentication provides a process by which the user that is using the mobile device can be identified securely.  This is generally done by entering a username and password.  However, modern systems can also provide <a href="https://en.wikipedia.org/wiki/Multi-factor_authentication">multi-factor authentication</a>, send you a text message to a registered device, or <a href="https://support.apple.com/en-us/HT201371">use your fingerprint</a> as the password.</p>
<h3 id="the-oauth-process">The OAuth Process</h3>
<p>In just about every single mobile application, a process called <a href="http://oauth.net/2/">OAuth</a> is used to properly identify a user to the mobile backend.  OAuth is not an authentication mechanism in its own right.  It is used to route the authentication request to the right place and to verify that the authentication took place. There are three actors in the OAuth protocol:</p>
<ul>
<li>The <strong>Client</strong> is the application attempting to get access to the resource.</li>
<li>The <strong>Resource</strong> is the mobile backend that the client is attempting to access.</li>
<li>The <strong>Identity Provider</strong> (or IdP) is the service that is responsible for authenticating the client.</li>
</ul>
<p>At the end of the process, a cryptographically signed token is minted.  This token is added to every single subsequent request to identify the user.</p>
<h3 id="server-side-vs-client-side-authentication">Server Side vs. Client Side Authentication</h3>
<p>There are two types of authentication flow: Server-Flow and Client-Flow.  They are so named because of who controls the flow of the actual authentication.</p>
<p><img alt="Authentication Flow" src="../chapter2/img/auth-flow.PNG" /></p>
<p>Server-flow is named because the authentication flow is managed by the server through a web connection.  It is generally used in two cases:</p>
<ul>
<li>You want a simple placeholder for authentication in your mobile app while you are developing other code.</li>
<li>You are developing a web app.</li>
</ul>
<p>In the case of Server Flow:</p>
<ol>
<li>The client brings up a web view and asks for the login page from the resource.</li>
<li>The resource redirects the client to the identity provider.</li>
<li>The identity provider does the authentication before redirecting the client
   back to the resource (with an identity provider token).</li>
<li>The resource validates the identity provider token with the identity provider.</li>
<li>Finally, the resource mints a new resource token that it returns to the client.</li>
</ol>
<p>Client-flow authentication uses an IdP provided SDK to integrate a more native feel to the authentication flow.  The actual flow happens on the client, communicating only with the IdP.</p>
<ol>
<li>The client uses the IdP SDK to communicate with the identity provider.</li>
<li>The identity provider does the authentication, returning an identity provider token.</li>
<li>The client presents the identity provider token to the resource.</li>
<li>The resource validates the identity provider token with the identity provider.</li>
<li>Finally, the resource mints a new resource token that it returns to the client.</li>
</ol>
<p>For example, if you use the Facebook SDK for authentication, your app will seamlessly switch over into the Facebook app and ask you to authorize your client application before switching you back to your client application.</p>
<p>It is generally recommended that you use the IdP SDK when developing an app that will be released on the app store.  This follows the best practice provided by the majority of identity providers and provides the best experience for your end users.</p>
<h3 id="authentication-providers">Authentication Providers</h3>
<p>Azure Mobile Apps supports five identity providers natively:</p>
<ul>
<li>Azure Active Directory</li>
<li>Facebook</li>
<li>Google</li>
<li>Microsoft (MSA)</li>
<li>Twitter</li>
</ul>
<p>In addition, you can set up client-flow custom authentication that allows you to mint a ZUMO token to your specifications for any provider using a client-flow.  For example, you could use authentication providers like <a href="https://azure.microsoft.com/en-us/services/active-directory-b2c/">Azure AD B2C</a>, <a href="https://developer.linkedin.com/docs/oauth2">LinkedIn</a> or <a href="https://developer.github.com/v3/oauth/">GitHub</a>, a third-party authentication provider like  <a href="https://auth0.com/">Auth0</a>, or you could set up an identity table in your database so that you can check  username and password without an identity provider.</p>
<h2 id="adding-authentication-to-a-mobile-backend">Adding Authentication to a Mobile Backend</h2>
<p>The Azure App Service Authentication / Authorization service integrates seamlessly into an Azure Mobile Apps backend as a piece of middleware that fills in the Identity information for ASP.NET.  That means the only thing we have to worry about is authorization.  The authentication piece (determining that a user is who they say they are) is already taken care of.</p>
<p>Authorization (which is the determination of whether an authenticated user can use a specific API) can happen at either the controller level or an individual operation level.  We can add authorization to an entire table controller by adding the <code>[Authorize]</code> attribute to the table controller.  For example, here is our table controller from the first chapter with authorization required for all operations:</p>
<pre><code class="csharp">using System.Linq;
using System.Threading.Tasks;
using System.Web.Http;
using System.Web.Http.Controllers;
using System.Web.Http.OData;
using Backend.DataObjects;
using Backend.Models;
using Microsoft.Azure.Mobile.Server;

namespace Backend.Controllers
{
    [Authorize]
    public class TodoItemController : TableController&lt;TodoItem&gt;
    {
        protected override void Initialize(HttpControllerContext controllerContext)
        {
            base.Initialize(controllerContext);
            MobileServiceContext context = new MobileServiceContext();
            DomainManager = new EntityDomainManager&lt;TodoItem&gt;(context, Request);
        }

        // GET tables/TodoItem
        public IQueryable&lt;TodoItem&gt; GetAllTodoItems() =&gt; Query();

        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959
        public SingleResult&lt;TodoItem&gt; GetTodoItem(string id) =&gt; Lookup(id);

        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959
        public Task&lt;TodoItem&gt; PatchTodoItem(string id, Delta&lt;TodoItem&gt; patch) =&gt; UpdateAsync(id, patch);

        // POST tables/TodoItem
        public async Task&lt;IHttpActionResult&gt; PostTodoItem(TodoItem item)
        {
            TodoItem current = await InsertAsync(item);
            return CreatedAtRoute(&quot;Tables&quot;, new { id = current.Id }, current);
        }

        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959
        public Task DeleteTodoItem(string id) =&gt; DeleteAsync(id);
    }
}
</code></pre>

<p>Authorization can also happen on a per-operation basis by adding the <code>[Authorize]</code> attribute to a single method within the table controller.  For example, instead of requiring authorization on the entire table, we want a version where reading was possible anonymously but updating the database required authentication:</p>
<pre><code class="csharp">using System.Linq;
using System.Threading.Tasks;
using System.Web.Http;
using System.Web.Http.Controllers;
using System.Web.Http.OData;
using Backend.DataObjects;
using Backend.Models;
using Microsoft.Azure.Mobile.Server;

namespace Backend.Controllers
{
    public class TodoItemController : TableController&lt;TodoItem&gt;
    {
        protected override void Initialize(HttpControllerContext controllerContext)
        {
            base.Initialize(controllerContext);
            MobileServiceContext context = new MobileServiceContext();
            DomainManager = new EntityDomainManager&lt;TodoItem&gt;(context, Request);
        }

        // GET tables/TodoItem
        public IQueryable&lt;TodoItem&gt; GetAllTodoItems() =&gt; Query();

        // GET tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959
        public SingleResult&lt;TodoItem&gt; GetTodoItem(string id) =&gt; Lookup(id);

        // PATCH tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959
        [Authorize]
        public Task&lt;TodoItem&gt; PatchTodoItem(string id, Delta&lt;TodoItem&gt; patch) =&gt; UpdateAsync(id, patch);

        // POST tables/TodoItem
        [Authorize]
        public async Task&lt;IHttpActionResult&gt; PostTodoItem(TodoItem item)
        {
            TodoItem current = await InsertAsync(item);
            return CreatedAtRoute(&quot;Tables&quot;, new { id = current.Id }, current);
        }

        // DELETE tables/TodoItem/48D68C86-6EA6-4C25-AA33-223FC9A27959
        [Authorize]
        public Task DeleteTodoItem(string id) =&gt; DeleteAsync(id);
    }
}
</code></pre>

<p>Note that the <code>[Authorize]</code> attribute can do much more than what is provided here.  Underneath there are various parameters that you can adjust to see if the user belongs to a specific group or role.  However, the token that is checked to see if the user is authenticated does not pull in any of the other information that is normally needed for such authorization tasks.  As a result, the <code>[Authorize]</code> tags is really only checking whether a request requires authentication or not.</p>
<h2 id="configuring-an-authentication-provider">Configuring an Authentication Provider</h2>
<p>Configuration of the identity provider is very dependent on the identity provider and whether the client is using a client-flow or server-flow.  Choose one of the several options for authentication:</p>
<ul>
<li><a href="#enterprise-auth">Enterprise Authentication</a> covers Azure Active Directory.</li>
<li><a href="#social-auth">Social Authentication</a> covers Facebook, Google, Microsoft and Twitter.</li>
</ul>
<p>We can also configure authentication using custom routes.  This allows us to use other (non-supported) services or to completely customize our flow (for example, to use an existing identity database).</p>
<h2 id="enterprise-authentication"><a name="enterprise-auth"></a>Enterprise Authentication</h2>
<p>Enterprise Authentication is handled by Azure Active Directory, which is fairly commonly configured within Azure.  Every Azure subscription has a default directory associated with it that you can leverage for this section.  In addition, if your organization has an Office 365 subscription, this will likely be tied to an Azure Active Directory domain to allow enterprise sign-in.  In either case, you have a directory you can use for providing authentication to your app.</p>
<p>In general, you will need to get special permissions to update the directory. If you want to use your organizations corporate directory, then you are likely to have to get your IT department involved to set it up.</p>
<h3 id="azure-active-directory-server-flow-setup">Azure Active Directory: Server-Flow setup</h3>
<p>The Azure Active Directory server-flow is perhaps the easiest of all the authentication methods to configure.  No matter if you are doing a client flow or server flow, you need to set up the server flow first.</p>
<blockquote>
<p>We recommend that you implement Client Flow in any non-trivial application.</p>
</blockquote>
<p>If you are using your default directory and you want to add a couple of test users, you will need to set those up first.   Start by going to the <a href="https://manage.windowsazure.com/">Classic Azure Portal</a>:</p>
<p><img alt="Classic Portal" src="../chapter2/img/ent-dev-1.PNG" /></p>
<p>Click on the <strong>Default Directory</strong>, then click on <strong>USERS</strong>.  You will notice that your Azure-linked ID is already present.</p>
<p><img alt="AzureAD: Users" src="../chapter2/img/ent-dev-2.PNG" /></p>
<p>Click on <strong>Add User</strong> at the bottom of the screen.  Enter a username in the box provided before clicking on the arrow.  Then fill in the personal information and click on the arrow again.  Finally, click on <strong>create</strong>.  Note the password, before clicking on the tick.  Now you have two users - your Azure ID and the one you just created.  Note the username.  It is based on the tenant, so it will be something like <code>adrian@photoadrianoutlook.onmicrosoft.com</code>.</p>
<p>To configure your app, switch back to the regular <a href="https://portal.azure.com/">Azure Portal</a>, find your App Service, click on <strong>All Settings</strong> followed by <strong>Authentication / Authorization</strong>. Finally, select <strong>Azure Active Directory</strong>.</p>
<p><img alt="AzureAD: Configuration" src="../chapter2/img/ent-dev-3.PNG" /></p>
<p>Click on <strong>Express</strong>.  Note that all the information is filled in for you.  All you have to do is click on <strong>OK</strong>, followed by <strong>Save</strong>.</p>
<blockquote>
<p>Make sure you create the app service in the right directory / subscription.  If you have access to more than one directory, you can choose the right one by selecting it under your account drop-down in the top-right corner.</p>
</blockquote>
<p>There is also an <strong>Advanced</strong> track.  This is used in client-flow situations and in situations where you have more than one directory.  The Express flow is great for getting started quickly.</p>
<p>You can walk through a server-flow authentication to test that you have all the settings correct.  Point your browser at https://<em>yoursite</em>.azurewebsites.net/.auth/login/aad.  The browser will take you through an authentication flow before giving you a successful authentication image:</p>
<p><img alt="AzureAD: Success" src="../chapter2/img/auth-success.PNG" /></p>
<h2 id="adding-authentication-to-a-mobile-client">Adding Authentication to a Mobile Client</h2>
<p>Now that the backend is completely configured, we can move our attention to the mobile client.  We are going to be using the same mobile client that we developed in the first chapter, but we are now going to add authentication to it.  Web views are one of those items that are platform dependent. Fortunately for us, Xamarin has already thought of this and provided a facility for running platform specific code called the <a href="https://developer.xamarin.com/guides/xamarin-forms/dependency-service/">DependencyService</a>.</p>
<blockquote>
<p>If we run our application right now, clicking on the "Enter the App" button will result in an error.  You will be able to see the Unauthorized error in the debug window of Visual Studio.</p>
</blockquote>
<p>Our first step is to define an <code>Abstractions\ILoginProvider.cs</code> interface within the  shared project:</p>
<pre><code class="csharp">using Microsoft.WindowsAzure.MobileServices;
using System.Threading.Tasks;

namespace TaskList.Abstractions
{
    public interface ILoginProvider
    {
        Task LoginAsync(MobileServiceClient client);
    }
}
</code></pre>

<p>Next, we are going to extend our <code>Abstractions\ICloudService.cs</code> interface so that the main application can call the login routine:</p>
<pre><code class="csharp">using System.Threading.Tasks;

namespace TaskList.Abstractions
{
    public interface ICloudService
    {
        ICloudTable&lt;T&gt; GetTable&lt;T&gt;() where T : TableData;

        Task LoginAsync();
    }
}
</code></pre>

<p>Our code will call <code>LoginAsync()</code> in the <code>ICloudService</code>, which will get the platform-specific version of the login provider and call <code>LoginAsync()</code> there, but with our defined mobile service client.  That is defined in the <code>Services\AzureCloudService.cs</code> class:</p>
<pre><code class="csharp">using System.Threading.Tasks;
using Microsoft.WindowsAzure.MobileServices;
using TaskList.Abstractions;
using TaskList.Helpers;
using Xamarin.Forms;

namespace TaskList.Services
{
    public class AzureCloudService : ICloudService
    {
        MobileServiceClient client;

        public AzureCloudService()
        {
            client = new MobileServiceClient(Locations.AppServiceUrl);
        }

        public ICloudTable&lt;T&gt; GetTable&lt;T&gt;() where T : TableData =&gt; new AzureCloudTable&lt;T&gt;(client);

        public Task LoginAsync()
        {
            var loginProvider = DependencyService.Get&lt;ILoginProvider&gt;();
            return loginProvider.LoginAsync(client);
        }
    }
}
</code></pre>

<p>The method looks up the platform dependent version of the login provider and executes the login method, passing along the client (which we will need later).</p>
<p>In each platform-specific project, we are going to define a concrete implementation of the login provider that uses a web view to hold the actual authentication flow.  Here is the droid <code>Services\DroidLoginProvider.cs</code> (in the TaskList.Droid project):</p>
<pre><code class="csharp">using System.Threading.Tasks;
using Android.Content;
using Microsoft.WindowsAzure.MobileServices;
using TaskList.Abstractions;
using TaskList.Droid.Services;

[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]
namespace TaskList.Droid.Services
{
    public class DroidLoginProvider : ILoginProvider
    {
        Context context;

        public void Init(Context context)
        {
            this.context = context;
        }

        public async Task LoginAsync(MobileServiceClient client)
        {
            await client.LoginAsync(context, &quot;aad&quot;);
        }
    }
}
</code></pre>

<p>Let us take a closer look at this implementation.  The <code>LoginAsync()</code> method on the Azure Mobile Apps client object takes the Android context (which is normally the main window) and a provider - we can pick any of "facebook", "google", "microsoftaccount", "twitter" or "aad" depending on what we have defined in the Azure App Service.  The clever piece is the <code>Xamarin.Forms.Dependency</code> call at the top - that registers the class as a platform service so we can access it through the Xamarin dependency service.</p>
<p>Note that we need an extra initialization routine for Android that must be called prior the login provider being called to pass along the main window of the app (also known as the context).  This is done in the <code>MainActivity.cs</code> file <strong>after</strong> the Xamarin Forms initialization call.  The dependency service is not set up until after the Xamarin Forms library is initialized, so we will not be able to get the login provider reference before that point:</p>
<pre><code class="csharp">protected override void OnCreate(Bundle bundle)
{
    base.OnCreate(bundle);

    Microsoft.WindowsAzure.MobileServices.CurrentPlatform.Init();

    global::Xamarin.Forms.Forms.Init(this, bundle);

    ((DroidLoginProvider)DependencyService.Get&lt;ILoginProvider&gt;()).Init(this);

    LoadApplication(new App());
}
</code></pre>

<p>iOS is similar, but does not require the initialization step in the main startup class.  The login provider class is in <code>Services\iOSLoginProvider.cs</code> (in the <strong>TaskList.iOS</strong> project):</p>
<pre><code class="csharp">using System.Threading.Tasks;
using Microsoft.WindowsAzure.MobileServices;
using TaskList.Abstractions;
using TaskList.iOS.Services;
using UIKit;

[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]
namespace TaskList.iOS.Services
{
    public class iOSLoginProvider : ILoginProvider
    {
        public async Task LoginAsync(MobileServiceClient client)
        {
            await client.LoginAsync(RootView, &quot;aad&quot;);
        }

        public UIViewController RootView =&gt; UIApplication.SharedApplication.KeyWindow.RootViewController;
    }
}
</code></pre>

<p>Note that we are using the same pattern here for registering the concrete implementation with the dependency service, so we can get it the same way. Finally, here is the UWP <code>Services\UWPLoginProvider.cs</code> (in the TaskList.UWP project):</p>
<pre><code class="csharp">using System.Threading.Tasks;
using Microsoft.WindowsAzure.MobileServices;
using TaskList.Abstractions;
using TaskList.UWP.Services;

[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]
namespace TaskList.UWP.Services
{
    public class UWPLoginProvider : ILoginProvider
    {
        public async Task LoginAsync(MobileServiceClient client)
        {
            await client.LoginAsync(&quot;aad&quot;);
        }
    }
}
</code></pre>

<p>Now that we have all the platform-specific login routines registered, we can move on to adding the login routine to the UI.  We have already got a button on the entry page to enter the app.  It makes sense to wire up that button so that it logs us in as well. The Command for the login button is in the <code>ViewModels\EntryPageViewModel.cs</code>:</p>
<pre><code class="csharp">async Task ExecuteLoginCommand()
{
    if (IsBusy)
        return;
    IsBusy = true;

    try
    {
        var cloudService = ServiceLocator.Instance.Resolve&lt;ICloudService&gt;();
        await cloudService.LoginAsync();
        Application.Current.MainPage = new NavigationPage(new Pages.TaskList());
    }
    catch (Exception ex)
    {
        Debug.WriteLine($&quot;[ExecuteLoginCommand] Error = {ex.Message}&quot;);
    }
    finally
    {
        IsBusy = false;
    }
}
</code></pre>

<blockquote>
<p>The <code>ServiceLocator</code> class is my basic singleton handler.  It is available in the <a href="https://github.com/adrianhall/develop-mobile-apps-with-csharp-and-azure/tree/master/Chapter2">Chapter2</a> project.  It returns the concrete version of the cloud service, just like the Singleton version we defined in Chapter1.</p>
</blockquote>
<p>When you run the application, clicking on the "Enter the App" button will now present you with an Authenticate window:</p>
<p><img alt="AAD Authenticate" src="../chapter2/img/aad-logon-window.PNG" /></p>
<p>Going through the authentication process will get you to the task list again.  If the authentication process fails, then <code>LoginAsync()</code> will throw an error, which is caught at the ViewModel.  Right now, the <code>EntryPageViewModel</code> does nothing more than print a diagnostic message to the debug window of Visual Studio.</p>
<h3 id="azure-active-directory-client-flow-setup">Azure Active Directory: Client-Flow Setup</h3>
<p>Configuring Azure Active Directory for client-flow is a three-step process.  First, we need to create a WEB application.  This represents the resource: in our case, the resource is the Azure Mobile Apps backend.  Then we need to create a NATIVE application.  This represents the client: in our case, the ADAL (Active Directory Access Library) library will need this information.  Finally, we need to give the NATIVE application permission to access the WEB application.</p>
<p>It starts with configuring a server-flow to protect the resource.  We've already done that above. Then configure a "Native Application" and give it permissions to the web application:</p>
<ul>
<li>Log on to the <a href="https://manage.windowsazure.com/">Classic Portal</a>.</li>
<li>Select the <strong>Default Directory</strong> from your list of all items.</li>
<li>Click on the <strong>APPLICATIONS</strong> tab.</li>
</ul>
<p><img alt="Azure AD Apps" src="../chapter2/img/aad-apps-1.PNG" /></p>
<ul>
<li>Note that our existing web application is already there.  You will see more applications, depending on what you have set up.  In this example, I have Visual Studio Team Services and Office 365 set up.</li>
<li>Click on the <strong>ADD</strong> button at the bottom of the page.</li>
</ul>
<p><img alt="Azure AD Apps - Add an App" src="../chapter2/img/aad-apps-2.PNG" /></p>
<ul>
<li>Click on <strong>Add an application my organization is developing</strong>.</li>
</ul>
<p><img alt="Azure AD Apps - Add a Native App" src="../chapter2/img/aad-apps-3.PNG" /></p>
<ul>
<li>Enter a name for the app registration, and select <strong>NATIVE CLIENT APPLICATION</strong>.</li>
<li>Click on the Next arrow.</li>
<li>Enter a valid URI - it can be anything, but it has to be valid</li>
</ul>
<p><img alt="Azure AD Apps - Native App Redirect URI" src="../chapter2/img/aad-apps-4.PNG" /></p>
<ul>
<li>Click on the tick to create the application.</li>
<li>The wizard will close, but you will be brought to the app configuration.  Click on the <strong>CONFIGURE</strong> tab.</li>
</ul>
<p><img alt="Azure AD Apps - Native App Configuration" src="../chapter2/img/aad-apps-5.PNG" /></p>
<ul>
<li>Add a Redirect URI of the form: <code>https://yoursite.azurewebsites.net/.auth/login/done</code>.</li>
</ul>
<p><img alt="Azure AD Apps - Native App Redirect URI Added" src="../chapter2/img/aad-apps-6.PNG" /></p>
<ul>
<li>At the bottom of the page is the <strong>permissions to other applications</strong> section.  Click on the <strong>Add application</strong> button.</li>
</ul>
<p><img alt="Azure AD Apps - Permissions (1)" src="../chapter2/img/aad-apps-7.PNG" /></p>
<ul>
<li>Click on the <strong>SHOW</strong> drop-down and select <strong>All Apps</strong>, then click on the tick next to the search box.</li>
<li>Click on the web application that you set up during the server-flow configuration, then click on the  tick in the lower-right corner.</li>
</ul>
<p><img alt="Azure AD Apps - Permissions (2)" src="../chapter2/img/aad-apps-8.PNG" /></p>
<ul>
<li>Click on <strong>Delegated Permissions</strong> next to the web application.  Check the box next to <strong>Access</strong>, then click on <strong>Save</strong> at the bottom of the screen.</li>
</ul>
<p><img alt="Azure AD Apps - Permissions (3)" src="../chapter2/img/aad-apps-9.PNG" /></p>
<p>At this point the application configuration will be saved.</p>
<p>So, what did we just do there?  We created a new Azure AD app for the native application.  We then gave permission for the native application to access resources that are protected by the web application.  In our Azure App Service, we configured the service so that the Azure AD web application is used to protect our resources.  The net effect is that our native application OR our web application can access the App Service resources that are protected via the <code>[Authorize]</code> attribute.</p>
<p>Before continuing, you will need the <strong>Client ID</strong> and the <strong>Redirect URI</strong> for the NATIVE application. You can enter these into the <code>Helpers\Locations.cs</code> file in the shared project:</p>
<pre><code class="csharp">namespace TaskList.Helpers
{
    public static class Locations
    {
        public static readonly string AppServiceUrl = &quot;https://the-book.azurewebsites.net&quot;;

        public static readonly string AadClientId = &quot;b61c7d68-2086-43a1-a8c9-d93c5732cc84&quot;;

        public static readonly string AadRedirectUri = &quot;https://the-book.azurewebsites.net/.auth/login/done&quot;;

        public static readonly string AadAuthority = &quot;https://login.windows.net/photoadrianoutlook.onmicrosoft.com&quot;;
    }
}
</code></pre>

<p>The <strong>AadClientId</strong> and <strong>AadRedirectUri</strong> must match what we have configured in Azure AD for the native app.  The other piece of information we need to add is the Azure AD Authority for the directory.  If you click on the <strong>DOMAINS</strong> tab, it will generally tell you what domain you are in. The Authority is just a path on the <code>https://login.windows.net</code> that corresponds to your domain.  There is also a GUID version of this domain.  You can find the GUID by looking at the <strong>View Endpoints</strong> in the <strong>APPLICATIONS</strong> tab.  Look at the first path section of most all the endpoints.</p>
<p>Add the <strong>Microsoft.IdentityModel.Clients.ActiveDirectory</strong> NuGet package using <strong>Manage NuGet Packages...</strong> to each platform project.  This package contains the ADAL library as a portable class library.</p>
<p><img alt="Azure AD - Add ADAL Library" src="../chapter2/img/adal-client-1.PNG" /></p>
<p>Now you can add the client flow to each project.  Start with the login provider in the <strong>TaskList.UWP</strong> project, located in the <code>Services\UWPLoginProvider.cs</code> file:</p>
<pre><code class="csharp">using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.IdentityModel.Clients.ActiveDirectory;
using Microsoft.WindowsAzure.MobileServices;
using Newtonsoft.Json.Linq;
using TaskList.Abstractions;
using TaskList.Helpers;
using TaskList.UWP.Services;

[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]
namespace TaskList.UWP.Services
{
    public class UWPLoginProvider : ILoginProvider
    {

        /// &lt;summary&gt;
        /// Login via ADAL
        /// &lt;/summary&gt;
        /// &lt;returns&gt;(async) token from the ADAL process&lt;/returns&gt;
        public async Task&lt;string&gt; LoginADALAsync()
        {
            Uri returnUri = new Uri(Locations.AadRedirectUri);

            var authContext = new AuthenticationContext(Locations.AadAuthority);
            if (authContext.TokenCache.ReadItems().Count() &gt; 0)
            {
                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);
            }
            var authResult = await authContext.AcquireTokenAsync(
                Locations.AppServiceUrl, /* The resource we want to access  */
                Locations.AadClientId,   /* The Client ID of the Native App */
                returnUri,               /* The Return URI we configured    */
                new PlatformParameters(PromptBehavior.Auto, false));
            return authResult.AccessToken;
        }


        public async Task LoginAsync(MobileServiceClient client)
        {
            // Client Flow
            var accessToken = await LoginADALAsync();
            var zumoPayload = new JObject();
            zumoPayload[&quot;access_token&quot;] = accessToken;
            await client.LoginAsync(&quot;aad&quot;, zumoPayload);

            // Server-Flow Version
            // await client.LoginAsync(&quot;aad&quot;);
        }
    }
}
</code></pre>

<p>The <code>LoginADALAsync()</code> method does the actual client-flow - using the ADAL library to authenticate the user and return the access token.  The <code>LoginAsync()</code> method initiates the client-flow.  It uses the token it receives from the client-flow to log in to the App Service, by packaging the token into a JSON object.  I have placed the client and server flow next to each other so you can compare the two.</p>
<p>In the <strong>TaskList.Droid</strong> project, we need to deal with the <code>Context</code>, as is common with Android libraries.  The client flow in <code>Services\DroidLoginProvider.cs</code> is remarkably similar though:</p>
<pre><code class="csharp">using System;
using System.Linq;
using System.Threading.Tasks;
using Android.App;
using Android.Content;
using Microsoft.IdentityModel.Clients.ActiveDirectory;
using Microsoft.WindowsAzure.MobileServices;
using Newtonsoft.Json.Linq;
using TaskList.Abstractions;
using TaskList.Droid.Services;
using TaskList.Helpers;

[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]
namespace TaskList.Droid.Services
{
    public class DroidLoginProvider : ILoginProvider
    {
        Context context;

        public void Init(Context context)
        {
            this.context = context;
        }

        /// &lt;summary&gt;
        /// Login via ADAL
        /// &lt;/summary&gt;
        /// &lt;returns&gt;(async) token from the ADAL process&lt;/returns&gt;
        public async Task&lt;string&gt; LoginADALAsync()
        {
            Uri returnUri = new Uri(Locations.AadRedirectUri);

            var authContext = new AuthenticationContext(Locations.AadAuthority);
            if (authContext.TokenCache.ReadItems().Count() &gt; 0)
            {
                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);
            }
            var authResult = await authContext.AcquireTokenAsync(
                Locations.AppServiceUrl, /* The resource we want to access  */
                Locations.AadClientId,   /* The Client ID of the Native App */
                returnUri,               /* The Return URI we configured    */
                new PlatformParameters((Activity)context));
            return authResult.AccessToken;
        }

        public async Task LoginAsync(MobileServiceClient client)
        {
            // Client Flow
            var accessToken = await LoginADALAsync();
            var zumoPayload = new JObject();
            zumoPayload[&quot;access_token&quot;] = accessToken;
            await client.LoginAsync(&quot;aad&quot;, zumoPayload);

            // Server-Flow Version
            // await client.LoginAsync(context, &quot;aad&quot;);
        }
    }
}
</code></pre>

<p>The only real difference between this one and the Universal Windows edition is the PlatformParameters. We need to pass in the context of the MainActivity (which is passed in through the <code>Init()</code> call).  However, we must also handle the response from the ADAL library.  This is done in <code>MainActivity.cs</code>. Add the following method to the <code>MainActivity</code> class:</p>
<pre><code class="csharp">protected override void OnActivityResult(int requestCode, Result resultCode, Intent data)
{
    base.OnActivityResult(requestCode, resultCode, data);
    AuthenticationAgentContinuationHelper.SetAuthenticationAgentContinuationEventArgs(requestCode, resultCode, data);
}
</code></pre>

<p>Finally, the iOS version also requires access to the root view, so its <code>PlatformParameters</code> are also slightly different.  Here is <code>Services\iOSLoginProvider.cs</code>:</p>
<pre><code class="csharp">using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.IdentityModel.Clients.ActiveDirectory;
using Microsoft.WindowsAzure.MobileServices;
using Newtonsoft.Json.Linq;
using TaskList.Abstractions;
using TaskList.Helpers;
using TaskList.iOS.Services;
using UIKit;

[assembly: Xamarin.Forms.Dependency(typeof(iOSLoginProvider))]
namespace TaskList.iOS.Services
{
    public class iOSLoginProvider : ILoginProvider
    {
        /// &lt;summary&gt;
        /// Login via ADAL
        /// &lt;/summary&gt;
        /// &lt;returns&gt;(async) token from the ADAL process&lt;/returns&gt;
        public async Task&lt;string&gt; LoginADALAsync(UIViewController view)
        {
            Uri returnUri = new Uri(Locations.AadRedirectUri);

            var authContext = new AuthenticationContext(Locations.AadAuthority);
            if (authContext.TokenCache.ReadItems().Count() &gt; 0)
            {
                authContext = new AuthenticationContext(authContext.TokenCache.ReadItems().First().Authority);
            }
            var authResult = await authContext.AcquireTokenAsync(
                Locations.AppServiceUrl, /* The resource we want to access  */
                Locations.AadClientId,   /* The Client ID of the Native App */
                returnUri,               /* The Return URI we configured    */
                new PlatformParameters(view));
            return authResult.AccessToken;
        }

        public async Task LoginAsync(MobileServiceClient client)
        {
            var rootView = UIApplication.SharedApplication.KeyWindow.RootViewController;

            // Client Flow
            var accessToken = await LoginADALAsync(rootView);
            var zumoPayload = new JObject();
            zumoPayload[&quot;access_token&quot;] = accessToken;
            await client.LoginAsync(&quot;aad&quot;, zumoPayload);

            // Server Flow
            //await client.LoginAsync(rootView, &quot;aad&quot;);
        }
    }
}
</code></pre>

<p>Note that we can balance the needs of each platform by using the dependency service.  The code that is unique to the platform is minimized and stored with the platform.</p>
<p>If you aren't interested in social authentication (Facebook, Google, Microsoft or Twitter authentication providers), you can <a href="#skip-social-auth">skip the social-auth section</a>.</p>
<h2 id="social-authentication"><a name="social-auth">Social Authentication</a></h2>
<p>Azure App Service provides built-in support for Facebook, Google, Microsoft and Twitter.  Irrespective of whether you intend to use server-flow or client-flow, you will need to configure the Azure App Service Authentication / Authorization service.  The method is pretty similar in each case:</p>
<ol>
<li>Obtain a Developer Account for the provider.</li>
<li>Create a new application, obtaining a Client ID and Secret.</li>
<li>Turn on Azure App Service Authentication.</li>
<li>Enter the Client ID and Secret into the specific provider setup.</li>
<li>Save the configuration.</li>
</ol>
<p>Before you start any of this, create a new Azure Mobile Apps as we described in [Chapter 1][int-intro].  If you want a site to deploy for the configuration, the <strong>Backend</strong> project in the <a href="https://github.com/adrianhall/develop-mobile-apps-with-csharp-and-azure/tree/master/Chapter2">Chapter2</a> solution is pre-configured for authorization. You just need to deploy it to Azure App Service.</p>
<h3 id="facebook-authentication">Facebook Authentication</h3>
<p>I am going to assume you have a Facebook account already.  If you do not have a Facebook account, go to <a href="https://facebook.com/">Facebook</a> and sign up.  All your friends are likely there already!  Now log in to the <a href="https://developers.facebook.com/">Facebook Developers</a> web site.  Create a new Facebook application:</p>
<p><img alt="Facebook Developers" src="../chapter2/img/fb-dev-1.PNG" /></p>
<p><strong>Note</strong>: Facebook updates the look and feel of their developer site on a regular basis.  As a result, the screen shots I have provided here may be different.  If in doubt, follow the bullet descriptions to find your way.</p>
<blockquote>
<p>If you are not already registered, click on the drop-down in the top-right corner and <strong>Register as a Developer</strong> before continuing.</p>
</blockquote>
<ul>
<li>Click on the <strong>My Apps</strong> link in the top right corner of the screen.</li>
<li>Click on <strong>Create a New App</strong>.</li>
<li>Fill in the form:</li>
</ul>
<p><img alt="Create a new Application" src="../chapter2/img/fb-dev-2.PNG" /></p>
<ul>
<li>
<p>If required, verify your account according to the instructions.  This usually involves adding a credit card number or verifying your mobile phone number.</p>
</li>
<li>
<p>Click on the <strong>Get Started</strong> button next to <strong>Facebook Login</strong>.</p>
</li>
</ul>
<p><img alt="Facebook Login" src="../chapter2/img/fb-dev-3.PNG" /></p>
<ul>
<li>Enter your application URL + <code>/.auth/login/facebook/callback</code> in the <strong>Valid OAuth redirect URIs</strong>.</li>
</ul>
<p><img alt="Facebook OAuth redirect URIs" src="../chapter2/img/fb-dev-4.PNG" /></p>
<ul>
<li>Click on <strong>Save Changes</strong>.</li>
<li>Click on the <strong>Settings</strong> -&gt; <strong>Basic</strong> in the left hand side-bar.</li>
<li>Click on the <strong>Show</strong> button next to the App Secret</li>
</ul>
<p>Now that you have the <strong>App ID</strong> and <strong>App Secret</strong>, you can continue configuration of your app within the <a href="https://portal.azure.com/">Azure Portal</a>.</p>
<ul>
<li>Open up your App Service by clicking on <strong>All Resources</strong> or <strong>App Services</strong> followed by the name of your app service.</li>
<li>In the <strong>Settings</strong> blade, click on <strong>Authentication / Authorization</strong> which is under <strong>Features</strong>.</li>
<li>Turn <strong>App Service Authentication</strong> to <strong>On</strong>.</li>
<li>In the <strong>Action to take when request is not authenticated</strong>, select <strong>Allow Request (no action)</strong>.</li>
</ul>
<blockquote>
<p>It is very tempting to choose <strong>Log in with Facebook</strong>.  However, you need to avoid this.  Selecting this option will mean that all requests need to be authenticated and you will not get the information about the identity on the back end.  Selecting <strong>Allow Request</strong> means your app is in charge of what gets authenticated and what does not require authentication.</p>
</blockquote>
<ul>
<li>Click on <strong>Facebook</strong> (which should show <em>Not Configured</em>).</li>
<li>Cut and Paste the <strong>App ID</strong> and <strong>App Secret</strong> into the boxes provided.</li>
<li>Select <strong>public_profile</strong> and <strong>email</strong> for Scopes.</li>
</ul>
<blockquote>
<p>Note that if you request anything but public_profile, user_friends, and email, your app will need further review by Facebook, which will take time.  This process is not worth it for test apps like this one.</p>
</blockquote>
<ul>
<li>Click on <strong>OK</strong> (at the bottom of the blade) to close the Facebook configuration blade.</li>
<li>Click on <strong>Save</strong> (at the top of the blade) to save your Authentication changes.</li>
</ul>
<p>You can test your authentication process by browsing to https://<em>yoursite</em>.azurewebsites.net/.auth/login/facebook; this is the same endpoint that the Azure Mobile Apps Client SDK calls when it is time to integrate authentication into the mobile client.</p>
<p><img alt="Confirming Facebook Authentication" src="../chapter2/img/fb-dev-5.PNG" /></p>
<p>If you are not logged in to facebook already, you will be prompted for your facebook credentials first.  Finally, here is your happy page - the page that signifies you have done everything right:</p>
<p><img alt="Authentication Succeeded" src="../chapter2/img/auth-success.PNG" /></p>
<blockquote>
<p><strong>Minimal Permissions</strong>  Every single OAuth provider will ask you what sort of information you want to have access to.  These "claims" translate into permissions.  The more permissions you request, the less likely the user is going to accept them.  Be a good net citizen and only request the information you are actually going to use.</p>
</blockquote>
<h3 id="google-authentication">Google Authentication</h3>
<p>It should be no shock that you need a <a href="https://accounts.google.com/">Google Account</a> to get started.  If you do not have one already (or you want a different account for your development activities), create a new account now.  Then log in to the <a href="https://console.developers.google.com/iam-admin/projects">Google Developer Portal</a>.  Click on the <strong>Create Project</strong> link at the top:</p>
<p><img alt="New Google Project" src="../chapter2/img/goog-dev-1.PNG" /></p>
<p>Enter a nice name (like mine) and click on <strong>Create</strong>.  The screen will show the progress and eventually the project will be listed in the <strong>All Projects</strong> list.  It takes about 30 seconds to create a project.  Once you have your Google project, click on it to see all the wonderful things you can add to your project:</p>
<p><img alt="Google APIs Library" src="../chapter2/img/goog-dev-2.PNG" /></p>
<p>There is no "Google Login" that can guide you here.  The API you need to add is called <strong>Google+</strong> and is listed under the <strong>Social APIs</strong>.  Click on it, then click on <strong>Enable</strong> at the top of the screen.</p>
<p>Just because it is enabled does not mean you automatically get to use it.  Click on <strong>Credentials</strong> link in the left-hand side bar.  You will also see a "Go to Credentials" button at the top of the screen, but it does not take you to the same screen, so do not click it.</p>
<p>On the Crendetials screen, click on the <strong>OAuth consent screen</strong> tab:</p>
<p><img alt="Google OAuth Credential" src="../chapter2/img/goog-dev-3.PNG" /></p>
<p>Fill in the form and click on <strong>Save</strong>.  This brings up the next step - creating credentials.  Click on the <strong>Create Credentials</strong> button.  This pops up a drop-down menu.  You want the <strong>OAuth Client ID</strong>.</p>
<p><img alt="Google Create Credentials" src="../chapter2/img/goog-dev-4.PNG" /></p>
<p>The specific type of client ID you want is a <strong>Web Application</strong>.  The server flow version of the application is a web-based form authentication, which matches the <strong>Web Application</strong> version of the Client ID.</p>
<p>When you select <strong>Web Application</strong>, you will get another form:</p>
<p><img alt="Google Create Client ID" src="../chapter2/img/goog-dev-5.PNG" /></p>
<p>Enter the URL of your App Service in the <strong>Authorized JavaScript origins</strong> box, and the URL + <code>/.auth/login/google/callback</code> into the <strong>Authorized redirect URIs</strong> box, then click on <strong>Create</strong>.</p>
<blockquote>
<p>Google is one of those providers that requires authentication redirect URIs to be secure - so ensure you use the https version of your URL.</p>
</blockquote>
<p>At this point, Google will show you the Client ID and Client Secret for your app.  You can also get the Client ID and Client Secret from the interface by clicking on the <strong>Credentials</strong> link on the left-hand side bar.</p>
<p>The process from here is practically the same as Facebook.  Open your App Service within the Azure Portal, click on <strong>All Settings</strong>, then <strong>Authentication / Authorization</strong> and finally <strong>Google</strong> (assuming you have already turned on the authentication service).  Cut and paste the Client ID and Client Secret
into the boxes provided.  Click on <strong>OK</strong> (at the bottom) followed by <strong>Save</strong> (at the top of the page).</p>
<blockquote>
<p>You can define multiple providers at the same time.  The code in the client determines what authentication mechanism gets used.</p>
</blockquote>
<p>You can test this just like Facebook.  Go to https://<em>yoursite</em>/.auth/login/google with your browser.  You should get something like the following:</p>
<p><img alt="Confirming Google Authentication" src="../chapter2/img/goog-dev-6.PNG" /></p>
<p>Confirming here should get us to the same happy screen we achieved with Facebook.</p>
<p>If you happen to mis-type the Authorized redirect URI, Google will tell you that the URI is wrong.  I inevitably swap http for https.  When this happens, it is an easy fix, but you have to wait a few minutes before the authentication system updates itself.</p>
<h3 id="microsoft-account-authentication">Microsoft Account Authentication</h3>
<p>The advantage of the Microsoft Account (or MSA, as it is known) is that you already have an account - you need one for Azure.  So this is the first time I am not going to explicitly tell you to sign up for an account.</p>
<p>Your first step is to go to the <a href="https://apps.dev.microsoft.com/?mkt=en-us#/appList">Microsoft Account Developer Center</a> and log on with your Microsoft account.  You should use the same one as you use for Azure, but it is not required.</p>
<p><img alt="Microsoft Account Developer Center" src="../chapter2/img/msa-dev-1.PNG" /></p>
<p>Just to confuse us, there are two <strong>Add an App</strong> buttons. Strangely, they are different. Click on the one next to <strong>My applications</strong>.</p>
<p><img alt="MSA: Create an application" src="../chapter2/img/msa-dev-2.PNG" /></p>
<p>Enter an awesome name and click on <strong>Create application</strong>.</p>
<p><img alt="MSA: Add a Platform" src="../chapter2/img/msa-dev-3.PNG" /></p>
<p>Click on <strong>Add Platform</strong>, followed by <strong>Web</strong>.  In the <strong>Redirect URIs</strong>, enter your app URL + <code>/.auth/login/microsoftaccount/callback</code>. Then click on <strong>Save</strong>.</p>
<p><img alt="MSA: Redirect URI" src="../chapter2/img/msa-dev-4.PNG" /></p>
<p>Now click on <strong>Generate New Password</strong> under <strong>Application Secrets</strong>.</p>
<p><img alt="MSA: New password" src="../chapter2/img/msa-dev-5.PNG" /></p>
<p>Unlike the other social providers, this is the only time you will get to see your client secret, so make a note of it or cut and paste it into a notepad.  Once you have it copied somewhere, click on <strong>OK</strong>, followed by <strong>Save</strong>.</p>
<p>You now have all the information you need to configure the Microsoft Account section within your App Server Authentication / Authorization.  The Client ID you need to enter is the Application ID and the Client Secret is the password you just copied somewhere.</p>
<p><img alt="MSA: Configuration of App Service" src="../chapter2/img/msa-dev-6.PNG" /></p>
<p>Note that you have to choose claims that you want to read.  The <strong>wl.basic</strong> and <strong>wl.emails</strong> will give you enough information to get started with this tutorial.</p>
<p>Click on <strong>OK</strong> (at the bottom), followed by <strong>Save</strong> (at the top).  You can test the settings by pointing your browser to https://<em>yoursite</em>.azurewebsites.net/.auth/login/microsoftaccount.  You will see what should be a normal claims request page:</p>
<p><img alt="MSA: Claims Request" src="../chapter2/img/msa-dev-7.PNG" /></p>
<p>Clicking on <strong>Yes</strong> should take you to the normal success page.</p>
<h3 id="twitter-authentication">Twitter Authentication</h3>
<p>I hope you are seeing that all the OAuth providers take a very similar route to configuring their service.  The semantics of the service are slightly different in each case.  Twitter is no different.  As you might expect, before continuing, sign up for <a href="https://twitter.com/">Twitter</a>.  Once you have signed up, the <a href="https://apps.twitter.com/">Twitter Developers Portal</a> is your next stop.  Once there, you can click on <strong>Create New App</strong>:</p>
<p><img alt="Twitter: New App" src="../chapter2/img/twtr-dev-1.PNG" /></p>
<p>Most of the fields are self-explanatory.  The <strong>Callback URL</strong> is the same thing that the other social providers have called the Redirect URL.  The appropriate value is your app URL + <code>/.auth/login/twitter/callback</code>.  There is a legal agreement at the bottom of the page, then you can click on <strong>Create your Twitter application</strong> button.</p>
<blockquote>
<p>All social authentication providers have some sort of legal agreement that governs their use.  In general, demo or PoC apps are fair use.  However, you should get a legal opinion before using a social authentication provider in a production app.</p>
</blockquote>
<p>Once you have created the app, you will get a tabbed display with all the settings.  Click on the <strong>Keys and Access Tokens</strong> tab:</p>
<p><img alt="Twitter: Keys" src="../chapter2/img/twtr-dev-2.PNG" /></p>
<p>Note the values for the <strong>Consumer Key (API Key)</strong> and <strong>Consumer Secret (API Secret)</strong>.  They get entered into the Azure Portal.</p>
<blockquote>
<p>There is a check box in the <strong>Settings</strong> tab that says <em>Allow this application to be used to Sign in with Twitter</em>.  At the time of writing, this is checked by default.  However, if you find you can not log in for some reason, then ensure this checkbox is checked.</p>
</blockquote>
<p>Back in the Azure Portal, select your app service, then <strong>All Settings</strong>, <strong>Authentication / Authorization</strong>, and finally <strong>Twitter</strong> (assuming you have already turned Authentication on).  You can now cut and paste the Consumer Key and Consumer Secret into the appropriate boxes, before clicking on <strong>OK</strong> (at the bottom) followed by <strong>Save</strong> (at the top).</p>
<p>As with the other providers, you should test the authentication flow by pointing your browser to https://<em>yoursite</em>.azurewebsites.net/.auth/login/twitter.</p>
<p><img alt="Twitter: Authorize App" src="../chapter2/img/twtr-dev-3.PNG" /></p>
<p>Clicking on <strong>Authorize app</strong> should show you our normal successful authentication screen.</p>
<p>The social authentication providers should now all be configured to handle a web-based or server-flow authentication request.  There are times when configuring a client-flow authentication is different.  We will point those out when we get to them.</p>
<blockquote>
<p>I'm going to assume you have [returned to the Concepts page][int-concepts] and added the client code for a server flow before continuing.</p>
</blockquote>
<h3 id="client-flow-for-social-providers"><a name="clientflow"></a> Client-Flow for Social Providers</h3>
<p>In each of the social providers, the identity provider SDK (provided by Facebook, Google, or Twitter) will need to be integrated.  In general, these SDKs are provided for a native platform (Objective-C or Swift for iOS, Java for Android), use callbacks or delegates (as is common practice in native libraries) and are thus more complicated to integrate with your mobile client than those that have a C#/.NET SDK delivered on NuGet.</p>
<p>The reward for doing so are a more integrated experience on mobile devices.  For example, if you integrate the Google Play Services SDK in an Android app, the app will seamlessly authenticate itself with the connected Google account in the background, avoiding the need for repeatedly authenticating the client.  It may ask for a fingerprint instead if the app is not trusted.  If you integrate the Facebook SDK, then the app will automatically switch to the Facebook app and ask you to approve the authentication request there instead of authenticating the user through a web view.  Both of these provide a more integrated experience for the end user, so this work is well worth pursuing.</p>
<p>As an example, here is an implementation of the Facebook authentication using client flow.  I've implemented this using the <code>Xamarin.Facebook.iOS</code> library, which can be downloaded and installed into the iOS project from NuGet.  The <code>Services\iOSLoginProvider.cs</code> contains the following:</p>
<pre><code class="csharp">        #region Facebook Client Flow
        private TaskCompletionSource&lt;string&gt; fbtcs;

        public async Task&lt;string&gt; LoginFacebookAsync()
        {
            fbtcs = new TaskCompletionSource&lt;string&gt;();
            var loginManager = new LoginManager();

            loginManager.LogInWithReadPermissions(new[] { &quot;public_profile&quot; }, RootView, LoginTokenHandler);
            return await fbtcs.Task;
        }

        private void LoginTokenHandler(LoginManagerLoginResult loginResult, NSError error)
        {
            if (loginResult.Token != null)
            {
                fbtcs.TrySetResult(loginResult.Token.TokenString);
            }
            else
            {
                fbtcs.TrySetException(new Exception(&quot;Facebook Client Flow Login Failed&quot;));
            }
        }
        #endregion
</code></pre>

<p>Note the use of a <code>TaskCompletionSource&lt;&gt;()</code> here.  This is used often to convert callback APIs into awaitable APIs.  We set off the async call with the callback, then await on the completion (which is signified by the <code>TaskCompletionSource</code>).  When the callback is called, it sets the value of the <code>TaskCompletionSource</code> (or causes an exception) and that causes the task to complete.</p>
<p>The <code>LoginAsync()</code> method can now be updated like this:</p>
<pre><code class="csharp">        public async Task LoginAsync(MobileServiceClient client)
        {
            var accessToken = await LoginFacebookAsync();

            var zumoPayload = new JObject();
            zumoPayload[&quot;access_token&quot;] = accessToken;
            await client.LoginAsync(&quot;facebook&quot;, zumoPayload);
        }

        public UIViewController RootView =&gt; UIApplication.SharedApplication.KeyWindow.RootViewController;
</code></pre>

<p>With this version, clicking on the login button will seamlessly switch into the Facebook application and ask the user to confirm the request, before switching back authenticated.</p>
<h2 id="what-is-in-a-jwt"><a name="skip-social-auth"></a>What is in a JWT</h2>
<p>At this point you will have the "Authentication Success" screen - perhaps several times.  If you bring up the Developer Tools for your browser, you can take a look at the token that is being minted for the authentication session.  Take a look at the URL on the "successful authentication" page.</p>
<p><img alt="The JWT" src="../chapter2/img/jwt-1.PNG" /></p>
<p>The authentication token is clearly marked (after you strip away the URL encoding).  You can use a <a href="http://meyerweb.com/eric/tools/dencoder/">URL Decoder / Encoder</a> - just cut and paste the entire URL into the box and click on <strong>Decode</strong>.  Note that the token is actually a JSON object.  You can now easily extract the <strong>authenticationToken</strong> field from the JSON object.</p>
<p><img alt="The JWT Revealed" src="../chapter2/img/jwt-2.PNG" /></p>
<p>Technically, the authentication token is a <a href="https://openid.net/specs/draft-jones-json-web-token-07.html">JSON Web Token</a>.  This is a mechanism for transferring claims between two systems securely.  The JWT is a cryptographically signed JSON object.  You can decode the JWT using the <a href="https://jwt.io">jwt.io tool</a>.  Cut and paste the authentication token into the <strong>Encoded</strong> box and it will be decoded.</p>
<p><img alt="The JWT Decoded" src="../chapter2/img/jwt-3.PNG" /></p>
<p>Note that the contents of the JWT are revealed even without knowing the secret.  However, we have not supplied a secret.  The secret is kept at the resource - in this case, your app service.  However, we can already see the issuer and audience (in this case, they are both set to your app service address), the identity provider that was used and a subject.</p>
<p>Technically, the JWT can include any data and there are some that place just about everything about the user in the JWT.  App Service keeps the amount of data small because the client will be sending the JWT with every request.  Imagine adding a few kilobytes to every single request that the client makes.  The bandwidth usage will add up quickly, and your app will be known as a bandwidth hog.</p>
<p>However, there are some fields that are pretty universal.  Your JWT should always have the following fields:</p>
<ul>
<li>sub = Subject (the identifier for the token)</li>
<li>exp = Expiry (when the token expires)</li>
<li>nbf = Not Before (the earliest point in time the token is valid)</li>
<li>iss = Issuer (the site that issued the token)</li>
<li>aud = Audience (who is the token for)</li>
</ul>
<p>The timestamps (exp and nbf) are all UNIX timestamps (i.e. the number of seconds since January 1, 1970).</p>
<p>App Service adds to this:</p>
<ul>
<li>stable_sid = Security Id of the user</li>
<li>idp = the IdP that was used in the authentication request</li>
<li>ver = the Version of the token</li>
</ul>
<p>App Service will be able to validate any token provided to it when presented in an X-ZUMO-AUTH header.  If you are using Azure Active Directory, you can also use the more standard Bearer Authorization header.  If the token does not match, then the X-ZUMO-AUTH header will be stripped from the request before the request is passed to your site.</p>
<h2 id="testing-authentication-without-a-client">Testing Authentication without a Client</h2>
<p>Testing your site without a client requires a REST client.  I use <a href="https://www.getpostman.com/">Postman</a>, which is based on Google Chrome.  If you use Firefox, you might want to take a look at <a href="https://addons.mozilla.org/en-US/firefox/addon/restclient/">RESTClient</a>.  Telerik also distributes a web debugging proxy called <a href="http://www.telerik.com/blogs/api-testing-with-telerik-fiddler">Fiddler</a> that can do API testing.  To test the server, we will need a token.  We can get one by testing authentication configuration by pointing the browser to <code>/.auth/login/aad</code>.  The return URL will contain a token.</p>
<blockquote>
<p>You can test any of the supported identity providers by replacing <em>aad</em> with the authentication provider name: facebook, google, microsoftaccount and twitter are possibilities here.</p>
</blockquote>
<p>We can then do a request to <code>/tables/todoitem</code> to try and obtain the list of current tasks.  We will need to add two headers:</p>
<ul>
<li><code>ZUMO-API-VERSION</code> should contain a value of <code>2.0.0</code>.</li>
<li><code>X-ZUMO-AUTH</code> should contain the token you received.</li>
</ul>
<p>My first request shows authentication failing:</p>
<p><img alt="Authentication Failing" src="../chapter2/img/testing-auth-failed.PNG" /></p>
<p>Go through one of the authentication flows and copy the authentication token.  In Postman, add a new header called <code>X-ZUMO-AUTH</code> and paste the authentication token in.</p>
<p><img alt="Authentication Success" src="../chapter2/img/testing-auth-success.PNG" /></p>
<p>Note that we have tested all this without touching the client.  Separating the backend operations from the client operations means we can be sure of where the inevitable bug that creeps in is located.  We have verified that we can do each authentication flow on the server side and that the server is properly rejecting unauthenticated requests, plus it is properly returning data when authenticated requests are issued.</p>
<h2 id="developing-locally">Developing Locally</h2>
<p>One would normally be able to run the ASP.NET backend locally and get full functionality without authentication.  However, authentication puts a stop to that because the redirect URLs, secrets and other authentication configuration settings only work with a known endpoint.  To alleviate that, Azure Mobile Apps allows you to run a local server while using an authentication endpoint in Azure App Service.  When the authentication transaction takes place, it is taking place against the Azure App Service.   When it is not doing the OAuth transaction, however, it is operating against a local server.</p>
<p>Setting this up requires a little bit of local machine configuration and a change to the configuration of your client.</p>
<h3 id="update-your-local-development-environment">Update your Local Development Environment</h3>
<p>The first step in this process is to make your local IIS development environment look more like the Azure App Service, particularly in reference to the authentication settings.  This means setting up a few app settings that should be pulled from your App Service.</p>
<ul>
<li>Log on to the <a href="https://portal.azure.com/">Azure Portal</a>.</li>
<li>Select your App Service from the <strong>App Services</strong> list.</li>
<li>Click on <strong>Tools</strong>, then <strong>Kudu</strong>, then <strong>Go</strong>.</li>
</ul>
<p>Kudu is the backend debug console for Azure App Service and there is a lot you can do here.  Of note in this instance is that you can gain access to the keys and audience for your App Service.</p>
<ul>
<li>Click on <strong>Environment</strong> in the top banner.</li>
<li>Click on <strong>Environment variables</strong>.</li>
<li>Scroll down to the environment variables starting with <strong>WEBSITE_AUTH</strong>.</li>
<li>Make a note of the <strong>WEBSITE_AUTH_SIGNING_KEY</strong> and <strong>WEBSITE_AUTH_ALLOWED_AUDIENCES</strong> values.</li>
</ul>
<p>Add the following to your project Web.config <code>&lt;appSettings&gt;</code> section:</p>
<pre><code class="xml">  &lt;appSettings&gt;
    &lt;add key=&quot;PreserveLoginUrl&quot; value=&quot;true&quot; /&gt;
    &lt;add key=&quot;MS_SigningKey&quot; value=&quot;Overridden by portal settings&quot; /&gt;
    &lt;add key=&quot;EMA_RuntimeUrl&quot; value=&quot;Overridden by portal settings&quot; /&gt;
    &lt;add key=&quot;MS_NotificationHubName&quot; value=&quot;Overridden by portal settings&quot; /&gt;
    &lt;add key=&quot;SigningKey&quot; value=&quot;{Your WEBSITE_AUTH_SIGNING_KEY}&quot;/&gt;
    &lt;add key=&quot;ValidAudience&quot; value=&quot;{Your WEBSITE_AUTH_ALLOWED_AUDIENCES}&quot;/&gt;
    &lt;add key=&quot;ValidIssuer&quot; value=&quot;https://{Your WEBSITE_HOSTNAME}/&quot;/&gt;
  &lt;/appSettings&gt;
</code></pre>

<blockquote>
<p><strong>NOTE</strong>: Both the ValidAudience and ValidIssuer will have a slash on the end and be a https URL.</p>
</blockquote>
<p>The last three keys are the keys you will need to add.  Make sure you do not have a <code>HostName</code> key as this is how the startup file determines if you are running locally or remote. Talking of which, edit your <code>App_Start\Startup.MobileApp.cs</code> file to include the following:</p>
<pre><code class="csharp">        public static void ConfigureMobileApp(IAppBuilder app)
        {
            HttpConfiguration config = new HttpConfiguration();

            new MobileAppConfiguration()
                .AddTablesWithEntityFramework()
                .ApplyTo(config);

            // Use Entity Framework Code First to create database tables based on your DbContext
            Database.SetInitializer(new MobileServiceInitializer());

            MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();

            if (string.IsNullOrEmpty(settings.HostName))
            {
                app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions
                {
                    SigningKey = ConfigurationManager.AppSettings[&quot;SigningKey&quot;],
                    ValidAudiences = new[] { ConfigurationManager.AppSettings[&quot;ValidAudience&quot;] },
                    ValidIssuers = new[] { ConfigurationManager.AppSettings[&quot;ValidIssuer&quot;] },
                    TokenHandler = config.GetAppServiceTokenHandler()
                });
            }

            app.UseWebApi(config);
        }
</code></pre>

<p>The <code>UserAppServiceAuthentication()</code> method sets up authentication checking.  This section is not required when running within App Service.</p>
<p>If you are running the server locally, you should either set up a local SQL Server instance and put the connection string into the <code>Web.config</code> file, or <a href="https://azure.microsoft.com/en-us/documentation/articles/sql-database-configure-firewall-settings/">open the firewall on your SQL Azure</a> database so that your local development environment can connect to it, then place the connection string in the <code>Web.config</code>.  You can get the connection string of the SQL Azure instance by looking at the Connection Strings in the <strong>Application properties</strong> of your App Service.</p>
<h3 id="update-your-mobile-client">Update your Mobile Client</h3>
<p>For this demonstration, I have updated the <strong>TaskList.UWP</strong> application so that it is using the server-flow authentication for Azure Active Directory.  This means updating the <code>LoginAsync()</code> method in the <code>Services\UWPLoginProvider.cs</code> file to be the following:</p>
<pre><code class="csharp">        public async Task LoginAsync(MobileServiceClient client)
        {
            // Server-Flow Version
            await client.LoginAsync(&quot;aad&quot;);
        }
</code></pre>

<p>This is because the default local IIS instance is IIS Express.  IIS Express only listens for local connections.  If you run a client from another device (for example, the Android emulator on a Hyper-V service or the iOS simulator on a Mac), then that client would be connecting via a network connection.  You can still debug locally, but you need to <a href="https://github.com/Azure/azure-mobile-apps-net-server/wiki/Local-development-and-debugging-the-Mobile-App-.NET-server-backend">convert your environment to IIS</a> first.</p>
<p>In the <strong>TaskList (Portable)</strong> project, update the <code>Helpers\Locations.cs</code> file:</p>
<pre><code class="csharp">namespace TaskList.Helpers
{
    public static class Locations
    {
#if DEBUG
        public static readonly string AppServiceUrl = &quot;http://localhost:17568/&quot;;
        public static readonly string AlternateLoginHost = &quot;https://the-book.azurewebsites.net&quot;;
#else
        public static readonly string AppServiceUrl = &quot;https://the-book.azurewebsites.net&quot;;
        public static readonly string AlternateLoginHost = null;
#endif
    }
}
</code></pre>

<p>The <code>AppServiceUrl</code> is always set to the location of your backend.  In this case, I right-clicked on the <code>Backend</code> project and selected <strong>Properties</strong> then <strong>Web</strong>.  The correct URL for local debugging is listed in the <strong>Project URL</strong>.  The <code>AlternateLoginHost</code> is set to the App Service when locally debugging or null if not. You can specify the <code>DEBUG</code> constant in the <strong>Build</strong> tab.</p>
<p>In the same project, update the <code>Services\AzureCloudService.cs</code> constructor to the following:</p>
<pre><code class="csharp">        public AzureCloudService()
        {
            client = new MobileServiceClient(Locations.AppServiceUrl);
            if (Locations.AlternateLoginHost != null)
                client.AlternateLoginHost = new Uri(Locations.AlternateLoginHost);
        }
</code></pre>

<blockquote>
<p>It's a good idea to separate the client and server into different solutions.  Although it doesn't hurt anything to have them in the same solution (like we have), having the client and server separated allows you to attach a debugger separately - which allows you to debug both sides of the connection at the same time.</p>
</blockquote>
<p>With these settings, the client will contact the AlternateLoginHost listed for the authentication process and then contact the local server for the rest of the transaction.</p>
<h3 id="run-the-local-server">Run the Local Server</h3>
<p>Running the local server and the client takes a larger machine.  You need to run two instances of Visual Studio: one for the client and one for the server. This is really where you will appreciate multiple monitors (my personal favorite) or the snap action to the sides of the screens.</p>
<p>Ensure you have your backend and clients in different solutions if you intend to run both client and server.  The debugger in Visual Studio will stop one to run the other when they are in the same solution.</p>
<h2 id="custom-authentication">Custom authentication</h2>
<p>For some situations, the social or enterprise flows are not valid for the mobile client.  Perhaps you want the ability to provide a sign-up process with a username and password rather than using a social provider.  Perhaps you want to use an alternate provider that is not one of the supported five providers.  Whatever the reason, Azure App Service provides the ability to handle all situations.  In this section, I will look at three methods for providing a unique set of usernames with no connection to the social or enterprise authentication.</p>
<h3 id="using-an-identity-database">Using an Identity Database.</h3>
<p>Probably the most common request is to use a custom identity database.  In general, this is desirable because you already have a database of usernames and password.  However, it's probably the least desirable option because of the security concerns that come along with this technique.  The news is rife with password leakage for very large organizations.  The best way to ensure you do not disclose a users
password is to not have it in the first place.</p>
<blockquote>
<p>I'm not going to cover the sign-up case here.  This would be an additional process and would use a regular Web API to insert data into the database after validation (and probably verification via email
or text message).</p>
</blockquote>
<p>The first thing we need to add to our project is a model for the user object.  I created the following in the <code>Models</code> folder of the <strong>Backend</strong> project:</p>
<pre><code class="csharp">using System.ComponentModel.DataAnnotations;

namespace Backend.Models
{
    public class User
    {
        [Key]
        public int Id { get; set; }

        public string Username { get; set; }

        public string Password { get; set; }
    }
}
</code></pre>

<p>We also need to modify the <code>MobileServiceContext.cs</code> file so that the database table is included in the Entity Framework context:</p>
<pre><code class="csharp">    public class MobileServiceContext : DbContext
    {
        private const string connectionStringName = &quot;Name=MS_TableConnectionString&quot;;

        public MobileServiceContext() : base(connectionStringName)
        {
        }

        public DbSet&lt;TodoItem&gt; TodoItems { get; set; }
        public DbSet&lt;User&gt; Users { get; set; }

        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Conventions.Add(
                new AttributeToColumnAnnotationConvention&lt;TableColumnAttribute, string&gt;(
                    &quot;ServiceTableColumn&quot;, (property, attributes) =&gt; attributes.Single().ColumnType.ToString()));
        }
    }
</code></pre>

<p>Finally, we probably want to put some seed data into the database when it is first created so that we can test it.  Adjust the <code>MobileServiceInitializer</code> in the <code>Startup.MobileApp.cs</code> file:</p>
<pre><code class="csharp">        protected override void Seed(MobileServiceContext context)
        {
            List&lt;TodoItem&gt; todoItems = new List&lt;TodoItem&gt;
            {
                new TodoItem { Id = Guid.NewGuid().ToString(), Text = &quot;First item&quot;, Complete = false },
                new TodoItem { Id = Guid.NewGuid().ToString(), Text = &quot;Second item&quot;, Complete = false }
            };

            foreach (TodoItem todoItem in todoItems)
            {
                context.Set&lt;TodoItem&gt;().Add(todoItem);
            }

            List&lt;User&gt; users = new List&lt;User&gt;
            {
                new User { Id = 1, Username = &quot;adrian&quot;, Password = &quot;supersecret&quot; }
            };

            foreach (User user in users)
            {
                context.Set&lt;User&gt;().Add(user);
            }

            base.Seed(context);
        }
</code></pre>

<p>Note that we are storing the passwords in plain text.  This is most definitely frowned upon.  We should be using some sort of encryption.  This code is most definitely just for demonstration purposes.  Continuing the code on the backend, we need to handle the request to authenticate from the client.  We will use a custom API controller for this; it is located in <code>Controllers\CustomAuthController.cs</code>:</p>
<pre><code class="csharp">using System;
using System.IdentityModel.Tokens;
using System.Linq;
using System.Security.Claims;
using System.Web.Http;
using Backend.Models;
using Microsoft.Azure.Mobile.Server.Login;
using Newtonsoft.Json;

namespace Backend.Controllers
{
    [Route(&quot;.auth/login/custom&quot;)]
    public class CustomAuthController : ApiController
    {
        private MobileServiceContext db;
        private string signingKey, audience, issuer;

        public CustomAuthController()
        {
            db = new MobileServiceContext();
            signingKey = Environment.GetEnvironmentVariable(&quot;WEBSITE_AUTH_SIGNING_KEY&quot;);
            var website = Environment.GetEnvironmentVariable(&quot;WEBSITE_HOSTNAME&quot;);
            audience = $&quot;https://{website}/&quot;;
            issuer = $&quot;https://{website}/&quot;;
        }

        [HttpPost]
        public IHttpActionResult Post([FromBody] User body)
        {
            if (body == null || body.Username == null || body.Password == null || body.Username.Length == 0 || body.Password.Length == 0)
            {
                return BadRequest(); ;
            }

            if (!IsValidUser(body))
            {
                return Unauthorized();
            }

            var claims = new Claim[]
            {
                new Claim(JwtRegisteredClaimNames.Sub, body.Username)
            };

            JwtSecurityToken token = AppServiceLoginHandler.CreateToken(
                claims, signingKey, audience, issuer, TimeSpan.FromDays(30));
            return Ok(new LoginResult()
            {
                AuthenticationToken = token.RawData,
                User = new LoginResultUser { UserId = body.Username }
            });
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                db.Dispose();
            }
            base.Dispose(disposing);
        }

        private bool IsValidUser(User user)
        {
            return db.Users.Count(u =&gt; u.Username.Equals(user.Username) &amp;&amp; u.Password.Equals(user.Password)) &gt; 0;
        }
    }

    public class LoginResult
    {
        [JsonProperty(PropertyName = &quot;authenticationToken&quot;)]
        public string AuthenticationToken { get; set; }

        [JsonProperty(PropertyName = &quot;user&quot;)]
        public LoginResultUser User { get; set; }
    }

    public class LoginResultUser
    {
        [JsonProperty(PropertyName = &quot;userId&quot;)]
        public string UserId { get; set; }
    }
}
</code></pre>

<p>There is a lot going on here:</p>
<ul>
<li>The constructor reads the signing key and other information that we need for constructing the JWT.  Note that the signing key is only available if you have the Authentication / Authorization is turned on.</li>
<li>The <code>LoginResult</code> and <code>LoginResultUser</code> provide the response to the client, when serialized by the JSON serializer.</li>
<li>The <code>Post()</code> method is where the work happens.  It verifies that you have a valid object, then checks that the username and password match something in the user database.  It then constructs the JWT and returns the required JSON object.</li>
<li>The <code>IsValidUser()</code> method actually validates the username and password provided in the request with the users in the database.  This version is very simplistic.  I expect your version to at least include encryption of the password.</li>
</ul>
<blockquote>
<p>Note that you must turn on Authentication / Authorization in your App Service.  Set the <strong>Action to take when request is not authenticated</strong> to <strong>Allow Request (no action)</strong> and do not configure any of the supported authentication providers.</p>
</blockquote>
<p>Next, we need to wire the custom authentication controller so that it appears in the same place as all the other authenticators.  We are going to access it via the <code>/.auth/login/custom</code> endpoint.  The normal ASP.NET methods can be applied for this.  In this project, we can enable <a href="http://www.asp.net/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2">attribute routing</a>:</p>
<pre><code class="csharp">public static void ConfigureMobileApp(IAppBuilder app)
{
    HttpConfiguration config = new HttpConfiguration();

    new MobileAppConfiguration()
        .AddTablesWithEntityFramework()
        .ApplyTo(config);

    // Map routes by attribute
    config.MapHttpAttributeRoutes();

    // Use Entity Framework Code First to create database tables based on your DbContext
    Database.SetInitializer(new MobileServiceInitializer());

    MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();

    if (string.IsNullOrEmpty(settings.HostName))
    {
        app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions
        {
            SigningKey = ConfigurationManager.AppSettings[&quot;SigningKey&quot;],
            ValidAudiences = new[] { ConfigurationManager.AppSettings[&quot;ValidAudience&quot;] },
            ValidIssuers = new[] { ConfigurationManager.AppSettings[&quot;ValidIssuer&quot;] },
            TokenHandler = config.GetAppServiceTokenHandler()
        });
    }

    app.UseWebApi(config);
}
</code></pre>

<p>At this point, we can deploy the backend to the App Service and send a suitably formed POST request to
the backend.  I use <a href="https://www.getpostman.com/">Postman</a> for this purpose. The request:</p>
<p><img alt="Custom Auth - Postman Request" src="../chapter2/img/customauth-postman-1.PNG" /></p>
<p>A successful POST will return the token and user ID in the response:</p>
<p><img alt="Custom Auth - Postman Response" src="../chapter2/img/customauth-postman-2.PNG" /></p>
<p>Any other request (such as no body or a wrong username or password) should produce the right response.  If the body is correct, but the information is wrong, then a 401 Unauthorized response should be produced.  If the body is invalid, then a 400 Bad Request should be produced.</p>
<blockquote>
<p>Note that the format of the response is exactly the same as the token response we saw earlier when we were discussing the contents of a JWT.</p>
</blockquote>
<p>We can now turn our attention to the mobile client.  Custom Authentication is always implemented using a client-flow mechanism. To implement this, we are going to adjust the entry page so that the username and password fields are displayed.  The gathered username and password will then be passed to a new ICloudService <code>LoginAsync()</code> method.  All of the UI work is done in the shared project.</p>
<p>To start, we need a copy of the <code>User.cs</code> model from the backend project.  Unlike Data Transfer Objects, this model is the same:</p>
<pre><code class="csharp">namespace TaskList.Models
{
    public class User
    {
        public string Username { get; set; }
        public string Password { get; set; }
    }
}
</code></pre>

<p>The abstraction we use for the cloud service needs to be adjusted so that we can pass the user object into the login method.  This is the <code>Abstractions\ICloudService.cs</code> interface:</p>
<pre><code class="csharp">using System.Threading.Tasks;
using TaskList.Models;

namespace TaskList.Abstractions
{
    public interface ICloudService
    {
        ICloudTable&lt;T&gt; GetTable&lt;T&gt;() where T : TableData;

        Task LoginAsync();

        Task LoginAsync(User user);
    }
}
</code></pre>

<p>Note that I am adding a new version of the <code>LoginAsync()</code> method.  The concrete version of this method no longer has to go through the dependency service since I can use shared code.  Here is the definition of our new <code>LoginAsync()</code> method in <code>Services\AzureCloudService.cs</code>:</p>
<pre><code class="csharp">        public Task LoginAsync(User user)
        {
            return client.LoginAsync(&quot;custom&quot;, JObject.FromObject(user));
        }
</code></pre>

<p>Finally, we need to update the view-model <code>ViewModels\EntryPageViewModel.cs</code> so that we can store the username and password in the model.  We will also update the call to the <code>LoginAsync()</code> method of the cloud service so it calls our new method:</p>
<pre><code class="csharp">using System;
using System.Diagnostics;
using System.Threading.Tasks;
using TaskList.Abstractions;
using TaskList.Helpers;
using TaskList.Models;
using Xamarin.Forms;

namespace TaskList.ViewModels
{
    public class EntryPageViewModel : BaseViewModel
    {
        public EntryPageViewModel()
        {
            Title = &quot;Task List&quot;;
            User = new Models.User { Username = &quot;&quot;, Password = &quot;&quot; };
        }

        Command loginCmd;
        public Command LoginCommand =&gt; loginCmd ?? (loginCmd = new Command(async () =&gt; await ExecuteLoginCommand()));

        public Models.User User { get; set; }

        async Task ExecuteLoginCommand()
        {
            if (IsBusy)
                return;
            IsBusy = true;

            try
            {
                var cloudService = ServiceLocator.Instance.Resolve&lt;ICloudService&gt;();
                await cloudService.LoginAsync(User);
                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());
            }
            catch (Exception ex)
            {
                Debug.WriteLine($&quot;[ExecuteLoginCommand] Error = {ex.Message}&quot;);
            }
            finally
            {
                IsBusy = false;
            }
        }
    }
}
</code></pre>

<p>There are three new pieces here.  Firstly, we have the User property (for holding the username and password in our form).  Next, the constructor initializes the user object to an empty object.  Finally, the call to <code>LoginAsync()</code> passes the user object to the cloud service.</p>
<p>We also need some UI changes.  Specifically, we need a couple of fields for the username and password added to the <code>Pages\EntryPage.xaml</code> file:</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;ContentPage x:Class=&quot;TaskList.Pages.EntryPage&quot;
             xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             Title=&quot;{Binding Title}&quot;&gt;
    &lt;ContentPage.Content&gt;
        &lt;StackLayout HorizontalOptions=&quot;Center&quot;
                     Orientation=&quot;Vertical&quot;
                     VerticalOptions=&quot;Center&quot;&gt;
            &lt;Label Text=&quot;Username?&quot; /&gt;
            &lt;Entry Text=&quot;{Binding User.Username}&quot; /&gt;
            &lt;Label Text=&quot;Password?&quot; /&gt;
            &lt;Entry IsPassword=&quot;True&quot; Text=&quot;{Binding User.Password}&quot; /&gt;

            &lt;Button BackgroundColor=&quot;Teal&quot;
                    BorderRadius=&quot;10&quot;
                    Command=&quot;{Binding LoginCommand}&quot;
                    Text=&quot;Enter The App&quot;
                    TextColor=&quot;White&quot; /&gt;
        &lt;/StackLayout&gt;
    &lt;/ContentPage.Content&gt;
&lt;/ContentPage&gt;
</code></pre>

<p>There is lots to complain about in this demonstration (including lack of encryption, storage of passwords, and a generally bad UI).  However, it serves to demonstrate the salient points for using a (perhaps pre-existing) identity database for authentication of the users.</p>
<h2 id="using-azure-active-directory-b2c">Using Azure Active Directory B2C</h2>
<p>Custom authentication allows you to really customize the process, but I like to reduce the amount of code I write by using services or libraries.   The whole sign-in and sign-up process is ripe for this.  The code needed for building the sign-in / sign-up process is boiler-plate code.  It also introduces problems that I have to deal with going forward.  I have to store passwords and profile information, which introduces a security concern.  I have to scale the database and ensure my app scales with it as my app gets popular.  Finally, I am being fairly inflexible and causing potential privacy concerns with my users.</p>
<p>There are a couple of services that I can use to get around these concerns.  The first is an Azure service: <a href="https://azure.microsoft.com/en-us/services/active-directory-b2c/">Azure Active Directory B2C</a>.  The B2C stands for Business to Consumer.  It is a mechanism by which you can add a sign-in and sign-up flow to your application.  The user can enter a username or password, or, at your option, add on support for one or more social providers.  In addition, there is support for branding the sign-in process, doing email verification of sign-ups and automatic password resets via email.  The Azure AD B2C sign-in / sign-up process is primarily a server-flow proecss, so we will be able to add support in our app with just one line of code.</p>
<h3 id="the-minimal-setup-of-azure-ad-b2c">The Minimal Setup of Azure AD B2C</h3>
<p>Azure AD is managed from the <a href="https://manage.windowsazure.com/">Classic Azure Portal</a>, so start by logging in using your Azure Subscription credentials.</p>
<ul>
<li>Click on the big <strong>+ NEW</strong> button in the bottom left of the screen.</li>
<li>Select <strong>App Services</strong> -&gt; <strong>Active Directory</strong> -&gt; <strong>Directory</strong> -&gt; <strong>Custom Create</strong>.</li>
</ul>
<p><img alt="AAD B2C Create Flow - Create a new resource" src="../chapter2/img/aad-b2c-1.PNG" /></p>
<ul>
<li>Choose a name for the tenant, then choose a unique domain name (which will appear in the   <em>onmicrosoft.com</em> domain) and country.  Ensure you check the <strong>This is a B2C directory.</strong></li>
</ul>
<p><img alt="AAD B2C Create Flow - Add a Directory" src="../chapter2/img/aad-b2c-2.PNG" /></p>
<ul>
<li>Click on the tick to create the directory.  As noted, this process will take a couple of minutes to complete.</li>
</ul>
<p>This creates a new tenant for you to manage.  If you go back to your <a href="https://portal.azure.com/">Azure Portal</a> and click on your name (top right corner), you will note that there is a new DIRECTORY entry for your B2C tenant.  This is where you will be managing your B2C tenant.</p>
<p>It's a good idea to pin the B2C settings blade to your dashboard or navigation pane so you can access it faster.  To do this:</p>
<ul>
<li>Log in to the <a href="https://portal.azure.com/">Azure Portal</a>.</li>
<li>Switch to your B2C tenant by clicking on your name, then selecting the new tenant in the drop-down.</li>
<li>The portal will probably ask you to confirm your ID and password.</li>
<li>Click on <strong>Browse&gt;</strong> in the left-hand navigation bar.</li>
<li>Search for <strong>B2C</strong>.</li>
<li>Click on the empty star next to <strong>Azure AD B2C</strong>.</li>
</ul>
<p><img alt="AAD B2C Create Flow - Favorite the B2C" src="../chapter2/img/aad-b2c-3.PNG" /></p>
<p>This will make Azure AD B2C appear in your left hand navigation bar.  To place it on the dashboard, click on <strong>Azure AD B2C</strong> in the left hand navigation bar, then click on the pin at the top of the <strong>AZURE AD B2C SETTINGS</strong> blade.</p>
<p>The next job is to create an application registration within the B2C tenant:</p>
<ul>
<li>Open the <strong>Azure AD B2C</strong> from your dashboard or the left hand navigation.</li>
<li>In the <strong>Settings</strong> blade, click on <strong>Applications</strong>.</li>
</ul>
<p><img alt="AAD B2C Create Flow - Create an App Step 1" src="../chapter2/img/aad-b2c-4.PNG" /></p>
<ul>
<li>In the <strong>New application</strong> blade:</li>
<li>Enter a unique name for the application.</li>
<li>Click on <strong>Yes</strong> under <strong>Include web app / web API</strong>.</li>
<li>In the Reply URL, enter <code>https://yoursite.azurewebsites.net/.auth/login/aad/callback</code>.</li>
<li>Click on <strong>Generate key</strong> - a key will be generated (cut and paste it somewhere).</li>
</ul>
<p><img alt="AAD B2C Create Flow - Create an App Step 2" src="../chapter2/img/aad-b2c-5.PNG" /></p>
<ul>
<li>Click on <strong>Create</strong>.</li>
</ul>
<p>There is no spinner or deployment here.  After approximately 5-10 seconds, the application registration will appear in the list.  Click on the application registration to see the <strong>Application ID</strong>:</p>
<p><img alt="AAD B2C Create Flow - Create an App Step 3" src="../chapter2/img/aad-b2c-6.PNG" /></p>
<p>You will need the Application ID and App Key (which you copied earlier) later on.  The next step is to create a Sign-in/Sign-up policy.  We'll create a policy for signing up with an email address and email confirmation, then signing in with that email address:</p>
<ul>
<li>In the <strong>Settings</strong> blade, click on <strong>Sign-up or sign-in policies</strong>.</li>
<li>Click on the <strong>+ Add</strong> button.</li>
<li>Give the policy a name, like <strong>emailPolicy</strong>.</li>
<li>Click on <strong>Identity providers</strong>:</li>
<li>Click on <strong>Email signup / Local Account</strong> (a tick will appear next to the row).</li>
<li>Click on <strong>OK</strong>.</li>
<li>Click on <strong>Sign-up attributes</strong>:</li>
<li>Click on <strong>Email Address</strong> and any other fields you want to gather.</li>
<li>Click on <strong>OK</strong>.</li>
<li>Click on <strong>Application claims</strong>:</li>
<li>Click on <strong>Email Addresses</strong> and any other fields you want to provide to the application.</li>
<li>Click on <strong>OK</strong></li>
<li>Click on <strong>Create</strong> on the <strong>Add policy</strong> blade.</li>
<li>Click on the policy you just created.  It will be named something like <em>B2C_1_emailPolicy</em>. Make a note of the <strong>Metadata Endpoint for this policy</strong>.</li>
</ul>
<p><img alt="AAD B2C Create Flow - Create a Policy" src="../chapter2/img/aad-b2c-7.PNG" /></p>
<p>Now that your B2C tenant is configured, you can switch back to your original tenant (by clicking on your name in the top-right corner and selecting the default directory).</p>
<p>To configure the App Service <strong>Authentication / Authorization</strong>.  Open up the <strong>Settings</strong> blade, then <strong>Authentication / Authorization</strong>.  Ensure the authentication service is turned on.  Click on <strong>Azure Active Directory</strong>. This time, we are going to select the <strong>Advanced</strong> option.  The <strong>Client ID</strong> is the application ID of your B2C application registration, and the <strong>Issuer Url</strong> is the <strong>Metadata Endpoint</strong> for your sign-up policy:</p>
<p><img alt="AAD B2C Create Flow - Configure EasyAuth" src="../chapter2/img/aad-b2c-8.PNG" /></p>
<p>Click on <strong>OK</strong> to configure the authentication server flow, the <strong>Save</strong> to save the settings.  As before, you can test your server flow by pointing your browser to <code>https://yoursite.azurewebsites.net/.auth/login/aad</code>:</p>
<p><img alt="AAD B2C Login Flow" src="../chapter2/img/aad-b2c-9.PNG" /></p>
<p>If you have done everything right, you should be able to register an account, get the email verification code, and finally log in to get the happy login page.</p>
<p><img alt="AAD B2C Sign Up Flow" src="../chapter2/img/aad-b2c-10.PNG" /></p>
<p>All that is left to do is to configure your app for Azure Active Directory Server Flow.  We did that earlier when discussing the Enterprise Authentication flow for the mobile client.</p>
<h3 id="drawbacks-of-azure-active-directory-b2c">Drawbacks of Azure Active Directory B2C</h3>
<p>Azure AD B2C is great for storing your users passwords and doing the sign-up and sign-in process for you.  There are a couple of reasons why you wouldn't want to use Azure Active Directory B2C.</p>
<p>The most obvious one is that this is a server-flow capability.  That means you won't be able to, for example, integrate the Facebook, Google and Twitter identity providers by utilizing their client libraries.  You also do not get access to the underlying identity provider token, so you are restricted from accessing the Graph API for the individual providers.  Finally, since the AAD B2C identity provider is configured with the AAD provider, you can't use both a B2C provider and a regular AAD provider.</p>
<p>If you just want a sign-up / sign-in flow, then AAD B2C is probably the best way to go.  If, however, your plans include integration with other social identity providers, you should consider whether you want to do more work on the client to support that.</p>
<h2 id="using-third-party-tokens">Using Third Party Tokens</h2>
<p>The final method of authenticating a user we are going to look at is a process by which you use a third party authentication token.   For example, you may want to authenticate via <a href="https://developer.github.com/v3/oauth/">GitHub</a> or <a href="http://www.miicard.com/for/individuals/how-it-works">miiCard</a> or using an authentication provider like <a href="https://www.auth0.com/">Auth0</a> to get some single sign-in capabilities.</p>
<p>Authentication with third party tokens works remarkably similar to the custom authentication case.  Instead of a username and password, you pass in the token from the other provider.</p>
<p>To look at this in example form, we are going to implement Auth0 as a provider. Your first stop should be the <a href="https://www.auth0.com/">Auth0</a> web site to sign up for a developer account. Once you have done that:</p>
<ul>
<li>Click on the <strong>+ NEW CLIENT</strong> button in the <strong>Dashboard</strong>.</li>
<li>Give your app a name, then click on <strong>Native</strong> and then <strong>CREATE</strong>.</li>
</ul>
<p><img alt="Auth0 Create Flow - Step 1" src="../chapter2/img/auth0-create-1.PNG" /></p>
<ul>
<li>Click on the <strong>Xamarin</strong> icon to get the Xamarin Quickstart.</li>
<li>Click on <strong>Settings</strong>.</li>
<li>Enter the callback URL in the <strong>Allowed Callback URLs</strong>.  The callback URL will be something like <code>https://_youraccount_.auth0.com/mobile</code> and will be listed in the Quickstart page.</li>
<li>Scroll down to the bottom of the page and click on <strong>SAVE CHANGES</strong>.</li>
<li>Make a note of the Client ID of the application.  You will need it later.</li>
<li>Click on <strong>Connections</strong>.</li>
<li>Turn on any connections that you want to use.  For this example, ensure you turn on the <strong>Username-Password-Authentication</strong> and a couple of social providers.</li>
</ul>
<p>Now that the Auth0 service is configured, we can turn our attention to the mobile client.  The Xamarin.Auth0Client is a component, so right-click on the <strong>Components</strong> node of a platform project and select <strong>Get More Components...</strong>.  In the dialog, find the <strong>Auth0 SDK</strong>, then click on <strong>Add to App</strong>.</p>
<p>For our iOS application, we are going to integrate Auth0 into the <code>Services\iOSLoginProvider.cs</code>:</p>
<pre><code class="csharp">        public async Task LoginAsync(MobileServiceClient client)
        {
            // Client Flow
            var accessToken = await LoginAuth0Async();

            var zumoPayload = new JObject();
            zumoPayload[&quot;access_token&quot;] = accessToken;
            await client.LoginAsync(&quot;auth0&quot;, zumoPayload);
        }

        public UIViewController RootView =&gt; UIApplication.SharedApplication.KeyWindow.RootViewController;

        public async Task&lt;string&gt; LoginAuth0Async()
        {
            var auth0 = new Auth0.SDK.Auth0Client(
                &quot;shellmonger.auth0.com&quot;,
                &quot;lmFp5jXnwPpD9lQIYwgwwPmFeofuLpYq&quot;);
            var user = await auth0.LoginAsync(RootView, scope: &quot;openid email&quot;);
            return user.Auth0AccessToken;
        }
</code></pre>

<p>The parameters for the constructor to the <code>Auth0Client</code> are your Auth0 domain and client ID.  You can retrieve these from the Auth0 management page for your app.  Note that I am requesting the email address.  This will become a part of my ZUMO token when I create it.</p>
<p>Switching our attention to our <code>Backend</code> project, we need a new custom authentication controller.  This is located in <code>Controllers\Auth0Controller.cs</code>:</p>
<pre><code class="csharp">using System;
using System.Diagnostics;
using System.IdentityModel.Tokens;
using System.Linq;
using System.Security.Claims;
using System.Web.Http;
using Backend.Models;
using Microsoft.Azure.Mobile.Server.Login;

namespace Backend.Controllers
{
    [Route(&quot;.auth/login/auth0&quot;)]
    public class Auth0Controller : ApiController
    {
        private JwtSecurityTokenHandler tokenHandler;
        private string clientID, domain;
        private string signingKey, audience, issuer;

        public Auth0Controller()
        {
            // Information for the incoming Auth0 Token
            domain = Environment.GetEnvironmentVariable(&quot;AUTH0_DOMAIN&quot;);
            clientID = Environment.GetEnvironmentVariable(&quot;AUTH0_CLIENTID&quot;);

            // Information for the outgoing ZUMO Token
            signingKey = Environment.GetEnvironmentVariable(&quot;WEBSITE_AUTH_SIGNING_KEY&quot;);
            var website = Environment.GetEnvironmentVariable(&quot;WEBSITE_HOSTNAME&quot;);
            audience = $&quot;https://{website}/&quot;;
            issuer = $&quot;https://{website}/&quot;;

            // Token Handler
            tokenHandler = new JwtSecurityTokenHandler();
        }

        [HttpPost]
        public IHttpActionResult Post([FromBody] Auth0User body)
        {
            if (body == null || body.access_token == null || body.access_token.Length == 0)
            {
                return BadRequest();
            }

            try
            {
                var token = (JwtSecurityToken)tokenHandler.ReadToken(body.access_token);
                if (!IsValidUser(token))
                {
                    return Unauthorized();
                }

                var subject = token.Claims.FirstOrDefault(c =&gt; c.Type.Equals(&quot;sub&quot;))?.Value;
                var email = token.Claims.FirstOrDefault(c =&gt; c.Type.Equals(&quot;email&quot;))?.Value;
                if (subject == null || email == null)
                {
                    return BadRequest();
                }

                var claims = new Claim[]
                {
                    new Claim(JwtRegisteredClaimNames.Sub, subject),
                    new Claim(JwtRegisteredClaimNames.Email, email)
                };

                JwtSecurityToken zumoToken = AppServiceLoginHandler.CreateToken(
                    claims, signingKey, audience, issuer, TimeSpan.FromDays(30));
                return Ok(new LoginResult()
                {
                    AuthenticationToken = zumoToken.RawData,
                    User = new LoginResultUser { UserId = email }
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine($&quot;Auth0 JWT Exception = {ex.Message}&quot;);
                throw ex;
            }
        }

        private bool IsValidUser(JwtSecurityToken token)
        {
            if (token == null)
                return false;
            var audience = token.Audiences.FirstOrDefault();
            if (!audience.Equals(clientID))
                return false;
            if (!token.Issuer.Equals($&quot;https://{domain}/&quot;))
                return false;
            if (token.ValidTo.AddMinutes(5) &lt; DateTime.Now)
                return false;
            return true;
        }
    }

    public class Auth0User
    {
        public string access_token { get; set; }
    }
}
</code></pre>

<p>Note that we are reading two new environment variables.  In the Azure App Service, you can read Application Settings by reading the environment variable of the same name.  We need to set the <strong>AUTH0_CLIENTID</strong> to the Client ID of our Auth0 application, and the <strong>AUTH0_DOMAIN</strong> to the domain of our account.  Both of these values need to match the settings in the client.  These are not "secure items".  If using the client secret (to validate the token), then that would be considered secure and should only appear on the server side.</p>
<p>The validation is that the token passed in is valid (i.e. it has the right audience, issuer and expiry times).  In addition, you should check the validity of the token signature.  You can do this by acquiring the token secret and using <code>tokenHandler.ValidateToken()</code> instead of <code>tokenHandler.ReadToken()</code>.  My new token lasts for 30 days.  The ZUMO token that is generated in custom authentication does not have to be the same length as the original token. You can make it last for as long as you like.</p>
<h2 id="claims-and-authorization">Claims and Authorization</h2>
<p>Now that we have covered all the techniques for authentication, it's time to look at authorization.  While authentication looked at verifying that a user is who they say they are, authorization looks at if a user is allowed to do a specific operation.</p>
<p>Authorization is handled within the server-side project by the <code>[Authorize]</code> attribute.  Our Azure Mobile Apps backend is leveraging this to provide authorization based on whether a user is authenticated or not.  The Authorize attribute can also check to see if a user is in a list of users or roles.  However, there is a problem with this.  The user id is not guessable and we have no roles.  To see what I mean, run the <strong>Backend</strong> project locally and set a break point on the <code>GetAllTodoItems()</code> method in the <code>TodoItemController</code>, then run your server and your UWP application.</p>
<blockquote>
<p>Once you have built and deployed the UWP application, it will appear in your normal Application list.  This allows you to run the application and the server at the same time on the same machine.</p>
</blockquote>
<p>Once you have authenticated, you will be able to set a break point to take a look at <code>this.User.Identity</code>:</p>
<p><img alt="this.User.Identity output" src="../chapter2/img/user-identity.PNG" /></p>
<p>Note that the <code>Name</code> property is null.  This is the property that is used when you want to authorize individual users.  Expand the <code>Claims</code> property and then click on <strong>Results View</strong>:</p>
<p><img alt="Claims output" src="../chapter2/img/user-claims.PNG" /></p>
<p>The only claims are the ones in the token, and none of them match the <code>RoleClaimType</code>, so we can't use roles either.  Clearly, we are going to have to do something else.</p>
<h2 id="obtaining-user-claims">Obtaining User Claims</h2>
<p>At some point you are going to need to deal with something other than the claims that are in the token passed for authentication.  Fortunately, the Authentication / Authorization feature has an endpoint for that at <code>/.auth/me</code>:</p>
<p><img alt="The /.auth/me endpoint" src="../chapter2/img/auth-me.PNG" /></p>
<p>Of course, the <code>/.auth/me</code> endpoint is not of any use if you cannot access it.  The most use of this information is gained during authorization on the server and we will cover this use later on.  However, there are reasons to pull this information on the client as well.  For example, we may want to make the List View title be our name instead of "Tasks".</p>
<blockquote>
<p>You can't use the /.auth/me endpoint when using custom authentication.</p>
</blockquote>
<p>Since identity provider claims can be anything, they are transferred as a list within a JSON object.  Before we can decode the JSON object, we need to define the models.  This is done in the shared <strong>TaskList</strong> project.  I've defined this in <code>Models\AppServiceIdentity.cs</code>.</p>
<pre><code class="csharp">using System.Collections.Generic;
using Newtonsoft.Json;

namespace TaskList.Models
{
    public class AppServiceIdentity
    {
        [JsonProperty(PropertyName = &quot;id_token&quot;)]
        public string IdToken { get; set; }

        [JsonProperty(PropertyName = &quot;provider_name&quot;)]
        public string ProviderName { get; set; }

        [JsonProperty(PropertyName = &quot;user_id&quot;)]
        public string UserId { get; set; }

        [JsonProperty(PropertyName = &quot;user_claims&quot;)]
        public List&lt;UserClaim&gt; UserClaims { get; set; }
    }

    public class UserClaim
    {
        [JsonProperty(PropertyName = &quot;typ&quot;)]
        public string Type { get; set; }

        [JsonProperty(PropertyName = &quot;val&quot;)]
        public string Value { get; set; }
    }
}
</code></pre>

<p>This matches the JSON format from the <code>/.auth/me</code> call we did earlier.   This is going to be a part of the ICloudService as follows:</p>
<pre><code class="csharp">using System.Threading.Tasks;
using TaskList.Models;

namespace TaskList.Abstractions
{
    public interface ICloudService
    {
        ICloudTable&lt;T&gt; GetTable&lt;T&gt;() where T : TableData;

        Task LoginAsync();

        Task LoginAsync(User user);

        Task&lt;AppServiceIdentity&gt; GetIdentityAsync();
    }
}
</code></pre>

<p>Finally, we need to actually implement the concrete version in <code>AzureCloudService.cs</code>:</p>
<pre><code class="csharp">List&lt;AppServiceIdentity&gt; identities = null;

public async Task&lt;AppServiceIdentity&gt; GetIdentityAsync()
{
    if (client.CurrentUser == null || client.CurrentUser?.MobileServiceAuthenticationToken == null)
    {
        throw new InvalidOperationException(&quot;Not Authenticated&quot;);
    }

    if (identities == null)
    {
        identities = await client.InvokeApiAsync&lt;List&lt;AppServiceIdentity&gt;&gt;(&quot;/.auth/me&quot;);
    }

    if (identities.Count &gt; 0)
        return identities[0];
    return null;
}
</code></pre>

<p>Note that there is no reason to instantiate your own <code>HttpClient()</code>.  The Azure Mobile Apps SDK has a method for invoking custom API calls (as we shall see later on).  However, if you prefix the path with a slash, it will execute a HTTP GET for any API with any authentication that is currently in force.  We can leverage this to call the <code>/.auth/me</code> endpoint and decode the response in one line of code.  Adjust the <code>ExecuteRefreshCommand()</code> method in the <code>ViewModels\TaskListViewModel.cs</code> file to take advantage of this:</p>
<pre><code class="csharp">async Task ExecuteRefreshCommand()
{
    if (IsBusy)
        return;
    IsBusy = true;

    try
    {
        var identity = await cloudService.GetIdentityAsync();
        if (identity != null)
        {
            var name = identity.UserClaims.FirstOrDefault(c =&gt; c.Type.Equals(&quot;name&quot;)).Value;
            Title = $&quot;Tasks for {name}&quot;;
        }
        var list = await Table.ReadAllItemsAsync();
        Items.ReplaceRange(list);
    }
    catch (Exception ex)
    {
        await Application.Current.MainPage.DisplayAlert(&quot;Items Not Loaded&quot;, ex.Message, &quot;OK&quot;);
    }
    finally
    {
        IsBusy = false;
    }
}
</code></pre>

<p>The return value from the <code>GetIdentityAsync()</code> method is the first identity.  Normally, a user would only authenticate once, so this is fairly safe.  The number of claims returned depends on the identity provider and could easily number in the hundreds.  Even the default configuration for Azure Active Directory returns 18 claims.  These are easily handled using LINQ, however.  The <code>Type</code> property holds the type.  This could be a short (common) name.  It could also be a schema name, which looks more like a URI.  The only way to know what claims are coming back for sure is to look at the <code>/.auth/me</code> result with something like Postman.</p>
<blockquote>
<p><strong>Note</strong>: If you are using Custom Authentication (e.g. username/password or a third-party token), then the <code>/.auth/me</code> endpoint is not available to you.  You can still produce a custom API in your backend to provide this information to your client, but you are responsible for the code - it's custom, after all!</p>
</blockquote>
<h2 id="authorization">Authorization</h2>
<p>Now that we have covered all the techniques for authentication, it's time to look at authorization.  While authentication looked at verifying that a user is who they say they are, authorization looks at if a user is allowed to do a specific operation.</p>
<p>Authorization is handled within the server-side project by the <code>[Authorize]</code> attribute.  Our Azure Mobile Apps backend is leveraging this to provide authorization based on whether a user is authenticated or not.  The Authorize attribute can also check to see if a user is in a list of users or roles.  However, there is a problem with this.  The user id is not guessable and we have no roles.  To see what I mean, run the <strong>Backend</strong> project and set a break point on the <code>GetAllTodoItems()</code> method in the <code>TodoItemController</code>, then run your server and your UWP application.</p>
<blockquote>
<p>Once you have built and deployed the UWP application, it will appear in your normal Application list.  This allows you to run the application and the server at the same time on the same machine.  Alternatively, you can attach a Debugger to your Azure App Service within Visual Studio's Cloud Explorer.</p>
</blockquote>
<p>Once you have authenticated, you will be able to set a break point to take a look at <code>this.User.Identity</code>:</p>
<p><img alt="this.User.Identity output" src="../chapter2/img/user-identity.PNG" /></p>
<p>Note that the <code>Name</code> property is null.  This is the property that is used when you want to authorize individual users.  Expand the <code>Claims</code> property and then click on <strong>Results View</strong>:</p>
<p><img alt="Claims output" src="../chapter2/img/user-claims.PNG" /></p>
<p>The only claims are the ones in the token, and none of them match the <code>RoleClaimType</code>, so we can't use roles either.  Clearly, we are going to have to do something else.  Fortunately, we already know that we can get some information about the identity provider claims from the <code>/.auth/me</code> endpoint.  To get the extra information, we need to query the <code>User</code> object:</p>
<pre><code class="csharp">var identity = await User.GetAppServiceIdentityAsync&lt;AzureActiveDirectoryCredentials&gt;(Request);
</code></pre>

<p>There is one <code>Credentials</code> class for each supported authentication technique - Azure Active Directory, Facebook, Google, Microsoft Account and Twitter.  These are in the <strong>Microsoft.Azure.Mobile.Server.Authentication</strong> namespace.  They all follow the same pattern as the model we created for the client - there are Provider, UserId and UserClaims properties.  The token and any special information will be automatically decoded for you.  For instance, the TenantId is pulled out of the response for Azure AD.</p>
<blockquote>
<p>You can use the AccessToken property to do Graph API lookups for most providers in a custom API. We'll get into this more in a later Chapter.</p>
</blockquote>
<h2 id="adding-group-claims-to-the-request"><a name="addlclaims"></a>Adding Group Claims to the Request</h2>
<p>There are times when you want to add something else to the token that is returned from Azure AD. The most common requirement is to add group information to the response so you can handle group-based authorization.</p>
<p>To add security groups to the Azure AD token:</p>
<ol>
<li>Log into the <a href="https://manage.windowsazure.com/">Classic Portal</a>.</li>
<li>Click on your directory (probably called <strong>Default Directory</strong>) in the <strong>All Items</strong> list.</li>
<li>Click on <strong>APPLICATIONS</strong>, then your WEB application.</li>
<li>Click on <strong>MANAGE MANIFEST</strong> (at the bottom of the page), then <strong>Download Manifest</strong>.</li>
<li>Click on <strong>Download manifest</strong>.</li>
</ol>
<p>This will download a JSON file.  Edit the file with a text editor.  (I use Visual Studio Code).  At the top of the file is this:</p>
<pre><code class="json">  &quot;displayName&quot;: &quot;webapp-for-the-book&quot;,
  &quot;errorUrl&quot;: null,
  &quot;groupMembershipClaims&quot;: null,
  &quot;homepage&quot;: &quot;https://the-book.azurewebsites.net&quot;,
  &quot;identifierUris&quot;: [
    &quot;https://the-book.azurewebsites.net&quot;
  ],
  &quot;keyCredentials&quot;: [],
  &quot;knownClientApplications&quot;: [],
</code></pre>

<p>Change the <strong>groupMembershipClaims</strong> to "SecurityGroup":</p>
<pre><code class="json">  &quot;displayName&quot;: &quot;webapp-for-the-book&quot;,
  &quot;errorUrl&quot;: null,
  &quot;groupMembershipClaims&quot;: &quot;SecurityGroup&quot;,
  &quot;homepage&quot;: &quot;https://the-book.azurewebsites.net&quot;,
  &quot;identifierUris&quot;: [
    &quot;https://the-book.azurewebsites.net&quot;
  ],
  &quot;keyCredentials&quot;: [],
  &quot;knownClientApplications&quot;: [],
</code></pre>

<p>Save the file.  You can now upload this again.  Go back to the WEB application, click on <strong>MANAGE MANIFEST</strong>, then click on <strong>Upload Manifest</strong>.  Select the file and click on the tick.</p>
<p><img alt="AAD - Upload Manifest" src="../chapter2/img/aad-manifest-upload.PNG" /></p>
<p>You can now give the web application additional permissions:</p>
<ol>
<li>Click on the <strong>CONFIGURE</strong> tab.</li>
<li>Scroll to the bottom, click on <strong>Delegated Permissions</strong>.</li>
<li>Check the box for <strong>Read directory data</strong>.</li>
</ol>
<p><img alt="AAD: Group Permissions" src="../chapter2/img/aad-group-perms.PNG" /></p>
<ol>
<li>Click on <strong>Save</strong>.</li>
</ol>
<p>Now that you have configured the application to return groups as part of the claims, you should probably add a couple of groups:</p>
<ol>
<li>Click on the back-arrow (at the top left) to return to the top level of your directory.</li>
<li>Click on <strong>GROUPS</strong>.</li>
<li>Click on <strong>ADD GROUP</strong>.</li>
<li>Fill in the information, select <strong>Security</strong> as the group type, then click on the tick.</li>
</ol>
<p><img alt="AAD: Add Group" src="../chapter2/img/aad-group-1.PNG" /></p>
<ol>
<li>Click on the new group, then click on <strong>PROPERTIES</strong>.</li>
</ol>
<p><img alt="AAD: Group Properties" src="../chapter2/img/aad-group-2.PNG" /></p>
<ol>
<li>Make a note of the <strong>OBJECT ID</strong>.  The claims for groups are listed by the Object ID, so you will need this to refer to the group later.</li>
</ol>
<p>It's a good idea to add a couple of groups for testing purposes.  If you are using the organization directory, you will need to request the creation of a couple of groups for application roles.  The view of the groups will be shown when we get the identity of
the user using <code>User.GetAppServiceIdentityAsync&lt;AzureActiveDirectoryCredentials&gt;(Request)</code>:</p>
<p><img alt="AAD: Group in Claims" src="../chapter2/img/aad-groups-views.PNG" /></p>
<h3 id="group-authorization">Group Authorization</h3>
<p>Now that we have group claims in the claims list for the <code>/.auth/me</code> endpoint, we can move forward to do authorization based on these claims.  This can be done in a relatively basic
manner by implementing a method to check the claims:</p>
<pre><code class="csharp">async Task&lt;bool&gt; IsAuthorizedAsync()
{
    var identity = await User.GetAppServiceIdentityAsync&lt;AzureActiveDirectoryCredentials&gt;(Request);
    var countofGroups = identity.UserClaims
        .Where(c =&gt; c.Type.Equals(&quot;groups&quot;) &amp;&amp; c.Value.Equals(&quot;01f214a9-af1f-4bdd-938f-3f16749aef0e&quot;))
        .Count();
    return (countofGroups &gt; 0);
}
</code></pre>

<p>The <code>UserClaims</code> object is an <code>IEnumerable</code> that contains objects with a Type and a Value.  The Type for the group claims is <code>groups</code>.  Once we have this knowledge, we can use a LINQ query to obtain a count of the claims that match the conditions we want to test.  The Value we use is the Object ID of the group.  This is available in the <strong>PROPERTIES</strong> tab of the group.</p>
<p>We can prevent a new record being added by adjusting the <code>PostTodoItem()</code> method:</p>
<pre><code class="csharp">public async Task&lt;IHttpActionResult&gt; PostTodoItem(TodoItem item)
{
    if (!await IsAuthorizedAsync())
    {
        return Unauthorized();
    }
    TodoItem current = await InsertAsync(item);
    return CreatedAtRoute(&quot;Tables&quot;, new { id = current.Id }, current);
}
</code></pre>

<p>Unfortunately, most of the table controller methods do not return an <code>IHttpActionResult</code>, so this has limited value.  What would be better would be an <code>[Authorize]</code> attribute that tests the claims for us.  For instance, we should be able to do the following:</p>
<pre><code class="csharp">[AuthorizeClaims(&quot;groups&quot;, &quot;01f214a9-af1f-4bdd-938f-3f16749aef0e&quot;)]
public async Task&lt;IHttpActionResult&gt; PostTodoItem(TodoItem item)
{
    TodoItem current = await InsertAsync(item);
    return CreatedAtRoute(&quot;Tables&quot;, new { id = current.Id }, current);
}
</code></pre>

<p>The <code>[AuthorizeClaims()]</code> attribute does not exist, so we have to provide it ourselves:</p>
<pre><code class="csharp">using System.Linq;
using System.Net;
using System.Security.Principal;
using System.Threading;
using System.Threading.Tasks;
using System.Web.Http;
using System.Web.Http.Controllers;
using System.Web.Http.Filters;
using Microsoft.Azure.Mobile.Server.Authentication;

namespace Backend.Helpers
{
    public class AuthorizeClaimsAttribute : AuthorizationFilterAttribute
    {
        string Type { get; }
        string Value { get; }

        public AuthorizeClaimsAttribute(string type, string value)
        {
            Type = type;
            Value = value;
        }

        public override async Task OnAuthorizationAsync(HttpActionContext actionContext, CancellationToken cancellationToken)
        {
            var request = actionContext.Request;
            var user = actionContext.RequestContext.Principal;
            if (user != null)
            {
                var identity = await user.GetAppServiceIdentityAsync&lt;AzureActiveDirectoryCredentials&gt;(request);
                var countOfMatchingClaims = identity.UserClaims
                    .Where(c =&gt; c.Type.Equals(Type) &amp;&amp; c.Value.Equals(Value))
                    .Count();
                if (countOfMatchingClaims &gt; 0) return;

            }
            throw new HttpResponseException(HttpStatusCode.Unauthorized);
        }
    }
}
</code></pre>

<p>This is the same type of authorization filter attribute that the officially provided <code>AuthorizeAttribute</code> is based on.  However, the AuthorizeAttribute is synchronous.  We require an asynchronous version of the attribute, so we cannot use a sub-class of the AuthorizeAttribute.  Aside from that note, this uses virtually the same code that we used in the <code>IsAythorizedAsync()</code> method we developped earlier.</p>
<p>We can now use this attribute for testing any claim.  For example, our claims has the identity provider as a claim.  We can use the following:</p>
<pre><code class="csharp">[AuthorizeClaims(&quot;http://schemas.microsoft.com/identity/claims/identityprovider&quot;, &quot;live.com&quot;)]
</code></pre>

<blockquote>
<p>If you want to test other claims that are not provided, you can enable the <strong>Read Directory Data</strong> permission in the Azure Active Directory permissions and do a query against the Azure Active Directory.  You should think about caching results if this is the case.</p>
</blockquote>
<h2 id="caching-tokens">Caching Tokens</h2>
<p>You will notice that we have to log in with every start of the application.  The token that is generated has a lifetime that is provided and controlled by the identity provider.  Some providers have a relatively short lifetime.  For example, Azure Active Directory tokens have a lifetime of 1 hour.  Others are incredibly long.  Facebook has an expiry time of 60 days.</p>
<p>Irrespective of the lifespan of the token, we will want to store it securely and re-use it when we can.  Xamarin has provided a nice component, [Xamarin.Auth], that provides such as secure store in a cross-platform manner.  It starts with an account store:</p>
<pre><code class="csharp">var accountStore = AccountStore.Create();
// For Android:
// var accountStore = AccountStore.Create(Context);
</code></pre>

<p>We can then store the token with the following:</p>
<pre><code class="csharp">accountStore.Save(account, &quot;descriptor&quot;);
</code></pre>

<p>The descriptor is a string that allows us to find the token again.  The account (which is an <code>Account</code> object) is uniquely identified by a key composed of the account's Username property and the descriptor.  The Account class is provided with Xamarin.Auth.  Storage is backed by the <a href="https://developer.apple.com/library/ios/#documentation/security/Reference/keychainservices/Reference/reference.html">Keychain</a> on iOS and the <a href="http://developer.android.com/reference/java/security/KeyStore.html">KeyStore</a> on Android.</p>
<p>To get the token back, we use the following:</p>
<pre><code class="csharp">var accounts = accountStore.FindAccountsForService(&quot;descriptor&quot;);
</code></pre>

<p>When we receive the token back from the key store, we will want to check the expiry time to ensure the token has not expired.  As a result, there is a little bit more code to caching code than one would expect.</p>
<p>Let's start with the Android version in <strong>TaskList.Droid</strong>.  As with all the other login code, we are adjusting the <code>LoginAsync()</code> method in <code>Services\DroidLoginProvider.cs</code>:</p>
<pre><code class="csharp">using System;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Android.App;
using Android.Content;
using Microsoft.IdentityModel.Clients.ActiveDirectory;
using Microsoft.WindowsAzure.MobileServices;
using Newtonsoft.Json.Linq;
using TaskList.Abstractions;
using TaskList.Droid.Services;
using TaskList.Helpers;
using Xamarin.Auth;

[assembly: Xamarin.Forms.Dependency(typeof(DroidLoginProvider))]
namespace TaskList.Droid.Services
{
    public class DroidLoginProvider : ILoginProvider
    {
        public Context RootView { get; private set; }

        public AccountStore AccountStore { get; private set; }

        public void Init(Context context)
        {
            RootView = context;
            AccountStore = AccountStore.Create(context);
        }

        public async Task LoginAsync(MobileServiceClient client)
        {
            // Check if the token is available within the key store
            var accounts = AccountStore.FindAccountsForService(&quot;tasklist&quot;);
            if (accounts != null)
            {
                foreach (var acct in accounts)
                {
                    string token;

                    if (acct.Properties.TryGetValue(&quot;token&quot;, out token))
                    {
                        if (!IsTokenExpired(token))
                        {
                            client.CurrentUser = new MobileServiceUser(acct.Username);
                            client.CurrentUser.MobileServiceAuthenticationToken = token;
                            return;
                        }
                    }
                }
            }

            // Server Flow
            await client.LoginAsync(RootView, &quot;aad&quot;);

            // Store the new token within the store
            var account = new Account(client.CurrentUser.UserId);
            account.Properties.Add(&quot;token&quot;, client.CurrentUser.MobileServiceAuthenticationToken);
            AccountStore.Save(account, &quot;tasklist&quot;);
        }

        bool IsTokenExpired(string token)
        {
            // Get just the JWT part of the token (without the signature).
            var jwt = token.Split(new Char[] { '.' })[1];

            // Undo the URL encoding.
            jwt = jwt.Replace('-', '+').Replace('_', '/');
            switch (jwt.Length % 4)
            {
                case 0: break;
                case 2: jwt += &quot;==&quot;; break;
                case 3: jwt += &quot;=&quot;; break;
                default:
                    throw new ArgumentException(&quot;The token is not a valid Base64 string.&quot;);
            }

            // Convert to a JSON String
            var bytes = Convert.FromBase64String(jwt);
            string jsonString = UTF8Encoding.UTF8.GetString(bytes, 0, bytes.Length);

            // Parse as JSON object and get the exp field value,
            // which is the expiration date as a JavaScript primative date.
            JObject jsonObj = JObject.Parse(jsonString);
            var exp = Convert.ToDouble(jsonObj[&quot;exp&quot;].ToString());

            // Calculate the expiration by adding the exp value (in seconds) to the
            // base date of 1/1/1970.
            DateTime minTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
            var expire = minTime.AddSeconds(exp);
            return (expire &lt; DateTime.UtcNow);
        }
    }
}
</code></pre>

<p>There are three new pieces to this code.  The first piece is to check to see if there is an existing token in the KeyStore.  If there is, we check the expiry time and then set up the Azure Mobile Apps client with the username and token from the KeyStore.  If there isn't, we do the normal authentication process.  If the authentication process is successful, we reach the second piece, which is to store the token within the KeyStore.  If there is an existing entry, it will be overwritten.  Finally, there is a method called <code>IsTokenExpired()</code> whose only job is to check to see if a token is expired or not.  This same code can be used in the <code>Services/iOSLoginProvider.cs</code>.  The only difference is in the <code>AccountStore.Create()</code> call (as discussed earlier).</p>
<p>I'm using an application specific service ID (or descriptor) for this purpose.  You could also use an identity provider-based service ID which is especially useful if your mobile client supports multiple identity providers.</p>
<p>Xamarin.Auth only support iOS and Android.  We need to turn to an alternate library for token caching on Universal Windows.  The standard library has a package called <a href="https://msdn.microsoft.com/library/windows/apps/windows.security.credentials.passwordvault.aspx">PasswordVault</a> that can be used identically to the <a href="http://developer.android.com/reference/java/security/KeyStore.html">KeyStore</a> and <a href="https://developer.apple.com/library/ios/#documentation/security/Reference/keychainservices/Reference/reference.html">Keychain</a> libraries.  Here is the Universal Windows version of the same code in <code>Services\UWPLoginProvider.cs</code>:</p>
<pre><code class="csharp">using System;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.IdentityModel.Clients.ActiveDirectory;
using Microsoft.WindowsAzure.MobileServices;
using Newtonsoft.Json.Linq;
using TaskList.Abstractions;
using TaskList.Helpers;
using TaskList.UWP.Services;
using Windows.Security.Credentials;

[assembly: Xamarin.Forms.Dependency(typeof(UWPLoginProvider))]
namespace TaskList.UWP.Services
{
    public class UWPLoginProvider : ILoginProvider
    {
        public PasswordVault PasswordVault { get; private set; }

        public UWPLoginProvider()
        {
            PasswordVault = new PasswordVault();
        }

        public async Task LoginAsync(MobileServiceClient client)
        {
            // Check if the token is available within the password vault
            var acct = PasswordVault.FindAllByResource(&quot;tasklist&quot;).FirstOrDefault();
            if (acct != null)
            {
                var token = PasswordVault.Retrieve(&quot;tasklist&quot;, acct.UserName).Password;
                if (token != null &amp;&amp; token.Length &gt; 0 &amp;&amp; !IsTokenExpired(token))
                {
                    client.CurrentUser = new MobileServiceUser(acct.UserName);
                    client.CurrentUser.MobileServiceAuthenticationToken = token;
                    return;
                }
            }

            // Server-Flow Version
            await client.LoginAsync(&quot;aad&quot;);

            // Store the token in the password vault
            PasswordVault.Add(new PasswordCredential(&quot;tasklist&quot;,
                client.CurrentUser.UserId,
                client.CurrentUser.MobileServiceAuthenticationToken));
        }

        bool IsTokenExpired(string token)
        {
            /* Copy code from DroidLoginProvider */
        }
    }
}
</code></pre>

<p>The PasswordVault replaces the KeyStore (Android) and Keychain (iOS), but the concepts are the same.  All three mechanisms provide the basic functionality of storing client secrets securely.</p>
<h2 id="refresh-tokens">Refresh Tokens</h2>
<p>Our token cache checks the token to see if it is expired and prompts the user if the token is no longer valid.  Since the life of a token is inevitably short (maybe 1 hour), this will still mean that the user is prompted for new credentials most of the time.  In addition, we have an issue when the app is running for a long time.  What happens if the user leaves the app running for 2 hours?  The token we received at the start of the session will be invalid halfway through the session and we will have to restart the app in order to continue.  Both of these situations are undesirable from the point of view of the user.  Access tokens eventually expire and we need to explicitly deal with this situation.</p>
<p>The first part of the solution is to request a <em>Refresh Token</em>.  This is something the identity provider issues when the scope of the request includes an offline scope.  Only certain identity providers include the ability to request refresh tokens.  For server-flow:</p>
<ul>
<li>Google: Append the "access_type=offline" to the request.</li>
<li>Microsoft Account: Select the wl.offline_access scope in the Azure management portal.</li>
<li>Azure AD: Configure Azure AD to support access to the Graph API.</li>
</ul>
<p>Facebook and Twitter do not provider refresh tokens.  Once you have the refresh tokens, you can simply call the refresh API in the Azure Mobile Apps SDK to refresh the token.</p>
<blockquote>
<p>Refresh Tokens are one area that require special consideration when using Custom Authentication.  Just like with the /.auth/me endpoint, you are on your own when it comes to handling token expiry for custom authentication.</p>
</blockquote>
<h3 id="configuring-refresh-tokens">Configuring Refresh Tokens</h3>
<p>Azure Active Directory is perhaps the trickiest to configure.</p>
<ul>
<li>Log on to the <a href="https://manage.windowsazure.com/">Classic Portal</a>.</li>
<li>Navigate to your Azure Active Directory.</li>
<li>Go to <strong>APPLICATIONS</strong> and then your WEB application.</li>
<li>Go to the <strong>CONFIGURE</strong> tab.</li>
<li>Scroll down to the <strong>Keys</strong> section.</li>
</ul>
<p><img alt="AAD: Add a Key" src="../chapter2/img/aad-add-key.PNG" /></p>
<ul>
<li>In the <strong>Select duration</strong> drop-down, select <em>2 Years</em>.</li>
<li>Click on <strong>SAVE</strong>.  The key will be generated for you.  Copy the key (you will need it below).</li>
<li>Go back to the <a href="https://portal.azure.com/">Azure Portal</a>.</li>
<li>Go to <strong>App Services</strong>, then your App Service.</li>
<li>Click on <strong>Tools</strong>, then <strong>Resource explorer</strong>, then <strong>Go</strong>.</li>
<li>In the Resource Explorer, expand <strong>config</strong> and select <strong>authsettings</strong>.</li>
<li>Click on <strong>Edit</strong>.</li>
<li>Set the clientSecret to the key you copied from above.</li>
<li>Set the additionalLoginParams to <code>["response_type=code id_token"]</code>.</li>
</ul>
<p><img alt="AAD: Resource Explorer View" src="../chapter2/img/aad-resource-explorer.PNG" /></p>
<ul>
<li>Click the <strong>Read/Write</strong> toggle button at the top of the page.</li>
<li>Click the <strong>PUT</strong> button.</li>
</ul>
<p>The next time the user logs into our web app side, there will be a one-time prompt to consent to graph API access.  Once granted, the App Service Authentication / Authorization service will start requesting and receiving refresh tokens.</p>
<h3 id="using-refresh-tokens">Using Refresh Tokens</h3>
<p>The Azure Mobile Apps Client SDK has a built in method for refreshing tokens for you.  It assumes that you are using a supported identity provider (Azure Active Directory, Google or Microsoft Account), and have configured the identity provider to generate the refresh token.</p>
<blockquote>
<p>Azure App Service Authentication / Authorization maintains a token store in the XDrive (which is the drive that is shared among all instances of the backend within the same App Service Plan).  The token store is located at <code>D:\\home\\data\\.auth\\tokens</code> on the backend.  The tokens are encrypted and stored in a per-user encrypted file.</p>
</blockquote>
<h2 id="logging-out">Logging out</h2>
<h2 id="best-practices">Best Practices</h2>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../data/" class="btn btn-neutral float-right" title="Data Access and Offline Sync">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../chapter1/firstapp_mac/" class="btn btn-neutral" title="Your First App - Mac Edition"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../chapter1/firstapp_mac/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../data/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

</body>
</html>
