<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="no-js ie6"><![endif]-->
<!--[if IE 7 ]><html class="no-js ie7"><![endif]-->
<!--[if IE 8 ]><html class="no-js ie8"><![endif]-->
<!--[if IE 9 ]><html class="no-js ie9"><![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html class="no-js"> <!--<![endif]-->
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    
      
        <title>Custom Authentication - Develop Cloud Connected Mobile Apps with Xamarin and Microsoft Azure</title>
      
      
      
        <link rel="canonical" href="https://adrianhall.github.io/develop-mobile-apps-with-csharp-and-azure/chapter2/custom/">
      
      
        <meta name="author" content="Adrian Hall">
      
    
    <meta property="og:url" content="https://adrianhall.github.io/develop-mobile-apps-with-csharp-and-azure/chapter2/custom/">
    <meta property="og:title" content="Develop Cloud Connected Mobile Apps with Xamarin and Microsoft Azure">
    <meta property="og:image" content="https://adrianhall.github.io/develop-mobile-apps-with-csharp-and-azure/chapter2/custom//../../">
    <meta name="apple-mobile-web-app-title" content="Develop Cloud Connected Mobile Apps with Xamarin and Microsoft Azure">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    
    <link rel="shortcut icon" type="image/x-icon" href="../../assets/images/favicon-e565ddfa3b.ico">
    <link rel="icon" type="image/x-icon" href="../../assets/images/favicon-e565ddfa3b.ico">
    <style>
      @font-face {
      	font-family: 'Icon';
      	src: url('../../assets/fonts/icon.eot?52m981');
      	src: url('../../assets/fonts/icon.eot?#iefix52m981')
               format('embedded-opentype'),
      		   url('../../assets/fonts/icon.woff?52m981')
               format('woff'),
      		   url('../../assets/fonts/icon.ttf?52m981')
               format('truetype'),
      		   url('../../assets/fonts/icon.svg?52m981#icon')
               format('svg');
      	font-weight: normal;
      	font-style: normal;
      }
    </style>
    <link rel="stylesheet" href="../../assets/stylesheets/application-a422ff04cc.css">
    
    
      
      
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,700|Ubuntu+Mono">
      <style>
        body, input {
          font-family: 'Ubuntu', Helvetica, Arial, sans-serif;
        }
        pre, code {
          font-family: 'Ubuntu Mono', 'Courier New', 'Courier', monospace;
        }
      </style>
    
    
      <link rel="stylesheet" href="../../css/extra.css">
    
      <link rel="stylesheet" href="../../css/vs.css">
    
    <script src="../../assets/javascripts/modernizr-4ab42b99fd.js"></script>
    
  </head>
  
  
  
  <body class=" ">
    
      
      
    
    <div class="backdrop">
      <div class="backdrop-paper"></div>
    </div>
    <input class="toggle" type="checkbox" id="toggle-drawer">
    <input class="toggle" type="checkbox" id="toggle-search">
    <label class="toggle-button overlay" for="toggle-drawer"></label>
    <header class="header">
      <nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        
          <span class="path">
            
              
                Chapter 2 - Authentication <i class="icon icon-link"></i>
              
            
          </span>
        
        Custom Authentication
      </div>
    </div>
    
      
      <div class="button button-twitter" role="button" aria-label="Twitter">
        <a href="https://twitter.com/FizzyInTheHall" title="@FizzyInTheHall on Twitter" target="_blank" class="toggle-button icon icon-twitter"></a>
      </div>
    
    
      
      <div class="button button-github" role="button" aria-label="GitHub">
        <a href="https://github.com/adrianhall" title="@adrianhall on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
      </div>
    
    <div class="button button-search" role="button" aria-label="Search">
      <label class="toggle-button icon icon-search" title="Search" for="toggle-search"></label>
    </div>
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
    </header>
    <main class="main">
      
      <div class="drawer">
        <nav aria-label="Navigation">
  
  <a href="https://github.com/adrianhall/develop-mobile-apps-with-csharp-and-azure" class="project">
    <div class="banner">
      
      <div class="name">
        <strong>
          Develop Cloud Connected Mobile Apps with Xamarin and Microsoft Azure
          <span class="version">
            
          </span>
        </strong>
        
          <br>
          adrianhall/develop-mobile-apps-with-csharp-and-azure
        
      </div>
    </div>
  </a>
  <div class="scrollable">
    <div class="wrapper">
      
        <ul class="repo">
          <li class="repo-download">
            
            <a href="https://github.com/adrianhall/develop-mobile-apps-with-csharp-and-azure/archive/master.zip" target="_blank" title="Download" data-action="download">
              <i class="icon icon-download"></i> Download
            </a>
          </li>
          <li class="repo-stars">
            <a href="https://github.com/adrianhall/develop-mobile-apps-with-csharp-and-azure/stargazers" target="_blank" title="Stargazers" data-action="star">
              <i class="icon icon-star"></i> Stars
              <span class="count">&ndash;</span>
            </a>
          </li>
        </ul>
        <hr>
      
      <div class="toc">
        <ul>
          
            
  <li>
    <a class="" title="Getting Started" href="../..">
      Getting Started
    </a>
    
  </li>

          
            
  <li>
    <span class="section">Chapter 1 - Introduction</span>
    <ul>
      
        
  <li>
    <a class="" title="Your First App - PC Edition" href="../../chapter1/firstapp_pc/">
      Your First App - PC Edition
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Your First App - Mac Edition" href="../../chapter1/firstapp_mac/">
      Your First App - Mac Edition
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">Chapter 2 - Authentication</span>
    <ul>
      
        
  <li>
    <a class="" title="Concepts" href="../authconcepts/">
      Concepts
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Authentication in the Backend" href="../backend/">
      Authentication in the Backend
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Enterprise Authentication" href="../enterprise/">
      Enterprise Authentication
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Social Authentication" href="../social/">
      Social Authentication
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Debugging Authentication" href="../debugging/">
      Debugging Authentication
    </a>
    
  </li>

      
        
  <li>
    <a class="current" title="Custom Authentication" href="./">
      Custom Authentication
    </a>
    
      
      
        <ul>
          
            <li class="anchor">
              <a title="Custom authentication" href="#custom-authentication">
                Custom authentication
              </a>
            </li>
          
            <li class="anchor">
              <a title="Using Azure Active Directory B2C" href="#using-azure-active-directory-b2c">
                Using Azure Active Directory B2C
              </a>
            </li>
          
            <li class="anchor">
              <a title="Using Third Party Tokens" href="#using-third-party-tokens">
                Using Third Party Tokens
              </a>
            </li>
          
        </ul>
      
    
  </li>

      
        
  <li>
    <a class="" title="Claims and Authorization" href="../authorization/">
      Claims and Authorization
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Tokens in Real Apps" href="../realworld/">
      Tokens in Real Apps
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Best Practices" href="../bestpractices/">
      Best Practices
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">Chapter 3 - Data Access and Offline Sync</span>
    <ul>
      
        
  <li>
    <a class="" title="Concepts" href="../../chapter3/dataconcepts/">
      Concepts
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Implementing Table Controllers" href="../../chapter3/server/">
      Implementing Table Controllers
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Data Projection and Queries" href="../../chapter3/projection/">
      Data Projection and Queries
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="The Mobile Client" href="../../chapter3/client/">
      The Mobile Client
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Relationships" href="../../chapter3/relationships/">
      Relationships
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="The Domain Manager" href="../../chapter3/domainmgr/">
      The Domain Manager
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">Chapter 4 - Server Side Code</span>
    <ul>
      
        
  <li>
    <a class="" title="Options for Server Code" href="../../chapter4/options/">
      Options for Server Code
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Custom HTTP Endpoints" href="../../chapter4/custom/">
      Custom HTTP Endpoints
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="WebJobs" href="../../chapter4/webjobs/">
      WebJobs
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Functions" href="../../chapter4/functions/">
      Functions
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Recipes" href="../../chapter4/recipes/">
      Recipes
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">Chapter 5 - Push Notifications</span>
    <ul>
      
        
  <li>
    <a class="" title="Concepts" href="../../chapter5/concepts/">
      Concepts
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Android Push" href="../../chapter5/android/">
      Android Push
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="iOS Push" href="../../chapter5/ios/">
      iOS Push
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Windows Push" href="../../chapter5/windows/">
      Windows Push
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Push Recipes" href="../../chapter5/recipes/">
      Push Recipes
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">Chapter 6 - Combining Web and Mobile Apps</span>
    <ul>
      
        
  <li>
    <a class="" title="MVC Applications" href="../../chapter6/mvc/">
      MVC Applications
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="SPA Applications" href="../../chapter6/spa/">
      SPA Applications
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">Chapter 7 - Other Useful Services</span>
    <ul>
      
        
  <li>
    <a class="" title="Azure Search" href="../../chapter7/search/">
      Azure Search
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Media Services" href="../../chapter7/media/">
      Media Services
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Real-time Notifications" href="../../chapter7/realtime/">
      Real-time Notifications
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">Chapter 8 - Developing An App</span>
    <ul>
      
        
  <li>
    <a class="" title="The Development Environment" href="../../chapter8/developing/">
      The Development Environment
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Testing your Application" href="../../chapter8/testing/">
      Testing your Application
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">Chapter 9 - Going to Production</span>
    <ul>
      
        
  <li>
    <a class="" title="Repeatable Deployments" href="../../chapter9/arm/">
      Repeatable Deployments
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Safe Deployments" href="../../chapter9/appsvc/">
      Safe Deployments
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Monitoring" href="../../chapter9/monitoring/">
      Monitoring
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Troubleshooting" href="../../chapter9/troubleshooting/">
      Troubleshooting
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <a class="" title="Xamarin Forms Tips" href="../../xamarin_tips/">
      Xamarin Forms Tips
    </a>
    
  </li>

          
            
  <li>
    <a class="" title="Android Developer Notes" href="../../android_appendix/">
      Android Developer Notes
    </a>
    
  </li>

          
            
  <li>
    <a class="" title="References" href="../../references/">
      References
    </a>
    
  </li>

          
            
  <li>
    <a class="" title="Credits" href="../../credits/">
      Credits
    </a>
    
  </li>

          
        </ul>
        
          <hr>
          <span class="section">The author</span>
          <ul>
            
              
              <li>
                <a href="https://twitter.com/FizzyInTheHall" target="_blank" title="@FizzyInTheHall on Twitter">
                  @FizzyInTheHall on Twitter
                </a>
              </li>
            
            
              
              <li>
                <a href="https://github.com/adrianhall" target="_blank" title="@adrianhall on GitHub">
                  @adrianhall on GitHub
                </a>
              </li>
            
          </ul>
        
      </div>
    </div>
  </div>
</nav>
      </div>
      <article class="article">
        <div class="wrapper">
          
            <h1>Custom Authentication</h1>
          
          <h2 id="custom-authentication">Custom authentication<a class="headerlink" href="#custom-authentication" title="Permanent link">&para;</a></h2>
<p>For some situations, the social or enterprise flows are not valid for the mobile client.  Perhaps you want the ability
to provide a sign-up process with a username and password rather than using a social provider.  Perhaps you want to use
an alternate provider that is not one of the supported five providers.  Whatever the reason, Azure App Service provides
the ability to handle all situations.  In this section, I will look at three methods for providing a unique set of
usernames with no connection to the social or enterprise authentication.</p>
<h3 id="using-an-identity-database">Using an Identity Database.<a class="headerlink" href="#using-an-identity-database" title="Permanent link">&para;</a></h3>
<p>Probably the most common request is to use a custom identity database.  In general, this is desirable because you
already have a database of usernames and password.  However, it's probably the least desirable option because of the
security concerns that come along with this technique.  The news is rife with password leakage for very large
organizations.  The best way to ensure you do not disclose a users password is to not have it in the first place.</p>
<div class="admonition warn">
<p class="admonition-title">Warn</p>
<p>I'm not going to cover the sign-up case here.  This would be an additional process and would use a regular Web API
to insert data into the database after validation (and probably verification via email or text message).</p>
</div>
<p>The first thing we need to add to our project is a model for the user object.  I created the following in the <code>Models</code>
folder of the <strong>Backend</strong> project:</p>
<pre><code class="csharp">using System.ComponentModel.DataAnnotations;

namespace Backend.Models
{
    public class User
    {
        [Key]
        public int Id { get; set; }

        public string Username { get; set; }

        public string Password { get; set; }
    }
}
</code></pre>

<p>We also need to modify the <code>MobileServiceContext.cs</code> file so that the database table is included in the Entity Framework
context:</p>
<pre><code class="csharp">    public class MobileServiceContext : DbContext
    {
        private const string connectionStringName = &quot;Name=MS_TableConnectionString&quot;;

        public MobileServiceContext() : base(connectionStringName)
        {
        }

        public DbSet&lt;TodoItem&gt; TodoItems { get; set; }
        public DbSet&lt;User&gt; Users { get; set; }

        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Conventions.Add(
                new AttributeToColumnAnnotationConvention&lt;TableColumnAttribute, string&gt;(
                    &quot;ServiceTableColumn&quot;, (property, attributes) =&gt; attributes.Single().ColumnType.ToString()));
        }
    }
</code></pre>

<p>Finally, we probably want to put some seed data into the database when it is first created so that we can test it.
Adjust the <code>MobileServiceInitializer</code> in the <code>Startup.MobileApp.cs</code> file:</p>
<pre><code class="csharp">        protected override void Seed(MobileServiceContext context)
        {
            List&lt;TodoItem&gt; todoItems = new List&lt;TodoItem&gt;
            {
                new TodoItem { Id = Guid.NewGuid().ToString(), Text = &quot;First item&quot;, Complete = false },
                new TodoItem { Id = Guid.NewGuid().ToString(), Text = &quot;Second item&quot;, Complete = false }
            };

            foreach (TodoItem todoItem in todoItems)
            {
                context.Set&lt;TodoItem&gt;().Add(todoItem);
            }

            List&lt;User&gt; users = new List&lt;User&gt;
            {
                new User { Id = 1, Username = &quot;adrian&quot;, Password = &quot;supersecret&quot; }
            };

            foreach (User user in users)
            {
                context.Set&lt;User&gt;().Add(user);
            }

            base.Seed(context);
        }
</code></pre>

<p>Note that we are storing the passwords in plain text.  This is most definitely frowned upon.  We should be using some
sort of encryption.  This code is most definitely just for demonstration purposes.  Continuing the code on the backend,
we need to handle the request to authenticate from the client.  We will use a custom API controller for this; it is
located in <code>Controllers\CustomAuthController.cs</code>:</p>
<pre><code class="csharp">using System;
using System.IdentityModel.Tokens;
using System.Linq;
using System.Security.Claims;
using System.Web.Http;
using Backend.Models;
using Microsoft.Azure.Mobile.Server.Login;
using Newtonsoft.Json;

namespace Backend.Controllers
{
    [Route(&quot;.auth/login/custom&quot;)]
    public class CustomAuthController : ApiController
    {
        private MobileServiceContext db;
        private string signingKey, audience, issuer;

        public CustomAuthController()
        {
            db = new MobileServiceContext();
            signingKey = Environment.GetEnvironmentVariable(&quot;WEBSITE_AUTH_SIGNING_KEY&quot;);
            var website = Environment.GetEnvironmentVariable(&quot;WEBSITE_HOSTNAME&quot;);
            audience = $&quot;https://{website}/&quot;;
            issuer = $&quot;https://{website}/&quot;;
        }

        [HttpPost]
        public IHttpActionResult Post([FromBody] User body)
        {
            if (body == null || body.Username == null || body.Password == null ||
                body.Username.Length == 0 || body.Password.Length == 0)
            {
                return BadRequest(); ;
            }

            if (!IsValidUser(body))
            {
                return Unauthorized();
            }

            var claims = new Claim[]
            {
                new Claim(JwtRegisteredClaimNames.Sub, body.Username)
            };

            JwtSecurityToken token = AppServiceLoginHandler.CreateToken(
                claims, signingKey, audience, issuer, TimeSpan.FromDays(30));
            return Ok(new LoginResult()
            {
                AuthenticationToken = token.RawData,
                User = new LoginResultUser { UserId = body.Username }
            });
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                db.Dispose();
            }
            base.Dispose(disposing);
        }

        private bool IsValidUser(User user)
        {
            return db.Users.Count(u =&gt; u.Username.Equals(user.Username) &amp;&amp; u.Password.Equals(user.Password)) &gt; 0;
        }
    }

    public class LoginResult
    {
        [JsonProperty(PropertyName = &quot;authenticationToken&quot;)]
        public string AuthenticationToken { get; set; }

        [JsonProperty(PropertyName = &quot;user&quot;)]
        public LoginResultUser User { get; set; }
    }

    public class LoginResultUser
    {
        [JsonProperty(PropertyName = &quot;userId&quot;)]
        public string UserId { get; set; }
    }
}
</code></pre>

<p>There is a lot going on here:</p>
<ul>
<li>The constructor reads the signing key and other information that we need for constructing the JWT.  Note that the
  signing key is only available if you have the Authentication / Authorization is turned on.</li>
<li>The <code>LoginResult</code> and <code>LoginResultUser</code> provide the response to the client, when serialized by the JSON serializer.</li>
<li>The <code>Post()</code> method is where the work happens.  It verifies that you have a valid object, then checks that the
  username and password match something in the user database.  It then constructs the JWT and returns the required
  JSON object.</li>
<li>The <code>IsValidUser()</code> method actually validates the username and password provided in the request with the users in
  the database.  This version is very simplistic.  I expect your version to at least include encryption of the password.</li>
</ul>
<div class="admonition warn">
<p class="admonition-title">Warn</p>
<p>You must turn on Authentication / Authorization in your App Service.  Set the <strong>Action to take when request
is not authenticated</strong> to <strong>Allow Request (no action)</strong> and do not configure any of the supported authentication
providers.</p>
</div>
<p>You can add additional claims in the token that is passed back to the client by adding additional rows to the <code>claims</code>
object.  For example:</p>
<pre><code class="csharp">    var claims = new Claim[]
    {
        new Claim(JwtRegisteredClaimNames.Sub, body.Username),
        new Claim(&quot;foo&quot;, &quot;Value for Foo&quot;)
    };
</code></pre>

<p>For example, you could do a custom authentication that includes group information, permissions structures, or
additional information about the user from the directory.  Claim names are normally three letters and the value
is always a string.  It is normal to create a class (just like the <code>JwtRegisteredClaimNames</code>) with the strings
in it that can be shared between the client and server projects:</p>
<pre><code class="csharp">public static class LocalClaimNames
{
    public string MainUser =&gt; &quot;mus&quot;
};
</code></pre>

<p>The only claim that <strong>must</strong> be present is the "sub" claim (referenced here by <code>JwtRegisteredClaimNames.Sub</code> claim
type).  The token, when encoded, must fit in a HTTP header.  For Windows systems based on IIS, the maximum size
of a header is 16Kb.  For Linux systems based on Apache, the maximum size of a header is 8Kb.  The server will
return <strong>413 Entity Too Large</strong> if the header is too long.  The token is also transmitted with every single
request so you should make efforts to reduce the size of the token.  It is better to make two requests initially
(one request for the token followed by an authenticated request for the extra information) than to include the
extra information in the token.</p>
<p>Next, we need to wire the custom authentication controller so that it appears in the same place as all the other
authenticators.  We are going to access it via the <code>/.auth/login/custom</code> endpoint.  The normal ASP.NET methods can be
applied for this.  In this project, we can enable <a href="http://www.asp.net/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2">attribute routing</a>:</p>
<pre><code class="csharp">public static void ConfigureMobileApp(IAppBuilder app)
{
    HttpConfiguration config = new HttpConfiguration();

    new MobileAppConfiguration()
        .AddTablesWithEntityFramework()
        .ApplyTo(config);

    // Map routes by attribute
    config.MapHttpAttributeRoutes();

    // Use Entity Framework Code First to create database tables based on your DbContext
    Database.SetInitializer(new MobileServiceInitializer());

    MobileAppSettingsDictionary settings = config.GetMobileAppSettingsProvider().GetMobileAppSettings();

    if (string.IsNullOrEmpty(settings.HostName))
    {
        app.UseAppServiceAuthentication(new AppServiceAuthenticationOptions
        {
            SigningKey = ConfigurationManager.AppSettings[&quot;SigningKey&quot;],
            ValidAudiences = new[] { ConfigurationManager.AppSettings[&quot;ValidAudience&quot;] },
            ValidIssuers = new[] { ConfigurationManager.AppSettings[&quot;ValidIssuer&quot;] },
            TokenHandler = config.GetAppServiceTokenHandler()
        });
    }

    app.UseWebApi(config);
}
</code></pre>

<p>At this point, we can deploy the backend to the App Service and send a suitably formed POST request to
the backend.  I use [Postman][19] for this purpose. The request:</p>
<p><img alt="Custom Auth - Postman Request" src="../img/customauth-postman-1.PNG" /></p>
<p>A successful POST will return the token and user ID in the response:</p>
<p><img alt="Custom Auth - Postman Response" src="../img/customauth-postman-2.PNG" /></p>
<p>Any other request (such as no body or a wrong username or password) should produce the right response.  If the body is
correct, but the information is wrong, then a 401 Unauthorized response should be produced.  If the body is invalid, then
400 Bad Request should be produced.</p>
<div class="admonition info">
<p class="admonition-title">Info</p>
<p>The format of the response is exactly the same as the token response we saw earlier when we were discussing
the contents of a JWT.</p>
</div>
<p>We can now turn our attention to the mobile client.  Custom Authentication is always implemented using a client-flow
mechanism. To implement this, we are going to adjust the entry page so that the username and password fields are
displayed.  The gathered username and password will then be passed to a new ICloudService <code>LoginAsync()</code> method.
All of the UI work is done in the shared project.</p>
<p>To start, we need a copy of the <code>User.cs</code> model from the backend project.  Unlike Data Transfer Objects, this model is
the same:</p>
<pre><code class="csharp">namespace TaskList.Models
{
    public class User
    {
        public string Username { get; set; }
        public string Password { get; set; }
    }
}
</code></pre>

<p>The abstraction we use for the cloud service needs to be adjusted so that we can pass the user object into the login
method.  This is the <code>Abstractions\ICloudService.cs</code> interface:</p>
<pre><code class="csharp">using System.Threading.Tasks;
using TaskList.Models;

namespace TaskList.Abstractions
{
    public interface ICloudService
    {
        ICloudTable&lt;T&gt; GetTable&lt;T&gt;() where T : TableData;

        Task LoginAsync();

        Task LoginAsync(User user);
    }
}
</code></pre>

<p>I am adding a new version of the <code>LoginAsync()</code> method.  The concrete version of this method no longer has to go
through the dependency service since I can use shared code.  Here is the definition of our new <code>LoginAsync()</code>
method in <code>Services\AzureCloudService.cs</code>:</p>
<pre><code class="csharp">        public Task LoginAsync(User user)
        {
            return client.LoginAsync(&quot;custom&quot;, JObject.FromObject(user));
        }
</code></pre>

<p>Finally, we need to update the view-model <code>ViewModels\EntryPageViewModel.cs</code> so that we can store the username and
password in the model.  We will also update the call to the <code>LoginAsync()</code> method of the cloud service so it calls
our new method:</p>
<pre><code class="csharp">using System;
using System.Diagnostics;
using System.Threading.Tasks;
using TaskList.Abstractions;
using TaskList.Helpers;
using TaskList.Models;
using Xamarin.Forms;

namespace TaskList.ViewModels
{
    public class EntryPageViewModel : BaseViewModel
    {
        public EntryPageViewModel()
        {
            Title = &quot;Task List&quot;;
            User = new Models.User { Username = &quot;&quot;, Password = &quot;&quot; };
        }

        Command loginCmd;
        public Command LoginCommand =&gt; loginCmd ?? (loginCmd = new Command(async () =&gt; await ExecuteLoginCommand()));

        public Models.User User { get; set; }

        async Task ExecuteLoginCommand()
        {
            if (IsBusy)
                return;
            IsBusy = true;

            try
            {
                var cloudService = ServiceLocator.Instance.Resolve&lt;ICloudService&gt;();
                await cloudService.LoginAsync(User);
                Application.Current.MainPage = new NavigationPage(new Pages.TaskList());
            }
            catch (Exception ex)
            {
                Debug.WriteLine($&quot;[ExecuteLoginCommand] Error = {ex.Message}&quot;);
            }
            finally
            {
                IsBusy = false;
            }
        }
    }
}
</code></pre>

<p>There are three new pieces here.  Firstly, we have the User property (for holding the username and password in our
form).  Next, the constructor initializes the user object to an empty object.  Finally, the call to <code>LoginAsync()</code>
passes the user object to the cloud service.</p>
<p>We also need some UI changes.  Specifically, we need a couple of fields for the username and password added to the
<code>Pages\EntryPage.xaml</code> file:</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;ContentPage x:Class=&quot;TaskList.Pages.EntryPage&quot;
             xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             Title=&quot;{Binding Title}&quot;&gt;
    &lt;ContentPage.Content&gt;
        &lt;StackLayout HorizontalOptions=&quot;Center&quot;
                     Orientation=&quot;Vertical&quot;
                     VerticalOptions=&quot;Center&quot;&gt;
            &lt;Label Text=&quot;Username?&quot; /&gt;
            &lt;Entry Text=&quot;{Binding User.Username}&quot; /&gt;
            &lt;Label Text=&quot;Password?&quot; /&gt;
            &lt;Entry IsPassword=&quot;True&quot; Text=&quot;{Binding User.Password}&quot; /&gt;

            &lt;Button BackgroundColor=&quot;Teal&quot;
                    BorderRadius=&quot;10&quot;
                    Command=&quot;{Binding LoginCommand}&quot;
                    Text=&quot;Enter The App&quot;
                    TextColor=&quot;White&quot; /&gt;
        &lt;/StackLayout&gt;
    &lt;/ContentPage.Content&gt;
&lt;/ContentPage&gt;
</code></pre>

<p>There is lots to complain about in this demonstration (including lack of encryption, storage of passwords, and a
generally bad UI).  However, it serves to demonstrate the salient points for using a (perhaps pre-existing) identity
database for authentication of the users.</p>
<h2 id="using-azure-active-directory-b2c">Using Azure Active Directory B2C<a class="headerlink" href="#using-azure-active-directory-b2c" title="Permanent link">&para;</a></h2>
<p>Custom authentication allows you to really customize the process, but I like to reduce the amount of code I write by
using services or libraries.   The whole sign-in and sign-up process is ripe for this.  The code needed for building
the sign-in / sign-up process is boiler-plate code.  It also introduces problems that I have to deal with going forward.
I have to store passwords and profile information, which introduces a security concern.  I have to scale the database
and ensure my app scales with it as my app gets popular.  Finally, I am being fairly inflexible and causing potential
privacy concerns with my users.</p>
<p>There are a couple of services that I can use to get around these concerns.  The first is an Azure service:
<a href="https://azure.microsoft.com/en-us/services/active-directory-b2c/">Azure Active Directory B2C</a>.  The B2C stands for Business to Consumer.  It is a mechanism by which you can add a
sign-in and sign-up flow to your application.  The user can enter a username or password, or, at your option, add on
support for one or more social providers.  In addition, there is support for branding the sign-in process, doing email
verification of sign-ups and automatic password resets via email.  The Azure AD B2C sign-in / sign-up process is
primarily a server-flow proecss, so we will be able to add support in our app with just one line of code.</p>
<h3 id="the-minimal-setup-of-azure-ad-b2c">The Minimal Setup of Azure AD B2C<a class="headerlink" href="#the-minimal-setup-of-azure-ad-b2c" title="Permanent link">&para;</a></h3>
<p>Azure AD is managed from the <a href="https://manage.windowsazure.com/">Classic Azure Portal</a>, so start by logging in using your Azure
Subscription credentials.</p>
<ul>
<li>Click on the big <strong>+ NEW</strong> button in the bottom left of the screen.</li>
<li>Select <strong>App Services</strong> -&gt; <strong>Active Directory</strong> -&gt; <strong>Directory</strong> -&gt; <strong>Custom Create</strong>.</li>
</ul>
<p><img alt="AAD B2C Create Flow - Create a new resource" src="../img/aad-b2c-1.PNG" /></p>
<ul>
<li>Choose a name for the tenant, then choose a unique domain name (which will appear in the   <em>onmicrosoft.com</em>
  domain) and country.  Ensure you check the <strong>This is a B2C directory.</strong></li>
</ul>
<p><img alt="AAD B2C Create Flow - Add a Directory" src="../img/aad-b2c-2.PNG" /></p>
<ul>
<li>Click on the tick to create the directory.  As noted, this process will take a couple of minutes to complete.</li>
</ul>
<p>This creates a new tenant for you to manage.  If you go back to your <a href="https://portal.azure.com/">Azure Portal</a> and click on your name
(top right corner), you will note that there is a new DIRECTORY entry for your B2C tenant.  This is where you will be
managing your B2C tenant.</p>
<p>It's a good idea to pin the B2C settings blade to your dashboard or navigation pane so you can access it faster.
To do this:</p>
<ul>
<li>Log in to the <a href="https://portal.azure.com/">Azure Portal</a>.</li>
<li>Switch to your B2C tenant by clicking on your name, then selecting the new tenant in the drop-down.</li>
<li>The portal will probably ask you to confirm your ID and password.</li>
<li>Click on <strong>Browse&gt;</strong> in the left-hand navigation bar.</li>
<li>Search for <strong>B2C</strong>.</li>
<li>Click on the empty star next to <strong>Azure AD B2C</strong>.</li>
</ul>
<p><img alt="AAD B2C Create Flow - Favorite the B2C" src="../img/aad-b2c-3.PNG" /></p>
<p>This will make Azure AD B2C appear in your left hand navigation bar.  To place it on the dashboard, click on
<strong>Azure AD B2C</strong> in the left hand navigation bar, then click on the pin at the top of the <strong>AZURE AD B2C SETTINGS</strong>
blade.</p>
<p>The next job is to create an application registration within the B2C tenant:</p>
<ul>
<li>Open the <strong>Azure AD B2C</strong> from your dashboard or the left hand navigation.</li>
<li>In the <strong>Settings</strong> blade, click on <strong>Applications</strong>.</li>
</ul>
<p><img alt="AAD B2C Create Flow - Create an App Step 1" src="../img/aad-b2c-4.PNG" /></p>
<ul>
<li>In the <strong>New application</strong> blade:</li>
<li>Enter a unique name for the application.</li>
<li>Click on <strong>Yes</strong> under <strong>Include web app / web API</strong>.</li>
<li>In the Reply URL, enter <code>https://yoursite.azurewebsites.net/.auth/login/aad/callback</code>.</li>
<li>Click on <strong>Generate key</strong> - a key will be generated (cut and paste it somewhere).</li>
</ul>
<p><img alt="AAD B2C Create Flow - Create an App Step 2" src="../img/aad-b2c-5.PNG" /></p>
<ul>
<li>Click on <strong>Create</strong>.</li>
</ul>
<p>There is no spinner or deployment here.  After approximately 5-10 seconds, the application registration will appear
in the list.  Click on the application registration to see the <strong>Application ID</strong>:</p>
<p><img alt="AAD B2C Create Flow - Create an App Step 3" src="../img/aad-b2c-6.PNG" /></p>
<p>You will need the Application ID and App Key (which you copied earlier) later on.  The next step is to create a
Sign-in/Sign-up policy.  We'll create a policy for signing up with an email address and email confirmation, then
signing in with that email address:</p>
<ul>
<li>In the <strong>Settings</strong> blade, click on <strong>Sign-up or sign-in policies</strong>.</li>
<li>Click on the <strong>+ Add</strong> button.</li>
<li>Give the policy a name, like <strong>emailPolicy</strong>.</li>
<li>Click on <strong>Identity providers</strong>:</li>
<li>Click on <strong>Email signup / Local Account</strong> (a tick will appear next to the row).</li>
<li>Click on <strong>OK</strong>.</li>
<li>Click on <strong>Sign-up attributes</strong>:</li>
<li>Click on <strong>Email Address</strong> and any other fields you want to gather.</li>
<li>Click on <strong>OK</strong>.</li>
<li>Click on <strong>Application claims</strong>:</li>
<li>Click on <strong>Email Addresses</strong> and any other fields you want to provide to the application.</li>
<li>Click on <strong>OK</strong></li>
<li>Click on <strong>Create</strong> on the <strong>Add policy</strong> blade.</li>
<li>Click on the policy you just created.  It will be named something like <em>B2C_1_emailPolicy</em>. Make a note of the
<strong>Metadata Endpoint for this policy</strong>.</li>
</ul>
<p><img alt="AAD B2C Create Flow - Create a Policy" src="../img/aad-b2c-7.PNG" /></p>
<p>Now that your B2C tenant is configured, you can switch back to your original tenant (by clicking on your name in
the top-right corner and selecting the default directory).</p>
<p>To configure the App Service <strong>Authentication / Authorization</strong>.  Open up the <strong>Settings</strong> blade, then
<strong>Authentication / Authorization</strong>.  Ensure the authentication service is turned on.  Click on
<strong>Azure Active Directory</strong>. This time, we are going to select the <strong>Advanced</strong> option.  The <strong>Client ID</strong> is
the application ID of your B2C application registration, and the <strong>Issuer Url</strong> is the <strong>Metadata Endpoint</strong>
for your sign-up policy:</p>
<p><img alt="AAD B2C Create Flow - Configure EasyAuth" src="../img/aad-b2c-8.PNG" /></p>
<p>Click on <strong>OK</strong> to configure the authentication server flow, the <strong>Save</strong> to save the settings.  As before, you
can test your server flow by pointing your browser to <code>https://yoursite.azurewebsites.net/.auth/login/aad</code>:</p>
<p><img alt="AAD B2C Login Flow" src="../img/aad-b2c-9.PNG" /></p>
<p>If you have done everything right, you should be able to register an account, get the email verification code,
and finally log in to get the happy login page.</p>
<p><img alt="AAD B2C Sign Up Flow" src="../img/aad-b2c-10.PNG" /></p>
<p>All that is left to do is to configure your app for Azure Active Directory Server Flow.  We did that earlier when
discussing the Enterprise Authentication flow for the mobile client.</p>
<h3 id="drawbacks-of-azure-active-directory-b2c">Drawbacks of Azure Active Directory B2C<a class="headerlink" href="#drawbacks-of-azure-active-directory-b2c" title="Permanent link">&para;</a></h3>
<p>Azure AD B2C is great for storing your users passwords and doing the sign-up and sign-in process for you.  There
are a couple of reasons why you wouldn't want to use Azure Active Directory B2C.</p>
<p>The most obvious one is that this is built on Azure Active Directory.  That means you won't be able to, for example,
integrate the Facebook, Google and Twitter identity providers by utilizing their client libraries.  You also do
not get access to the underlying identity provider token, so you are restricted from accessing the Graph API for
the individual providers.  Finally, since the AAD B2C identity provider is configured with the AAD provider, you
can't use both a B2C provider and a regular AAD provider.</p>
<p>If you just want a sign-up / sign-in flow, then AAD B2C is probably the best way to go.  If, however, your plans
include integration with other social identity providers, you should consider using the identity providers
directly or via separate configuration with the Azure App Service Authentication / Authorization.</p>
<h2 id="using-third-party-tokens">Using Third Party Tokens<a class="headerlink" href="#using-third-party-tokens" title="Permanent link">&para;</a></h2>
<p>The final method of authenticating a user we are going to look at is a process by which you use a third party
authentication token.   For example, you may want to authenticate via <a href="https://developer.github.com/v3/oauth/">GitHub</a> or <a href="http://www.miicard.com/for/individuals/how-it-works">miiCard</a> or using
an authentication provider like <a href="https://www.auth0.com/">Auth0</a> to get some single sign-in capabilities.</p>
<p>Authentication with third party tokens works remarkably similar to the custom authentication case.  Instead of
a username and password, you pass in the token from the other provider.</p>
<p>To look at this in example form, we are going to implement Auth0 as a provider. Your first stop should be the
<a href="https://www.auth0.com/">Auth0</a> web site to sign up for a developer account. Once you have done that:</p>
<ul>
<li>Click on the <strong>+ NEW CLIENT</strong> button in the <strong>Dashboard</strong>.</li>
<li>Give your app a name, then click on <strong>Native</strong> and then <strong>CREATE</strong>.</li>
</ul>
<p><img alt="Auth0 Create Flow - Step 1" src="../img/auth0-create-1.PNG" /></p>
<ul>
<li>Click on the <strong>Xamarin</strong> icon to get the Xamarin Quickstart.</li>
<li>Click on <strong>Settings</strong>.</li>
<li>Enter the callback URL in the <strong>Allowed Callback URLs</strong>.  The callback URL will be something like
  <code>https://_youraccount_.auth0.com/mobile</code> and will be listed in the Quickstart page.</li>
<li>Scroll down to the bottom of the page and click on <strong>SAVE CHANGES</strong>.</li>
<li>Make a note of the Client ID of the application.  You will need it later.</li>
<li>Click on <strong>Connections</strong>.</li>
<li>Turn on any connections that you want to use.  For this example, ensure you turn on the
<strong>Username-Password-Authentication</strong> and a couple of social providers.</li>
</ul>
<p>Now that the Auth0 service is configured, we can turn our attention to the mobile client.  The Xamarin.Auth0Client
is a component, so right-click on the <strong>Components</strong> node of a platform project and select <strong>Get More Components...</strong>.
In the dialog, find the <strong>Auth0 SDK</strong>, then click on <strong>Add to App</strong>.</p>
<p>For our iOS application, we are going to integrate Auth0 into the <code>Services\iOSLoginProvider.cs</code>:</p>
<pre><code class="csharp">        public async Task LoginAsync(MobileServiceClient client)
        {
            // Client Flow
            var accessToken = await LoginAuth0Async();

            var zumoPayload = new JObject();
            zumoPayload[&quot;access_token&quot;] = accessToken;
            await client.LoginAsync(&quot;auth0&quot;, zumoPayload);
        }

        public UIViewController RootView =&gt; UIApplication.SharedApplication.KeyWindow.RootViewController;

        public async Task&lt;string&gt; LoginAuth0Async()
        {
            var auth0 = new Auth0.SDK.Auth0Client(
                &quot;shellmonger.auth0.com&quot;,
                &quot;lmFp5jXnwPpD9lQIYwgwwPmFeofuLpYq&quot;);
            var user = await auth0.LoginAsync(RootView, scope: &quot;openid email&quot;);
            return user.Auth0AccessToken;
        }
</code></pre>

<p>The parameters for the constructor to the <code>Auth0Client</code> are your Auth0 domain and client ID.  You can retrieve these
from the Auth0 management page for your app.  Note that I am requesting the email address.  This will become a part
of my ZUMO token when I create it.</p>
<p>Switching our attention to our <code>Backend</code> project, we need a new custom authentication controller.  This is located
in <code>Controllers\Auth0Controller.cs</code>:</p>
<pre><code class="csharp">using System;
using System.Diagnostics;
using System.IdentityModel.Tokens;
using System.Linq;
using System.Security.Claims;
using System.Web.Http;
using Backend.Models;
using Microsoft.Azure.Mobile.Server.Login;

namespace Backend.Controllers
{
    [Route(&quot;.auth/login/auth0&quot;)]
    public class Auth0Controller : ApiController
    {
        private JwtSecurityTokenHandler tokenHandler;
        private string clientID, domain;
        private string signingKey, audience, issuer;

        public Auth0Controller()
        {
            // Information for the incoming Auth0 Token
            domain = Environment.GetEnvironmentVariable(&quot;AUTH0_DOMAIN&quot;);
            clientID = Environment.GetEnvironmentVariable(&quot;AUTH0_CLIENTID&quot;);

            // Information for the outgoing ZUMO Token
            signingKey = Environment.GetEnvironmentVariable(&quot;WEBSITE_AUTH_SIGNING_KEY&quot;);
            var website = Environment.GetEnvironmentVariable(&quot;WEBSITE_HOSTNAME&quot;);
            audience = $&quot;https://{website}/&quot;;
            issuer = $&quot;https://{website}/&quot;;

            // Token Handler
            tokenHandler = new JwtSecurityTokenHandler();
        }

        [HttpPost]
        public IHttpActionResult Post([FromBody] Auth0User body)
        {
            if (body == null || body.access_token == null || body.access_token.Length == 0)
            {
                return BadRequest();
            }

            try
            {
                var token = (JwtSecurityToken)tokenHandler.ReadToken(body.access_token);
                if (!IsValidUser(token))
                {
                    return Unauthorized();
                }

                var subject = token.Claims.FirstOrDefault(c =&gt; c.Type.Equals(&quot;sub&quot;))?.Value;
                var email = token.Claims.FirstOrDefault(c =&gt; c.Type.Equals(&quot;email&quot;))?.Value;
                if (subject == null || email == null)
                {
                    return BadRequest();
                }

                var claims = new Claim[]
                {
                    new Claim(JwtRegisteredClaimNames.Sub, subject),
                    new Claim(JwtRegisteredClaimNames.Email, email)
                };

                JwtSecurityToken zumoToken = AppServiceLoginHandler.CreateToken(
                    claims, signingKey, audience, issuer, TimeSpan.FromDays(30));
                return Ok(new LoginResult()
                {
                    AuthenticationToken = zumoToken.RawData,
                    User = new LoginResultUser { UserId = email }
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine($&quot;Auth0 JWT Exception = {ex.Message}&quot;);
                throw ex;
            }
        }

        private bool IsValidUser(JwtSecurityToken token)
        {
            if (token == null)
                return false;
            var audience = token.Audiences.FirstOrDefault();
            if (!audience.Equals(clientID))
                return false;
            if (!token.Issuer.Equals($&quot;https://{domain}/&quot;))
                return false;
            if (token.ValidTo.AddMinutes(5) &lt; DateTime.Now)
                return false;
            return true;
        }
    }

    public class Auth0User
    {
        public string access_token { get; set; }
    }
}
</code></pre>

<p>Note that we are reading two new environment variables.  In the Azure App Service, you can read Application Settings
by reading the environment variable of the same name.  We need to set the <strong>AUTH0_CLIENTID</strong> to the Client ID of
our Auth0 application, and the <strong>AUTH0_DOMAIN</strong> to the domain of our account.  Both of these values need to match
the settings in the client.  These are not "secure items".  If using the client secret (to validate the token), then
that would be considered secure and should only appear on the server side.</p>
<p>The validation is that the token passed in is valid (i.e. it has the right audience, issuer and expiry times).  In
addition, you should check the validity of the token signature.  You can do this by acquiring the token secret and
using <code>tokenHandler.ValidateToken()</code> instead of <code>tokenHandler.ReadToken()</code>.  My new token lasts for 30 days.  The
ZUMO token that is generated in custom authentication does not have to be the same length as the original token.
You can make it last for as long as you like.</p>
<!-- Images -->

<!-- Links -->
          <aside class="copyright" role="note">
            
            Documentation built with
            <a href="http://www.mkdocs.org" target="_blank">MkDocs</a>
            using the
            <a href="http://squidfunk.github.io/mkdocs-material/" target="_blank">
              Material
            </a>
            theme.
          </aside>
          
            <footer class="footer">
              
  <nav class="pagination" aria-label="Footer">
    <div class="previous">
      
        <a href="../debugging/" title="Debugging Authentication">
          <span class="direction">
            Previous
          </span>
          <div class="page">
            <div class="button button-previous" role="button" aria-label="Previous">
              <i class="icon icon-back"></i>
            </div>
            <div class="stretch">
              <div class="title">
                Debugging Authentication
              </div>
            </div>
          </div>
        </a>
      
    </div>
    <div class="next">
      
        <a href="../authorization/" title="Claims and Authorization">
          <span class="direction">
            Next
          </span>
          <div class="page">
            <div class="stretch">
              <div class="title">
                Claims and Authorization
              </div>
            </div>
            <div class="button button-next" role="button" aria-label="Next">
              <i class="icon icon-forward"></i>
            </div>
          </div>
        </a>
      
    </div>
  </nav>

            </footer>
          
        </div>
      </article>
      <div class="results" role="status" aria-live="polite">
        <div class="scrollable">
          <div class="wrapper">
            <div class="meta"></div>
            <div class="list"></div>
          </div>
        </div>
      </div>
    </main>
    <script>
      var base_url = '../..';
      var repo_id  = 'adrianhall/develop-mobile-apps-with-csharp-and-azure';
    </script>
    <script src="../../assets/javascripts/application-997097ee0c.js"></script>
    
      <script src="../../js/highlight.pack.js"></script>
    
    
  </body>
</html>